/*************************************************************************
ALGLIB 3.20.0 (source code generated 2022-12-19)
Copyright (c) Sergey Bochkanov (ALGLIB project).

>>> SOURCE LICENSE >>>
This program is a trial version of the ALGLIB package  licensed
to IBC (Licensee, You).

Only Licensee can use  it  according   to   the  ALGLIB   Trial
License Agreement between Licensor and Licensee.

=============== ALGLIB TRIAL LICENSE AGREEMENT ================

1. Only owners of e-mails below can use this trial version:
* ijimenez@ibc.bio

2. This trial version can be used only for 30 days  (expiration
date is 27 Apr, 2023).

It can be used only for evaluation  purposes. You can  not  use
it to perform some "real" work.

After this trial period is over, you MUST delete all  copies of
software (including ones made for backup  purposes)  -  or  buy
commercial license for ALGLIB.

3. Following restrictions are applied:
A. Trial version of ALGLIB can not be used by other individuals
   or legal entities. It can not  be  distributed  in  any  way
   (including rent, lease, other means of sharing software).
B. Any application/product  developed  with  trial  version  of
   ALGLIB may only be used for  evaluation  purposes  and  only
   during evaluation period.
   You may not  distribute  applications/products  linked  with
   trial version of ALGLIB.
   After evaluation period  is  over, you should  re-link  such
   applications/products  with  Free  Edition  or  one  of  the
   Commercial editions of ALGLIB - or delete them.
C. You can not remove any  copyright  notice  from  the  Source
   Codes/Binary Files
   
WARRANTIES:

This trial version  is  provided  AS IS,  with  no  warranties,
express or implied.  Licensor  does  NOT  provide  support  and
maintenance for this trial version. If you need warranties  and
support, you should buy commercial version of ALGLIB.

COPYRIGHT:

Title to the ALGLIB and all copies thereof remain with Licensor
The ALGLIB is copyrighted and  is  protected  by  international
copyright laws.  You  will not remove any copyright notice from
the ALGLIB files. You agree to prevent any unauthorized copying
of the ALGLIB. Except as expressly  provided  herein,  Licensor
does  not  grant  any  express  or  implied right to you  under
Licensor  patents,  copyrights,  trademarks,  or  trade  secret
information.
>>> END OF LICENSE >>>
*************************************************************************/
using System;
using System.Reflection;
using System.Runtime.InteropServices;
public partial class alglib
{
    /********************************************************************
    Callback definitions for optimizers/fitters/solvers.
    
    Callbacks for unparameterized (general) functions:
    * ndimensional_func         calculates f(arg), stores result to func
    * ndimensional_grad         calculates func = f(arg), 
                                grad[i] = df(arg)/d(arg[i])
    * ndimensional_hess         calculates func = f(arg),
                                grad[i] = df(arg)/d(arg[i]),
                                hess[i,j] = d2f(arg)/(d(arg[i])*d(arg[j]))
    
    Callbacks for systems of functions:
    * ndimensional_fvec         calculates vector function f(arg),
                                stores result to fi
    * ndimensional_jac          calculates f[i] = fi(arg)
                                jac[i,j] = df[i](arg)/d(arg[j])
                                
    Callbacks for  parameterized  functions,  i.e.  for  functions  which 
    depend on two vectors: P and Q.  Gradient  and Hessian are calculated 
    with respect to P only.
    * ndimensional_pfunc        calculates f(p,q),
                                stores result to func
    * ndimensional_pgrad        calculates func = f(p,q),
                                grad[i] = df(p,q)/d(p[i])
    * ndimensional_phess        calculates func = f(p,q),
                                grad[i] = df(p,q)/d(p[i]),
                                hess[i,j] = d2f(p,q)/(d(p[i])*d(p[j]))

    Callbacks for progress reports:
    * ndimensional_rep          reports current position of optimization algo    
    
    Callbacks for ODE solvers:
    * ndimensional_ode_rp       calculates dy/dx for given y[] and x
    
    Callbacks for integrators:
    * integrator1_func          calculates f(x) for given x
                                (additional parameters xminusa and bminusx
                                contain x-a and b-x)
    ********************************************************************/
    public delegate void ndimensional_func (double[] arg, ref double func, object obj);
    public delegate void ndimensional_grad (double[] arg, ref double func, double[] grad, object obj);
    public delegate void ndimensional_hess (double[] arg, ref double func, double[] grad, double[,] hess, object obj);
    
    public delegate void ndimensional_fvec (double[] arg, double[] fi, object obj);
    public delegate void ndimensional_jac  (double[] arg, double[] fi, double[,] jac, object obj);
    
    public delegate void ndimensional_pfunc(double[] p, double[] q, ref double func, object obj);
    public delegate void ndimensional_pgrad(double[] p, double[] q, ref double func, double[] grad, object obj);
    public delegate void ndimensional_phess(double[] p, double[] q, ref double func, double[] grad, double[,] hess, object obj);
    
    public delegate void ndimensional_rep(double[] arg, double func, object obj);

    public delegate void ndimensional_ode_rp (double[] y, double x, double[] dy, object obj);

    public delegate void integrator1_func (double x, double xminusa, double bminusx, ref double f, object obj);

    /********************************************************************
    Class defining a complex number with double precision.
    ********************************************************************/
    [StructLayout(LayoutKind.Sequential, Pack=8)]
    public struct complex
    {
        public double x;
        public double y;

        public complex(double _x)
        {
            x = _x;
            y = 0;
        }
        public complex(double _x, double _y)
        {
            x = _x;
            y = _y;
        }
        public static implicit operator complex(double _x)
        {
            return new complex(_x);
        }
        public static bool operator==(complex lhs, complex rhs)
        {
            return ((double)lhs.x==(double)rhs.x) & ((double)lhs.y==(double)rhs.y);
        }
        public static bool operator!=(complex lhs, complex rhs)
        {
            return ((double)lhs.x!=(double)rhs.x) | ((double)lhs.y!=(double)rhs.y);
        }
        public static complex operator+(complex lhs)
        {
            return lhs;
        }
        public static complex operator-(complex lhs)
        {
            return new complex(-lhs.x,-lhs.y);
        }
        public static complex operator+(complex lhs, complex rhs)
        {
            return new complex(lhs.x+rhs.x,lhs.y+rhs.y);
        }
        public static complex operator-(complex lhs, complex rhs)
        {
            return new complex(lhs.x-rhs.x,lhs.y-rhs.y);
        }
        public static complex operator*(complex lhs, complex rhs)
        { 
            return new complex(lhs.x*rhs.x-lhs.y*rhs.y, lhs.x*rhs.y+lhs.y*rhs.x);
        }
        public static complex operator/(complex lhs, complex rhs)
        {
            complex result;
            double e;
            double f;
            if( System.Math.Abs(rhs.y)<System.Math.Abs(rhs.x) )
            {
                e = rhs.y/rhs.x;
                f = rhs.x+rhs.y*e;
                result.x = (lhs.x+lhs.y*e)/f;
                result.y = (lhs.y-lhs.x*e)/f;
            }
            else
            {
                e = rhs.x/rhs.y;
                f = rhs.y+rhs.x*e;
                result.x = (lhs.y+lhs.x*e)/f;
                result.y = (-lhs.x+lhs.y*e)/f;
            }
            return result;
        }
        public override int GetHashCode() 
        { 
            return x.GetHashCode() ^ y.GetHashCode(); 
        }
        public override bool Equals(object obj) 
        { 
            if( obj is byte)
                return Equals(new complex((byte)obj));
            if( obj is sbyte)
                return Equals(new complex((sbyte)obj));
            if( obj is short)
                return Equals(new complex((short)obj));
            if( obj is ushort)
                return Equals(new complex((ushort)obj));
            if( obj is int)
                return Equals(new complex((int)obj));
            if( obj is uint)
                return Equals(new complex((uint)obj));
            if( obj is long)
                return Equals(new complex((long)obj));
            if( obj is ulong)
                return Equals(new complex((ulong)obj));
            if( obj is float)
                return Equals(new complex((float)obj));
            if( obj is double)
                return Equals(new complex((double)obj));
            if( obj is decimal)
                return Equals(new complex((double)(decimal)obj));
            return base.Equals(obj); 
        }    
    }    
    
    /********************************************************************
    Class defining an ALGLIB exception
    ********************************************************************/
    public class alglibexception : System.Exception
    {
        public string msg;
        public alglibexception(string s)
        {
            msg = s;
        }
        
    }
    
    /********************************************************************
    Critical failure, resilts in immediate termination of entire program.
    ********************************************************************/
    public static void AE_CRITICAL_ASSERT(bool x)
    {
        if( !x )
            System.Environment.FailFast("ALGLIB: critical error");
    }
    
    /********************************************************************
    ALGLIB object, parent class for all user-visible objects  managed  by
    ALGLIB.
    
    Methods:
        _deallocate()       deallocation:
                            * in managed ALGLIB it does nothing
                            * in native ALGLIB it clears  dynamic  memory
                              being  hold  by  object  and  sets internal
                              reference to null.
        make_copy()         creates deep copy of the object.
                            Works in both managed and native versions  of
                            ALGLIB.
    ********************************************************************/
    public abstract class alglibobject : IDisposable
    {
        public virtual void _deallocate() {}
        public abstract alglibobject make_copy();
        public void Dispose()
        {
            _deallocate();
        }
    }
    
    /********************************************************************
    xparams object, used to pass additional parameters like multithreading
    settings, and several predefined values
    ********************************************************************/
    public class xparams
    {
        public ulong flags;
        public xparams(ulong v)
        {
            flags = v;
        }
    }
    //private static ulong FLG_THREADING_MASK          = 0x7;
    //private static   int FLG_THREADING_SHIFT         = 0;
    //private static ulong FLG_THREADING_USE_GLOBAL    = 0x0;
    private static ulong FLG_THREADING_SERIAL        = 0x1;
    private static ulong FLG_THREADING_PARALLEL      = 0x2;
    public static xparams serial   = new xparams(FLG_THREADING_SERIAL);
    public static xparams parallel = new xparams(FLG_THREADING_PARALLEL);

    /********************************************************************
    Deallocation of ALGLIB object:
    * in managed ALGLIB this method just sets refence to null
    * in native ALGLIB call of this method:
      1) clears dynamic memory being hold by  object  and  sets  internal
         reference to null.
      2) sets to null variable being passed to this method
      
    IMPORTANT (1): in  native  edition  of  ALGLIB,  obj becomes unusable
                   after this call!!!  It  is  possible  to  save  a copy
                   of reference in another variable (original variable is
                   set to null), but any attempt to work with this object
                   will crash your program.
    
    IMPORTANT (2): memory owned by object will be recycled by GC  in  any
                   case. This method just enforces IMMEDIATE deallocation.
    ********************************************************************/
    public static void deallocateimmediately<T>(ref T obj) where T : alglib.alglibobject
    {
        obj._deallocate();
        obj = null;
    }
    
    /********************************************************************
    Allocation counter:
    * in managed ALGLIB it always returns 0 (dummy code)
    * in native ALGLIB it returns current value of the allocation counter
      (if it was activated)
    ********************************************************************/
    public static long alloc_counter()
    {
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        return x_alloc_counter();
    }
    
    /********************************************************************
    Activization of the allocation counter:
    * in managed ALGLIB it does nothing (dummy code)
    * in native ALGLIB it turns on allocation counting.
    ********************************************************************/
    public static void alloc_counter_activate()
    {
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        x_alloc_counter_activate();
    }
    
    /********************************************************************
    This function allows to set one of the debug flags:
    * flag_id==0        activates/deactivates alloc_counter (counts number
                        of allocations minus number of deallocations;  but
                        not their sizes - only number of calls). This counter
                        does not include several one-time  allocations  of
                        service structures which persist for  the  entire
                        lifetime of the program.
    * flag_id==1        activates/deactivates cumulative allocation counter
                        (sum of sizes of allocated memory blocks; this
                        counter does not decrease when blocks are freed).
    ********************************************************************/
    public static void set_dbg_flag(long flag_id, long flag_value)
    {
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        x_set_dbg_flag(flag_id, flag_value);
    }
    
    /********************************************************************
    This function allows to get one of the debug counters:
    * flag_id==0        returns alloc_counter
    * flag_id==1        returns cumulative allocation size
    ********************************************************************/
    public static long get_dbg_value(long id)
    {
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        return x_get_dbg_value(id);
    }
    
    /********************************************************************
    Clears all internally cached objects which prevent allocation counters
    from becoming zero on exit.
    ********************************************************************/
    public static void free_disposed_items()
    {
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        x_free_disposed_items();
    }
    
    /************************************************************************
    This function maps nworkers  number  (which  can  be  positive,  zero  or
    negative with 0 meaning "all cores", -1 meaning "all cores -1" and so on)
    to "effective", strictly positive workers count.

    This  function  is  intended  to  be used by debugging/testing code which
    tests different number of worker threads. It is NOT aligned  in  any  way
    with ALGLIB multithreading framework (i.e. it can return  non-zero worker
    count even for single-threaded GPLed ALGLIB).
    ************************************************************************/
    public static int get_effective_workers(int nworkers)
    {
        int ncores = System.Environment.ProcessorCount;
        if( nworkers>=1 )
            return nworkers>ncores ? ncores : nworkers;
        return ncores+nworkers>=1 ? ncores+nworkers : 1;
    }
    
    /********************************************************************
    This function activates trace output, with trace log being  saved  to
    file (appended to the end).

    Tracing allows us to study behavior of ALGLIB solvers  and  to  debug
    their failures:
    * tracing is  limited  by one/several ALGLIB parts specified by means
      of trace tags, like "SLP" (for SLP solver) or "OPTGUARD"  (OptGuard
      integrity checker).
    * some ALGLIB solvers support hierarchies of trace tags which activate
      different kinds of tracing. Say, "SLP" defines some basic  tracing,
      but "SLP.PROBING" defines more detailed and costly tracing.
    * generally, "TRACETAG.SUBTAG"   also  implicitly  activates  logging
      which is activated by "TRACETAG"
    * you may define multiple trace tags by separating them with  commas,
      like "SLP,OPTGUARD,SLP.PROBING"
    * trace tags are case-insensitive
    * spaces/tabs are NOT allowed in the tags string

    Trace log is saved to file "filename", which is opened in the  append
    mode. If no file with such name  can  be  opened,  tracing  won't  be
    performed (but no exception will be generated).
    ********************************************************************/
    public static void trace_file(string tags, string filename)
    {
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        x_trace_file(tags, filename);
    }
    
    /********************************************************************
    This function disables tracing.
    ********************************************************************/
    public static void trace_disable()
    {
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        x_trace_disable();
    }
    
    /********************************************************************
    internal functions
    ********************************************************************/
    public class ap
    {
        public static int len<T>(T[] a)
        { return a.Length; }
        public static int rows<T>(T[,] a)
        { return a.GetLength(0); }
        public static int cols<T>(T[,] a)
        { return a.GetLength(1); }
        public static void swap<T>(ref T a, ref T b)
        {
            T t = a;
            a = b;
            b = t;
        }
        
        public static void assert(bool cond, string s)
        {
            if( !cond )
                throw new alglibexception(s);
        }
        
        public static void assert(bool cond)
        {
            assert(cond, "ALGLIB: assertion failed");
        }
        
        /****************************************************************
        prints formatted complex
        ****************************************************************/
        public static string format(complex a, int _dps)
        {
            int dps = Math.Abs(_dps);
            string fmt = _dps>=0 ? "F" : "E";
            string fmtx = String.Format("{{0:"+fmt+"{0}}}", dps);
            string fmty = String.Format("{{0:"+fmt+"{0}}}", dps);
            string result = String.Format(fmtx, a.x) + (a.y >= 0 ? "+" : "-") + String.Format(fmty, Math.Abs(a.y)) + "i";
            result = result.Replace(',', '.');
            return result;
        }

        /****************************************************************
        prints formatted array
        ****************************************************************/
        public static string format(bool[] a)
        {
            string[] result = new string[len(a)];
            int i;
            for(i=0; i<len(a); i++)
                if( a[i] )
                    result[i] = "true";
                else
                    result[i] = "false";
            return "{"+String.Join(",",result)+"}";
        }
        
        /****************************************************************
        prints formatted array
        ****************************************************************/
        public static string format(int[] a)
        {
            string[] result = new string[len(a)];
            int i;
            for (i = 0; i < len(a); i++)
                result[i] = a[i].ToString();
            return "{" + String.Join(",", result) + "}";
        }

        /****************************************************************
        prints formatted array
        ****************************************************************/
        public static string format(double[] a, int _dps)
        {
            int dps = Math.Abs(_dps);
            string sfmt = _dps >= 0 ? "F" : "E";
            string fmt = String.Format("{{0:" + sfmt + "{0}}}", dps);
            string[] result = new string[len(a)];
            int i;
            for (i = 0; i < len(a); i++)
            {
                result[i] = String.Format(fmt, a[i]);
                result[i] = result[i].Replace(',', '.');
            }
            return "{" + String.Join(",", result) + "}";
        }

        /****************************************************************
        prints formatted array
        ****************************************************************/
        public static string format(complex[] a, int _dps)
        {
            int dps = Math.Abs(_dps);
            string fmt = _dps >= 0 ? "F" : "E";
            string fmtx = String.Format("{{0:"+fmt+"{0}}}", dps);
            string fmty = String.Format("{{0:"+fmt+"{0}}}", dps);
            string[] result = new string[len(a)];
            int i;
            for (i = 0; i < len(a); i++)
            {
                result[i] = String.Format(fmtx, a[i].x) + (a[i].y >= 0 ? "+" : "-") + String.Format(fmty, Math.Abs(a[i].y)) + "i";
                result[i] = result[i].Replace(',', '.');
            }
            return "{" + String.Join(",", result) + "}";
        }

        /****************************************************************
        prints formatted matrix
        ****************************************************************/
        public static string format(bool[,] a)
        {
            int i, j, m, n;
            n = cols(a);
            m = rows(a);
            bool[] line = new bool[n];
            string[] result = new string[m];
            for (i = 0; i < m; i++)
            {
                for (j = 0; j < n; j++)
                    line[j] = a[i, j];
                result[i] = format(line);
            }
            return "{" + String.Join(",", result) + "}";
        }

        /****************************************************************
        prints formatted matrix
        ****************************************************************/
        public static string format(int[,] a)
        {
            int i, j, m, n;
            n = cols(a);
            m = rows(a);
            int[] line = new int[n];
            string[] result = new string[m];
            for (i = 0; i < m; i++)
            {
                for (j = 0; j < n; j++)
                    line[j] = a[i, j];
                result[i] = format(line);
            }
            return "{" + String.Join(",", result) + "}";
        }

        /****************************************************************
        prints formatted matrix
        ****************************************************************/
        public static string format(double[,] a, int dps)
        {
            int i, j, m, n;
            n = cols(a);
            m = rows(a);
            double[] line = new double[n];
            string[] result = new string[m];
            for (i = 0; i < m; i++)
            {
                for (j = 0; j < n; j++)
                    line[j] = a[i, j];
                result[i] = format(line, dps);
            }
            return "{" + String.Join(",", result) + "}";
        }

        /****************************************************************
        prints formatted matrix
        ****************************************************************/
        public static string format(complex[,] a, int dps)
        {
            int i, j, m, n;
            n = cols(a);
            m = rows(a);
            complex[] line = new complex[n];
            string[] result = new string[m];
            for (i = 0; i < m; i++)
            {
                for (j = 0; j < n; j++)
                    line[j] = a[i, j];
                result[i] = format(line, dps);
            }
            return "{" + String.Join(",", result) + "}";
        }

        /****************************************************************
        checks that matrix is symmetric.
        max|A-A^T| is calculated; if it is within 1.0E-14 of max|A|,
        matrix is considered symmetric
        ****************************************************************/
        public static bool issymmetric(double[,] a)
        {
            int i, j, n;
            double err, mx, v1, v2;
            if( rows(a)!=cols(a) )
                return false;
            n = rows(a);
            if( n==0 )
                return true;
            mx = 0;
            err = 0;
            for( i=0; i<n; i++)
            {
                for(j=i+1; j<n; j++)
                {
                    v1 = a[i,j];
                    v2 = a[j,i];
                    if( !math.isfinite(v1) )
                        return false;
                    if( !math.isfinite(v2) )
                        return false;
                    err = Math.Max(err, Math.Abs(v1-v2));
                    mx  = Math.Max(mx,  Math.Abs(v1));
                    mx  = Math.Max(mx,  Math.Abs(v2));
                }
                v1 = a[i,i];
                if( !math.isfinite(v1) )
                    return false;
                mx = Math.Max(mx, Math.Abs(v1));
            }
            if( mx==0 )
                return true;
            return err/mx<=1.0E-14;
        }
        
        /****************************************************************
        checks that matrix is Hermitian.
        max|A-A^H| is calculated; if it is within 1.0E-14 of max|A|,
        matrix is considered Hermitian
        ****************************************************************/
        public static bool ishermitian(complex[,] a)
        {
            int i, j, n;
            double err, mx;
            complex v1, v2, vt;
            if( rows(a)!=cols(a) )
                return false;
            n = rows(a);
            if( n==0 )
                return true;
            mx = 0;
            err = 0;
            for( i=0; i<n; i++)
            {
                for(j=i+1; j<n; j++)
                {
                    v1 = a[i,j];
                    v2 = a[j,i];
                    if( !math.isfinite(v1.x) )
                        return false;
                    if( !math.isfinite(v1.y) )
                        return false;
                    if( !math.isfinite(v2.x) )
                        return false;
                    if( !math.isfinite(v2.y) )
                        return false;
                    vt.x = v1.x-v2.x;
                    vt.y = v1.y+v2.y;
                    err = Math.Max(err, math.abscomplex(vt));
                    mx  = Math.Max(mx,  math.abscomplex(v1));
                    mx  = Math.Max(mx,  math.abscomplex(v2));
                }
                v1 = a[i,i];
                if( !math.isfinite(v1.x) )
                    return false;
                if( !math.isfinite(v1.y) )
                    return false;
                err = Math.Max(err, Math.Abs(v1.y));
                mx = Math.Max(mx, math.abscomplex(v1));
            }
            if( mx==0 )
                return true;
            return err/mx<=1.0E-14;
        }
        
        
        /****************************************************************
        Forces symmetricity by copying upper half of A to the lower one
        ****************************************************************/
        public static bool forcesymmetric(double[,] a)
        {
            int i, j, n;
            if( rows(a)!=cols(a) )
                return false;
            n = rows(a);
            if( n==0 )
                return true;
            for( i=0; i<n; i++)
                for(j=i+1; j<n; j++)
                    a[i,j] = a[j,i];
            return true;
        }
        
        /****************************************************************
        Forces Hermiticity by copying upper half of A to the lower one
        ****************************************************************/
        public static bool forcehermitian(complex[,] a)
        {
            int i, j, n;
            complex v;
            if( rows(a)!=cols(a) )
                return false;
            n = rows(a);
            if( n==0 )
                return true;
            for( i=0; i<n; i++)
                for(j=i+1; j<n; j++)
                {
                    v = a[j,i];
                    a[i,j].x = v.x;
                    a[i,j].y = -v.y;
                }
            return true;
        }
    };
    
    /********************************************************************
    math functions
    ********************************************************************/
    public class math
    {
        public static System.Random rndobject = new System.Random(System.DateTime.Now.Millisecond + 1000*System.DateTime.Now.Second + 60*1000*System.DateTime.Now.Minute);

        public const double machineepsilon = 5E-16;
        public const double maxrealnumber = 1E300;
        public const double minrealnumber = 1E-300;
        
        public static bool isfinite(double d)
        {
            return !System.Double.IsNaN(d) && !System.Double.IsInfinity(d);
        }
        
        public static double randomreal()
        {
            double r = 0;
            lock(rndobject){ r = rndobject.NextDouble(); }
            return r;
        }
        public static int randominteger(int N)
        {
            int r = 0;
            lock(rndobject){ r = rndobject.Next(N); }
            return r;
        }
        public static double sqr(double X)
        {
            return X*X;
        }        
        public static double abscomplex(complex z)
        {
            double w;
            double xabs;
            double yabs;
            double v;
    
            xabs = System.Math.Abs(z.x);
            yabs = System.Math.Abs(z.y);
            w = xabs>yabs ? xabs : yabs;
            v = xabs<yabs ? xabs : yabs; 
            if( v==0 )
                return w;
            else
            {
                double t = v/w;
                return w*System.Math.Sqrt(1+t*t);
            }
        }
        public static complex conj(complex z)
        {
            return new complex(z.x, -z.y); 
        }    
        public static complex csqr(complex z)
        {
            return new complex(z.x*z.x-z.y*z.y, 2*z.x*z.y); 
        }

    }
    

    /*
     * CSV functionality
     */
     
    public static int CSV_DEFAULT      = 0x0;
    public static int CSV_SKIP_HEADERS = 0x1;
    
    /*
     * CSV operations: reading CSV file to real matrix.
     * 
     * This function reads CSV  file  and  stores  its  contents  to  double
     * precision 2D array. Format of the data file must conform to RFC  4180
     * specification, with additional notes:
     * - file size should be less than 2GB
     * - ASCI encoding, UTF-8 without BOM (in header names) are supported
     * - any character (comma/tab/space) may be used as field separator,  as
     *   long as it is distinct from one used for decimal point
     * - multiple subsequent field separators (say, two  spaces) are treated
     *   as MULTIPLE separators, not one big separator
     * - both comma and full stop may be used as decimal point. Parser  will
     *   automatically determine specific character being used.  Both  fixed
     *   and exponential number formats are  allowed.   Thousand  separators
     *   are NOT allowed.
     * - line may end with \n (Unix style) or \r\n (Windows  style),  parser
     *   will automatically adapt to chosen convention
     * - escaped fields (ones in double quotes) are not supported
     * 
     * INPUT PARAMETERS:
     *     filename        relative/absolute path
     *     separator       character used to separate fields.  May  be  ' ',
     *                     ',', '\t'. Other separators are possible too.
     *     flags           several values combined with bitwise OR:
     *                     * alglib::CSV_SKIP_HEADERS -  if present, first row
     *                       contains headers  and  will  be  skipped.   Its
     *                       contents is used to determine fields count, and
     *                       that's all.
     *                     If no flags are specified, default value 0x0  (or
     *                     alglib::CSV_DEFAULT, which is same) should be used.
     *                     
     * OUTPUT PARAMETERS:
     *     out             2D matrix, CSV file parsed with atof()
     *     
     * HANDLING OF SPECIAL CASES:
     * - file does not exist - alglib::ap_error exception is thrown
     * - empty file - empty array is returned (no exception)
     * - skip_first_row=true, only one row in file - empty array is returned
     * - field contents is not recognized by atof() - field value is replaced
     *   by 0.0
     */
    public static void read_csv(string filename, char separator, int flags, out double[,] matrix)
    {
        //
        // Parameters
        //
        bool skip_first_row = (flags&CSV_SKIP_HEADERS)!=0;
        
        //
        // Prepare empty output array
        //
        matrix = new double[0,0];
        
        //
        // Read file, normalize file contents:
        // * replace 0x0 by spaces
        // * remove trailing spaces and newlines
        // * append trailing '\n' and '\0' characters
        // Return if file contains only spaces/newlines.
        //
        byte b_space = System.Convert.ToByte(' ');
        byte b_tab   = System.Convert.ToByte('\t');
        byte b_lf    = System.Convert.ToByte('\n');
        byte b_cr    = System.Convert.ToByte('\r');
        byte b_comma = System.Convert.ToByte(',');
        byte b_fullstop= System.Convert.ToByte('.');
        byte[] v0 = System.IO.File.ReadAllBytes(filename);
        if( v0.Length==0 )
            return;
        byte[] v1 = new byte[v0.Length+2];
        int filesize = v0.Length;
        for(int i=0; i<filesize; i++)
            v1[i] = v0[i]==0 ? b_space : v0[i];
        for(; filesize>0; )
        {
            byte c = v1[filesize-1];
            if( c==b_space || c==b_tab || c==b_cr || c==b_lf )
            {
                filesize--;
                continue;
            }
            break;
        }
        if( filesize==0 )
            return;
        v1[filesize+0] = b_lf;
        v1[filesize+1] = 0x0;
        filesize+=2;
        
        
        //
        // Scan dataset.
        //
        int rows_count, cols_count, max_length = 0;
        cols_count = 1;
        for(int idx=0; idx<filesize; idx++)
        {
            if( v1[idx]==separator )
                cols_count++;
            if( v1[idx]==b_lf )
                break;
        }
        rows_count = 0;
        for(int idx=0; idx<filesize; idx++)
            if( v1[idx]==b_lf )
                rows_count++;
        if( rows_count==1 && skip_first_row ) // empty output, return
            return;
        int[] offsets = new int[rows_count*cols_count];
        int[] lengths = new int[rows_count*cols_count];
        int cur_row_idx = 0;
        for(int row_start=0; v1[row_start]!=0x0; )
        {
            // determine row length
            int row_length;
            for(row_length=0; v1[row_start+row_length]!=b_lf; row_length++);
            
            // determine cols count, perform integrity check
            int cur_cols_cnt=1;
            for(int idx=0; idx<row_length; idx++)
                if( v1[row_start+idx]==separator )
                    cur_cols_cnt++;
            if( cols_count!=cur_cols_cnt )
                throw new alglib.alglibexception("read_csv: non-rectangular contents, rows have different sizes");
            
            // store offsets and lengths of the fields
            int cur_offs = 0;
            int cur_col_idx = 0;
            for(int idx=0; idx<row_length+1; idx++)
                if( v1[row_start+idx]==separator || v1[row_start+idx]==b_lf )
                {
                    offsets[cur_row_idx*cols_count+cur_col_idx] = row_start+cur_offs;
                    lengths[cur_row_idx*cols_count+cur_col_idx] = idx-cur_offs;
                    max_length = idx-cur_offs>max_length ? idx-cur_offs : max_length;
                    cur_offs = idx+1;
                    cur_col_idx++;
                }
            
            // advance row start
            cur_row_idx++;
            row_start = row_start+row_length+1;
        }
        
        //
        // Convert
        //
        int row0 = skip_first_row ? 1 : 0;
        int row1 = rows_count;
        System.Globalization.CultureInfo culture = System.Globalization.CultureInfo.CreateSpecificCulture(""); // invariant culture
        matrix = new double[row1-row0, cols_count];
        alglib.AE_CRITICAL_ASSERT(culture.NumberFormat.NumberDecimalSeparator==".");
        for(int ridx=row0; ridx<row1; ridx++)
            for(int cidx=0; cidx<cols_count; cidx++)
            {
                int field_len  = lengths[ridx*cols_count+cidx];
                int field_offs = offsets[ridx*cols_count+cidx];
                
                // replace , by full stop
                for(int idx=0; idx<field_len; idx++)
                    if( v1[field_offs+idx]==b_comma )
                        v1[field_offs+idx] = b_fullstop;
                
                // convert
                string s_val = System.Text.Encoding.ASCII.GetString(v1, field_offs, field_len);
                double d_val;
                Double.TryParse(s_val, System.Globalization.NumberStyles.Float, culture, out d_val);
                matrix[ridx-row0,cidx] = d_val;
            }
    }
}

//
// Code below contains interface to HPC computational core
//
#pragma warning disable 414
public partial class alglib
{
    private static object   CoreInitLock     = new object();
    private static volatile IntPtr hAlglibDL = IntPtr.Zero;
    private static string[] paths = new string[0];
    
    // SMP modes
    private enum alglibmode { serial, parallel }; // TODO: remove!!!!
    
    // X status codes
    private const int X_OK               = 0;
    private const int X_MALLOC_ERROR     = 1;
    private const int X_ASSERTION_FAILED = 5;
    
    // data types
    private const int DT_BOOL    = 1;
    private const int DT_INT     = 2;
    private const int DT_REAL    = 3;
    private const int DT_COMPLEX = 4;
    
    // datatype sizes
    private const int SIZE_BOOL      = 1;
    private static int SIZE_INT      = IntPtr.Size;
    private const int SIZE_REAL      = 8;
    private const int SIZE_COMPLEX   = 16;

    // owner types
    private const int OWN_CALLER = 1;
    private const int OWN_AE     = 2;

    // actions which are performed during conversion from C# array to X array
    private const int X_SET     = 1; // data are copied into already initialized x-vector/matrix; previous contents of x-structure is freed
    private const int X_CREATE  = 2; // new x-vector/matrix is created, its previous contents is ignored
    private const int X_REWRITE = 3; // data are copied into already allocated storage; size of X array memory must be equal to the source array size

    // actions performed by ALGLIB core under arrays
    private const int ACT_UNCHANGED     = 1;
    private const int ACT_SAME_LOCATION = 2;
    private const int ACT_NEW_LOCATION  = 3;
    
    // communication codes for X-core
    private const int _ALGLIB_SET_GLOBAL_THREADING       = 1001;
    private const int _ALGLIB_SET_NWORKERS               = 1002;
    
    private const int _ALGLIB_GET_ALLOC_COUNTER          =    0;
    private const int _ALGLIB_GET_CUMULATIVE_ALLOC_SIZE  =    1;
    private const int _ALGLIB_GET_CUMULATIVE_ALLOC_COUNT =    2;
    
    private const int _ALGLIB_GET_GLOBAL_THREADING       = 1001;
    private const int _ALGLIB_GET_NWORKERS               = 1002;
    
    public partial class smp
    {
        public static int cores_count = System.Environment.ProcessorCount;
    }
    
    // X-structure used to exchange pointer-sized integers
    [StructLayout(LayoutKind.Explicit, Pack=1)]
    private struct x_int
    {   
        public x_int(long v)
        { intval = 0; longval = v; }
       
        [FieldOffset(0)] public int intval;   // int-sized data MUST be loaded from this field
        [FieldOffset(0)] public long longval; // int-sized data MUST be stored to this field
    }

    // X-structure used to exchange pointers
    [StructLayout(LayoutKind.Explicit, Pack=1)]
    private struct x_ptr
    {   
        public x_ptr(IntPtr p)
        { alignment_enforcer = 0; ptr = p; }
       
        [FieldOffset(0)] public IntPtr ptr;              // actual pointer
        [FieldOffset(0)] public long alignment_enforcer; // placeholder for proper alignment
    }

    [StructLayout(LayoutKind.Sequential, Pack=8)]
    private unsafe struct x_vector
    {
        public long     cnt;
        public long     datatype;
        public long     owner;
        public long     last_action;
        public x_ptr    xptr;
    }

    [StructLayout(LayoutKind.Sequential, Pack=8)]
    private unsafe struct x_matrix
    {
        public long     rows;
        public long     cols;
        public long     stride;
        public long     datatype;
        public long     owner;
        public long     last_action;
        public x_ptr    xptr;
    }

    private static unsafe void x_vector_create_empty(ref x_vector x, int datatype)
    {
        x.cnt = 0;
        x.datatype = datatype;
        x.owner = OWN_CALLER;
        x.last_action = ACT_UNCHANGED;
        x.xptr.ptr = IntPtr.Zero;
    }
               
    private static unsafe void x_matrix_create_empty(ref x_matrix x, int datatype)
    {
        x.rows = 0;
        x.cols = 0;
        x.stride = 0;
        x.datatype = datatype;
        x.owner = OWN_CALLER;
        x.last_action = ACT_UNCHANGED;
        x.xptr.ptr = IntPtr.Zero;
    }
    
    private static unsafe void x_vector_clear(ref x_vector x)
    {
        if( x.owner==OWN_AE )
            x_free(x.xptr.ptr);
        x.cnt = 0;
        x.xptr.ptr = IntPtr.Zero;
    }
    
    private static unsafe void x_matrix_clear(ref x_matrix x)
    {
        if( x.owner==OWN_AE )
            x_free(x.xptr.ptr);
        x.rows = 0;
        x.cols = 0;
        x.stride = 0;
        x.xptr.ptr = IntPtr.Zero;
    }
               
    private static unsafe void x_vector_from_array(ref x_vector x, bool[] v, int mode)
    {
        int elemsize = SIZE_BOOL;
        int i, cnt;
        byte *p;
        
        //
        // Allocate
        //
        if( mode==X_CREATE )
        {
            x.datatype = DT_BOOL;
            x.cnt = ap.len(v);
            x.owner = OWN_AE;
            ap.assert(x_malloc(out x.xptr.ptr, elemsize*x.cnt)==X_OK, "ALGLIB: x_malloc failed");
            x.last_action = ACT_UNCHANGED;
        }
        if( mode==X_SET )
        {
            if( x.owner==OWN_AE )
                x_free(x.xptr.ptr);
            x.datatype = DT_BOOL;
            x.cnt = ap.len(v);
            x.owner = OWN_AE;
            ap.assert(x_malloc(out x.xptr.ptr, elemsize*x.cnt)==X_OK, "ALGLIB: x_malloc failed");
            x.last_action = ACT_NEW_LOCATION;
        }
        if( mode==X_REWRITE )
        {
            ap.assert(x.datatype==DT_BOOL,  "ALGLIB: trying to rewrite vector - types don't match");
            ap.assert(ap.len(v)==x.cnt,     "ALGLIB: trying to rewrite vector - sizes don't match");
            ap.assert(x.last_action==ACT_UNCHANGED ||
                      x.last_action==ACT_SAME_LOCATION ||
                      x.last_action==ACT_NEW_LOCATION, "ALGLIB: trying to rewrite vector - internal protection error");
            if( x.last_action==ACT_UNCHANGED )
                x.last_action = ACT_SAME_LOCATION;
        }
        
        //
        // Copy data
        //
        p = (byte*)x.xptr.ptr.ToPointer();
        cnt = (int)x.cnt;
        ap.assert(cnt==x.cnt,  "ALGLIB: 32/64 conversion error (x-vector too long)");
        for(i=0; i<cnt; i++)
            p[i] = v[i] ? (byte)1 : (byte)0;
    }
    
    // attaches X-array to existing C# array
    private static unsafe void x_vector_attach_to_array(ref x_vector x, bool *v, int len)
    {
        //
        // Attach
        //
        x.datatype = DT_BOOL;
        x.cnt = len;
        x.owner = OWN_CALLER;
        x.xptr.ptr = new IntPtr((void*)v);
        x.last_action = ACT_UNCHANGED;
    }
    
    // converts X-array to C# array; v can be null.
    private static unsafe void x_vector_to_array(ref x_vector x, ref bool[] v)
    {
        int i, cnt;
        byte *p;
        cnt = (int)x.cnt;
        ap.assert(cnt==x.cnt,           "ALGLIB: 32/64 conversion error (x-vector too long)");
        ap.assert(x.datatype==DT_BOOL,  "ALGLIB: internal error (unexpected x-vector type)");
        p = (byte*)x.xptr.ptr;
        if( v==null || ap.len(v)!=cnt )
            v = new bool[cnt];
        for(i=0; i<cnt; i++)
            v[i] = p[i]!=0;
    }
               
    private static unsafe void x_matrix_from_array(ref x_matrix x, bool[,] v, int mode)
    {
        int elemsize = SIZE_BOOL;
        int i, j;
        int rows, cols;
        byte *p;
        
        //
        // Normalize matrix size
        //
        rows = ap.rows(v);
        if( rows>0 )
            cols = ap.cols(v);
        else
            cols = 0;
        if( cols==0 )
            rows = 0;
        
        //
        // Allocate
        //
        if( mode==X_CREATE )
        {
            x.datatype = DT_BOOL;
            x.rows = rows;
            x.cols = cols;
            x.stride = cols;
            x.owner = OWN_AE;
            ap.assert(x_malloc(out x.xptr.ptr, elemsize*x.stride*x.rows)==X_OK, "ALGLIB: x_malloc failed");
            x.last_action = ACT_UNCHANGED;
        }
        if( mode==X_SET )
        {
            if( x.owner==OWN_AE )
                x_free(x.xptr.ptr);
            x.datatype = DT_BOOL;
            x.rows = rows;
            x.cols = cols;
            x.stride = cols;
            x.owner = OWN_AE;
            ap.assert(x_malloc(out x.xptr.ptr, elemsize*x.stride*x.rows)==X_OK, "ALGLIB: x_malloc failed");
            x.last_action = ACT_NEW_LOCATION;
        }
        if( mode==X_REWRITE )
        {
            ap.assert(x.datatype==DT_BOOL,  "ALGLIB: trying to rewrite matrix - types don't match");
            ap.assert(ap.rows(v)==x.rows,   "ALGLIB: trying to rewrite matrix - sizes don't match");
            ap.assert(ap.cols(v)==x.cols,   "ALGLIB: trying to rewrite matrix - sizes don't match");
            ap.assert(x.last_action==ACT_UNCHANGED ||
                      x.last_action==ACT_SAME_LOCATION ||
                      x.last_action==ACT_NEW_LOCATION, "ALGLIB: trying to rewrite matrix - internal protection error");
            if( x.last_action==ACT_UNCHANGED )
                x.last_action = ACT_SAME_LOCATION;
        }
        
        //
        // Copy data
        //
        p = (byte*)x.xptr.ptr.ToPointer();
        for(i=0; i<rows; i++)
        {
            for(j=0; j<cols; j++)
                p[j] = v[i,j] ? (byte)1 : (byte)0;
            p += x.stride;
        }
    }
    
    // attaches X-array to existing C# array
    private static unsafe void x_matrix_attach_to_array(ref x_matrix x, bool *v, int rows, int cols)
    {
        //
        // Normalize matrix size
        //
        if( rows==0 || cols==0 )
        {
            cols = 0;
            rows = 0;
        }
        
        //
        // Allocate
        //
        x.datatype = DT_BOOL;
        x.rows = rows;
        x.cols = cols;
        x.stride = cols;
        x.owner = OWN_CALLER;
        x.xptr.ptr = new IntPtr((void*)v);
        x.last_action = ACT_UNCHANGED;
    }
    
    // converts X-array to C# array; v can be null.
    private static unsafe void x_matrix_to_array(ref x_matrix x, ref bool[,] v)
    {
        int i, j;
        int rows, cols, stride;
        byte *p;
        rows   = (int)x.rows;
        cols   = (int)x.cols;
        stride = (int)x.stride;
        ap.assert(rows==x.rows,         "ALGLIB: 32/64 conversion error (x-matrix too long)");
        ap.assert(cols==x.cols,         "ALGLIB: 32/64 conversion error (x-matrix too long)");
        ap.assert(stride==x.stride,     "ALGLIB: 32/64 conversion error (x-matrix too long)");
        ap.assert(x.datatype==DT_BOOL,  "ALGLIB: internal error (unexpected x-matrix type)");
        if( v==null || ap.rows(v)!=rows || ap.cols(v)!=cols )
            v = new bool[rows,cols];
        p = (byte*)x.xptr.ptr;
        for(i=0; i<rows; i++)
        {
            for(j=0; j<cols; j++)
                v[i,j] = p[j]!=0;
            p += stride;
        }
    }
               
    private static unsafe void x_vector_from_array(ref x_vector x, int[] v, int mode)
    {
        int elemsize = SIZE_INT;
        int i, cnt;
        IntPtr *p;
        
        //
        // Allocate
        //
        if( mode==X_CREATE )
        {
            x.datatype = DT_INT;
            x.cnt = ap.len(v);
            x.owner = OWN_AE;
            ap.assert(x_malloc(out x.xptr.ptr, elemsize*x.cnt)==X_OK, "ALGLIB: x_malloc failed");
            x.last_action = ACT_UNCHANGED;
        }
        if( mode==X_SET )
        {
            if( x.owner==OWN_AE )
                x_free(x.xptr.ptr);
            x.datatype = DT_INT;
            x.cnt = ap.len(v);
            x.owner = OWN_AE;
            ap.assert(x_malloc(out x.xptr.ptr, elemsize*x.cnt)==X_OK, "ALGLIB: x_malloc failed");
            x.last_action = ACT_NEW_LOCATION;
        }
        if( mode==X_REWRITE )
        {
            ap.assert(x.datatype==DT_INT,   "ALGLIB: trying to rewrite vector - types don't match");
            ap.assert(ap.len(v)==x.cnt,     "ALGLIB: trying to rewrite vector - sizes don't match");
            ap.assert(x.last_action==ACT_UNCHANGED ||
                      x.last_action==ACT_SAME_LOCATION ||
                      x.last_action==ACT_NEW_LOCATION, "ALGLIB: trying to rewrite vector - internal protection error");
            if( x.last_action==ACT_UNCHANGED )
                x.last_action = ACT_SAME_LOCATION;
        }
        
        //
        // Copy data
        //
        p = (IntPtr*)x.xptr.ptr.ToPointer();
        cnt = (int)x.cnt;
        ap.assert(cnt==x.cnt,  "ALGLIB: 32/64 conversion error (x-vector too long)");
        for(i=0; i<cnt; i++)
            p[i] = (IntPtr)v[i];
    }
    
    // converts X-array to C# array; v can be null.
    private static unsafe void x_vector_to_array(ref x_vector x, ref int[] v)
    {
        int i, cnt;
        IntPtr *p;
        cnt = (int)x.cnt;
        ap.assert(cnt==x.cnt,           "ALGLIB: 32/64 conversion error (x-vector too long)");
        ap.assert(x.datatype==DT_INT,   "ALGLIB: internal error (unexpected x-vector type)");
        p = (IntPtr*)x.xptr.ptr;
        if( v==null || ap.len(v)!=cnt )
            v = new int[cnt];
        for(i=0; i<cnt; i++)
            v[i] = (int)p[i];
    }
               
    private static unsafe void x_matrix_from_array(ref x_matrix x, int[,] v, int mode)
    {
        int elemsize = SIZE_INT;
        int i, j;
        int rows, cols;
        IntPtr *p;
        
        //
        // Normalize matrix size
        //
        rows = ap.rows(v);
        if( rows>0 )
            cols = ap.cols(v);
        else
            cols = 0;
        if( cols==0 )
            rows = 0;
        
        //
        // Allocate
        //
        if( mode==X_CREATE )
        {
            x.datatype = DT_INT;
            x.rows = rows;
            x.cols = cols;
            x.stride = cols;
            x.owner = OWN_AE;
            ap.assert(x_malloc(out x.xptr.ptr, elemsize*x.stride*x.rows)==X_OK, "ALGLIB: x_malloc failed");
            x.last_action = ACT_UNCHANGED;
        }
        if( mode==X_SET )
        {
            if( x.owner==OWN_AE )
                x_free(x.xptr.ptr);
            x.datatype = DT_INT;
            x.rows = rows;
            x.cols = cols;
            x.stride = cols;
            x.owner = OWN_AE;
            ap.assert(x_malloc(out x.xptr.ptr, elemsize*x.stride*x.rows)==X_OK, "ALGLIB: x_malloc failed");
            x.last_action = ACT_NEW_LOCATION;
        }
        if( mode==X_REWRITE )
        {
            ap.assert(x.datatype==DT_INT,   "ALGLIB: trying to rewrite matrix - types don't match");
            ap.assert(ap.rows(v)==x.rows,   "ALGLIB: trying to rewrite matrix - sizes don't match");
            ap.assert(ap.cols(v)==x.cols,   "ALGLIB: trying to rewrite matrix - sizes don't match");
            ap.assert(x.last_action==ACT_UNCHANGED ||
                      x.last_action==ACT_SAME_LOCATION ||
                      x.last_action==ACT_NEW_LOCATION, "ALGLIB: trying to rewrite matrix - internal protection error");
            if( x.last_action==ACT_UNCHANGED )
                x.last_action = ACT_SAME_LOCATION;
        }
        
        //
        // Copy data
        //
        p = (IntPtr*)x.xptr.ptr.ToPointer();
        for(i=0; i<rows; i++)
        {
            for(j=0; j<cols; j++)
                p[j] = (IntPtr)v[i,j];
            p += x.stride;
        }
    }
    
    // converts X-array to C# array; v can be null.
    private static unsafe void x_matrix_to_array(ref x_matrix x, ref int[,] v)
    {
        int i, j;
        int rows, cols, stride;
        IntPtr *p;
        rows   = (int)x.rows;
        cols   = (int)x.cols;
        stride = (int)x.stride;
        ap.assert(rows==x.rows,         "ALGLIB: 32/64 conversion error (x-matrix too long)");
        ap.assert(cols==x.cols,         "ALGLIB: 32/64 conversion error (x-matrix too long)");
        ap.assert(stride==x.stride,     "ALGLIB: 32/64 conversion error (x-matrix too long)");
        ap.assert(x.datatype==DT_INT,   "ALGLIB: internal error (unexpected x-matrix type)");
        if( v==null || ap.rows(v)!=rows || ap.cols(v)!=cols )
            v = new int[rows,cols];
        p = (IntPtr*)x.xptr.ptr;
        for(i=0; i<rows; i++)
        {
            for(j=0; j<cols; j++)
                v[i,j] = (int)p[j];
            p += stride;
        }
    }
               
    private static unsafe void x_vector_from_array(ref x_vector x, double[] v, int mode)
    {
        int elemsize = SIZE_REAL;
        int i, cnt;
        double *p;
        
        //
        // Allocate
        //
        if( mode==X_CREATE )
        {
            x.datatype = DT_REAL;
            x.cnt = ap.len(v);
            x.owner = OWN_AE;
            ap.assert(x_malloc(out x.xptr.ptr, elemsize*x.cnt)==X_OK, "ALGLIB: x_malloc failed");
            x.last_action = ACT_UNCHANGED;
        }
        if( mode==X_SET )
        {
            if( x.owner==OWN_AE )
                x_free(x.xptr.ptr);
            x.datatype = DT_REAL;
            x.cnt = ap.len(v);
            x.owner = OWN_AE;
            ap.assert(x_malloc(out x.xptr.ptr, elemsize*x.cnt)==X_OK, "ALGLIB: x_malloc failed");
            x.last_action = ACT_NEW_LOCATION;
        }
        if( mode==X_REWRITE )
        {
            ap.assert(x.datatype==DT_REAL,  "ALGLIB: trying to rewrite vector - types don't match");
            ap.assert(ap.len(v)==x.cnt,     "ALGLIB: trying to rewrite vector - sizes don't match");
            ap.assert(x.last_action==ACT_UNCHANGED ||
                      x.last_action==ACT_SAME_LOCATION ||
                      x.last_action==ACT_NEW_LOCATION, "ALGLIB: trying to rewrite vector - internal protection error");
            if( x.last_action==ACT_UNCHANGED )
                x.last_action = ACT_SAME_LOCATION;
        }
        
        //
        // Copy data
        //
        p = (double*)x.xptr.ptr.ToPointer();
        cnt = (int)x.cnt;
        ap.assert(cnt==x.cnt,  "ALGLIB: 32/64 conversion error (x-vector too long)");
        for(i=0; i<cnt; i++)
            p[i] = v[i];
    }
    
    // attaches X-array to existing C# array
    private static unsafe void x_vector_attach_to_array(ref x_vector x, double *v, int len)
    {
        //
        // Attach
        //
        x.datatype = DT_REAL;
        x.cnt = len;
        x.owner = OWN_CALLER;
        x.xptr.ptr = new IntPtr((void*)v);
        x.last_action = ACT_UNCHANGED;
    }
    
    // converts X-array to C# array; v can be null.
    private static unsafe void x_vector_to_array(ref x_vector x, ref double[] v)
    {
        int i, cnt;
        double *p;
        cnt = (int)x.cnt;
        ap.assert(cnt==x.cnt,           "ALGLIB: 32/64 conversion error (x-vector too long)");
        ap.assert(x.datatype==DT_REAL,  "ALGLIB: internal error (unexpected x-vector type)");
        p = (double*)x.xptr.ptr;
        if( v==null || ap.len(v)!=cnt )
            v = new double[cnt];
        for(i=0; i<cnt; i++)
            v[i] = p[i];
    }
               
    private static unsafe void x_matrix_from_array(ref x_matrix x, double[,] v, int mode)
    {
        int elemsize = SIZE_REAL;
        int i, j;
        int rows, cols;
        double *p;
        
        //
        // Normalize matrix size
        //
        rows = ap.rows(v);
        if( rows>0 )
            cols = ap.cols(v);
        else
            cols = 0;
        if( cols==0 )
            rows = 0;
        
        //
        // Allocate
        //
        if( mode==X_CREATE )
        {
            x.datatype = DT_REAL;
            x.rows = rows;
            x.cols = cols;
            x.stride = cols;
            x.owner = OWN_AE;
            ap.assert(x_malloc(out x.xptr.ptr, elemsize*x.stride*x.rows)==X_OK, "ALGLIB: x_malloc failed");
            x.last_action = ACT_UNCHANGED;
        }
        if( mode==X_SET )
        {
            if( x.owner==OWN_AE )
                x_free(x.xptr.ptr);
            x.datatype = DT_REAL;
            x.rows = rows;
            x.cols = cols;
            x.stride = cols;
            x.owner = OWN_AE;
            ap.assert(x_malloc(out x.xptr.ptr, elemsize*x.stride*x.rows)==X_OK, "ALGLIB: x_malloc failed");
            x.last_action = ACT_NEW_LOCATION;
        }
        if( mode==X_REWRITE )
        {
            ap.assert(x.datatype==DT_REAL,  "ALGLIB: trying to rewrite matrix - types don't match");
            ap.assert(ap.rows(v)==x.rows,   "ALGLIB: trying to rewrite matrix - sizes don't match");
            ap.assert(ap.cols(v)==x.cols,   "ALGLIB: trying to rewrite matrix - sizes don't match");
            ap.assert(x.last_action==ACT_UNCHANGED ||
                      x.last_action==ACT_SAME_LOCATION ||
                      x.last_action==ACT_NEW_LOCATION, "ALGLIB: trying to rewrite matrix - internal protection error");
            if( x.last_action==ACT_UNCHANGED )
                x.last_action = ACT_SAME_LOCATION;
        }
        
        //
        // Copy data
        //
        p = (double*)x.xptr.ptr.ToPointer();
        for(i=0; i<rows; i++)
        {
            for(j=0; j<cols; j++)
                p[j] = v[i,j];
            p += x.stride;
        }
    }
               
    private static unsafe void x_matrix_attach_to_array(ref x_matrix x, double *v, int rows, int cols)
    {   
        //
        // Normalize matrix size
        //
        if( rows==0 || cols==0 )
        {
            cols = 0;
            rows = 0;
        }
        
        //
        // Allocate
        //
        x.datatype = DT_REAL;
        x.rows = rows;
        x.cols = cols;
        x.stride = cols;
        x.owner = OWN_CALLER;
        x.xptr.ptr = new IntPtr((void*)v);
        x.last_action = ACT_UNCHANGED;
    }
    
    // converts X-array to C# array; v can be null.
    private static unsafe void x_matrix_to_array(ref x_matrix x, ref double[,] v)
    {
        int i, j;
        int rows, cols, stride;
        double *p;
        rows   = (int)x.rows;
        cols   = (int)x.cols;
        stride = (int)x.stride;
        ap.assert(rows==x.rows,         "ALGLIB: 32/64 conversion error (x-matrix too long)");
        ap.assert(cols==x.cols,         "ALGLIB: 32/64 conversion error (x-matrix too long)");
        ap.assert(stride==x.stride,     "ALGLIB: 32/64 conversion error (x-matrix too long)");
        ap.assert(x.datatype==DT_REAL,  "ALGLIB: internal error (unexpected x-matrix type)");
        if( v==null || ap.rows(v)!=rows || ap.cols(v)!=cols )
            v = new double[rows,cols];
        p = (double*)x.xptr.ptr;
        for(i=0; i<rows; i++)
        {
            for(j=0; j<cols; j++)
                v[i,j] = p[j];
            p += stride;
        }
    }
               
    private static unsafe void x_vector_from_array(ref x_vector x, alglib.complex[] v, int mode)
    {
        int elemsize = SIZE_COMPLEX;
        int i, cnt;
        alglib.complex *p;
        
        //
        // Allocate
        //
        if( mode==X_CREATE )
        {
            x.datatype = DT_COMPLEX;
            x.cnt = ap.len(v);
            x.owner = OWN_AE;
            ap.assert(x_malloc(out x.xptr.ptr, elemsize*x.cnt)==X_OK, "ALGLIB: x_malloc failed");
            x.last_action = ACT_UNCHANGED;
        }
        if( mode==X_SET )
        {
            if( x.owner==OWN_AE )
                x_free(x.xptr.ptr);
            x.datatype = DT_COMPLEX;
            x.cnt = ap.len(v);
            x.owner = OWN_AE;
            ap.assert(x_malloc(out x.xptr.ptr, elemsize*x.cnt)==X_OK, "ALGLIB: x_malloc failed");
            x.last_action = ACT_NEW_LOCATION;
        }
        if( mode==X_REWRITE )
        {
            ap.assert(x.datatype==DT_COMPLEX,"ALGLIB: trying to rewrite vector - types don't match");
            ap.assert(ap.len(v)==x.cnt,     "ALGLIB: trying to rewrite vector - sizes don't match");
            ap.assert(x.last_action==ACT_UNCHANGED ||
                      x.last_action==ACT_SAME_LOCATION ||
                      x.last_action==ACT_NEW_LOCATION, "ALGLIB: trying to rewrite vector - internal protection error");
            if( x.last_action==ACT_UNCHANGED )
                x.last_action = ACT_SAME_LOCATION;
        }
        
        //
        // Copy data
        //
        p = (alglib.complex*)x.xptr.ptr.ToPointer();
        cnt = (int)x.cnt;
        ap.assert(cnt==x.cnt,  "ALGLIB: 32/64 conversion error (x-vector too long)");
        for(i=0; i<cnt; i++)
        {
            p[i].x = v[i].x;
            p[i].y = v[i].y;
        }
    }
    
    // attaches X-array to existing C# array
    private static unsafe void x_vector_attach_to_array(ref x_vector x, alglib.complex *v, int len)
    {
        //
        // Attach
        //
        x.datatype = DT_COMPLEX;
        x.cnt = len;
        x.owner = OWN_CALLER;
        x.xptr.ptr = new IntPtr((void*)v);
        x.last_action = ACT_UNCHANGED;
    }
    
    // converts X-array to C# array; v can be null.
    private static unsafe void x_vector_to_array(ref x_vector x, ref alglib.complex[] v)
    {
        int i, cnt;
        alglib.complex *p;
        cnt = (int)x.cnt;
        ap.assert(cnt==x.cnt,               "ALGLIB: 32/64 conversion error (x-vector too long)");
        ap.assert(x.datatype==DT_COMPLEX,   "ALGLIB: internal error (unexpected x-vector type)");
        p = (alglib.complex*)x.xptr.ptr;
        if( v==null || ap.len(v)!=cnt )
            v = new alglib.complex[cnt];
        for(i=0; i<cnt; i++)
        {
            v[i].x = p[i].x;
            v[i].y = p[i].y;
        }
    }
               
    private static unsafe void x_matrix_from_array(ref x_matrix x, alglib.complex[,] v, int mode)
    {
        int elemsize = SIZE_COMPLEX;
        int i, j;
        int rows, cols;
        alglib.complex *p;
        
        //
        // Normalize matrix size
        //
        rows = ap.rows(v);
        if( rows>0 )
            cols = ap.cols(v);
        else
            cols = 0;
        if( cols==0 )
            rows = 0;
        
        //
        // Allocate
        //
        if( mode==X_CREATE )
        {
            x.datatype = DT_COMPLEX;
            x.rows = rows;
            x.cols = cols;
            x.stride = cols;
            x.owner = OWN_AE;
            ap.assert(x_malloc(out x.xptr.ptr, elemsize*x.stride*x.rows)==X_OK, "ALGLIB: x_malloc failed");
            x.last_action = ACT_UNCHANGED;
        }
        if( mode==X_SET )
        {
            if( x.owner==OWN_AE )
                x_free(x.xptr.ptr);
            x.datatype = DT_COMPLEX;
            x.rows = rows;
            x.cols = cols;
            x.stride = cols;
            x.owner = OWN_AE;
            ap.assert(x_malloc(out x.xptr.ptr, elemsize*x.stride*x.rows)==X_OK, "ALGLIB: x_malloc failed");
            x.last_action = ACT_NEW_LOCATION;
        }
        if( mode==X_REWRITE )
        {
            ap.assert(x.datatype==DT_COMPLEX,"ALGLIB: trying to rewrite matrix - types don't match");
            ap.assert(ap.rows(v)==x.rows,   "ALGLIB: trying to rewrite matrix - sizes don't match");
            ap.assert(ap.cols(v)==x.cols,   "ALGLIB: trying to rewrite matrix - sizes don't match");
            ap.assert(x.last_action==ACT_UNCHANGED ||
                      x.last_action==ACT_SAME_LOCATION ||
                      x.last_action==ACT_NEW_LOCATION, "ALGLIB: trying to rewrite matrix - internal protection error");
            if( x.last_action==ACT_UNCHANGED )
                x.last_action = ACT_SAME_LOCATION;
        }
        
        //
        // Copy data
        //
        p = (alglib.complex*)x.xptr.ptr.ToPointer();
        for(i=0; i<rows; i++)
        {
            for(j=0; j<cols; j++)
            {
                p[j].x = v[i,j].x;
                p[j].y = v[i,j].y;
            }
            p += x.stride;
        }
    }
    
    // attaches X-array to existing C# array
    private static unsafe void x_matrix_attach_to_array(ref x_matrix x, alglib.complex *v, int rows, int cols)
    {   
        //
        // Normalize matrix size
        //
        if( rows==0 || cols==0 )
        {
            cols = 0;
            rows = 0;
        }
        
        //
        // Allocate
        //
        x.datatype = DT_COMPLEX;
        x.rows = rows;
        x.cols = cols;
        x.stride = cols;
        x.owner = OWN_CALLER;
        x.xptr.ptr = new IntPtr((void*)v);
        x.last_action = ACT_UNCHANGED;
    }
    
    // converts X-array to C# array; v can be null.
    private static unsafe void x_matrix_to_array(ref x_matrix x, ref alglib.complex[,] v)
    {
        int i, j;
        int rows, cols, stride;
        alglib.complex *p;
        rows   = (int)x.rows;
        cols   = (int)x.cols;
        stride = (int)x.stride;
        ap.assert(rows==x.rows,         "ALGLIB: 32/64 conversion error (x-matrix too long)");
        ap.assert(cols==x.cols,         "ALGLIB: 32/64 conversion error (x-matrix too long)");
        ap.assert(stride==x.stride,     "ALGLIB: 32/64 conversion error (x-matrix too long)");
        ap.assert(x.datatype==DT_COMPLEX,"ALGLIB: internal error (unexpected x-matrix type)");
        if( v==null || ap.rows(v)!=rows || ap.cols(v)!=cols )
            v = new alglib.complex[rows,cols];
        p = (alglib.complex*)x.xptr.ptr;
        for(i=0; i<rows; i++)
        {
            for(j=0; j<cols; j++)
            {
                v[i,j].x = p[j].x;
                v[i,j].y = p[j].y;
            }
            p += stride;
        }
    }
    
    /*
     * Exception handling/forwarding
     * Successfully returns for error_code==X_OK.
     */
    private static unsafe void handle_exception(int error_code, byte *s_msg, string func_name)
    {
        if( error_code==X_OK )
            return;
        if( error_code==X_ASSERTION_FAILED )
            throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)s_msg));
        if( error_code==X_MALLOC_ERROR )
            throw new alglibexception("ALGLIB: malloc() error during '"+func_name+"' call");
        throw new alglibexception("ALGLIB: unknown error during '"+func_name+"' call");
    }
    
    /*
     * Windows dynamic PInvoke
     *
     * Can be turned off by defining AE_OS_NOT_WINDOWS at global level.
     */
#if !AE_OS_NOT_WINDOWS
    [DllImport("kernel32")]
    private extern static IntPtr LoadLibrary(string libraryName);

    [DllImport("kernel32", CharSet=CharSet.Ansi)]
    private extern static IntPtr GetProcAddress(IntPtr hwnd, string procedureName);
#endif

    /*
     * Linux dynamic PInvoke
     */
#if !AE_OS_NOT_LINUX
    const int RTLD_NOW = 2; // for dlopen's flags

    [DllImport("libdl.so")]
    static extern IntPtr dlopen(string filename, int flags);

    [DllImport("libdl.so")]
    protected static extern IntPtr dlsym(IntPtr handle, string symbol);
#endif
    
    /*
     * ALGLIB compatibility layer
     */
    // loads dynamic library returns IntPtr which holds its handle
    private static IntPtr DynamicLoad(string name)
    {
        string s = GetOSName();
#if !AE_OS_NOT_WINDOWS
        if( s=="windows" )
            return LoadLibrary(name);
#endif
#if !AE_OS_NOT_LINUX
        if( s=="linux" )
            return dlopen(name, RTLD_NOW);
#endif
        return IntPtr.Zero;
    }
    
    // returns IntPtr pointing to function 'name' from dynamic library hLib
    private static IntPtr DynamicAddr(IntPtr hLib, string name)
    {
        string s = GetOSName();
#if !AE_OS_NOT_WINDOWS
        if( s=="windows" )
            return GetProcAddress(hLib, name);
#endif
#if !AE_OS_NOT_LINUX
        if( s=="linux" )
            return dlsym(hLib, name);
#endif
        return IntPtr.Zero;
    }
    
    // binds delegate Dlg to the native function from ALGLIB library
    private static void LoadXFunction<T>(IntPtr hLib, string name, out T Dlg)
    {
        IntPtr p = DynamicAddr(hLib, name);
        if( p==IntPtr.Zero )
            throw new System.Exception("ALGLIB: can't load function '"+name+"'");
        Dlg = (T)((object)Marshal.GetDelegateForFunctionPointer(p, typeof(T)));
    }
    
    // returns OS name: 'windows' or 'linux'
    private static string GetOSName()
    {
        if( System.IO.Path.DirectorySeparatorChar=='/' )
            return "linux";
        return "windows";
    }
    
    //
    // This function tries to locate library given by its name (with
    // OS-specific extension) in one of the following search directories:
    // *  given by paths[] array
    // *  given by GetExecutingAssembly().CodeBase property for
    //    assemblies NOT in the GAC (if previous attempt failed)
    // *  given by GetEntryAssembly().CodeBase property (if previous
    //    attempt failed)
    //
    private static string LocateLibrary(string name)
    {
        string libpath = "";
        string tmppath = "";
        if( libpath=="" )
        {
            int i;
            for(i=0; i<paths.Length; i++)
                if( System.IO.File.Exists(paths[i]+System.IO.Path.DirectorySeparatorChar+name) )
                {
                    libpath = paths[i];
                    break;
                }
                    
        }
        if( libpath=="" && Assembly.GetExecutingAssembly().CodeBase!="" )
        {
            string codeBase = Assembly.GetExecutingAssembly().CodeBase;
            UriBuilder uri = new UriBuilder(codeBase);
            string path = Uri.UnescapeDataString(uri.Path);
            tmppath = System.IO.Path.GetDirectoryName(path);
            if( System.IO.File.Exists(tmppath+System.IO.Path.DirectorySeparatorChar+name) )
                libpath = tmppath;
        }
        if( libpath=="" && Assembly.GetEntryAssembly()!=null )
        {
            string codeBase = Assembly.GetEntryAssembly().CodeBase;
            UriBuilder uri = new UriBuilder(codeBase);
            string path = Uri.UnescapeDataString(uri.Path);
            tmppath = System.IO.Path.GetDirectoryName(path);
            if( System.IO.File.Exists(tmppath+System.IO.Path.DirectorySeparatorChar+name) )
                libpath = tmppath;
        }
        if( libpath=="" )
            throw new System.Exception("ALGLIB: can't determine path to "+name);
        return libpath+System.IO.Path.DirectorySeparatorChar+name;
    }
    
    /********************************************************************
    This function loads ALGLIB HPC core (if not loaded yet).
    
    ALGLIB core is automatically  loaded  before  first  call  of  ALGLIB
    functions, but you may call this function  if  you  want  core  being
    loaded right now.
    ********************************************************************/
    public static void activatealglibcore()
    {
        // code below uses double-checked locking, safe in NET 2.0 and later
        if( hAlglibDL==IntPtr.Zero )
            lock(CoreInitLock)
            {
                if( hAlglibDL==IntPtr.Zero )
                {
                    string os = GetOSName();
                    string libname = "";
                    if( os=="linux" )
                        libname = "alglib320_"+(IntPtr.Size*8).ToString()+"hpc.so";
                    if( os=="windows" )
                        libname = "alglib320_"+(IntPtr.Size*8).ToString()+"hpc.dll";
                    if( libname=="" )
                        throw new System.Exception("ALGLIB: unknown OS - '"+os+"'");
                    libname = LocateLibrary(libname);
                    IntPtr hTemporaryAlglibDL = DynamicLoad(libname);
                    if( hTemporaryAlglibDL==IntPtr.Zero )
                        throw new System.Exception("ALGLIB: unable to load binaries");
                    LoadALGLIBFunctions(hTemporaryAlglibDL);
                    x_activate_core();
                    hAlglibDL = hTemporaryAlglibDL;
                }
            }
    }
    
    /************************************************************************
    This function adds to search list  one  more  potential  path  to  ALGLIB
    native DLL's. This function should be  called  prior  to  first  call  of
    ALGLIB  functions.
    
    INPUT PARAMETERS:
        path        -   search path, can be relative (to  current  directory)
                        or absolute.
                        
                        
    NOTE 1: If  you  specified  relative  path, you should remember that path
            is evaluated during first call of ALGLIB functions. Say, if:
            * 'programdir' is current directory, with  'subdir'  subdirectory
              where ALGLIB DLL's are located.
            * you added 'subdir' as search path
            * you changed current directory to 'c:/'
            * and only after THAT you called first ALGLIB function
            then you won't be able to detect and load ALGLIB DLL's
            
    NOTE 2: If you want, you may enforce activation of ALGLIB core by calling
            activatealglibcore() function.
    ************************************************************************/
    public static void addsearchpath(string path)
    {
         lock(CoreInitLock)
         {
             string[] newpaths = new string[paths.Length+1];
             int i;
             for(i=0; i<paths.Length; i++)
                 newpaths[i] = paths[i];
             newpaths[paths.Length] = path;
             paths = newpaths;
         }
    }
    
    /************************************************************************
    This function sets number of CPU cores which should  be  used  by  worker
    threads. In case user specified non-positive number of cores to use, this
    number will be converted according to following rules:
    *  0 => ae_cores_count()
    * -1 => max(ae_cores_count()-1,1)
    * -2 => max(ae_cores_count()-2,1)
    and so on.

    In case user specified positive number of  cores,  greater  than 1,  then
    ALGLIB will launch no more than ncores threads (or less, when nworkers is
    larger than actual number of cores).
    ************************************************************************/
    public static void setnworkers(int nworkers)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        x_setnworkers(nworkers);
    }
    
    /************************************************************************
    This function sets number of CPU cores which should  be  used  by  worker
    threads. In case user specified non-positive number of cores to use, this
    number will be converted according to following rules:
    *  0 => ae_cores_count()
    * -1 => max(ae_cores_count()-1,1)
    * -2 => max(ae_cores_count()-2,1)
    and so on.

    In case user specified positive number of  cores,  greater  than 1,  then
    ALGLIB will launch no more than ncores threads (or less, when nworkers is
    larger than actual number of cores).
    ************************************************************************/
    public static int getnworkers()
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        return (int)x_get_dbg_value(_ALGLIB_GET_NWORKERS);
    }
    
    /************************************************************************
    This function sets global threading settings.
    ************************************************************************/
    public static void setglobalthreading(xparams p)
    {
        AE_CRITICAL_ASSERT(p!=null);
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        x_set_dbg_flag(_ALGLIB_SET_GLOBAL_THREADING, unchecked((long)p.flags));
    }
    
    public static void ae_set_global_threading(ulong flg_value)
    {
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        x_set_dbg_flag(_ALGLIB_SET_GLOBAL_THREADING, unchecked((long)flg_value));
    }
    
    public static ulong ae_get_global_threading()
    {
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        return unchecked((ulong)x_get_dbg_value(_ALGLIB_GET_GLOBAL_THREADING));
    }
    
    
    /************************************************************************
    This  class  is  an interface between native serialization infrastructure
    and managed stream class.
    ************************************************************************/
    public unsafe class native_stream_adapter
    {
        enum SMODE { DEFAULT, TO_STREAM, FROM_STREAM };
        private const int MAX_BUF = 20;
        
        private SMODE mode;
        private System.IO.Stream io_stream;
        private byte[] entry_buf_byte; 

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate byte reader_delegate(System.IntPtr aux, System.IntPtr cnt, System.IntPtr ibuf);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate byte writer_delegate(System.IntPtr ibuf, System.IntPtr aux);
        
        public native_stream_adapter()
        {
            mode = SMODE.DEFAULT;
            entry_buf_byte = new byte[MAX_BUF];
        }

        public void clear_buffers()
        {
            io_stream = null;
        }

        public void sstart_stream(System.IO.Stream o_stream)
        {   
            // clear input/output buffers which may hold pointers to unneeded memory
            // NOTE: it also helps us to avoid errors when data are written to incorrect location
            clear_buffers();
            
            // check and change mode
            if( mode!=SMODE.DEFAULT )
                throw new alglib.alglibexception("ALGLIB: internal error during (un)serialization");
            mode = SMODE.TO_STREAM;
            io_stream = o_stream;
        }

        public void ustart_stream(System.IO.Stream i_stream)
        {
            // clear input/output buffers which may hold pointers to unneeded memory
            // NOTE: it also helps us to avoid errors when data are written to incorrect location
            clear_buffers();
            
            // check and change mode
            if( mode!=SMODE.DEFAULT )
                throw new alglib.alglibexception("ALGLIB: internal error during (un)serialization");
            mode = SMODE.FROM_STREAM;
            io_stream = i_stream;
        }
        
        public byte reader_callback(System.IntPtr ipaux, System.IntPtr ipcnt, System.IntPtr ipbuf)
        {
            try
            {
                if( mode!=SMODE.FROM_STREAM )
                    return 1;
                if( ipcnt.ToInt32()<1 )
                    return 1;
                
                byte *p_dst = (byte*)ipbuf.ToPointer();
                int cnt = ipcnt.ToInt32();
                int c;
                for(;;)
                {
                    c = io_stream.ReadByte();
                    if( c<0 )
                        return 1;
                    if( c!=' ' && c!='\t' && c!='\n' && c!='\r' )
                        break;
                }
                p_dst[0] = (byte)c;
                for(int k=1; k<cnt; k++)
                {
                    c = io_stream.ReadByte();
                    if( c<0 || c==' ' || c=='\t' || c=='\n' || c=='\r' )
                        return 1;
                    p_dst[k] = (byte)c;
                }
                p_dst[cnt] = (byte)0;
                return 0;
            }
            catch
            {
                return 1;
            }
        }

        public byte writer_callback(System.IntPtr ibuf, System.IntPtr aux)
        {
            try
            {
                if( mode!=SMODE.TO_STREAM )
                    return 1;
                byte *p_src = (byte*)ibuf.ToPointer();
                int cnt;
                for(cnt=0; p_src[cnt]!=0; cnt++)
                    entry_buf_byte[cnt] = p_src[cnt];
                io_stream.Write(entry_buf_byte, 0, cnt);
                return 0;
            }
            catch
            {
                return 1;
            }
        }
    }

    
    
    //
    // Subpackage hqrnd
    //
    

    public unsafe class hqrndstate : alglibobject
    {
        private void *_ptr;
        public hqrndstate(void *x)
        {
            _ptr = x;
        }
        ~hqrndstate()
        {
            _deallocate();
        }
        public void* ptr { get { return _ptr; } }
        public override alglib.alglibobject make_copy()
        {
            if( _ptr==null )
                return new hqrndstate(null);
            return new hqrndstate(_i_x_obj_copy_hqrndstate(_ptr));
        }
        public override void _deallocate()
        {
            if( _ptr!=null )
                _i_x_obj_free_hqrndstate(_ptr);
            _ptr = null;
            System.GC.SuppressFinalize(this);
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_hqrndstate(void *x);
    private static _d_x_obj_copy_hqrndstate _i_x_obj_copy_hqrndstate = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_obj_free_hqrndstate(void *x);
    private static _d_x_obj_free_hqrndstate _i_x_obj_free_hqrndstate = null;
    
    private static unsafe void _core_hqrndrandomize(out hqrndstate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = null;
        state = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_hqrndrandomize(&_s_errormsg, &_d_state, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "hqrndrandomize");
            state = new hqrndstate(_d_state);
        }
        finally
        {
            if( _d_state!=null && state==null)
                _i_x_obj_free_hqrndstate(_d_state); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void hqrndrandomize(out hqrndstate state)
    {
        _core_hqrndrandomize(out  state, 0x0);
    }
    
    public static void hqrndrandomize(out hqrndstate state, alglib.xparams _xparams)
    {
        _core_hqrndrandomize(out  state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_hqrndseed(int s1, int s2, out hqrndstate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_s1 = new x_int(s1);
        x_int _d_s2 = new x_int(s2);
        void *_d_state = null;
        state = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_hqrndseed(&_s_errormsg, &_d_s1, &_d_s2, &_d_state, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "hqrndseed");
            state = new hqrndstate(_d_state);
        }
        finally
        {
            if( _d_state!=null && state==null)
                _i_x_obj_free_hqrndstate(_d_state); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void hqrndseed(int s1, int s2, out hqrndstate state)
    {
        _core_hqrndseed( s1,  s2, out  state, 0x0);
    }
    
    public static void hqrndseed(int s1, int s2, out hqrndstate state, alglib.xparams _xparams)
    {
        _core_hqrndseed( s1,  s2, out  state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_hqrnduniformr(hqrndstate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_hqrnduniformr(&_s_errormsg, &_d_result, &_d_state, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "hqrnduniformr");
            result = _d_result;
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double hqrnduniformr(hqrndstate state)
    {
        return _core_hqrnduniformr( state, 0x0);
    }
    
    public static double hqrnduniformr(hqrndstate state, alglib.xparams _xparams)
    {
        return _core_hqrnduniformr( state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe int _core_hqrnduniformi(hqrndstate state, int n, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        int result;
        x_int _d_result = new x_int();
        void *_d_state = state.ptr;
        x_int _d_n = new x_int(n);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_hqrnduniformi(&_s_errormsg, &_d_result, &_d_state, &_d_n, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "hqrnduniformi");
            result = _d_result.intval;
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static int hqrnduniformi(hqrndstate state, int n)
    {
        return _core_hqrnduniformi( state,  n, 0x0);
    }
    
    public static int hqrnduniformi(hqrndstate state, int n, alglib.xparams _xparams)
    {
        return _core_hqrnduniformi( state,  n, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_hqrndnormal(hqrndstate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_hqrndnormal(&_s_errormsg, &_d_result, &_d_state, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "hqrndnormal");
            result = _d_result;
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double hqrndnormal(hqrndstate state)
    {
        return _core_hqrndnormal( state, 0x0);
    }
    
    public static double hqrndnormal(hqrndstate state, alglib.xparams _xparams)
    {
        return _core_hqrndnormal( state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_hqrndnormalv(hqrndstate state, int n, out double[] x, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_int _d_n = new x_int(n);
        x_vector _d_x = new x_vector();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_x, DT_REAL);
            x = null;
            _error_code = _i_xv2_hqrndnormalv(&_s_errormsg, &_d_state, &_d_n, &_d_x, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "hqrndnormalv");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
        }
        // This function returns no value.
    }
    
    public static void hqrndnormalv(hqrndstate state, int n, out double[] x)
    {
        _core_hqrndnormalv( state,  n, out  x, 0x0);
    }
    
    public static void hqrndnormalv(hqrndstate state, int n, out double[] x, alglib.xparams _xparams)
    {
        _core_hqrndnormalv( state,  n, out  x, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_hqrndnormalm(hqrndstate state, int m, int n, out double[,] x, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_matrix _d_x = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            x_matrix_create_empty(ref _d_x, DT_REAL);
            x = null;
            _error_code = _i_xv2_hqrndnormalm(&_s_errormsg, &_d_state, &_d_m, &_d_n, &_d_x, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "hqrndnormalm");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_x);
        }
        // This function returns no value.
    }
    
    public static void hqrndnormalm(hqrndstate state, int m, int n, out double[,] x)
    {
        _core_hqrndnormalm( state,  m,  n, out  x, 0x0);
    }
    
    public static void hqrndnormalm(hqrndstate state, int m, int n, out double[,] x, alglib.xparams _xparams)
    {
        _core_hqrndnormalm( state,  m,  n, out  x, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_hqrndunit2(hqrndstate state, out double x, out double y, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_x = 0;
        double _d_y = 0;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_hqrndunit2(&_s_errormsg, &_d_state, &_d_x, &_d_y, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "hqrndunit2");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            x = _d_x;
            y = _d_y;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void hqrndunit2(hqrndstate state, out double x, out double y)
    {
        _core_hqrndunit2( state, out  x, out  y, 0x0);
    }
    
    public static void hqrndunit2(hqrndstate state, out double x, out double y, alglib.xparams _xparams)
    {
        _core_hqrndunit2( state, out  x, out  y, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_hqrndnormal2(hqrndstate state, out double x1, out double x2, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_x1 = 0;
        double _d_x2 = 0;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_hqrndnormal2(&_s_errormsg, &_d_state, &_d_x1, &_d_x2, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "hqrndnormal2");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            x1 = _d_x1;
            x2 = _d_x2;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void hqrndnormal2(hqrndstate state, out double x1, out double x2)
    {
        _core_hqrndnormal2( state, out  x1, out  x2, 0x0);
    }
    
    public static void hqrndnormal2(hqrndstate state, out double x1, out double x2, alglib.xparams _xparams)
    {
        _core_hqrndnormal2( state, out  x1, out  x2, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_hqrndexponential(hqrndstate state, double lambdav, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_state = state.ptr;
        double _d_lambdav = lambdav;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_hqrndexponential(&_s_errormsg, &_d_result, &_d_state, &_d_lambdav, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "hqrndexponential");
            result = _d_result;
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double hqrndexponential(hqrndstate state, double lambdav)
    {
        return _core_hqrndexponential( state,  lambdav, 0x0);
    }
    
    public static double hqrndexponential(hqrndstate state, double lambdav, alglib.xparams _xparams)
    {
        return _core_hqrndexponential( state,  lambdav, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_hqrnddiscrete(hqrndstate state, double[] x, int n, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_state = state.ptr;
        x_vector _d_x = new x_vector();
        x_int _d_n = new x_int(n);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_xv2_hqrnddiscrete(&_s_errormsg, &_d_result, &_d_state, &_d_x, &_d_n, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "hqrnddiscrete");
            result = _d_result;
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_x);
        }
        return result;
    }
    
    public static double hqrnddiscrete(hqrndstate state, double[] x, int n)
    {
        return _core_hqrnddiscrete( state,  x,  n, 0x0);
    }
    
    public static double hqrnddiscrete(hqrndstate state, double[] x, int n, alglib.xparams _xparams)
    {
        return _core_hqrnddiscrete( state,  x,  n, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_hqrndcontinuous(hqrndstate state, double[] x, int n, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_state = state.ptr;
        x_vector _d_x = new x_vector();
        x_int _d_n = new x_int(n);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_xv2_hqrndcontinuous(&_s_errormsg, &_d_result, &_d_state, &_d_x, &_d_n, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "hqrndcontinuous");
            result = _d_result;
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_x);
        }
        return result;
    }
    
    public static double hqrndcontinuous(hqrndstate state, double[] x, int n)
    {
        return _core_hqrndcontinuous( state,  x,  n, 0x0);
    }
    
    public static double hqrndcontinuous(hqrndstate state, double[] x, int n, alglib.xparams _xparams)
    {
        return _core_hqrndcontinuous( state,  x,  n, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage ablas
    //
    
    
    private static unsafe void _core_cmatrixtranspose(int m, int n, complex[,] a, int ia, int ja, ref complex[,] b, int ib, int jb, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_matrix _d_a = new x_matrix();
        x_int _d_ia = new x_int(ia);
        x_int _d_ja = new x_int(ja);
        x_matrix _d_b = new x_matrix();
        x_int _d_ib = new x_int(ib);
        x_int _d_jb = new x_int(jb);
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a, _fp_b = b){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matrix_attach_to_array(ref _d_b, _fp_b, ap.rows(b), ap.cols(b));
                _error_code = _i_xv2_cmatrixtranspose(&_s_errormsg, &_d_m, &_d_n, &_d_a, &_d_ia, &_d_ja, &_d_b, &_d_ib, &_d_jb, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "cmatrixtranspose");
            if( _d_b.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_b, ref b);
            if( b == null )
                b = new alglib.complex[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matrix_clear(ref _d_b);
        }
        // This function returns no value.
    }
    
    public static void cmatrixtranspose(int m, int n, complex[,] a, int ia, int ja, ref complex[,] b, int ib, int jb)
    {
        _core_cmatrixtranspose( m,  n,  a,  ia,  ja, ref  b,  ib,  jb, 0x0);
    }
    
    public static void cmatrixtranspose(int m, int n, complex[,] a, int ia, int ja, ref complex[,] b, int ib, int jb, alglib.xparams _xparams)
    {
        _core_cmatrixtranspose( m,  n,  a,  ia,  ja, ref  b,  ib,  jb, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_rmatrixtranspose(int m, int n, double[,] a, int ia, int ja, ref double[,] b, int ib, int jb, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_matrix _d_a = new x_matrix();
        x_int _d_ia = new x_int(ia);
        x_int _d_ja = new x_int(ja);
        x_matrix _d_b = new x_matrix();
        x_int _d_ib = new x_int(ib);
        x_int _d_jb = new x_int(jb);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a, _fp_b = b){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matrix_attach_to_array(ref _d_b, _fp_b, ap.rows(b), ap.cols(b));
                _error_code = _i_xv2_rmatrixtranspose(&_s_errormsg, &_d_m, &_d_n, &_d_a, &_d_ia, &_d_ja, &_d_b, &_d_ib, &_d_jb, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rmatrixtranspose");
            if( _d_b.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_b, ref b);
            if( b == null )
                b = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matrix_clear(ref _d_b);
        }
        // This function returns no value.
    }
    
    public static void rmatrixtranspose(int m, int n, double[,] a, int ia, int ja, ref double[,] b, int ib, int jb)
    {
        _core_rmatrixtranspose( m,  n,  a,  ia,  ja, ref  b,  ib,  jb, 0x0);
    }
    
    public static void rmatrixtranspose(int m, int n, double[,] a, int ia, int ja, ref double[,] b, int ib, int jb, alglib.xparams _xparams)
    {
        _core_rmatrixtranspose( m,  n,  a,  ia,  ja, ref  b,  ib,  jb, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_rmatrixenforcesymmetricity(ref double[,] a, int n, bool isupper, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                _error_code = _i_xv2_rmatrixenforcesymmetricity(&_s_errormsg, &_d_a, &_d_n, &_d_isupper, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rmatrixenforcesymmetricity");
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        // This function returns no value.
    }
    
    public static void rmatrixenforcesymmetricity(ref double[,] a, int n, bool isupper)
    {
        _core_rmatrixenforcesymmetricity(ref  a,  n,  isupper, 0x0);
    }
    
    public static void rmatrixenforcesymmetricity(ref double[,] a, int n, bool isupper, alglib.xparams _xparams)
    {
        _core_rmatrixenforcesymmetricity(ref  a,  n,  isupper, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_cmatrixcopy(int m, int n, complex[,] a, int ia, int ja, ref complex[,] b, int ib, int jb, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_matrix _d_a = new x_matrix();
        x_int _d_ia = new x_int(ia);
        x_int _d_ja = new x_int(ja);
        x_matrix _d_b = new x_matrix();
        x_int _d_ib = new x_int(ib);
        x_int _d_jb = new x_int(jb);
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a, _fp_b = b){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matrix_attach_to_array(ref _d_b, _fp_b, ap.rows(b), ap.cols(b));
                _error_code = _i_xv2_cmatrixcopy(&_s_errormsg, &_d_m, &_d_n, &_d_a, &_d_ia, &_d_ja, &_d_b, &_d_ib, &_d_jb, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "cmatrixcopy");
            if( _d_b.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_b, ref b);
            if( b == null )
                b = new alglib.complex[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matrix_clear(ref _d_b);
        }
        // This function returns no value.
    }
    
    public static void cmatrixcopy(int m, int n, complex[,] a, int ia, int ja, ref complex[,] b, int ib, int jb)
    {
        _core_cmatrixcopy( m,  n,  a,  ia,  ja, ref  b,  ib,  jb, 0x0);
    }
    
    public static void cmatrixcopy(int m, int n, complex[,] a, int ia, int ja, ref complex[,] b, int ib, int jb, alglib.xparams _xparams)
    {
        _core_cmatrixcopy( m,  n,  a,  ia,  ja, ref  b,  ib,  jb, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_rvectorcopy(int n, double[] a, int ia, ref double[] b, int ib, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        x_vector _d_a = new x_vector();
        x_int _d_ia = new x_int(ia);
        x_vector _d_b = new x_vector();
        x_int _d_ib = new x_int(ib);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a, _fp_b = b){
                x_vector_attach_to_array(ref _d_a, _fp_a, ap.len(a));
                x_vector_attach_to_array(ref _d_b, _fp_b, ap.len(b));
                _error_code = _i_xv2_rvectorcopy(&_s_errormsg, &_d_n, &_d_a, &_d_ia, &_d_b, &_d_ib, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rvectorcopy");
            if( _d_b.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_b, ref b);
            if( b == null )
                b = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_a);
            x_vector_clear(ref _d_b);
        }
        // This function returns no value.
    }
    
    public static void rvectorcopy(int n, double[] a, int ia, ref double[] b, int ib)
    {
        _core_rvectorcopy( n,  a,  ia, ref  b,  ib, 0x0);
    }
    
    public static void rvectorcopy(int n, double[] a, int ia, ref double[] b, int ib, alglib.xparams _xparams)
    {
        _core_rvectorcopy( n,  a,  ia, ref  b,  ib, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_rmatrixcopy(int m, int n, double[,] a, int ia, int ja, ref double[,] b, int ib, int jb, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_matrix _d_a = new x_matrix();
        x_int _d_ia = new x_int(ia);
        x_int _d_ja = new x_int(ja);
        x_matrix _d_b = new x_matrix();
        x_int _d_ib = new x_int(ib);
        x_int _d_jb = new x_int(jb);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a, _fp_b = b){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matrix_attach_to_array(ref _d_b, _fp_b, ap.rows(b), ap.cols(b));
                _error_code = _i_xv2_rmatrixcopy(&_s_errormsg, &_d_m, &_d_n, &_d_a, &_d_ia, &_d_ja, &_d_b, &_d_ib, &_d_jb, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rmatrixcopy");
            if( _d_b.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_b, ref b);
            if( b == null )
                b = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matrix_clear(ref _d_b);
        }
        // This function returns no value.
    }
    
    public static void rmatrixcopy(int m, int n, double[,] a, int ia, int ja, ref double[,] b, int ib, int jb)
    {
        _core_rmatrixcopy( m,  n,  a,  ia,  ja, ref  b,  ib,  jb, 0x0);
    }
    
    public static void rmatrixcopy(int m, int n, double[,] a, int ia, int ja, ref double[,] b, int ib, int jb, alglib.xparams _xparams)
    {
        _core_rmatrixcopy( m,  n,  a,  ia,  ja, ref  b,  ib,  jb, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_rmatrixgencopy(int m, int n, double alpha, double[,] a, int ia, int ja, double beta, ref double[,] b, int ib, int jb, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        double _d_alpha = alpha;
        x_matrix _d_a = new x_matrix();
        x_int _d_ia = new x_int(ia);
        x_int _d_ja = new x_int(ja);
        double _d_beta = beta;
        x_matrix _d_b = new x_matrix();
        x_int _d_ib = new x_int(ib);
        x_int _d_jb = new x_int(jb);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a, _fp_b = b){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matrix_attach_to_array(ref _d_b, _fp_b, ap.rows(b), ap.cols(b));
                _error_code = _i_xv2_rmatrixgencopy(&_s_errormsg, &_d_m, &_d_n, &_d_alpha, &_d_a, &_d_ia, &_d_ja, &_d_beta, &_d_b, &_d_ib, &_d_jb, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rmatrixgencopy");
            if( _d_b.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_b, ref b);
            if( b == null )
                b = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matrix_clear(ref _d_b);
        }
        // This function returns no value.
    }
    
    public static void rmatrixgencopy(int m, int n, double alpha, double[,] a, int ia, int ja, double beta, ref double[,] b, int ib, int jb)
    {
        _core_rmatrixgencopy( m,  n,  alpha,  a,  ia,  ja,  beta, ref  b,  ib,  jb, 0x0);
    }
    
    public static void rmatrixgencopy(int m, int n, double alpha, double[,] a, int ia, int ja, double beta, ref double[,] b, int ib, int jb, alglib.xparams _xparams)
    {
        _core_rmatrixgencopy( m,  n,  alpha,  a,  ia,  ja,  beta, ref  b,  ib,  jb, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_rmatrixger(int m, int n, ref double[,] a, int ia, int ja, double alpha, double[] u, int iu, double[] v, int iv, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_matrix _d_a = new x_matrix();
        x_int _d_ia = new x_int(ia);
        x_int _d_ja = new x_int(ja);
        double _d_alpha = alpha;
        x_vector _d_u = new x_vector();
        x_int _d_iu = new x_int(iu);
        x_vector _d_v = new x_vector();
        x_int _d_iv = new x_int(iv);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a, _fp_u = u, _fp_v = v){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_attach_to_array(ref _d_u, _fp_u, ap.len(u));
                x_vector_attach_to_array(ref _d_v, _fp_v, ap.len(v));
                _error_code = _i_xv2_rmatrixger(&_s_errormsg, &_d_m, &_d_n, &_d_a, &_d_ia, &_d_ja, &_d_alpha, &_d_u, &_d_iu, &_d_v, &_d_iv, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rmatrixger");
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_u);
            x_vector_clear(ref _d_v);
        }
        // This function returns no value.
    }
    
    public static void rmatrixger(int m, int n, ref double[,] a, int ia, int ja, double alpha, double[] u, int iu, double[] v, int iv)
    {
        _core_rmatrixger( m,  n, ref  a,  ia,  ja,  alpha,  u,  iu,  v,  iv, 0x0);
    }
    
    public static void rmatrixger(int m, int n, ref double[,] a, int ia, int ja, double alpha, double[] u, int iu, double[] v, int iv, alglib.xparams _xparams)
    {
        _core_rmatrixger( m,  n, ref  a,  ia,  ja,  alpha,  u,  iu,  v,  iv, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_cmatrixrank1(int m, int n, ref complex[,] a, int ia, int ja, ref complex[] u, int iu, ref complex[] v, int iv, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_matrix _d_a = new x_matrix();
        x_int _d_ia = new x_int(ia);
        x_int _d_ja = new x_int(ja);
        x_vector _d_u = new x_vector();
        x_int _d_iu = new x_int(iu);
        x_vector _d_v = new x_vector();
        x_int _d_iv = new x_int(iv);
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a, _fp_u = u, _fp_v = v){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_attach_to_array(ref _d_u, _fp_u, ap.len(u));
                x_vector_attach_to_array(ref _d_v, _fp_v, ap.len(v));
                _error_code = _i_xv2_cmatrixrank1(&_s_errormsg, &_d_m, &_d_n, &_d_a, &_d_ia, &_d_ja, &_d_u, &_d_iu, &_d_v, &_d_iv, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "cmatrixrank1");
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new alglib.complex[0,0];
            if( _d_u.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_u, ref u);
            if( u == null )
                u = new alglib.complex[0];
            if( _d_v.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_v, ref v);
            if( v == null )
                v = new alglib.complex[0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_u);
            x_vector_clear(ref _d_v);
        }
        // This function returns no value.
    }
    
    public static void cmatrixrank1(int m, int n, ref complex[,] a, int ia, int ja, ref complex[] u, int iu, ref complex[] v, int iv)
    {
        _core_cmatrixrank1( m,  n, ref  a,  ia,  ja, ref  u,  iu, ref  v,  iv, 0x0);
    }
    
    public static void cmatrixrank1(int m, int n, ref complex[,] a, int ia, int ja, ref complex[] u, int iu, ref complex[] v, int iv, alglib.xparams _xparams)
    {
        _core_cmatrixrank1( m,  n, ref  a,  ia,  ja, ref  u,  iu, ref  v,  iv, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_rmatrixrank1(int m, int n, ref double[,] a, int ia, int ja, ref double[] u, int iu, ref double[] v, int iv, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_matrix _d_a = new x_matrix();
        x_int _d_ia = new x_int(ia);
        x_int _d_ja = new x_int(ja);
        x_vector _d_u = new x_vector();
        x_int _d_iu = new x_int(iu);
        x_vector _d_v = new x_vector();
        x_int _d_iv = new x_int(iv);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a, _fp_u = u, _fp_v = v){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_attach_to_array(ref _d_u, _fp_u, ap.len(u));
                x_vector_attach_to_array(ref _d_v, _fp_v, ap.len(v));
                _error_code = _i_xv2_rmatrixrank1(&_s_errormsg, &_d_m, &_d_n, &_d_a, &_d_ia, &_d_ja, &_d_u, &_d_iu, &_d_v, &_d_iv, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rmatrixrank1");
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new double[0,0];
            if( _d_u.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_u, ref u);
            if( u == null )
                u = new double[0];
            if( _d_v.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_v, ref v);
            if( v == null )
                v = new double[0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_u);
            x_vector_clear(ref _d_v);
        }
        // This function returns no value.
    }
    
    public static void rmatrixrank1(int m, int n, ref double[,] a, int ia, int ja, ref double[] u, int iu, ref double[] v, int iv)
    {
        _core_rmatrixrank1( m,  n, ref  a,  ia,  ja, ref  u,  iu, ref  v,  iv, 0x0);
    }
    
    public static void rmatrixrank1(int m, int n, ref double[,] a, int ia, int ja, ref double[] u, int iu, ref double[] v, int iv, alglib.xparams _xparams)
    {
        _core_rmatrixrank1( m,  n, ref  a,  ia,  ja, ref  u,  iu, ref  v,  iv, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_rmatrixgemv(int m, int n, double alpha, double[,] a, int ia, int ja, int opa, double[] x, int ix, double beta, ref double[] y, int iy, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        double _d_alpha = alpha;
        x_matrix _d_a = new x_matrix();
        x_int _d_ia = new x_int(ia);
        x_int _d_ja = new x_int(ja);
        x_int _d_opa = new x_int(opa);
        x_vector _d_x = new x_vector();
        x_int _d_ix = new x_int(ix);
        double _d_beta = beta;
        x_vector _d_y = new x_vector();
        x_int _d_iy = new x_int(iy);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a, _fp_x = x, _fp_y = y){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                _error_code = _i_xv2_rmatrixgemv(&_s_errormsg, &_d_m, &_d_n, &_d_alpha, &_d_a, &_d_ia, &_d_ja, &_d_opa, &_d_x, &_d_ix, &_d_beta, &_d_y, &_d_iy, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rmatrixgemv");
            if( _d_y.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_y, ref y);
            if( y == null )
                y = new double[0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
        }
        // This function returns no value.
    }
    
    public static void rmatrixgemv(int m, int n, double alpha, double[,] a, int ia, int ja, int opa, double[] x, int ix, double beta, ref double[] y, int iy)
    {
        _core_rmatrixgemv( m,  n,  alpha,  a,  ia,  ja,  opa,  x,  ix,  beta, ref  y,  iy, 0x0);
    }
    
    public static void rmatrixgemv(int m, int n, double alpha, double[,] a, int ia, int ja, int opa, double[] x, int ix, double beta, ref double[] y, int iy, alglib.xparams _xparams)
    {
        _core_rmatrixgemv( m,  n,  alpha,  a,  ia,  ja,  opa,  x,  ix,  beta, ref  y,  iy, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_cmatrixmv(int m, int n, complex[,] a, int ia, int ja, int opa, complex[] x, int ix, ref complex[] y, int iy, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_matrix _d_a = new x_matrix();
        x_int _d_ia = new x_int(ia);
        x_int _d_ja = new x_int(ja);
        x_int _d_opa = new x_int(opa);
        x_vector _d_x = new x_vector();
        x_int _d_ix = new x_int(ix);
        x_vector _d_y = new x_vector();
        x_int _d_iy = new x_int(iy);
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a, _fp_x = x, _fp_y = y){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                _error_code = _i_xv2_cmatrixmv(&_s_errormsg, &_d_m, &_d_n, &_d_a, &_d_ia, &_d_ja, &_d_opa, &_d_x, &_d_ix, &_d_y, &_d_iy, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "cmatrixmv");
            if( _d_y.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_y, ref y);
            if( y == null )
                y = new alglib.complex[0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
        }
        // This function returns no value.
    }
    
    public static void cmatrixmv(int m, int n, complex[,] a, int ia, int ja, int opa, complex[] x, int ix, ref complex[] y, int iy)
    {
        _core_cmatrixmv( m,  n,  a,  ia,  ja,  opa,  x,  ix, ref  y,  iy, 0x0);
    }
    
    public static void cmatrixmv(int m, int n, complex[,] a, int ia, int ja, int opa, complex[] x, int ix, ref complex[] y, int iy, alglib.xparams _xparams)
    {
        _core_cmatrixmv( m,  n,  a,  ia,  ja,  opa,  x,  ix, ref  y,  iy, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_rmatrixmv(int m, int n, double[,] a, int ia, int ja, int opa, double[] x, int ix, ref double[] y, int iy, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_matrix _d_a = new x_matrix();
        x_int _d_ia = new x_int(ia);
        x_int _d_ja = new x_int(ja);
        x_int _d_opa = new x_int(opa);
        x_vector _d_x = new x_vector();
        x_int _d_ix = new x_int(ix);
        x_vector _d_y = new x_vector();
        x_int _d_iy = new x_int(iy);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a, _fp_x = x, _fp_y = y){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                _error_code = _i_xv2_rmatrixmv(&_s_errormsg, &_d_m, &_d_n, &_d_a, &_d_ia, &_d_ja, &_d_opa, &_d_x, &_d_ix, &_d_y, &_d_iy, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rmatrixmv");
            if( _d_y.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_y, ref y);
            if( y == null )
                y = new double[0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
        }
        // This function returns no value.
    }
    
    public static void rmatrixmv(int m, int n, double[,] a, int ia, int ja, int opa, double[] x, int ix, ref double[] y, int iy)
    {
        _core_rmatrixmv( m,  n,  a,  ia,  ja,  opa,  x,  ix, ref  y,  iy, 0x0);
    }
    
    public static void rmatrixmv(int m, int n, double[,] a, int ia, int ja, int opa, double[] x, int ix, ref double[] y, int iy, alglib.xparams _xparams)
    {
        _core_rmatrixmv( m,  n,  a,  ia,  ja,  opa,  x,  ix, ref  y,  iy, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_rmatrixsymv(int n, double alpha, double[,] a, int ia, int ja, bool isupper, double[] x, int ix, double beta, ref double[] y, int iy, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        double _d_alpha = alpha;
        x_matrix _d_a = new x_matrix();
        x_int _d_ia = new x_int(ia);
        x_int _d_ja = new x_int(ja);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_vector _d_x = new x_vector();
        x_int _d_ix = new x_int(ix);
        double _d_beta = beta;
        x_vector _d_y = new x_vector();
        x_int _d_iy = new x_int(iy);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a, _fp_x = x, _fp_y = y){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                _error_code = _i_xv2_rmatrixsymv(&_s_errormsg, &_d_n, &_d_alpha, &_d_a, &_d_ia, &_d_ja, &_d_isupper, &_d_x, &_d_ix, &_d_beta, &_d_y, &_d_iy, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rmatrixsymv");
            if( _d_y.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_y, ref y);
            if( y == null )
                y = new double[0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
        }
        // This function returns no value.
    }
    
    public static void rmatrixsymv(int n, double alpha, double[,] a, int ia, int ja, bool isupper, double[] x, int ix, double beta, ref double[] y, int iy)
    {
        _core_rmatrixsymv( n,  alpha,  a,  ia,  ja,  isupper,  x,  ix,  beta, ref  y,  iy, 0x0);
    }
    
    public static void rmatrixsymv(int n, double alpha, double[,] a, int ia, int ja, bool isupper, double[] x, int ix, double beta, ref double[] y, int iy, alglib.xparams _xparams)
    {
        _core_rmatrixsymv( n,  alpha,  a,  ia,  ja,  isupper,  x,  ix,  beta, ref  y,  iy, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_rmatrixsyvmv(int n, double[,] a, int ia, int ja, bool isupper, double[] x, int ix, ref double[] tmp, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_int _d_n = new x_int(n);
        x_matrix _d_a = new x_matrix();
        x_int _d_ia = new x_int(ia);
        x_int _d_ja = new x_int(ja);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_vector _d_x = new x_vector();
        x_int _d_ix = new x_int(ix);
        x_vector _d_tmp = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a, _fp_x = x, _fp_tmp = tmp){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_tmp, _fp_tmp, ap.len(tmp));
                _error_code = _i_xv2_rmatrixsyvmv(&_s_errormsg, &_d_result, &_d_n, &_d_a, &_d_ia, &_d_ja, &_d_isupper, &_d_x, &_d_ix, &_d_tmp, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rmatrixsyvmv");
            result = _d_result;
            if( _d_tmp.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_tmp, ref tmp);
            if( tmp == null )
                tmp = new double[0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_tmp);
        }
        return result;
    }
    
    public static double rmatrixsyvmv(int n, double[,] a, int ia, int ja, bool isupper, double[] x, int ix, ref double[] tmp)
    {
        return _core_rmatrixsyvmv( n,  a,  ia,  ja,  isupper,  x,  ix, ref  tmp, 0x0);
    }
    
    public static double rmatrixsyvmv(int n, double[,] a, int ia, int ja, bool isupper, double[] x, int ix, ref double[] tmp, alglib.xparams _xparams)
    {
        return _core_rmatrixsyvmv( n,  a,  ia,  ja,  isupper,  x,  ix, ref  tmp, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_rmatrixtrsv(int n, double[,] a, int ia, int ja, bool isupper, bool isunit, int optype, ref double[] x, int ix, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        x_matrix _d_a = new x_matrix();
        x_int _d_ia = new x_int(ia);
        x_int _d_ja = new x_int(ja);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        byte _d_isunit = (byte)(isunit ? 1 : 0);
        x_int _d_optype = new x_int(optype);
        x_vector _d_x = new x_vector();
        x_int _d_ix = new x_int(ix);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a, _fp_x = x){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_xv2_rmatrixtrsv(&_s_errormsg, &_d_n, &_d_a, &_d_ia, &_d_ja, &_d_isupper, &_d_isunit, &_d_optype, &_d_x, &_d_ix, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rmatrixtrsv");
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_x);
        }
        // This function returns no value.
    }
    
    public static void rmatrixtrsv(int n, double[,] a, int ia, int ja, bool isupper, bool isunit, int optype, ref double[] x, int ix)
    {
        _core_rmatrixtrsv( n,  a,  ia,  ja,  isupper,  isunit,  optype, ref  x,  ix, 0x0);
    }
    
    public static void rmatrixtrsv(int n, double[,] a, int ia, int ja, bool isupper, bool isunit, int optype, ref double[] x, int ix, alglib.xparams _xparams)
    {
        _core_rmatrixtrsv( n,  a,  ia,  ja,  isupper,  isunit,  optype, ref  x,  ix, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_cmatrixrighttrsm(int m, int n, complex[,] a, int i1, int j1, bool isupper, bool isunit, int optype, ref complex[,] x, int i2, int j2, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_matrix _d_a = new x_matrix();
        x_int _d_i1 = new x_int(i1);
        x_int _d_j1 = new x_int(j1);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        byte _d_isunit = (byte)(isunit ? 1 : 0);
        x_int _d_optype = new x_int(optype);
        x_matrix _d_x = new x_matrix();
        x_int _d_i2 = new x_int(i2);
        x_int _d_j2 = new x_int(j2);
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a, _fp_x = x){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matrix_attach_to_array(ref _d_x, _fp_x, ap.rows(x), ap.cols(x));
                _error_code = _i_xv2_cmatrixrighttrsm(&_s_errormsg, &_d_m, &_d_n, &_d_a, &_d_i1, &_d_j1, &_d_isupper, &_d_isunit, &_d_optype, &_d_x, &_d_i2, &_d_j2, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "cmatrixrighttrsm");
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_x, ref x);
            if( x == null )
                x = new alglib.complex[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matrix_clear(ref _d_x);
        }
        // This function returns no value.
    }
    
    public static void cmatrixrighttrsm(int m, int n, complex[,] a, int i1, int j1, bool isupper, bool isunit, int optype, ref complex[,] x, int i2, int j2)
    {
        _core_cmatrixrighttrsm( m,  n,  a,  i1,  j1,  isupper,  isunit,  optype, ref  x,  i2,  j2, 0x0);
    }
    
    public static void cmatrixrighttrsm(int m, int n, complex[,] a, int i1, int j1, bool isupper, bool isunit, int optype, ref complex[,] x, int i2, int j2, alglib.xparams _xparams)
    {
        _core_cmatrixrighttrsm( m,  n,  a,  i1,  j1,  isupper,  isunit,  optype, ref  x,  i2,  j2, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_cmatrixlefttrsm(int m, int n, complex[,] a, int i1, int j1, bool isupper, bool isunit, int optype, ref complex[,] x, int i2, int j2, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_matrix _d_a = new x_matrix();
        x_int _d_i1 = new x_int(i1);
        x_int _d_j1 = new x_int(j1);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        byte _d_isunit = (byte)(isunit ? 1 : 0);
        x_int _d_optype = new x_int(optype);
        x_matrix _d_x = new x_matrix();
        x_int _d_i2 = new x_int(i2);
        x_int _d_j2 = new x_int(j2);
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a, _fp_x = x){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matrix_attach_to_array(ref _d_x, _fp_x, ap.rows(x), ap.cols(x));
                _error_code = _i_xv2_cmatrixlefttrsm(&_s_errormsg, &_d_m, &_d_n, &_d_a, &_d_i1, &_d_j1, &_d_isupper, &_d_isunit, &_d_optype, &_d_x, &_d_i2, &_d_j2, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "cmatrixlefttrsm");
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_x, ref x);
            if( x == null )
                x = new alglib.complex[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matrix_clear(ref _d_x);
        }
        // This function returns no value.
    }
    
    public static void cmatrixlefttrsm(int m, int n, complex[,] a, int i1, int j1, bool isupper, bool isunit, int optype, ref complex[,] x, int i2, int j2)
    {
        _core_cmatrixlefttrsm( m,  n,  a,  i1,  j1,  isupper,  isunit,  optype, ref  x,  i2,  j2, 0x0);
    }
    
    public static void cmatrixlefttrsm(int m, int n, complex[,] a, int i1, int j1, bool isupper, bool isunit, int optype, ref complex[,] x, int i2, int j2, alglib.xparams _xparams)
    {
        _core_cmatrixlefttrsm( m,  n,  a,  i1,  j1,  isupper,  isunit,  optype, ref  x,  i2,  j2, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_rmatrixrighttrsm(int m, int n, double[,] a, int i1, int j1, bool isupper, bool isunit, int optype, ref double[,] x, int i2, int j2, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_matrix _d_a = new x_matrix();
        x_int _d_i1 = new x_int(i1);
        x_int _d_j1 = new x_int(j1);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        byte _d_isunit = (byte)(isunit ? 1 : 0);
        x_int _d_optype = new x_int(optype);
        x_matrix _d_x = new x_matrix();
        x_int _d_i2 = new x_int(i2);
        x_int _d_j2 = new x_int(j2);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a, _fp_x = x){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matrix_attach_to_array(ref _d_x, _fp_x, ap.rows(x), ap.cols(x));
                _error_code = _i_xv2_rmatrixrighttrsm(&_s_errormsg, &_d_m, &_d_n, &_d_a, &_d_i1, &_d_j1, &_d_isupper, &_d_isunit, &_d_optype, &_d_x, &_d_i2, &_d_j2, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rmatrixrighttrsm");
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matrix_clear(ref _d_x);
        }
        // This function returns no value.
    }
    
    public static void rmatrixrighttrsm(int m, int n, double[,] a, int i1, int j1, bool isupper, bool isunit, int optype, ref double[,] x, int i2, int j2)
    {
        _core_rmatrixrighttrsm( m,  n,  a,  i1,  j1,  isupper,  isunit,  optype, ref  x,  i2,  j2, 0x0);
    }
    
    public static void rmatrixrighttrsm(int m, int n, double[,] a, int i1, int j1, bool isupper, bool isunit, int optype, ref double[,] x, int i2, int j2, alglib.xparams _xparams)
    {
        _core_rmatrixrighttrsm( m,  n,  a,  i1,  j1,  isupper,  isunit,  optype, ref  x,  i2,  j2, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_rmatrixlefttrsm(int m, int n, double[,] a, int i1, int j1, bool isupper, bool isunit, int optype, ref double[,] x, int i2, int j2, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_matrix _d_a = new x_matrix();
        x_int _d_i1 = new x_int(i1);
        x_int _d_j1 = new x_int(j1);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        byte _d_isunit = (byte)(isunit ? 1 : 0);
        x_int _d_optype = new x_int(optype);
        x_matrix _d_x = new x_matrix();
        x_int _d_i2 = new x_int(i2);
        x_int _d_j2 = new x_int(j2);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a, _fp_x = x){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matrix_attach_to_array(ref _d_x, _fp_x, ap.rows(x), ap.cols(x));
                _error_code = _i_xv2_rmatrixlefttrsm(&_s_errormsg, &_d_m, &_d_n, &_d_a, &_d_i1, &_d_j1, &_d_isupper, &_d_isunit, &_d_optype, &_d_x, &_d_i2, &_d_j2, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rmatrixlefttrsm");
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matrix_clear(ref _d_x);
        }
        // This function returns no value.
    }
    
    public static void rmatrixlefttrsm(int m, int n, double[,] a, int i1, int j1, bool isupper, bool isunit, int optype, ref double[,] x, int i2, int j2)
    {
        _core_rmatrixlefttrsm( m,  n,  a,  i1,  j1,  isupper,  isunit,  optype, ref  x,  i2,  j2, 0x0);
    }
    
    public static void rmatrixlefttrsm(int m, int n, double[,] a, int i1, int j1, bool isupper, bool isunit, int optype, ref double[,] x, int i2, int j2, alglib.xparams _xparams)
    {
        _core_rmatrixlefttrsm( m,  n,  a,  i1,  j1,  isupper,  isunit,  optype, ref  x,  i2,  j2, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_cmatrixherk(int n, int k, double alpha, complex[,] a, int ia, int ja, int optypea, double beta, ref complex[,] c, int ic, int jc, bool isupper, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        x_int _d_k = new x_int(k);
        double _d_alpha = alpha;
        x_matrix _d_a = new x_matrix();
        x_int _d_ia = new x_int(ia);
        x_int _d_ja = new x_int(ja);
        x_int _d_optypea = new x_int(optypea);
        double _d_beta = beta;
        x_matrix _d_c = new x_matrix();
        x_int _d_ic = new x_int(ic);
        x_int _d_jc = new x_int(jc);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a, _fp_c = c){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matrix_attach_to_array(ref _d_c, _fp_c, ap.rows(c), ap.cols(c));
                _error_code = _i_xv2_cmatrixherk(&_s_errormsg, &_d_n, &_d_k, &_d_alpha, &_d_a, &_d_ia, &_d_ja, &_d_optypea, &_d_beta, &_d_c, &_d_ic, &_d_jc, &_d_isupper, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "cmatrixherk");
            if( _d_c.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_c, ref c);
            if( c == null )
                c = new alglib.complex[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matrix_clear(ref _d_c);
        }
        // This function returns no value.
    }
    
    public static void cmatrixherk(int n, int k, double alpha, complex[,] a, int ia, int ja, int optypea, double beta, ref complex[,] c, int ic, int jc, bool isupper)
    {
        _core_cmatrixherk( n,  k,  alpha,  a,  ia,  ja,  optypea,  beta, ref  c,  ic,  jc,  isupper, 0x0);
    }
    
    public static void cmatrixherk(int n, int k, double alpha, complex[,] a, int ia, int ja, int optypea, double beta, ref complex[,] c, int ic, int jc, bool isupper, alglib.xparams _xparams)
    {
        _core_cmatrixherk( n,  k,  alpha,  a,  ia,  ja,  optypea,  beta, ref  c,  ic,  jc,  isupper, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_rmatrixsyrk(int n, int k, double alpha, double[,] a, int ia, int ja, int optypea, double beta, ref double[,] c, int ic, int jc, bool isupper, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        x_int _d_k = new x_int(k);
        double _d_alpha = alpha;
        x_matrix _d_a = new x_matrix();
        x_int _d_ia = new x_int(ia);
        x_int _d_ja = new x_int(ja);
        x_int _d_optypea = new x_int(optypea);
        double _d_beta = beta;
        x_matrix _d_c = new x_matrix();
        x_int _d_ic = new x_int(ic);
        x_int _d_jc = new x_int(jc);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a, _fp_c = c){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matrix_attach_to_array(ref _d_c, _fp_c, ap.rows(c), ap.cols(c));
                _error_code = _i_xv2_rmatrixsyrk(&_s_errormsg, &_d_n, &_d_k, &_d_alpha, &_d_a, &_d_ia, &_d_ja, &_d_optypea, &_d_beta, &_d_c, &_d_ic, &_d_jc, &_d_isupper, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rmatrixsyrk");
            if( _d_c.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_c, ref c);
            if( c == null )
                c = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matrix_clear(ref _d_c);
        }
        // This function returns no value.
    }
    
    public static void rmatrixsyrk(int n, int k, double alpha, double[,] a, int ia, int ja, int optypea, double beta, ref double[,] c, int ic, int jc, bool isupper)
    {
        _core_rmatrixsyrk( n,  k,  alpha,  a,  ia,  ja,  optypea,  beta, ref  c,  ic,  jc,  isupper, 0x0);
    }
    
    public static void rmatrixsyrk(int n, int k, double alpha, double[,] a, int ia, int ja, int optypea, double beta, ref double[,] c, int ic, int jc, bool isupper, alglib.xparams _xparams)
    {
        _core_rmatrixsyrk( n,  k,  alpha,  a,  ia,  ja,  optypea,  beta, ref  c,  ic,  jc,  isupper, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_cmatrixgemm(int m, int n, int k, complex alpha, complex[,] a, int ia, int ja, int optypea, complex[,] b, int ib, int jb, int optypeb, complex beta, ref complex[,] c, int ic, int jc, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_int _d_k = new x_int(k);
        alglib.complex _d_alpha;
        x_matrix _d_a = new x_matrix();
        x_int _d_ia = new x_int(ia);
        x_int _d_ja = new x_int(ja);
        x_int _d_optypea = new x_int(optypea);
        x_matrix _d_b = new x_matrix();
        x_int _d_ib = new x_int(ib);
        x_int _d_jb = new x_int(jb);
        x_int _d_optypeb = new x_int(optypeb);
        alglib.complex _d_beta;
        x_matrix _d_c = new x_matrix();
        x_int _d_ic = new x_int(ic);
        x_int _d_jc = new x_int(jc);
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a, _fp_b = b, _fp_c = c){
                _d_alpha.x = alpha.x;
                _d_alpha.y = alpha.y;
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matrix_attach_to_array(ref _d_b, _fp_b, ap.rows(b), ap.cols(b));
                _d_beta.x = beta.x;
                _d_beta.y = beta.y;
                x_matrix_attach_to_array(ref _d_c, _fp_c, ap.rows(c), ap.cols(c));
                _error_code = _i_xv2_cmatrixgemm(&_s_errormsg, &_d_m, &_d_n, &_d_k, &_d_alpha, &_d_a, &_d_ia, &_d_ja, &_d_optypea, &_d_b, &_d_ib, &_d_jb, &_d_optypeb, &_d_beta, &_d_c, &_d_ic, &_d_jc, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "cmatrixgemm");
            if( _d_c.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_c, ref c);
            if( c == null )
                c = new alglib.complex[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matrix_clear(ref _d_b);
            x_matrix_clear(ref _d_c);
        }
        // This function returns no value.
    }
    
    public static void cmatrixgemm(int m, int n, int k, complex alpha, complex[,] a, int ia, int ja, int optypea, complex[,] b, int ib, int jb, int optypeb, complex beta, ref complex[,] c, int ic, int jc)
    {
        _core_cmatrixgemm( m,  n,  k,  alpha,  a,  ia,  ja,  optypea,  b,  ib,  jb,  optypeb,  beta, ref  c,  ic,  jc, 0x0);
    }
    
    public static void cmatrixgemm(int m, int n, int k, complex alpha, complex[,] a, int ia, int ja, int optypea, complex[,] b, int ib, int jb, int optypeb, complex beta, ref complex[,] c, int ic, int jc, alglib.xparams _xparams)
    {
        _core_cmatrixgemm( m,  n,  k,  alpha,  a,  ia,  ja,  optypea,  b,  ib,  jb,  optypeb,  beta, ref  c,  ic,  jc, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_rmatrixgemm(int m, int n, int k, double alpha, double[,] a, int ia, int ja, int optypea, double[,] b, int ib, int jb, int optypeb, double beta, ref double[,] c, int ic, int jc, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_int _d_k = new x_int(k);
        double _d_alpha = alpha;
        x_matrix _d_a = new x_matrix();
        x_int _d_ia = new x_int(ia);
        x_int _d_ja = new x_int(ja);
        x_int _d_optypea = new x_int(optypea);
        x_matrix _d_b = new x_matrix();
        x_int _d_ib = new x_int(ib);
        x_int _d_jb = new x_int(jb);
        x_int _d_optypeb = new x_int(optypeb);
        double _d_beta = beta;
        x_matrix _d_c = new x_matrix();
        x_int _d_ic = new x_int(ic);
        x_int _d_jc = new x_int(jc);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a, _fp_b = b, _fp_c = c){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matrix_attach_to_array(ref _d_b, _fp_b, ap.rows(b), ap.cols(b));
                x_matrix_attach_to_array(ref _d_c, _fp_c, ap.rows(c), ap.cols(c));
                _error_code = _i_xv2_rmatrixgemm(&_s_errormsg, &_d_m, &_d_n, &_d_k, &_d_alpha, &_d_a, &_d_ia, &_d_ja, &_d_optypea, &_d_b, &_d_ib, &_d_jb, &_d_optypeb, &_d_beta, &_d_c, &_d_ic, &_d_jc, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rmatrixgemm");
            if( _d_c.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_c, ref c);
            if( c == null )
                c = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matrix_clear(ref _d_b);
            x_matrix_clear(ref _d_c);
        }
        // This function returns no value.
    }
    
    public static void rmatrixgemm(int m, int n, int k, double alpha, double[,] a, int ia, int ja, int optypea, double[,] b, int ib, int jb, int optypeb, double beta, ref double[,] c, int ic, int jc)
    {
        _core_rmatrixgemm( m,  n,  k,  alpha,  a,  ia,  ja,  optypea,  b,  ib,  jb,  optypeb,  beta, ref  c,  ic,  jc, 0x0);
    }
    
    public static void rmatrixgemm(int m, int n, int k, double alpha, double[,] a, int ia, int ja, int optypea, double[,] b, int ib, int jb, int optypeb, double beta, ref double[,] c, int ic, int jc, alglib.xparams _xparams)
    {
        _core_rmatrixgemm( m,  n,  k,  alpha,  a,  ia,  ja,  optypea,  b,  ib,  jb,  optypeb,  beta, ref  c,  ic,  jc, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_cmatrixsyrk(int n, int k, double alpha, complex[,] a, int ia, int ja, int optypea, double beta, ref complex[,] c, int ic, int jc, bool isupper, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        x_int _d_k = new x_int(k);
        double _d_alpha = alpha;
        x_matrix _d_a = new x_matrix();
        x_int _d_ia = new x_int(ia);
        x_int _d_ja = new x_int(ja);
        x_int _d_optypea = new x_int(optypea);
        double _d_beta = beta;
        x_matrix _d_c = new x_matrix();
        x_int _d_ic = new x_int(ic);
        x_int _d_jc = new x_int(jc);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a, _fp_c = c){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matrix_attach_to_array(ref _d_c, _fp_c, ap.rows(c), ap.cols(c));
                _error_code = _i_xv2_cmatrixsyrk(&_s_errormsg, &_d_n, &_d_k, &_d_alpha, &_d_a, &_d_ia, &_d_ja, &_d_optypea, &_d_beta, &_d_c, &_d_ic, &_d_jc, &_d_isupper, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "cmatrixsyrk");
            if( _d_c.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_c, ref c);
            if( c == null )
                c = new alglib.complex[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matrix_clear(ref _d_c);
        }
        // This function returns no value.
    }
    
    public static void cmatrixsyrk(int n, int k, double alpha, complex[,] a, int ia, int ja, int optypea, double beta, ref complex[,] c, int ic, int jc, bool isupper)
    {
        _core_cmatrixsyrk( n,  k,  alpha,  a,  ia,  ja,  optypea,  beta, ref  c,  ic,  jc,  isupper, 0x0);
    }
    
    public static void cmatrixsyrk(int n, int k, double alpha, complex[,] a, int ia, int ja, int optypea, double beta, ref complex[,] c, int ic, int jc, bool isupper, alglib.xparams _xparams)
    {
        _core_cmatrixsyrk( n,  k,  alpha,  a,  ia,  ja,  optypea,  beta, ref  c,  ic,  jc,  isupper, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage ortfac
    //
    
    
    private static unsafe void _core_rmatrixqr(ref double[,] a, int m, int n, out double[] tau, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_vector _d_tau = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_create_empty(ref _d_tau, DT_REAL);
                tau = null;
                _error_code = _i_xv2_rmatrixqr(&_s_errormsg, &_d_a, &_d_m, &_d_n, &_d_tau, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rmatrixqr");
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new double[0,0];
            if( _d_tau.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_tau, ref tau);
            if( tau == null )
                tau = new double[0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_tau);
        }
        // This function returns no value.
    }
    
    public static void rmatrixqr(ref double[,] a, int m, int n, out double[] tau)
    {
        _core_rmatrixqr(ref  a,  m,  n, out  tau, 0x0);
    }
    
    public static void rmatrixqr(ref double[,] a, int m, int n, out double[] tau, alglib.xparams _xparams)
    {
        _core_rmatrixqr(ref  a,  m,  n, out  tau, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_rmatrixlq(ref double[,] a, int m, int n, out double[] tau, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_vector _d_tau = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_create_empty(ref _d_tau, DT_REAL);
                tau = null;
                _error_code = _i_xv2_rmatrixlq(&_s_errormsg, &_d_a, &_d_m, &_d_n, &_d_tau, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rmatrixlq");
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new double[0,0];
            if( _d_tau.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_tau, ref tau);
            if( tau == null )
                tau = new double[0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_tau);
        }
        // This function returns no value.
    }
    
    public static void rmatrixlq(ref double[,] a, int m, int n, out double[] tau)
    {
        _core_rmatrixlq(ref  a,  m,  n, out  tau, 0x0);
    }
    
    public static void rmatrixlq(ref double[,] a, int m, int n, out double[] tau, alglib.xparams _xparams)
    {
        _core_rmatrixlq(ref  a,  m,  n, out  tau, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_cmatrixqr(ref complex[,] a, int m, int n, out complex[] tau, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_vector _d_tau = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_create_empty(ref _d_tau, DT_COMPLEX);
                tau = null;
                _error_code = _i_xv2_cmatrixqr(&_s_errormsg, &_d_a, &_d_m, &_d_n, &_d_tau, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "cmatrixqr");
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new alglib.complex[0,0];
            if( _d_tau.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_tau, ref tau);
            if( tau == null )
                tau = new alglib.complex[0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_tau);
        }
        // This function returns no value.
    }
    
    public static void cmatrixqr(ref complex[,] a, int m, int n, out complex[] tau)
    {
        _core_cmatrixqr(ref  a,  m,  n, out  tau, 0x0);
    }
    
    public static void cmatrixqr(ref complex[,] a, int m, int n, out complex[] tau, alglib.xparams _xparams)
    {
        _core_cmatrixqr(ref  a,  m,  n, out  tau, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_cmatrixlq(ref complex[,] a, int m, int n, out complex[] tau, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_vector _d_tau = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_create_empty(ref _d_tau, DT_COMPLEX);
                tau = null;
                _error_code = _i_xv2_cmatrixlq(&_s_errormsg, &_d_a, &_d_m, &_d_n, &_d_tau, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "cmatrixlq");
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new alglib.complex[0,0];
            if( _d_tau.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_tau, ref tau);
            if( tau == null )
                tau = new alglib.complex[0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_tau);
        }
        // This function returns no value.
    }
    
    public static void cmatrixlq(ref complex[,] a, int m, int n, out complex[] tau)
    {
        _core_cmatrixlq(ref  a,  m,  n, out  tau, 0x0);
    }
    
    public static void cmatrixlq(ref complex[,] a, int m, int n, out complex[] tau, alglib.xparams _xparams)
    {
        _core_cmatrixlq(ref  a,  m,  n, out  tau, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_rmatrixqrunpackq(double[,] a, int m, int n, double[] tau, int qcolumns, out double[,] q, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_vector _d_tau = new x_vector();
        x_int _d_qcolumns = new x_int(qcolumns);
        x_matrix _d_q = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a, _fp_tau = tau){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_attach_to_array(ref _d_tau, _fp_tau, ap.len(tau));
                x_matrix_create_empty(ref _d_q, DT_REAL);
                q = null;
                _error_code = _i_xv2_rmatrixqrunpackq(&_s_errormsg, &_d_a, &_d_m, &_d_n, &_d_tau, &_d_qcolumns, &_d_q, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rmatrixqrunpackq");
            if( _d_q.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_q, ref q);
            if( q == null )
                q = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_tau);
            x_matrix_clear(ref _d_q);
        }
        // This function returns no value.
    }
    
    public static void rmatrixqrunpackq(double[,] a, int m, int n, double[] tau, int qcolumns, out double[,] q)
    {
        _core_rmatrixqrunpackq( a,  m,  n,  tau,  qcolumns, out  q, 0x0);
    }
    
    public static void rmatrixqrunpackq(double[,] a, int m, int n, double[] tau, int qcolumns, out double[,] q, alglib.xparams _xparams)
    {
        _core_rmatrixqrunpackq( a,  m,  n,  tau,  qcolumns, out  q, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_rmatrixqrunpackr(double[,] a, int m, int n, out double[,] r, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_matrix _d_r = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matrix_create_empty(ref _d_r, DT_REAL);
                r = null;
                _error_code = _i_xv2_rmatrixqrunpackr(&_s_errormsg, &_d_a, &_d_m, &_d_n, &_d_r, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rmatrixqrunpackr");
            if( _d_r.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_r, ref r);
            if( r == null )
                r = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matrix_clear(ref _d_r);
        }
        // This function returns no value.
    }
    
    public static void rmatrixqrunpackr(double[,] a, int m, int n, out double[,] r)
    {
        _core_rmatrixqrunpackr( a,  m,  n, out  r, 0x0);
    }
    
    public static void rmatrixqrunpackr(double[,] a, int m, int n, out double[,] r, alglib.xparams _xparams)
    {
        _core_rmatrixqrunpackr( a,  m,  n, out  r, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_rmatrixlqunpackq(double[,] a, int m, int n, double[] tau, int qrows, out double[,] q, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_vector _d_tau = new x_vector();
        x_int _d_qrows = new x_int(qrows);
        x_matrix _d_q = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a, _fp_tau = tau){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_attach_to_array(ref _d_tau, _fp_tau, ap.len(tau));
                x_matrix_create_empty(ref _d_q, DT_REAL);
                q = null;
                _error_code = _i_xv2_rmatrixlqunpackq(&_s_errormsg, &_d_a, &_d_m, &_d_n, &_d_tau, &_d_qrows, &_d_q, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rmatrixlqunpackq");
            if( _d_q.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_q, ref q);
            if( q == null )
                q = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_tau);
            x_matrix_clear(ref _d_q);
        }
        // This function returns no value.
    }
    
    public static void rmatrixlqunpackq(double[,] a, int m, int n, double[] tau, int qrows, out double[,] q)
    {
        _core_rmatrixlqunpackq( a,  m,  n,  tau,  qrows, out  q, 0x0);
    }
    
    public static void rmatrixlqunpackq(double[,] a, int m, int n, double[] tau, int qrows, out double[,] q, alglib.xparams _xparams)
    {
        _core_rmatrixlqunpackq( a,  m,  n,  tau,  qrows, out  q, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_rmatrixlqunpackl(double[,] a, int m, int n, out double[,] l, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_matrix _d_l = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matrix_create_empty(ref _d_l, DT_REAL);
                l = null;
                _error_code = _i_xv2_rmatrixlqunpackl(&_s_errormsg, &_d_a, &_d_m, &_d_n, &_d_l, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rmatrixlqunpackl");
            if( _d_l.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_l, ref l);
            if( l == null )
                l = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matrix_clear(ref _d_l);
        }
        // This function returns no value.
    }
    
    public static void rmatrixlqunpackl(double[,] a, int m, int n, out double[,] l)
    {
        _core_rmatrixlqunpackl( a,  m,  n, out  l, 0x0);
    }
    
    public static void rmatrixlqunpackl(double[,] a, int m, int n, out double[,] l, alglib.xparams _xparams)
    {
        _core_rmatrixlqunpackl( a,  m,  n, out  l, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_cmatrixqrunpackq(complex[,] a, int m, int n, complex[] tau, int qcolumns, out complex[,] q, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_vector _d_tau = new x_vector();
        x_int _d_qcolumns = new x_int(qcolumns);
        x_matrix _d_q = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a, _fp_tau = tau){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_attach_to_array(ref _d_tau, _fp_tau, ap.len(tau));
                x_matrix_create_empty(ref _d_q, DT_COMPLEX);
                q = null;
                _error_code = _i_xv2_cmatrixqrunpackq(&_s_errormsg, &_d_a, &_d_m, &_d_n, &_d_tau, &_d_qcolumns, &_d_q, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "cmatrixqrunpackq");
            if( _d_q.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_q, ref q);
            if( q == null )
                q = new alglib.complex[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_tau);
            x_matrix_clear(ref _d_q);
        }
        // This function returns no value.
    }
    
    public static void cmatrixqrunpackq(complex[,] a, int m, int n, complex[] tau, int qcolumns, out complex[,] q)
    {
        _core_cmatrixqrunpackq( a,  m,  n,  tau,  qcolumns, out  q, 0x0);
    }
    
    public static void cmatrixqrunpackq(complex[,] a, int m, int n, complex[] tau, int qcolumns, out complex[,] q, alglib.xparams _xparams)
    {
        _core_cmatrixqrunpackq( a,  m,  n,  tau,  qcolumns, out  q, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_cmatrixqrunpackr(complex[,] a, int m, int n, out complex[,] r, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_matrix _d_r = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matrix_create_empty(ref _d_r, DT_COMPLEX);
                r = null;
                _error_code = _i_xv2_cmatrixqrunpackr(&_s_errormsg, &_d_a, &_d_m, &_d_n, &_d_r, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "cmatrixqrunpackr");
            if( _d_r.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_r, ref r);
            if( r == null )
                r = new alglib.complex[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matrix_clear(ref _d_r);
        }
        // This function returns no value.
    }
    
    public static void cmatrixqrunpackr(complex[,] a, int m, int n, out complex[,] r)
    {
        _core_cmatrixqrunpackr( a,  m,  n, out  r, 0x0);
    }
    
    public static void cmatrixqrunpackr(complex[,] a, int m, int n, out complex[,] r, alglib.xparams _xparams)
    {
        _core_cmatrixqrunpackr( a,  m,  n, out  r, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_cmatrixlqunpackq(complex[,] a, int m, int n, complex[] tau, int qrows, out complex[,] q, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_vector _d_tau = new x_vector();
        x_int _d_qrows = new x_int(qrows);
        x_matrix _d_q = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a, _fp_tau = tau){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_attach_to_array(ref _d_tau, _fp_tau, ap.len(tau));
                x_matrix_create_empty(ref _d_q, DT_COMPLEX);
                q = null;
                _error_code = _i_xv2_cmatrixlqunpackq(&_s_errormsg, &_d_a, &_d_m, &_d_n, &_d_tau, &_d_qrows, &_d_q, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "cmatrixlqunpackq");
            if( _d_q.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_q, ref q);
            if( q == null )
                q = new alglib.complex[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_tau);
            x_matrix_clear(ref _d_q);
        }
        // This function returns no value.
    }
    
    public static void cmatrixlqunpackq(complex[,] a, int m, int n, complex[] tau, int qrows, out complex[,] q)
    {
        _core_cmatrixlqunpackq( a,  m,  n,  tau,  qrows, out  q, 0x0);
    }
    
    public static void cmatrixlqunpackq(complex[,] a, int m, int n, complex[] tau, int qrows, out complex[,] q, alglib.xparams _xparams)
    {
        _core_cmatrixlqunpackq( a,  m,  n,  tau,  qrows, out  q, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_cmatrixlqunpackl(complex[,] a, int m, int n, out complex[,] l, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_matrix _d_l = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matrix_create_empty(ref _d_l, DT_COMPLEX);
                l = null;
                _error_code = _i_xv2_cmatrixlqunpackl(&_s_errormsg, &_d_a, &_d_m, &_d_n, &_d_l, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "cmatrixlqunpackl");
            if( _d_l.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_l, ref l);
            if( l == null )
                l = new alglib.complex[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matrix_clear(ref _d_l);
        }
        // This function returns no value.
    }
    
    public static void cmatrixlqunpackl(complex[,] a, int m, int n, out complex[,] l)
    {
        _core_cmatrixlqunpackl( a,  m,  n, out  l, 0x0);
    }
    
    public static void cmatrixlqunpackl(complex[,] a, int m, int n, out complex[,] l, alglib.xparams _xparams)
    {
        _core_cmatrixlqunpackl( a,  m,  n, out  l, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_rmatrixbd(ref double[,] a, int m, int n, out double[] tauq, out double[] taup, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_vector _d_tauq = new x_vector();
        x_vector _d_taup = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_create_empty(ref _d_tauq, DT_REAL);
                tauq = null;
                x_vector_create_empty(ref _d_taup, DT_REAL);
                taup = null;
                _error_code = _i_xv2_rmatrixbd(&_s_errormsg, &_d_a, &_d_m, &_d_n, &_d_tauq, &_d_taup, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rmatrixbd");
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new double[0,0];
            if( _d_tauq.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_tauq, ref tauq);
            if( tauq == null )
                tauq = new double[0];
            if( _d_taup.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_taup, ref taup);
            if( taup == null )
                taup = new double[0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_tauq);
            x_vector_clear(ref _d_taup);
        }
        // This function returns no value.
    }
    
    public static void rmatrixbd(ref double[,] a, int m, int n, out double[] tauq, out double[] taup)
    {
        _core_rmatrixbd(ref  a,  m,  n, out  tauq, out  taup, 0x0);
    }
    
    public static void rmatrixbd(ref double[,] a, int m, int n, out double[] tauq, out double[] taup, alglib.xparams _xparams)
    {
        _core_rmatrixbd(ref  a,  m,  n, out  tauq, out  taup, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_rmatrixbdunpackq(double[,] qp, int m, int n, double[] tauq, int qcolumns, out double[,] q, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_qp = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_vector _d_tauq = new x_vector();
        x_int _d_qcolumns = new x_int(qcolumns);
        x_matrix _d_q = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_qp = qp, _fp_tauq = tauq){
                x_matrix_attach_to_array(ref _d_qp, _fp_qp, ap.rows(qp), ap.cols(qp));
                x_vector_attach_to_array(ref _d_tauq, _fp_tauq, ap.len(tauq));
                x_matrix_create_empty(ref _d_q, DT_REAL);
                q = null;
                _error_code = _i_xv2_rmatrixbdunpackq(&_s_errormsg, &_d_qp, &_d_m, &_d_n, &_d_tauq, &_d_qcolumns, &_d_q, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rmatrixbdunpackq");
            if( _d_q.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_q, ref q);
            if( q == null )
                q = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_qp);
            x_vector_clear(ref _d_tauq);
            x_matrix_clear(ref _d_q);
        }
        // This function returns no value.
    }
    
    public static void rmatrixbdunpackq(double[,] qp, int m, int n, double[] tauq, int qcolumns, out double[,] q)
    {
        _core_rmatrixbdunpackq( qp,  m,  n,  tauq,  qcolumns, out  q, 0x0);
    }
    
    public static void rmatrixbdunpackq(double[,] qp, int m, int n, double[] tauq, int qcolumns, out double[,] q, alglib.xparams _xparams)
    {
        _core_rmatrixbdunpackq( qp,  m,  n,  tauq,  qcolumns, out  q, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_rmatrixbdmultiplybyq(double[,] qp, int m, int n, double[] tauq, ref double[,] z, int zrows, int zcolumns, bool fromtheright, bool dotranspose, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_qp = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_vector _d_tauq = new x_vector();
        x_matrix _d_z = new x_matrix();
        x_int _d_zrows = new x_int(zrows);
        x_int _d_zcolumns = new x_int(zcolumns);
        byte _d_fromtheright = (byte)(fromtheright ? 1 : 0);
        byte _d_dotranspose = (byte)(dotranspose ? 1 : 0);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_qp = qp, _fp_tauq = tauq, _fp_z = z){
                x_matrix_attach_to_array(ref _d_qp, _fp_qp, ap.rows(qp), ap.cols(qp));
                x_vector_attach_to_array(ref _d_tauq, _fp_tauq, ap.len(tauq));
                x_matrix_attach_to_array(ref _d_z, _fp_z, ap.rows(z), ap.cols(z));
                _error_code = _i_xv2_rmatrixbdmultiplybyq(&_s_errormsg, &_d_qp, &_d_m, &_d_n, &_d_tauq, &_d_z, &_d_zrows, &_d_zcolumns, &_d_fromtheright, &_d_dotranspose, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rmatrixbdmultiplybyq");
            if( _d_z.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_z, ref z);
            if( z == null )
                z = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_qp);
            x_vector_clear(ref _d_tauq);
            x_matrix_clear(ref _d_z);
        }
        // This function returns no value.
    }
    
    public static void rmatrixbdmultiplybyq(double[,] qp, int m, int n, double[] tauq, ref double[,] z, int zrows, int zcolumns, bool fromtheright, bool dotranspose)
    {
        _core_rmatrixbdmultiplybyq( qp,  m,  n,  tauq, ref  z,  zrows,  zcolumns,  fromtheright,  dotranspose, 0x0);
    }
    
    public static void rmatrixbdmultiplybyq(double[,] qp, int m, int n, double[] tauq, ref double[,] z, int zrows, int zcolumns, bool fromtheright, bool dotranspose, alglib.xparams _xparams)
    {
        _core_rmatrixbdmultiplybyq( qp,  m,  n,  tauq, ref  z,  zrows,  zcolumns,  fromtheright,  dotranspose, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_rmatrixbdunpackpt(double[,] qp, int m, int n, double[] taup, int ptrows, out double[,] pt, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_qp = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_vector _d_taup = new x_vector();
        x_int _d_ptrows = new x_int(ptrows);
        x_matrix _d_pt = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_qp = qp, _fp_taup = taup){
                x_matrix_attach_to_array(ref _d_qp, _fp_qp, ap.rows(qp), ap.cols(qp));
                x_vector_attach_to_array(ref _d_taup, _fp_taup, ap.len(taup));
                x_matrix_create_empty(ref _d_pt, DT_REAL);
                pt = null;
                _error_code = _i_xv2_rmatrixbdunpackpt(&_s_errormsg, &_d_qp, &_d_m, &_d_n, &_d_taup, &_d_ptrows, &_d_pt, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rmatrixbdunpackpt");
            if( _d_pt.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_pt, ref pt);
            if( pt == null )
                pt = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_qp);
            x_vector_clear(ref _d_taup);
            x_matrix_clear(ref _d_pt);
        }
        // This function returns no value.
    }
    
    public static void rmatrixbdunpackpt(double[,] qp, int m, int n, double[] taup, int ptrows, out double[,] pt)
    {
        _core_rmatrixbdunpackpt( qp,  m,  n,  taup,  ptrows, out  pt, 0x0);
    }
    
    public static void rmatrixbdunpackpt(double[,] qp, int m, int n, double[] taup, int ptrows, out double[,] pt, alglib.xparams _xparams)
    {
        _core_rmatrixbdunpackpt( qp,  m,  n,  taup,  ptrows, out  pt, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_rmatrixbdmultiplybyp(double[,] qp, int m, int n, double[] taup, ref double[,] z, int zrows, int zcolumns, bool fromtheright, bool dotranspose, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_qp = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_vector _d_taup = new x_vector();
        x_matrix _d_z = new x_matrix();
        x_int _d_zrows = new x_int(zrows);
        x_int _d_zcolumns = new x_int(zcolumns);
        byte _d_fromtheright = (byte)(fromtheright ? 1 : 0);
        byte _d_dotranspose = (byte)(dotranspose ? 1 : 0);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_qp = qp, _fp_taup = taup, _fp_z = z){
                x_matrix_attach_to_array(ref _d_qp, _fp_qp, ap.rows(qp), ap.cols(qp));
                x_vector_attach_to_array(ref _d_taup, _fp_taup, ap.len(taup));
                x_matrix_attach_to_array(ref _d_z, _fp_z, ap.rows(z), ap.cols(z));
                _error_code = _i_xv2_rmatrixbdmultiplybyp(&_s_errormsg, &_d_qp, &_d_m, &_d_n, &_d_taup, &_d_z, &_d_zrows, &_d_zcolumns, &_d_fromtheright, &_d_dotranspose, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rmatrixbdmultiplybyp");
            if( _d_z.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_z, ref z);
            if( z == null )
                z = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_qp);
            x_vector_clear(ref _d_taup);
            x_matrix_clear(ref _d_z);
        }
        // This function returns no value.
    }
    
    public static void rmatrixbdmultiplybyp(double[,] qp, int m, int n, double[] taup, ref double[,] z, int zrows, int zcolumns, bool fromtheright, bool dotranspose)
    {
        _core_rmatrixbdmultiplybyp( qp,  m,  n,  taup, ref  z,  zrows,  zcolumns,  fromtheright,  dotranspose, 0x0);
    }
    
    public static void rmatrixbdmultiplybyp(double[,] qp, int m, int n, double[] taup, ref double[,] z, int zrows, int zcolumns, bool fromtheright, bool dotranspose, alglib.xparams _xparams)
    {
        _core_rmatrixbdmultiplybyp( qp,  m,  n,  taup, ref  z,  zrows,  zcolumns,  fromtheright,  dotranspose, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_rmatrixbdunpackdiagonals(double[,] b, int m, int n, out bool isupper, out double[] d, out double[] e, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_b = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)0;
        x_vector _d_d = new x_vector();
        x_vector _d_e = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_b = b){
                x_matrix_attach_to_array(ref _d_b, _fp_b, ap.rows(b), ap.cols(b));
                x_vector_create_empty(ref _d_d, DT_REAL);
                d = null;
                x_vector_create_empty(ref _d_e, DT_REAL);
                e = null;
                _error_code = _i_xv2_rmatrixbdunpackdiagonals(&_s_errormsg, &_d_b, &_d_m, &_d_n, &_d_isupper, &_d_d, &_d_e, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rmatrixbdunpackdiagonals");
            isupper = _d_isupper!=0;
            if( _d_d.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_d, ref d);
            if( d == null )
                d = new double[0];
            if( _d_e.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_e, ref e);
            if( e == null )
                e = new double[0];
        }
        finally
        {
            x_matrix_clear(ref _d_b);
            x_vector_clear(ref _d_d);
            x_vector_clear(ref _d_e);
        }
        // This function returns no value.
    }
    
    public static void rmatrixbdunpackdiagonals(double[,] b, int m, int n, out bool isupper, out double[] d, out double[] e)
    {
        _core_rmatrixbdunpackdiagonals( b,  m,  n, out  isupper, out  d, out  e, 0x0);
    }
    
    public static void rmatrixbdunpackdiagonals(double[,] b, int m, int n, out bool isupper, out double[] d, out double[] e, alglib.xparams _xparams)
    {
        _core_rmatrixbdunpackdiagonals( b,  m,  n, out  isupper, out  d, out  e, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_rmatrixhessenberg(ref double[,] a, int n, out double[] tau, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        x_vector _d_tau = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_create_empty(ref _d_tau, DT_REAL);
                tau = null;
                _error_code = _i_xv2_rmatrixhessenberg(&_s_errormsg, &_d_a, &_d_n, &_d_tau, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rmatrixhessenberg");
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new double[0,0];
            if( _d_tau.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_tau, ref tau);
            if( tau == null )
                tau = new double[0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_tau);
        }
        // This function returns no value.
    }
    
    public static void rmatrixhessenberg(ref double[,] a, int n, out double[] tau)
    {
        _core_rmatrixhessenberg(ref  a,  n, out  tau, 0x0);
    }
    
    public static void rmatrixhessenberg(ref double[,] a, int n, out double[] tau, alglib.xparams _xparams)
    {
        _core_rmatrixhessenberg(ref  a,  n, out  tau, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_rmatrixhessenbergunpackq(double[,] a, int n, double[] tau, out double[,] q, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        x_vector _d_tau = new x_vector();
        x_matrix _d_q = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a, _fp_tau = tau){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_attach_to_array(ref _d_tau, _fp_tau, ap.len(tau));
                x_matrix_create_empty(ref _d_q, DT_REAL);
                q = null;
                _error_code = _i_xv2_rmatrixhessenbergunpackq(&_s_errormsg, &_d_a, &_d_n, &_d_tau, &_d_q, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rmatrixhessenbergunpackq");
            if( _d_q.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_q, ref q);
            if( q == null )
                q = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_tau);
            x_matrix_clear(ref _d_q);
        }
        // This function returns no value.
    }
    
    public static void rmatrixhessenbergunpackq(double[,] a, int n, double[] tau, out double[,] q)
    {
        _core_rmatrixhessenbergunpackq( a,  n,  tau, out  q, 0x0);
    }
    
    public static void rmatrixhessenbergunpackq(double[,] a, int n, double[] tau, out double[,] q, alglib.xparams _xparams)
    {
        _core_rmatrixhessenbergunpackq( a,  n,  tau, out  q, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_rmatrixhessenbergunpackh(double[,] a, int n, out double[,] h, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        x_matrix _d_h = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matrix_create_empty(ref _d_h, DT_REAL);
                h = null;
                _error_code = _i_xv2_rmatrixhessenbergunpackh(&_s_errormsg, &_d_a, &_d_n, &_d_h, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rmatrixhessenbergunpackh");
            if( _d_h.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_h, ref h);
            if( h == null )
                h = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matrix_clear(ref _d_h);
        }
        // This function returns no value.
    }
    
    public static void rmatrixhessenbergunpackh(double[,] a, int n, out double[,] h)
    {
        _core_rmatrixhessenbergunpackh( a,  n, out  h, 0x0);
    }
    
    public static void rmatrixhessenbergunpackh(double[,] a, int n, out double[,] h, alglib.xparams _xparams)
    {
        _core_rmatrixhessenbergunpackh( a,  n, out  h, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_smatrixtd(ref double[,] a, int n, bool isupper, out double[] tau, out double[] d, out double[] e, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_vector _d_tau = new x_vector();
        x_vector _d_d = new x_vector();
        x_vector _d_e = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_create_empty(ref _d_tau, DT_REAL);
                tau = null;
                x_vector_create_empty(ref _d_d, DT_REAL);
                d = null;
                x_vector_create_empty(ref _d_e, DT_REAL);
                e = null;
                _error_code = _i_xv2_smatrixtd(&_s_errormsg, &_d_a, &_d_n, &_d_isupper, &_d_tau, &_d_d, &_d_e, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "smatrixtd");
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new double[0,0];
            if( _d_tau.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_tau, ref tau);
            if( tau == null )
                tau = new double[0];
            if( _d_d.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_d, ref d);
            if( d == null )
                d = new double[0];
            if( _d_e.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_e, ref e);
            if( e == null )
                e = new double[0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_tau);
            x_vector_clear(ref _d_d);
            x_vector_clear(ref _d_e);
        }
        // This function returns no value.
    }
    
    public static void smatrixtd(ref double[,] a, int n, bool isupper, out double[] tau, out double[] d, out double[] e)
    {
        _core_smatrixtd(ref  a,  n,  isupper, out  tau, out  d, out  e, 0x0);
    }
    
    public static void smatrixtd(ref double[,] a, int n, bool isupper, out double[] tau, out double[] d, out double[] e, alglib.xparams _xparams)
    {
        _core_smatrixtd(ref  a,  n,  isupper, out  tau, out  d, out  e, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_smatrixtdunpackq(double[,] a, int n, bool isupper, double[] tau, out double[,] q, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_vector _d_tau = new x_vector();
        x_matrix _d_q = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a, _fp_tau = tau){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_attach_to_array(ref _d_tau, _fp_tau, ap.len(tau));
                x_matrix_create_empty(ref _d_q, DT_REAL);
                q = null;
                _error_code = _i_xv2_smatrixtdunpackq(&_s_errormsg, &_d_a, &_d_n, &_d_isupper, &_d_tau, &_d_q, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "smatrixtdunpackq");
            if( _d_q.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_q, ref q);
            if( q == null )
                q = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_tau);
            x_matrix_clear(ref _d_q);
        }
        // This function returns no value.
    }
    
    public static void smatrixtdunpackq(double[,] a, int n, bool isupper, double[] tau, out double[,] q)
    {
        _core_smatrixtdunpackq( a,  n,  isupper,  tau, out  q, 0x0);
    }
    
    public static void smatrixtdunpackq(double[,] a, int n, bool isupper, double[] tau, out double[,] q, alglib.xparams _xparams)
    {
        _core_smatrixtdunpackq( a,  n,  isupper,  tau, out  q, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_hmatrixtd(ref complex[,] a, int n, bool isupper, out complex[] tau, out double[] d, out double[] e, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_vector _d_tau = new x_vector();
        x_vector _d_d = new x_vector();
        x_vector _d_e = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_create_empty(ref _d_tau, DT_COMPLEX);
                tau = null;
                x_vector_create_empty(ref _d_d, DT_REAL);
                d = null;
                x_vector_create_empty(ref _d_e, DT_REAL);
                e = null;
                _error_code = _i_xv2_hmatrixtd(&_s_errormsg, &_d_a, &_d_n, &_d_isupper, &_d_tau, &_d_d, &_d_e, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "hmatrixtd");
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new alglib.complex[0,0];
            if( _d_tau.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_tau, ref tau);
            if( tau == null )
                tau = new alglib.complex[0];
            if( _d_d.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_d, ref d);
            if( d == null )
                d = new double[0];
            if( _d_e.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_e, ref e);
            if( e == null )
                e = new double[0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_tau);
            x_vector_clear(ref _d_d);
            x_vector_clear(ref _d_e);
        }
        // This function returns no value.
    }
    
    public static void hmatrixtd(ref complex[,] a, int n, bool isupper, out complex[] tau, out double[] d, out double[] e)
    {
        _core_hmatrixtd(ref  a,  n,  isupper, out  tau, out  d, out  e, 0x0);
    }
    
    public static void hmatrixtd(ref complex[,] a, int n, bool isupper, out complex[] tau, out double[] d, out double[] e, alglib.xparams _xparams)
    {
        _core_hmatrixtd(ref  a,  n,  isupper, out  tau, out  d, out  e, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_hmatrixtdunpackq(complex[,] a, int n, bool isupper, complex[] tau, out complex[,] q, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_vector _d_tau = new x_vector();
        x_matrix _d_q = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a, _fp_tau = tau){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_attach_to_array(ref _d_tau, _fp_tau, ap.len(tau));
                x_matrix_create_empty(ref _d_q, DT_COMPLEX);
                q = null;
                _error_code = _i_xv2_hmatrixtdunpackq(&_s_errormsg, &_d_a, &_d_n, &_d_isupper, &_d_tau, &_d_q, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "hmatrixtdunpackq");
            if( _d_q.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_q, ref q);
            if( q == null )
                q = new alglib.complex[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_tau);
            x_matrix_clear(ref _d_q);
        }
        // This function returns no value.
    }
    
    public static void hmatrixtdunpackq(complex[,] a, int n, bool isupper, complex[] tau, out complex[,] q)
    {
        _core_hmatrixtdunpackq( a,  n,  isupper,  tau, out  q, 0x0);
    }
    
    public static void hmatrixtdunpackq(complex[,] a, int n, bool isupper, complex[] tau, out complex[,] q, alglib.xparams _xparams)
    {
        _core_hmatrixtdunpackq( a,  n,  isupper,  tau, out  q, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage matgen
    //
    
    
    private static unsafe void _core_rmatrixrndorthogonal(int n, out double[,] a, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        x_matrix _d_a = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            x_matrix_create_empty(ref _d_a, DT_REAL);
            a = null;
            _error_code = _i_xv2_rmatrixrndorthogonal(&_s_errormsg, &_d_n, &_d_a, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rmatrixrndorthogonal");
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        // This function returns no value.
    }
    
    public static void rmatrixrndorthogonal(int n, out double[,] a)
    {
        _core_rmatrixrndorthogonal( n, out  a, 0x0);
    }
    
    public static void rmatrixrndorthogonal(int n, out double[,] a, alglib.xparams _xparams)
    {
        _core_rmatrixrndorthogonal( n, out  a, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_rmatrixrndcond(int n, double c, out double[,] a, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        double _d_c = c;
        x_matrix _d_a = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            x_matrix_create_empty(ref _d_a, DT_REAL);
            a = null;
            _error_code = _i_xv2_rmatrixrndcond(&_s_errormsg, &_d_n, &_d_c, &_d_a, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rmatrixrndcond");
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        // This function returns no value.
    }
    
    public static void rmatrixrndcond(int n, double c, out double[,] a)
    {
        _core_rmatrixrndcond( n,  c, out  a, 0x0);
    }
    
    public static void rmatrixrndcond(int n, double c, out double[,] a, alglib.xparams _xparams)
    {
        _core_rmatrixrndcond( n,  c, out  a, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_cmatrixrndorthogonal(int n, out complex[,] a, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        x_matrix _d_a = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            x_matrix_create_empty(ref _d_a, DT_COMPLEX);
            a = null;
            _error_code = _i_xv2_cmatrixrndorthogonal(&_s_errormsg, &_d_n, &_d_a, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "cmatrixrndorthogonal");
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new alglib.complex[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        // This function returns no value.
    }
    
    public static void cmatrixrndorthogonal(int n, out complex[,] a)
    {
        _core_cmatrixrndorthogonal( n, out  a, 0x0);
    }
    
    public static void cmatrixrndorthogonal(int n, out complex[,] a, alglib.xparams _xparams)
    {
        _core_cmatrixrndorthogonal( n, out  a, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_cmatrixrndcond(int n, double c, out complex[,] a, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        double _d_c = c;
        x_matrix _d_a = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            x_matrix_create_empty(ref _d_a, DT_COMPLEX);
            a = null;
            _error_code = _i_xv2_cmatrixrndcond(&_s_errormsg, &_d_n, &_d_c, &_d_a, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "cmatrixrndcond");
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new alglib.complex[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        // This function returns no value.
    }
    
    public static void cmatrixrndcond(int n, double c, out complex[,] a)
    {
        _core_cmatrixrndcond( n,  c, out  a, 0x0);
    }
    
    public static void cmatrixrndcond(int n, double c, out complex[,] a, alglib.xparams _xparams)
    {
        _core_cmatrixrndcond( n,  c, out  a, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_smatrixrndcond(int n, double c, out double[,] a, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        double _d_c = c;
        x_matrix _d_a = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            x_matrix_create_empty(ref _d_a, DT_REAL);
            a = null;
            _error_code = _i_xv2_smatrixrndcond(&_s_errormsg, &_d_n, &_d_c, &_d_a, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "smatrixrndcond");
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        // This function returns no value.
    }
    
    public static void smatrixrndcond(int n, double c, out double[,] a)
    {
        _core_smatrixrndcond( n,  c, out  a, 0x0);
    }
    
    public static void smatrixrndcond(int n, double c, out double[,] a, alglib.xparams _xparams)
    {
        _core_smatrixrndcond( n,  c, out  a, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_spdmatrixrndcond(int n, double c, out double[,] a, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        double _d_c = c;
        x_matrix _d_a = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            x_matrix_create_empty(ref _d_a, DT_REAL);
            a = null;
            _error_code = _i_xv2_spdmatrixrndcond(&_s_errormsg, &_d_n, &_d_c, &_d_a, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spdmatrixrndcond");
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        // This function returns no value.
    }
    
    public static void spdmatrixrndcond(int n, double c, out double[,] a)
    {
        _core_spdmatrixrndcond( n,  c, out  a, 0x0);
    }
    
    public static void spdmatrixrndcond(int n, double c, out double[,] a, alglib.xparams _xparams)
    {
        _core_spdmatrixrndcond( n,  c, out  a, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_hmatrixrndcond(int n, double c, out complex[,] a, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        double _d_c = c;
        x_matrix _d_a = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            x_matrix_create_empty(ref _d_a, DT_COMPLEX);
            a = null;
            _error_code = _i_xv2_hmatrixrndcond(&_s_errormsg, &_d_n, &_d_c, &_d_a, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "hmatrixrndcond");
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new alglib.complex[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        // This function returns no value.
    }
    
    public static void hmatrixrndcond(int n, double c, out complex[,] a)
    {
        _core_hmatrixrndcond( n,  c, out  a, 0x0);
    }
    
    public static void hmatrixrndcond(int n, double c, out complex[,] a, alglib.xparams _xparams)
    {
        _core_hmatrixrndcond( n,  c, out  a, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_hpdmatrixrndcond(int n, double c, out complex[,] a, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        double _d_c = c;
        x_matrix _d_a = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            x_matrix_create_empty(ref _d_a, DT_COMPLEX);
            a = null;
            _error_code = _i_xv2_hpdmatrixrndcond(&_s_errormsg, &_d_n, &_d_c, &_d_a, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "hpdmatrixrndcond");
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new alglib.complex[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        // This function returns no value.
    }
    
    public static void hpdmatrixrndcond(int n, double c, out complex[,] a)
    {
        _core_hpdmatrixrndcond( n,  c, out  a, 0x0);
    }
    
    public static void hpdmatrixrndcond(int n, double c, out complex[,] a, alglib.xparams _xparams)
    {
        _core_hpdmatrixrndcond( n,  c, out  a, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_rmatrixrndorthogonalfromtheright(ref double[,] a, int m, int n, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                _error_code = _i_xv2_rmatrixrndorthogonalfromtheright(&_s_errormsg, &_d_a, &_d_m, &_d_n, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rmatrixrndorthogonalfromtheright");
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        // This function returns no value.
    }
    
    public static void rmatrixrndorthogonalfromtheright(ref double[,] a, int m, int n)
    {
        _core_rmatrixrndorthogonalfromtheright(ref  a,  m,  n, 0x0);
    }
    
    public static void rmatrixrndorthogonalfromtheright(ref double[,] a, int m, int n, alglib.xparams _xparams)
    {
        _core_rmatrixrndorthogonalfromtheright(ref  a,  m,  n, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_rmatrixrndorthogonalfromtheleft(ref double[,] a, int m, int n, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                _error_code = _i_xv2_rmatrixrndorthogonalfromtheleft(&_s_errormsg, &_d_a, &_d_m, &_d_n, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rmatrixrndorthogonalfromtheleft");
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        // This function returns no value.
    }
    
    public static void rmatrixrndorthogonalfromtheleft(ref double[,] a, int m, int n)
    {
        _core_rmatrixrndorthogonalfromtheleft(ref  a,  m,  n, 0x0);
    }
    
    public static void rmatrixrndorthogonalfromtheleft(ref double[,] a, int m, int n, alglib.xparams _xparams)
    {
        _core_rmatrixrndorthogonalfromtheleft(ref  a,  m,  n, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_cmatrixrndorthogonalfromtheright(ref complex[,] a, int m, int n, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                _error_code = _i_xv2_cmatrixrndorthogonalfromtheright(&_s_errormsg, &_d_a, &_d_m, &_d_n, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "cmatrixrndorthogonalfromtheright");
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new alglib.complex[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        // This function returns no value.
    }
    
    public static void cmatrixrndorthogonalfromtheright(ref complex[,] a, int m, int n)
    {
        _core_cmatrixrndorthogonalfromtheright(ref  a,  m,  n, 0x0);
    }
    
    public static void cmatrixrndorthogonalfromtheright(ref complex[,] a, int m, int n, alglib.xparams _xparams)
    {
        _core_cmatrixrndorthogonalfromtheright(ref  a,  m,  n, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_cmatrixrndorthogonalfromtheleft(ref complex[,] a, int m, int n, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                _error_code = _i_xv2_cmatrixrndorthogonalfromtheleft(&_s_errormsg, &_d_a, &_d_m, &_d_n, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "cmatrixrndorthogonalfromtheleft");
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new alglib.complex[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        // This function returns no value.
    }
    
    public static void cmatrixrndorthogonalfromtheleft(ref complex[,] a, int m, int n)
    {
        _core_cmatrixrndorthogonalfromtheleft(ref  a,  m,  n, 0x0);
    }
    
    public static void cmatrixrndorthogonalfromtheleft(ref complex[,] a, int m, int n, alglib.xparams _xparams)
    {
        _core_cmatrixrndorthogonalfromtheleft(ref  a,  m,  n, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_smatrixrndmultiply(ref double[,] a, int n, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                _error_code = _i_xv2_smatrixrndmultiply(&_s_errormsg, &_d_a, &_d_n, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "smatrixrndmultiply");
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        // This function returns no value.
    }
    
    public static void smatrixrndmultiply(ref double[,] a, int n)
    {
        _core_smatrixrndmultiply(ref  a,  n, 0x0);
    }
    
    public static void smatrixrndmultiply(ref double[,] a, int n, alglib.xparams _xparams)
    {
        _core_smatrixrndmultiply(ref  a,  n, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_hmatrixrndmultiply(ref complex[,] a, int n, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                _error_code = _i_xv2_hmatrixrndmultiply(&_s_errormsg, &_d_a, &_d_n, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "hmatrixrndmultiply");
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new alglib.complex[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        // This function returns no value.
    }
    
    public static void hmatrixrndmultiply(ref complex[,] a, int n)
    {
        _core_hmatrixrndmultiply(ref  a,  n, 0x0);
    }
    
    public static void hmatrixrndmultiply(ref complex[,] a, int n, alglib.xparams _xparams)
    {
        _core_hmatrixrndmultiply(ref  a,  n, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage sparse
    //
    

    public unsafe class sparsematrix : alglibobject
    {
        private void *_ptr;
        public sparsematrix(void *x)
        {
            _ptr = x;
        }
        ~sparsematrix()
        {
            _deallocate();
        }
        public void* ptr { get { return _ptr; } }
        public override alglib.alglibobject make_copy()
        {
            if( _ptr==null )
                return new sparsematrix(null);
            return new sparsematrix(_i_x_obj_copy_sparsematrix(_ptr));
        }
        public override void _deallocate()
        {
            if( _ptr!=null )
                _i_x_obj_free_sparsematrix(_ptr);
            _ptr = null;
            System.GC.SuppressFinalize(this);
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_sparsematrix(void *x);
    private static _d_x_obj_copy_sparsematrix _i_x_obj_copy_sparsematrix = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_obj_free_sparsematrix(void *x);
    private static _d_x_obj_free_sparsematrix _i_x_obj_free_sparsematrix = null;

    public unsafe class sparsebuffers : alglibobject
    {
        private void *_ptr;
        public sparsebuffers(void *x)
        {
            _ptr = x;
        }
        ~sparsebuffers()
        {
            _deallocate();
        }
        public void* ptr { get { return _ptr; } }
        public override alglib.alglibobject make_copy()
        {
            if( _ptr==null )
                return new sparsebuffers(null);
            return new sparsebuffers(_i_x_obj_copy_sparsebuffers(_ptr));
        }
        public override void _deallocate()
        {
            if( _ptr!=null )
                _i_x_obj_free_sparsebuffers(_ptr);
            _ptr = null;
            System.GC.SuppressFinalize(this);
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_sparsebuffers(void *x);
    private static _d_x_obj_copy_sparsebuffers _i_x_obj_copy_sparsebuffers = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_obj_free_sparsebuffers(void *x);
    private static _d_x_obj_free_sparsebuffers _i_x_obj_free_sparsebuffers = null;
    public static unsafe void sparseserialize(sparsematrix obj, out string s_out)
    {
        byte *_s_errormsg = null;
        byte *_out = null;
        void *_x = obj.ptr;
        try
        {
            int _error_code = _i_x_sparseserialize(&_s_errormsg, &_x, &_out);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparseserialize");
            s_out = Marshal.PtrToStringAnsi((IntPtr)_out);
        }
        finally
        {
            x_free((IntPtr)_out);
        }
    }
    
    public static unsafe void sparseunserialize(string s_in, out sparsematrix obj)
    {
        byte *_s_errormsg = null;
        byte[] _ain = System.Text.Encoding.UTF8.GetBytes(s_in);
        fixed(byte *_pin = _ain )
        {
            byte *_in = _pin;
            void *_x = null;
            obj = null;
            try
            {
                int _error_code = _i_x_sparseunserialize(&_s_errormsg, &_in, &_x);
                if( _error_code!=X_OK )
                    handle_exception(_error_code, _s_errormsg, "sparseunserialize");
                obj = new sparsematrix(_x);
            }
            finally
            {
                // on exception clean up X objects which were not attached to C# objects
                if( _x!=null && obj==null)
                    _i_x_obj_free_sparsematrix(_x);
            }
        }
    }
    public static unsafe void sparseserialize(sparsematrix obj, System.IO.Stream s_out)
    {
        byte *_s_errormsg = null;
        void *_x = obj.ptr;
        alglib.native_stream_adapter a = new alglib.native_stream_adapter();
        a.sstart_stream(s_out);
        int _error_code = _i_x_sparseserialize_stream(&_s_errormsg, &_x, a.writer_callback, IntPtr.Zero);
        if( _error_code!=X_OK )
            handle_exception(_error_code, _s_errormsg, "sparseserialize");
    }
    
    public static unsafe void sparseunserialize(System.IO.Stream s_in, out sparsematrix obj)
    {
        byte *_s_errormsg = null;
        void *_x = null;
        obj = null;
        alglib.native_stream_adapter a = new alglib.native_stream_adapter();
        a.ustart_stream(s_in);
        try
        {
            int _error_code = _i_x_sparseunserialize_stream(&_s_errormsg, a.reader_callback, IntPtr.Zero, &_x);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparseunserialize");
            obj = new sparsematrix(_x);
        }
        finally
        {
            // on exception clean up X objects which were not attached to C# objects
            if( _x!=null && obj==null)
                _i_x_obj_free_sparsematrix(_x);
        }
    }
    
    private static unsafe void _core_sparsecreate(int m, int n, int k, out sparsematrix s, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_int _d_k = new x_int(k);
        void *_d_s = null;
        s = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_sparsecreate(&_s_errormsg, &_d_m, &_d_n, &_d_k, &_d_s, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparsecreate");
            s = new sparsematrix(_d_s);
        }
        finally
        {
            if( _d_s!=null && s==null)
                _i_x_obj_free_sparsematrix(_d_s); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void sparsecreate(int m, int n, int k, out sparsematrix s)
    {
        _core_sparsecreate( m,  n,  k, out  s, 0x0);
    }
    
    public static void sparsecreate(int m, int n, int k, out sparsematrix s, alglib.xparams _xparams)
    {
        _core_sparsecreate( m,  n,  k, out  s, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void sparsecreate(int m, int n, out sparsematrix s)
    {
        int k;
    
        k = 0;
        _core_sparsecreate( m,  n,  k, out  s, 0x0);
    
        
    }
    
    public static void sparsecreate(int m, int n, out sparsematrix s, alglib.xparams _xparams)
    {
        int k;
    
        k = 0;
        _core_sparsecreate( m,  n,  k, out  s, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_sparsecreatebuf(int m, int n, int k, sparsematrix s, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_int _d_k = new x_int(k);
        void *_d_s = s.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_sparsecreatebuf(&_s_errormsg, &_d_m, &_d_n, &_d_k, &_d_s, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparsecreatebuf");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void sparsecreatebuf(int m, int n, int k, sparsematrix s)
    {
        _core_sparsecreatebuf( m,  n,  k,  s, 0x0);
    }
    
    public static void sparsecreatebuf(int m, int n, int k, sparsematrix s, alglib.xparams _xparams)
    {
        _core_sparsecreatebuf( m,  n,  k,  s, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void sparsecreatebuf(int m, int n, sparsematrix s)
    {
        int k;
    
        k = 0;
        _core_sparsecreatebuf( m,  n,  k,  s, 0x0);
    
        
    }
    
    public static void sparsecreatebuf(int m, int n, sparsematrix s, alglib.xparams _xparams)
    {
        int k;
    
        k = 0;
        _core_sparsecreatebuf( m,  n,  k,  s, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_sparsecreatecrs(int m, int n, int[] ner, out sparsematrix s, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_vector _d_ner = new x_vector();
        void *_d_s = null;
        s = null;
        
        // Pack, call, unpack
        try
        {
            x_vector_from_array(ref _d_ner, ner, X_CREATE);
            _error_code = _i_xv2_sparsecreatecrs(&_s_errormsg, &_d_m, &_d_n, &_d_ner, &_d_s, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparsecreatecrs");
            s = new sparsematrix(_d_s);
        }
        finally
        {
            x_vector_clear(ref _d_ner);
            if( _d_s!=null && s==null)
                _i_x_obj_free_sparsematrix(_d_s); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void sparsecreatecrs(int m, int n, int[] ner, out sparsematrix s)
    {
        _core_sparsecreatecrs( m,  n,  ner, out  s, 0x0);
    }
    
    public static void sparsecreatecrs(int m, int n, int[] ner, out sparsematrix s, alglib.xparams _xparams)
    {
        _core_sparsecreatecrs( m,  n,  ner, out  s, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_sparsecreatecrsbuf(int m, int n, int[] ner, sparsematrix s, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_vector _d_ner = new x_vector();
        void *_d_s = s.ptr;
        
        // Pack, call, unpack
        try
        {
            x_vector_from_array(ref _d_ner, ner, X_CREATE);
            _error_code = _i_xv2_sparsecreatecrsbuf(&_s_errormsg, &_d_m, &_d_n, &_d_ner, &_d_s, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparsecreatecrsbuf");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_ner);
        }
        // This function returns no value.
    }
    
    public static void sparsecreatecrsbuf(int m, int n, int[] ner, sparsematrix s)
    {
        _core_sparsecreatecrsbuf( m,  n,  ner,  s, 0x0);
    }
    
    public static void sparsecreatecrsbuf(int m, int n, int[] ner, sparsematrix s, alglib.xparams _xparams)
    {
        _core_sparsecreatecrsbuf( m,  n,  ner,  s, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_sparsecreatesks(int m, int n, int[] d, int[] u, out sparsematrix s, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_vector _d_d = new x_vector();
        x_vector _d_u = new x_vector();
        void *_d_s = null;
        s = null;
        
        // Pack, call, unpack
        try
        {
            x_vector_from_array(ref _d_d, d, X_CREATE);
            x_vector_from_array(ref _d_u, u, X_CREATE);
            _error_code = _i_xv2_sparsecreatesks(&_s_errormsg, &_d_m, &_d_n, &_d_d, &_d_u, &_d_s, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparsecreatesks");
            s = new sparsematrix(_d_s);
        }
        finally
        {
            x_vector_clear(ref _d_d);
            x_vector_clear(ref _d_u);
            if( _d_s!=null && s==null)
                _i_x_obj_free_sparsematrix(_d_s); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void sparsecreatesks(int m, int n, int[] d, int[] u, out sparsematrix s)
    {
        _core_sparsecreatesks( m,  n,  d,  u, out  s, 0x0);
    }
    
    public static void sparsecreatesks(int m, int n, int[] d, int[] u, out sparsematrix s, alglib.xparams _xparams)
    {
        _core_sparsecreatesks( m,  n,  d,  u, out  s, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_sparsecreatesksbuf(int m, int n, int[] d, int[] u, sparsematrix s, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_vector _d_d = new x_vector();
        x_vector _d_u = new x_vector();
        void *_d_s = s.ptr;
        
        // Pack, call, unpack
        try
        {
            x_vector_from_array(ref _d_d, d, X_CREATE);
            x_vector_from_array(ref _d_u, u, X_CREATE);
            _error_code = _i_xv2_sparsecreatesksbuf(&_s_errormsg, &_d_m, &_d_n, &_d_d, &_d_u, &_d_s, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparsecreatesksbuf");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_d);
            x_vector_clear(ref _d_u);
        }
        // This function returns no value.
    }
    
    public static void sparsecreatesksbuf(int m, int n, int[] d, int[] u, sparsematrix s)
    {
        _core_sparsecreatesksbuf( m,  n,  d,  u,  s, 0x0);
    }
    
    public static void sparsecreatesksbuf(int m, int n, int[] d, int[] u, sparsematrix s, alglib.xparams _xparams)
    {
        _core_sparsecreatesksbuf( m,  n,  d,  u,  s, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_sparsecreatesksband(int m, int n, int bw, out sparsematrix s, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_int _d_bw = new x_int(bw);
        void *_d_s = null;
        s = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_sparsecreatesksband(&_s_errormsg, &_d_m, &_d_n, &_d_bw, &_d_s, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparsecreatesksband");
            s = new sparsematrix(_d_s);
        }
        finally
        {
            if( _d_s!=null && s==null)
                _i_x_obj_free_sparsematrix(_d_s); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void sparsecreatesksband(int m, int n, int bw, out sparsematrix s)
    {
        _core_sparsecreatesksband( m,  n,  bw, out  s, 0x0);
    }
    
    public static void sparsecreatesksband(int m, int n, int bw, out sparsematrix s, alglib.xparams _xparams)
    {
        _core_sparsecreatesksband( m,  n,  bw, out  s, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_sparsecreatesksbandbuf(int m, int n, int bw, sparsematrix s, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_int _d_bw = new x_int(bw);
        void *_d_s = s.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_sparsecreatesksbandbuf(&_s_errormsg, &_d_m, &_d_n, &_d_bw, &_d_s, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparsecreatesksbandbuf");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void sparsecreatesksbandbuf(int m, int n, int bw, sparsematrix s)
    {
        _core_sparsecreatesksbandbuf( m,  n,  bw,  s, 0x0);
    }
    
    public static void sparsecreatesksbandbuf(int m, int n, int bw, sparsematrix s, alglib.xparams _xparams)
    {
        _core_sparsecreatesksbandbuf( m,  n,  bw,  s, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_sparsecopy(sparsematrix s0, out sparsematrix s1, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s0 = s0.ptr;
        void *_d_s1 = null;
        s1 = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_sparsecopy(&_s_errormsg, &_d_s0, &_d_s1, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparsecopy");
            ap.assert(s0.ptr==_d_s0, "ALGLIB: internal error (reference changed for non-out X-object)");
            s1 = new sparsematrix(_d_s1);
        }
        finally
        {
            if( _d_s1!=null && s1==null)
                _i_x_obj_free_sparsematrix(_d_s1); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void sparsecopy(sparsematrix s0, out sparsematrix s1)
    {
        _core_sparsecopy( s0, out  s1, 0x0);
    }
    
    public static void sparsecopy(sparsematrix s0, out sparsematrix s1, alglib.xparams _xparams)
    {
        _core_sparsecopy( s0, out  s1, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_sparsecopybuf(sparsematrix s0, sparsematrix s1, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s0 = s0.ptr;
        void *_d_s1 = s1.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_sparsecopybuf(&_s_errormsg, &_d_s0, &_d_s1, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparsecopybuf");
            ap.assert(s0.ptr==_d_s0, "ALGLIB: internal error (reference changed for non-out X-object)");
            ap.assert(s1.ptr==_d_s1, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void sparsecopybuf(sparsematrix s0, sparsematrix s1)
    {
        _core_sparsecopybuf( s0,  s1, 0x0);
    }
    
    public static void sparsecopybuf(sparsematrix s0, sparsematrix s1, alglib.xparams _xparams)
    {
        _core_sparsecopybuf( s0,  s1, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_sparseswap(sparsematrix s0, sparsematrix s1, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s0 = s0.ptr;
        void *_d_s1 = s1.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_sparseswap(&_s_errormsg, &_d_s0, &_d_s1, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparseswap");
            ap.assert(s0.ptr==_d_s0, "ALGLIB: internal error (reference changed for non-out X-object)");
            ap.assert(s1.ptr==_d_s1, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void sparseswap(sparsematrix s0, sparsematrix s1)
    {
        _core_sparseswap( s0,  s1, 0x0);
    }
    
    public static void sparseswap(sparsematrix s0, sparsematrix s1, alglib.xparams _xparams)
    {
        _core_sparseswap( s0,  s1, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_sparseadd(sparsematrix s, int i, int j, double v, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_int _d_i = new x_int(i);
        x_int _d_j = new x_int(j);
        double _d_v = v;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_sparseadd(&_s_errormsg, &_d_s, &_d_i, &_d_j, &_d_v, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparseadd");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void sparseadd(sparsematrix s, int i, int j, double v)
    {
        _core_sparseadd( s,  i,  j,  v, 0x0);
    }
    
    public static void sparseadd(sparsematrix s, int i, int j, double v, alglib.xparams _xparams)
    {
        _core_sparseadd( s,  i,  j,  v, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_sparseset(sparsematrix s, int i, int j, double v, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_int _d_i = new x_int(i);
        x_int _d_j = new x_int(j);
        double _d_v = v;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_sparseset(&_s_errormsg, &_d_s, &_d_i, &_d_j, &_d_v, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparseset");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void sparseset(sparsematrix s, int i, int j, double v)
    {
        _core_sparseset( s,  i,  j,  v, 0x0);
    }
    
    public static void sparseset(sparsematrix s, int i, int j, double v, alglib.xparams _xparams)
    {
        _core_sparseset( s,  i,  j,  v, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_sparseget(sparsematrix s, int i, int j, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_s = s.ptr;
        x_int _d_i = new x_int(i);
        x_int _d_j = new x_int(j);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_sparseget(&_s_errormsg, &_d_result, &_d_s, &_d_i, &_d_j, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparseget");
            result = _d_result;
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double sparseget(sparsematrix s, int i, int j)
    {
        return _core_sparseget( s,  i,  j, 0x0);
    }
    
    public static double sparseget(sparsematrix s, int i, int j, alglib.xparams _xparams)
    {
        return _core_sparseget( s,  i,  j, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe bool _core_sparseexists(sparsematrix s, int i, int j, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        bool result;
        byte _d_result = (byte)0;
        void *_d_s = s.ptr;
        x_int _d_i = new x_int(i);
        x_int _d_j = new x_int(j);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_sparseexists(&_s_errormsg, &_d_result, &_d_s, &_d_i, &_d_j, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparseexists");
            result = _d_result!=0;
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static bool sparseexists(sparsematrix s, int i, int j)
    {
        return _core_sparseexists( s,  i,  j, 0x0);
    }
    
    public static bool sparseexists(sparsematrix s, int i, int j, alglib.xparams _xparams)
    {
        return _core_sparseexists( s,  i,  j, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_sparsegetdiagonal(sparsematrix s, int i, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_s = s.ptr;
        x_int _d_i = new x_int(i);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_sparsegetdiagonal(&_s_errormsg, &_d_result, &_d_s, &_d_i, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparsegetdiagonal");
            result = _d_result;
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double sparsegetdiagonal(sparsematrix s, int i)
    {
        return _core_sparsegetdiagonal( s,  i, 0x0);
    }
    
    public static double sparsegetdiagonal(sparsematrix s, int i, alglib.xparams _xparams)
    {
        return _core_sparsegetdiagonal( s,  i, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_sparsemv(sparsematrix s, double[] x, ref double[] y, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                _error_code = _i_xv2_sparsemv(&_s_errormsg, &_d_s, &_d_x, &_d_y, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparsemv");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_y.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_y, ref y);
            if( y == null )
                y = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
        }
        // This function returns no value.
    }
    
    public static void sparsemv(sparsematrix s, double[] x, ref double[] y)
    {
        _core_sparsemv( s,  x, ref  y, 0x0);
    }
    
    public static void sparsemv(sparsematrix s, double[] x, ref double[] y, alglib.xparams _xparams)
    {
        _core_sparsemv( s,  x, ref  y, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_sparsemtv(sparsematrix s, double[] x, ref double[] y, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                _error_code = _i_xv2_sparsemtv(&_s_errormsg, &_d_s, &_d_x, &_d_y, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparsemtv");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_y.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_y, ref y);
            if( y == null )
                y = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
        }
        // This function returns no value.
    }
    
    public static void sparsemtv(sparsematrix s, double[] x, ref double[] y)
    {
        _core_sparsemtv( s,  x, ref  y, 0x0);
    }
    
    public static void sparsemtv(sparsematrix s, double[] x, ref double[] y, alglib.xparams _xparams)
    {
        _core_sparsemtv( s,  x, ref  y, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_sparsegemv(sparsematrix s, double alpha, int ops, double[] x, int ix, double beta, ref double[] y, int iy, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        double _d_alpha = alpha;
        x_int _d_ops = new x_int(ops);
        x_vector _d_x = new x_vector();
        x_int _d_ix = new x_int(ix);
        double _d_beta = beta;
        x_vector _d_y = new x_vector();
        x_int _d_iy = new x_int(iy);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                _error_code = _i_xv2_sparsegemv(&_s_errormsg, &_d_s, &_d_alpha, &_d_ops, &_d_x, &_d_ix, &_d_beta, &_d_y, &_d_iy, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparsegemv");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_y.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_y, ref y);
            if( y == null )
                y = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
        }
        // This function returns no value.
    }
    
    public static void sparsegemv(sparsematrix s, double alpha, int ops, double[] x, int ix, double beta, ref double[] y, int iy)
    {
        _core_sparsegemv( s,  alpha,  ops,  x,  ix,  beta, ref  y,  iy, 0x0);
    }
    
    public static void sparsegemv(sparsematrix s, double alpha, int ops, double[] x, int ix, double beta, ref double[] y, int iy, alglib.xparams _xparams)
    {
        _core_sparsegemv( s,  alpha,  ops,  x,  ix,  beta, ref  y,  iy, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_sparsemv2(sparsematrix s, double[] x, ref double[] y0, ref double[] y1, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_vector _d_x = new x_vector();
        x_vector _d_y0 = new x_vector();
        x_vector _d_y1 = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y0 = y0, _fp_y1 = y1){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y0, _fp_y0, ap.len(y0));
                x_vector_attach_to_array(ref _d_y1, _fp_y1, ap.len(y1));
                _error_code = _i_xv2_sparsemv2(&_s_errormsg, &_d_s, &_d_x, &_d_y0, &_d_y1, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparsemv2");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_y0.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_y0, ref y0);
            if( y0 == null )
                y0 = new double[0];
            if( _d_y1.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_y1, ref y1);
            if( y1 == null )
                y1 = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y0);
            x_vector_clear(ref _d_y1);
        }
        // This function returns no value.
    }
    
    public static void sparsemv2(sparsematrix s, double[] x, ref double[] y0, ref double[] y1)
    {
        _core_sparsemv2( s,  x, ref  y0, ref  y1, 0x0);
    }
    
    public static void sparsemv2(sparsematrix s, double[] x, ref double[] y0, ref double[] y1, alglib.xparams _xparams)
    {
        _core_sparsemv2( s,  x, ref  y0, ref  y1, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_sparsesmv(sparsematrix s, bool isupper, double[] x, ref double[] y, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                _error_code = _i_xv2_sparsesmv(&_s_errormsg, &_d_s, &_d_isupper, &_d_x, &_d_y, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparsesmv");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_y.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_y, ref y);
            if( y == null )
                y = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
        }
        // This function returns no value.
    }
    
    public static void sparsesmv(sparsematrix s, bool isupper, double[] x, ref double[] y)
    {
        _core_sparsesmv( s,  isupper,  x, ref  y, 0x0);
    }
    
    public static void sparsesmv(sparsematrix s, bool isupper, double[] x, ref double[] y, alglib.xparams _xparams)
    {
        _core_sparsesmv( s,  isupper,  x, ref  y, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_sparsevsmv(sparsematrix s, bool isupper, double[] x, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_s = s.ptr;
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_vector _d_x = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_xv2_sparsevsmv(&_s_errormsg, &_d_result, &_d_s, &_d_isupper, &_d_x, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparsevsmv");
            result = _d_result;
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_x);
        }
        return result;
    }
    
    public static double sparsevsmv(sparsematrix s, bool isupper, double[] x)
    {
        return _core_sparsevsmv( s,  isupper,  x, 0x0);
    }
    
    public static double sparsevsmv(sparsematrix s, bool isupper, double[] x, alglib.xparams _xparams)
    {
        return _core_sparsevsmv( s,  isupper,  x, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_sparsemm(sparsematrix s, double[,] a, int k, ref double[,] b, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_matrix _d_a = new x_matrix();
        x_int _d_k = new x_int(k);
        x_matrix _d_b = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a, _fp_b = b){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matrix_attach_to_array(ref _d_b, _fp_b, ap.rows(b), ap.cols(b));
                _error_code = _i_xv2_sparsemm(&_s_errormsg, &_d_s, &_d_a, &_d_k, &_d_b, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparsemm");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_b.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_b, ref b);
            if( b == null )
                b = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matrix_clear(ref _d_b);
        }
        // This function returns no value.
    }
    
    public static void sparsemm(sparsematrix s, double[,] a, int k, ref double[,] b)
    {
        _core_sparsemm( s,  a,  k, ref  b, 0x0);
    }
    
    public static void sparsemm(sparsematrix s, double[,] a, int k, ref double[,] b, alglib.xparams _xparams)
    {
        _core_sparsemm( s,  a,  k, ref  b, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_sparsemtm(sparsematrix s, double[,] a, int k, ref double[,] b, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_matrix _d_a = new x_matrix();
        x_int _d_k = new x_int(k);
        x_matrix _d_b = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a, _fp_b = b){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matrix_attach_to_array(ref _d_b, _fp_b, ap.rows(b), ap.cols(b));
                _error_code = _i_xv2_sparsemtm(&_s_errormsg, &_d_s, &_d_a, &_d_k, &_d_b, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparsemtm");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_b.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_b, ref b);
            if( b == null )
                b = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matrix_clear(ref _d_b);
        }
        // This function returns no value.
    }
    
    public static void sparsemtm(sparsematrix s, double[,] a, int k, ref double[,] b)
    {
        _core_sparsemtm( s,  a,  k, ref  b, 0x0);
    }
    
    public static void sparsemtm(sparsematrix s, double[,] a, int k, ref double[,] b, alglib.xparams _xparams)
    {
        _core_sparsemtm( s,  a,  k, ref  b, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_sparsemm2(sparsematrix s, double[,] a, int k, ref double[,] b0, ref double[,] b1, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_matrix _d_a = new x_matrix();
        x_int _d_k = new x_int(k);
        x_matrix _d_b0 = new x_matrix();
        x_matrix _d_b1 = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a, _fp_b0 = b0, _fp_b1 = b1){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matrix_attach_to_array(ref _d_b0, _fp_b0, ap.rows(b0), ap.cols(b0));
                x_matrix_attach_to_array(ref _d_b1, _fp_b1, ap.rows(b1), ap.cols(b1));
                _error_code = _i_xv2_sparsemm2(&_s_errormsg, &_d_s, &_d_a, &_d_k, &_d_b0, &_d_b1, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparsemm2");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_b0.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_b0, ref b0);
            if( b0 == null )
                b0 = new double[0,0];
            if( _d_b1.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_b1, ref b1);
            if( b1 == null )
                b1 = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matrix_clear(ref _d_b0);
            x_matrix_clear(ref _d_b1);
        }
        // This function returns no value.
    }
    
    public static void sparsemm2(sparsematrix s, double[,] a, int k, ref double[,] b0, ref double[,] b1)
    {
        _core_sparsemm2( s,  a,  k, ref  b0, ref  b1, 0x0);
    }
    
    public static void sparsemm2(sparsematrix s, double[,] a, int k, ref double[,] b0, ref double[,] b1, alglib.xparams _xparams)
    {
        _core_sparsemm2( s,  a,  k, ref  b0, ref  b1, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_sparsesmm(sparsematrix s, bool isupper, double[,] a, int k, ref double[,] b, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_matrix _d_a = new x_matrix();
        x_int _d_k = new x_int(k);
        x_matrix _d_b = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a, _fp_b = b){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matrix_attach_to_array(ref _d_b, _fp_b, ap.rows(b), ap.cols(b));
                _error_code = _i_xv2_sparsesmm(&_s_errormsg, &_d_s, &_d_isupper, &_d_a, &_d_k, &_d_b, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparsesmm");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_b.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_b, ref b);
            if( b == null )
                b = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matrix_clear(ref _d_b);
        }
        // This function returns no value.
    }
    
    public static void sparsesmm(sparsematrix s, bool isupper, double[,] a, int k, ref double[,] b)
    {
        _core_sparsesmm( s,  isupper,  a,  k, ref  b, 0x0);
    }
    
    public static void sparsesmm(sparsematrix s, bool isupper, double[,] a, int k, ref double[,] b, alglib.xparams _xparams)
    {
        _core_sparsesmm( s,  isupper,  a,  k, ref  b, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_sparsetrmv(sparsematrix s, bool isupper, bool isunit, int optype, ref double[] x, ref double[] y, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        byte _d_isunit = (byte)(isunit ? 1 : 0);
        x_int _d_optype = new x_int(optype);
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                _error_code = _i_xv2_sparsetrmv(&_s_errormsg, &_d_s, &_d_isupper, &_d_isunit, &_d_optype, &_d_x, &_d_y, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparsetrmv");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
            if( _d_y.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_y, ref y);
            if( y == null )
                y = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
        }
        // This function returns no value.
    }
    
    public static void sparsetrmv(sparsematrix s, bool isupper, bool isunit, int optype, ref double[] x, ref double[] y)
    {
        _core_sparsetrmv( s,  isupper,  isunit,  optype, ref  x, ref  y, 0x0);
    }
    
    public static void sparsetrmv(sparsematrix s, bool isupper, bool isunit, int optype, ref double[] x, ref double[] y, alglib.xparams _xparams)
    {
        _core_sparsetrmv( s,  isupper,  isunit,  optype, ref  x, ref  y, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_sparsetrsv(sparsematrix s, bool isupper, bool isunit, int optype, ref double[] x, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        byte _d_isunit = (byte)(isunit ? 1 : 0);
        x_int _d_optype = new x_int(optype);
        x_vector _d_x = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_xv2_sparsetrsv(&_s_errormsg, &_d_s, &_d_isupper, &_d_isunit, &_d_optype, &_d_x, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparsetrsv");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
        }
        // This function returns no value.
    }
    
    public static void sparsetrsv(sparsematrix s, bool isupper, bool isunit, int optype, ref double[] x)
    {
        _core_sparsetrsv( s,  isupper,  isunit,  optype, ref  x, 0x0);
    }
    
    public static void sparsetrsv(sparsematrix s, bool isupper, bool isunit, int optype, ref double[] x, alglib.xparams _xparams)
    {
        _core_sparsetrsv( s,  isupper,  isunit,  optype, ref  x, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_sparsesymmpermtbl(sparsematrix a, bool isupper, int[] p, out sparsematrix b, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_a = a.ptr;
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_vector _d_p = new x_vector();
        void *_d_b = null;
        b = null;
        
        // Pack, call, unpack
        try
        {
            x_vector_from_array(ref _d_p, p, X_CREATE);
            _error_code = _i_xv2_sparsesymmpermtbl(&_s_errormsg, &_d_a, &_d_isupper, &_d_p, &_d_b, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparsesymmpermtbl");
            ap.assert(a.ptr==_d_a, "ALGLIB: internal error (reference changed for non-out X-object)");
            b = new sparsematrix(_d_b);
        }
        finally
        {
            x_vector_clear(ref _d_p);
            if( _d_b!=null && b==null)
                _i_x_obj_free_sparsematrix(_d_b); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void sparsesymmpermtbl(sparsematrix a, bool isupper, int[] p, out sparsematrix b)
    {
        _core_sparsesymmpermtbl( a,  isupper,  p, out  b, 0x0);
    }
    
    public static void sparsesymmpermtbl(sparsematrix a, bool isupper, int[] p, out sparsematrix b, alglib.xparams _xparams)
    {
        _core_sparsesymmpermtbl( a,  isupper,  p, out  b, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_sparsesymmpermtblbuf(sparsematrix a, bool isupper, int[] p, sparsematrix b, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_a = a.ptr;
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_vector _d_p = new x_vector();
        void *_d_b = b.ptr;
        
        // Pack, call, unpack
        try
        {
            x_vector_from_array(ref _d_p, p, X_CREATE);
            _error_code = _i_xv2_sparsesymmpermtblbuf(&_s_errormsg, &_d_a, &_d_isupper, &_d_p, &_d_b, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparsesymmpermtblbuf");
            ap.assert(a.ptr==_d_a, "ALGLIB: internal error (reference changed for non-out X-object)");
            ap.assert(b.ptr==_d_b, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_p);
        }
        // This function returns no value.
    }
    
    public static void sparsesymmpermtblbuf(sparsematrix a, bool isupper, int[] p, sparsematrix b)
    {
        _core_sparsesymmpermtblbuf( a,  isupper,  p,  b, 0x0);
    }
    
    public static void sparsesymmpermtblbuf(sparsematrix a, bool isupper, int[] p, sparsematrix b, alglib.xparams _xparams)
    {
        _core_sparsesymmpermtblbuf( a,  isupper,  p,  b, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_sparseresizematrix(sparsematrix s, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_sparseresizematrix(&_s_errormsg, &_d_s, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparseresizematrix");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void sparseresizematrix(sparsematrix s)
    {
        _core_sparseresizematrix( s, 0x0);
    }
    
    public static void sparseresizematrix(sparsematrix s, alglib.xparams _xparams)
    {
        _core_sparseresizematrix( s, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe bool _core_sparseenumerate(sparsematrix s, ref int t0, ref int t1, out int i, out int j, out double v, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        bool result;
        byte _d_result = (byte)0;
        void *_d_s = s.ptr;
        x_int _d_t0 = new x_int(t0);
        x_int _d_t1 = new x_int(t1);
        x_int _d_i = new x_int();
        x_int _d_j = new x_int();
        double _d_v = 0;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_sparseenumerate(&_s_errormsg, &_d_result, &_d_s, &_d_t0, &_d_t1, &_d_i, &_d_j, &_d_v, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparseenumerate");
            result = _d_result!=0;
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            t0 = _d_t0.intval;
            t1 = _d_t1.intval;
            i = _d_i.intval;
            j = _d_j.intval;
            v = _d_v;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static bool sparseenumerate(sparsematrix s, ref int t0, ref int t1, out int i, out int j, out double v)
    {
        return _core_sparseenumerate( s, ref  t0, ref  t1, out  i, out  j, out  v, 0x0);
    }
    
    public static bool sparseenumerate(sparsematrix s, ref int t0, ref int t1, out int i, out int j, out double v, alglib.xparams _xparams)
    {
        return _core_sparseenumerate( s, ref  t0, ref  t1, out  i, out  j, out  v, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe bool _core_sparserewriteexisting(sparsematrix s, int i, int j, double v, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        bool result;
        byte _d_result = (byte)0;
        void *_d_s = s.ptr;
        x_int _d_i = new x_int(i);
        x_int _d_j = new x_int(j);
        double _d_v = v;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_sparserewriteexisting(&_s_errormsg, &_d_result, &_d_s, &_d_i, &_d_j, &_d_v, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparserewriteexisting");
            result = _d_result!=0;
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static bool sparserewriteexisting(sparsematrix s, int i, int j, double v)
    {
        return _core_sparserewriteexisting( s,  i,  j,  v, 0x0);
    }
    
    public static bool sparserewriteexisting(sparsematrix s, int i, int j, double v, alglib.xparams _xparams)
    {
        return _core_sparserewriteexisting( s,  i,  j,  v, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_sparsegetrow(sparsematrix s, int i, ref double[] irow, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_int _d_i = new x_int(i);
        x_vector _d_irow = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_irow = irow){
                x_vector_attach_to_array(ref _d_irow, _fp_irow, ap.len(irow));
                _error_code = _i_xv2_sparsegetrow(&_s_errormsg, &_d_s, &_d_i, &_d_irow, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparsegetrow");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_irow.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_irow, ref irow);
            if( irow == null )
                irow = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_irow);
        }
        // This function returns no value.
    }
    
    public static void sparsegetrow(sparsematrix s, int i, ref double[] irow)
    {
        _core_sparsegetrow( s,  i, ref  irow, 0x0);
    }
    
    public static void sparsegetrow(sparsematrix s, int i, ref double[] irow, alglib.xparams _xparams)
    {
        _core_sparsegetrow( s,  i, ref  irow, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_sparsegetcompressedrow(sparsematrix s, int i, ref int[] colidx, ref double[] vals, out int nzcnt, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_int _d_i = new x_int(i);
        x_vector _d_colidx = new x_vector();
        x_vector _d_vals = new x_vector();
        x_int _d_nzcnt = new x_int();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_vals = vals){
                x_vector_from_array(ref _d_colidx, colidx, X_CREATE);
                x_vector_attach_to_array(ref _d_vals, _fp_vals, ap.len(vals));
                _error_code = _i_xv2_sparsegetcompressedrow(&_s_errormsg, &_d_s, &_d_i, &_d_colidx, &_d_vals, &_d_nzcnt, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparsegetcompressedrow");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            x_vector_to_array(ref _d_colidx, ref colidx);
            if( _d_vals.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_vals, ref vals);
            if( vals == null )
                vals = new double[0];
            nzcnt = _d_nzcnt.intval;
        }
        finally
        {
            x_vector_clear(ref _d_colidx);
            x_vector_clear(ref _d_vals);
        }
        // This function returns no value.
    }
    
    public static void sparsegetcompressedrow(sparsematrix s, int i, ref int[] colidx, ref double[] vals, out int nzcnt)
    {
        _core_sparsegetcompressedrow( s,  i, ref  colidx, ref  vals, out  nzcnt, 0x0);
    }
    
    public static void sparsegetcompressedrow(sparsematrix s, int i, ref int[] colidx, ref double[] vals, out int nzcnt, alglib.xparams _xparams)
    {
        _core_sparsegetcompressedrow( s,  i, ref  colidx, ref  vals, out  nzcnt, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_sparsetransposesks(sparsematrix s, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_sparsetransposesks(&_s_errormsg, &_d_s, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparsetransposesks");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void sparsetransposesks(sparsematrix s)
    {
        _core_sparsetransposesks( s, 0x0);
    }
    
    public static void sparsetransposesks(sparsematrix s, alglib.xparams _xparams)
    {
        _core_sparsetransposesks( s, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_sparsetransposecrs(sparsematrix s, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_sparsetransposecrs(&_s_errormsg, &_d_s, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparsetransposecrs");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void sparsetransposecrs(sparsematrix s)
    {
        _core_sparsetransposecrs( s, 0x0);
    }
    
    public static void sparsetransposecrs(sparsematrix s, alglib.xparams _xparams)
    {
        _core_sparsetransposecrs( s, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_sparsecopytransposecrs(sparsematrix s0, out sparsematrix s1, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s0 = s0.ptr;
        void *_d_s1 = null;
        s1 = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_sparsecopytransposecrs(&_s_errormsg, &_d_s0, &_d_s1, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparsecopytransposecrs");
            ap.assert(s0.ptr==_d_s0, "ALGLIB: internal error (reference changed for non-out X-object)");
            s1 = new sparsematrix(_d_s1);
        }
        finally
        {
            if( _d_s1!=null && s1==null)
                _i_x_obj_free_sparsematrix(_d_s1); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void sparsecopytransposecrs(sparsematrix s0, out sparsematrix s1)
    {
        _core_sparsecopytransposecrs( s0, out  s1, 0x0);
    }
    
    public static void sparsecopytransposecrs(sparsematrix s0, out sparsematrix s1, alglib.xparams _xparams)
    {
        _core_sparsecopytransposecrs( s0, out  s1, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_sparsecopytransposecrsbuf(sparsematrix s0, sparsematrix s1, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s0 = s0.ptr;
        void *_d_s1 = s1.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_sparsecopytransposecrsbuf(&_s_errormsg, &_d_s0, &_d_s1, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparsecopytransposecrsbuf");
            ap.assert(s0.ptr==_d_s0, "ALGLIB: internal error (reference changed for non-out X-object)");
            ap.assert(s1.ptr==_d_s1, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void sparsecopytransposecrsbuf(sparsematrix s0, sparsematrix s1)
    {
        _core_sparsecopytransposecrsbuf( s0,  s1, 0x0);
    }
    
    public static void sparsecopytransposecrsbuf(sparsematrix s0, sparsematrix s1, alglib.xparams _xparams)
    {
        _core_sparsecopytransposecrsbuf( s0,  s1, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_sparseconvertto(sparsematrix s0, int fmt, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s0 = s0.ptr;
        x_int _d_fmt = new x_int(fmt);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_sparseconvertto(&_s_errormsg, &_d_s0, &_d_fmt, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparseconvertto");
            ap.assert(s0.ptr==_d_s0, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void sparseconvertto(sparsematrix s0, int fmt)
    {
        _core_sparseconvertto( s0,  fmt, 0x0);
    }
    
    public static void sparseconvertto(sparsematrix s0, int fmt, alglib.xparams _xparams)
    {
        _core_sparseconvertto( s0,  fmt, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_sparsecopytobuf(sparsematrix s0, int fmt, sparsematrix s1, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s0 = s0.ptr;
        x_int _d_fmt = new x_int(fmt);
        void *_d_s1 = s1.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_sparsecopytobuf(&_s_errormsg, &_d_s0, &_d_fmt, &_d_s1, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparsecopytobuf");
            ap.assert(s0.ptr==_d_s0, "ALGLIB: internal error (reference changed for non-out X-object)");
            ap.assert(s1.ptr==_d_s1, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void sparsecopytobuf(sparsematrix s0, int fmt, sparsematrix s1)
    {
        _core_sparsecopytobuf( s0,  fmt,  s1, 0x0);
    }
    
    public static void sparsecopytobuf(sparsematrix s0, int fmt, sparsematrix s1, alglib.xparams _xparams)
    {
        _core_sparsecopytobuf( s0,  fmt,  s1, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_sparseconverttohash(sparsematrix s, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_sparseconverttohash(&_s_errormsg, &_d_s, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparseconverttohash");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void sparseconverttohash(sparsematrix s)
    {
        _core_sparseconverttohash( s, 0x0);
    }
    
    public static void sparseconverttohash(sparsematrix s, alglib.xparams _xparams)
    {
        _core_sparseconverttohash( s, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_sparsecopytohash(sparsematrix s0, out sparsematrix s1, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s0 = s0.ptr;
        void *_d_s1 = null;
        s1 = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_sparsecopytohash(&_s_errormsg, &_d_s0, &_d_s1, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparsecopytohash");
            ap.assert(s0.ptr==_d_s0, "ALGLIB: internal error (reference changed for non-out X-object)");
            s1 = new sparsematrix(_d_s1);
        }
        finally
        {
            if( _d_s1!=null && s1==null)
                _i_x_obj_free_sparsematrix(_d_s1); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void sparsecopytohash(sparsematrix s0, out sparsematrix s1)
    {
        _core_sparsecopytohash( s0, out  s1, 0x0);
    }
    
    public static void sparsecopytohash(sparsematrix s0, out sparsematrix s1, alglib.xparams _xparams)
    {
        _core_sparsecopytohash( s0, out  s1, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_sparsecopytohashbuf(sparsematrix s0, sparsematrix s1, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s0 = s0.ptr;
        void *_d_s1 = s1.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_sparsecopytohashbuf(&_s_errormsg, &_d_s0, &_d_s1, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparsecopytohashbuf");
            ap.assert(s0.ptr==_d_s0, "ALGLIB: internal error (reference changed for non-out X-object)");
            ap.assert(s1.ptr==_d_s1, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void sparsecopytohashbuf(sparsematrix s0, sparsematrix s1)
    {
        _core_sparsecopytohashbuf( s0,  s1, 0x0);
    }
    
    public static void sparsecopytohashbuf(sparsematrix s0, sparsematrix s1, alglib.xparams _xparams)
    {
        _core_sparsecopytohashbuf( s0,  s1, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_sparseconverttocrs(sparsematrix s, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_sparseconverttocrs(&_s_errormsg, &_d_s, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparseconverttocrs");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void sparseconverttocrs(sparsematrix s)
    {
        _core_sparseconverttocrs( s, 0x0);
    }
    
    public static void sparseconverttocrs(sparsematrix s, alglib.xparams _xparams)
    {
        _core_sparseconverttocrs( s, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_sparsecopytocrs(sparsematrix s0, out sparsematrix s1, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s0 = s0.ptr;
        void *_d_s1 = null;
        s1 = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_sparsecopytocrs(&_s_errormsg, &_d_s0, &_d_s1, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparsecopytocrs");
            ap.assert(s0.ptr==_d_s0, "ALGLIB: internal error (reference changed for non-out X-object)");
            s1 = new sparsematrix(_d_s1);
        }
        finally
        {
            if( _d_s1!=null && s1==null)
                _i_x_obj_free_sparsematrix(_d_s1); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void sparsecopytocrs(sparsematrix s0, out sparsematrix s1)
    {
        _core_sparsecopytocrs( s0, out  s1, 0x0);
    }
    
    public static void sparsecopytocrs(sparsematrix s0, out sparsematrix s1, alglib.xparams _xparams)
    {
        _core_sparsecopytocrs( s0, out  s1, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_sparsecopytocrsbuf(sparsematrix s0, sparsematrix s1, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s0 = s0.ptr;
        void *_d_s1 = s1.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_sparsecopytocrsbuf(&_s_errormsg, &_d_s0, &_d_s1, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparsecopytocrsbuf");
            ap.assert(s0.ptr==_d_s0, "ALGLIB: internal error (reference changed for non-out X-object)");
            ap.assert(s1.ptr==_d_s1, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void sparsecopytocrsbuf(sparsematrix s0, sparsematrix s1)
    {
        _core_sparsecopytocrsbuf( s0,  s1, 0x0);
    }
    
    public static void sparsecopytocrsbuf(sparsematrix s0, sparsematrix s1, alglib.xparams _xparams)
    {
        _core_sparsecopytocrsbuf( s0,  s1, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_sparseconverttosks(sparsematrix s, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_sparseconverttosks(&_s_errormsg, &_d_s, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparseconverttosks");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void sparseconverttosks(sparsematrix s)
    {
        _core_sparseconverttosks( s, 0x0);
    }
    
    public static void sparseconverttosks(sparsematrix s, alglib.xparams _xparams)
    {
        _core_sparseconverttosks( s, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_sparsecopytosks(sparsematrix s0, out sparsematrix s1, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s0 = s0.ptr;
        void *_d_s1 = null;
        s1 = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_sparsecopytosks(&_s_errormsg, &_d_s0, &_d_s1, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparsecopytosks");
            ap.assert(s0.ptr==_d_s0, "ALGLIB: internal error (reference changed for non-out X-object)");
            s1 = new sparsematrix(_d_s1);
        }
        finally
        {
            if( _d_s1!=null && s1==null)
                _i_x_obj_free_sparsematrix(_d_s1); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void sparsecopytosks(sparsematrix s0, out sparsematrix s1)
    {
        _core_sparsecopytosks( s0, out  s1, 0x0);
    }
    
    public static void sparsecopytosks(sparsematrix s0, out sparsematrix s1, alglib.xparams _xparams)
    {
        _core_sparsecopytosks( s0, out  s1, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_sparsecopytosksbuf(sparsematrix s0, sparsematrix s1, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s0 = s0.ptr;
        void *_d_s1 = s1.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_sparsecopytosksbuf(&_s_errormsg, &_d_s0, &_d_s1, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparsecopytosksbuf");
            ap.assert(s0.ptr==_d_s0, "ALGLIB: internal error (reference changed for non-out X-object)");
            ap.assert(s1.ptr==_d_s1, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void sparsecopytosksbuf(sparsematrix s0, sparsematrix s1)
    {
        _core_sparsecopytosksbuf( s0,  s1, 0x0);
    }
    
    public static void sparsecopytosksbuf(sparsematrix s0, sparsematrix s1, alglib.xparams _xparams)
    {
        _core_sparsecopytosksbuf( s0,  s1, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe int _core_sparsegetmatrixtype(sparsematrix s, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        int result;
        x_int _d_result = new x_int();
        void *_d_s = s.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_sparsegetmatrixtype(&_s_errormsg, &_d_result, &_d_s, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparsegetmatrixtype");
            result = _d_result.intval;
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static int sparsegetmatrixtype(sparsematrix s)
    {
        return _core_sparsegetmatrixtype( s, 0x0);
    }
    
    public static int sparsegetmatrixtype(sparsematrix s, alglib.xparams _xparams)
    {
        return _core_sparsegetmatrixtype( s, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe bool _core_sparseishash(sparsematrix s, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        bool result;
        byte _d_result = (byte)0;
        void *_d_s = s.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_sparseishash(&_s_errormsg, &_d_result, &_d_s, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparseishash");
            result = _d_result!=0;
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static bool sparseishash(sparsematrix s)
    {
        return _core_sparseishash( s, 0x0);
    }
    
    public static bool sparseishash(sparsematrix s, alglib.xparams _xparams)
    {
        return _core_sparseishash( s, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe bool _core_sparseiscrs(sparsematrix s, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        bool result;
        byte _d_result = (byte)0;
        void *_d_s = s.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_sparseiscrs(&_s_errormsg, &_d_result, &_d_s, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparseiscrs");
            result = _d_result!=0;
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static bool sparseiscrs(sparsematrix s)
    {
        return _core_sparseiscrs( s, 0x0);
    }
    
    public static bool sparseiscrs(sparsematrix s, alglib.xparams _xparams)
    {
        return _core_sparseiscrs( s, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe bool _core_sparseissks(sparsematrix s, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        bool result;
        byte _d_result = (byte)0;
        void *_d_s = s.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_sparseissks(&_s_errormsg, &_d_result, &_d_s, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparseissks");
            result = _d_result!=0;
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static bool sparseissks(sparsematrix s)
    {
        return _core_sparseissks( s, 0x0);
    }
    
    public static bool sparseissks(sparsematrix s, alglib.xparams _xparams)
    {
        return _core_sparseissks( s, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_sparsefree(out sparsematrix s, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = null;
        s = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_sparsefree(&_s_errormsg, &_d_s, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparsefree");
            s = new sparsematrix(_d_s);
        }
        finally
        {
            if( _d_s!=null && s==null)
                _i_x_obj_free_sparsematrix(_d_s); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void sparsefree(out sparsematrix s)
    {
        _core_sparsefree(out  s, 0x0);
    }
    
    public static void sparsefree(out sparsematrix s, alglib.xparams _xparams)
    {
        _core_sparsefree(out  s, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe int _core_sparsegetnrows(sparsematrix s, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        int result;
        x_int _d_result = new x_int();
        void *_d_s = s.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_sparsegetnrows(&_s_errormsg, &_d_result, &_d_s, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparsegetnrows");
            result = _d_result.intval;
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static int sparsegetnrows(sparsematrix s)
    {
        return _core_sparsegetnrows( s, 0x0);
    }
    
    public static int sparsegetnrows(sparsematrix s, alglib.xparams _xparams)
    {
        return _core_sparsegetnrows( s, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe int _core_sparsegetncols(sparsematrix s, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        int result;
        x_int _d_result = new x_int();
        void *_d_s = s.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_sparsegetncols(&_s_errormsg, &_d_result, &_d_s, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparsegetncols");
            result = _d_result.intval;
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static int sparsegetncols(sparsematrix s)
    {
        return _core_sparsegetncols( s, 0x0);
    }
    
    public static int sparsegetncols(sparsematrix s, alglib.xparams _xparams)
    {
        return _core_sparsegetncols( s, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe int _core_sparsegetuppercount(sparsematrix s, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        int result;
        x_int _d_result = new x_int();
        void *_d_s = s.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_sparsegetuppercount(&_s_errormsg, &_d_result, &_d_s, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparsegetuppercount");
            result = _d_result.intval;
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static int sparsegetuppercount(sparsematrix s)
    {
        return _core_sparsegetuppercount( s, 0x0);
    }
    
    public static int sparsegetuppercount(sparsematrix s, alglib.xparams _xparams)
    {
        return _core_sparsegetuppercount( s, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe int _core_sparsegetlowercount(sparsematrix s, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        int result;
        x_int _d_result = new x_int();
        void *_d_s = s.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_sparsegetlowercount(&_s_errormsg, &_d_result, &_d_s, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparsegetlowercount");
            result = _d_result.intval;
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static int sparsegetlowercount(sparsematrix s)
    {
        return _core_sparsegetlowercount( s, 0x0);
    }
    
    public static int sparsegetlowercount(sparsematrix s, alglib.xparams _xparams)
    {
        return _core_sparsegetlowercount( s, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage hsschur
    //
    
    
    
    //
    // Subpackage evd
    //
    

    public unsafe class eigsubspacestate : alglibobject
    {
        private void *_ptr;
        public eigsubspacestate(void *x)
        {
            _ptr = x;
        }
        ~eigsubspacestate()
        {
            _deallocate();
        }
        public void* ptr { get { return _ptr; } }
        public override alglib.alglibobject make_copy()
        {
            if( _ptr==null )
                return new eigsubspacestate(null);
            return new eigsubspacestate(_i_x_obj_copy_eigsubspacestate(_ptr));
        }
        public override void _deallocate()
        {
            if( _ptr!=null )
                _i_x_obj_free_eigsubspacestate(_ptr);
            _ptr = null;
            System.GC.SuppressFinalize(this);
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_eigsubspacestate(void *x);
    private static _d_x_obj_copy_eigsubspacestate _i_x_obj_copy_eigsubspacestate = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_obj_free_eigsubspacestate(void *x);
    private static _d_x_obj_free_eigsubspacestate _i_x_obj_free_eigsubspacestate = null;

    [StructLayout(LayoutKind.Sequential, Pack=8)]
    private struct x_eigsubspacereport
    {
        public x_int iterationscount;
    }

    public class eigsubspacereport : alglibobject
    {
        public int iterationscount;
        public override alglib.alglibobject make_copy()
        {
            eigsubspacereport dst = new eigsubspacereport();
            dst.iterationscount = iterationscount;
            return dst;
        }
    }

    // This function initializes X-structure (its previous content is ignored)
    private static void x_eigsubspacereport_init(ref x_eigsubspacereport x)
    {
        x.iterationscount.longval = 0;
    }

    // This function finalizes fields of X-structure (however, memory occupied by structure itself is not freed)
    // After destruction structure becomes unusable and should be re-initialized if you want to use it
    private static void x_eigsubspacereport_clear(ref x_eigsubspacereport x)
    {
    }

    // This function initializes X-structure by appropriate C# instance
    // (previous content of X structure is ignored)
    private static void x_eigsubspacereport_init_from(ref x_eigsubspacereport x, eigsubspacereport v)
    {
        x.iterationscount.longval = v.iterationscount;
    }

    // This function initializes C# structure by appropriate X instance
    // (previous content of C# structure is ignored).
    // This function may accept null v, in this case v is automatically allocated with new().
    private static void x_eigsubspacereport_to_record(ref x_eigsubspacereport x, ref eigsubspacereport v)
    {
        if( v==null )
            v = new eigsubspacereport();
        v.iterationscount = x.iterationscount.intval; // long is silently truncated to int
    }
    
    private static unsafe void _core_eigsubspacecreate(int n, int k, out eigsubspacestate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        x_int _d_k = new x_int(k);
        void *_d_state = null;
        state = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_eigsubspacecreate(&_s_errormsg, &_d_n, &_d_k, &_d_state, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "eigsubspacecreate");
            state = new eigsubspacestate(_d_state);
        }
        finally
        {
            if( _d_state!=null && state==null)
                _i_x_obj_free_eigsubspacestate(_d_state); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void eigsubspacecreate(int n, int k, out eigsubspacestate state)
    {
        _core_eigsubspacecreate( n,  k, out  state, 0x0);
    }
    
    public static void eigsubspacecreate(int n, int k, out eigsubspacestate state, alglib.xparams _xparams)
    {
        _core_eigsubspacecreate( n,  k, out  state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_eigsubspacecreatebuf(int n, int k, eigsubspacestate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        x_int _d_k = new x_int(k);
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_eigsubspacecreatebuf(&_s_errormsg, &_d_n, &_d_k, &_d_state, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "eigsubspacecreatebuf");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void eigsubspacecreatebuf(int n, int k, eigsubspacestate state)
    {
        _core_eigsubspacecreatebuf( n,  k,  state, 0x0);
    }
    
    public static void eigsubspacecreatebuf(int n, int k, eigsubspacestate state, alglib.xparams _xparams)
    {
        _core_eigsubspacecreatebuf( n,  k,  state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_eigsubspacesetcond(eigsubspacestate state, double eps, int maxits, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_eps = eps;
        x_int _d_maxits = new x_int(maxits);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_eigsubspacesetcond(&_s_errormsg, &_d_state, &_d_eps, &_d_maxits, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "eigsubspacesetcond");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void eigsubspacesetcond(eigsubspacestate state, double eps, int maxits)
    {
        _core_eigsubspacesetcond( state,  eps,  maxits, 0x0);
    }
    
    public static void eigsubspacesetcond(eigsubspacestate state, double eps, int maxits, alglib.xparams _xparams)
    {
        _core_eigsubspacesetcond( state,  eps,  maxits, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_eigsubspacesetwarmstart(eigsubspacestate state, bool usewarmstart, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        byte _d_usewarmstart = (byte)(usewarmstart ? 1 : 0);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_eigsubspacesetwarmstart(&_s_errormsg, &_d_state, &_d_usewarmstart, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "eigsubspacesetwarmstart");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void eigsubspacesetwarmstart(eigsubspacestate state, bool usewarmstart)
    {
        _core_eigsubspacesetwarmstart( state,  usewarmstart, 0x0);
    }
    
    public static void eigsubspacesetwarmstart(eigsubspacestate state, bool usewarmstart, alglib.xparams _xparams)
    {
        _core_eigsubspacesetwarmstart( state,  usewarmstart, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_eigsubspaceoocstart(eigsubspacestate state, int mtype, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_int _d_mtype = new x_int(mtype);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_eigsubspaceoocstart(&_s_errormsg, &_d_state, &_d_mtype, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "eigsubspaceoocstart");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void eigsubspaceoocstart(eigsubspacestate state, int mtype)
    {
        _core_eigsubspaceoocstart( state,  mtype, 0x0);
    }
    
    public static void eigsubspaceoocstart(eigsubspacestate state, int mtype, alglib.xparams _xparams)
    {
        _core_eigsubspaceoocstart( state,  mtype, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe bool _core_eigsubspaceooccontinue(eigsubspacestate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        bool result;
        byte _d_result = (byte)0;
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_eigsubspaceooccontinue(&_s_errormsg, &_d_result, &_d_state, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "eigsubspaceooccontinue");
            result = _d_result!=0;
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static bool eigsubspaceooccontinue(eigsubspacestate state)
    {
        return _core_eigsubspaceooccontinue( state, 0x0);
    }
    
    public static bool eigsubspaceooccontinue(eigsubspacestate state, alglib.xparams _xparams)
    {
        return _core_eigsubspaceooccontinue( state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_eigsubspaceoocgetrequestinfo(eigsubspacestate state, out int requesttype, out int requestsize, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_int _d_requesttype = new x_int();
        x_int _d_requestsize = new x_int();
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_eigsubspaceoocgetrequestinfo(&_s_errormsg, &_d_state, &_d_requesttype, &_d_requestsize, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "eigsubspaceoocgetrequestinfo");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            requesttype = _d_requesttype.intval;
            requestsize = _d_requestsize.intval;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void eigsubspaceoocgetrequestinfo(eigsubspacestate state, out int requesttype, out int requestsize)
    {
        _core_eigsubspaceoocgetrequestinfo( state, out  requesttype, out  requestsize, 0x0);
    }
    
    public static void eigsubspaceoocgetrequestinfo(eigsubspacestate state, out int requesttype, out int requestsize, alglib.xparams _xparams)
    {
        _core_eigsubspaceoocgetrequestinfo( state, out  requesttype, out  requestsize, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_eigsubspaceoocgetrequestdata(eigsubspacestate state, ref double[,] x, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_matrix _d_x = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_matrix_attach_to_array(ref _d_x, _fp_x, ap.rows(x), ap.cols(x));
                _error_code = _i_xv2_eigsubspaceoocgetrequestdata(&_s_errormsg, &_d_state, &_d_x, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "eigsubspaceoocgetrequestdata");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_x);
        }
        // This function returns no value.
    }
    
    public static void eigsubspaceoocgetrequestdata(eigsubspacestate state, ref double[,] x)
    {
        _core_eigsubspaceoocgetrequestdata( state, ref  x, 0x0);
    }
    
    public static void eigsubspaceoocgetrequestdata(eigsubspacestate state, ref double[,] x, alglib.xparams _xparams)
    {
        _core_eigsubspaceoocgetrequestdata( state, ref  x, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_eigsubspaceoocsendresult(eigsubspacestate state, double[,] ax, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_matrix _d_ax = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_ax = ax){
                x_matrix_attach_to_array(ref _d_ax, _fp_ax, ap.rows(ax), ap.cols(ax));
                _error_code = _i_xv2_eigsubspaceoocsendresult(&_s_errormsg, &_d_state, &_d_ax, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "eigsubspaceoocsendresult");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_ax);
        }
        // This function returns no value.
    }
    
    public static void eigsubspaceoocsendresult(eigsubspacestate state, double[,] ax)
    {
        _core_eigsubspaceoocsendresult( state,  ax, 0x0);
    }
    
    public static void eigsubspaceoocsendresult(eigsubspacestate state, double[,] ax, alglib.xparams _xparams)
    {
        _core_eigsubspaceoocsendresult( state,  ax, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_eigsubspaceoocstop(eigsubspacestate state, out double[] w, out double[,] z, out eigsubspacereport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_w = new x_vector();
        x_matrix _d_z = new x_matrix();
        x_eigsubspacereport _d_rep = new x_eigsubspacereport();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_w, DT_REAL);
            w = null;
            x_matrix_create_empty(ref _d_z, DT_REAL);
            z = null;
            x_eigsubspacereport_init(ref _d_rep);
            _error_code = _i_xv2_eigsubspaceoocstop(&_s_errormsg, &_d_state, &_d_w, &_d_z, &_d_rep, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "eigsubspaceoocstop");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_w.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_w, ref w);
            if( w == null )
                w = new double[0];
            if( _d_z.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_z, ref z);
            if( z == null )
                z = new double[0,0];
            rep = null;
            x_eigsubspacereport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_w);
            x_matrix_clear(ref _d_z);
            x_eigsubspacereport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void eigsubspaceoocstop(eigsubspacestate state, out double[] w, out double[,] z, out eigsubspacereport rep)
    {
        _core_eigsubspaceoocstop( state, out  w, out  z, out  rep, 0x0);
    }
    
    public static void eigsubspaceoocstop(eigsubspacestate state, out double[] w, out double[,] z, out eigsubspacereport rep, alglib.xparams _xparams)
    {
        _core_eigsubspaceoocstop( state, out  w, out  z, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_eigsubspacesolvedenses(eigsubspacestate state, double[,] a, bool isupper, out double[] w, out double[,] z, out eigsubspacereport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_matrix _d_a = new x_matrix();
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_vector _d_w = new x_vector();
        x_matrix _d_z = new x_matrix();
        x_eigsubspacereport _d_rep = new x_eigsubspacereport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_create_empty(ref _d_w, DT_REAL);
                w = null;
                x_matrix_create_empty(ref _d_z, DT_REAL);
                z = null;
                x_eigsubspacereport_init(ref _d_rep);
                _error_code = _i_xv2_eigsubspacesolvedenses(&_s_errormsg, &_d_state, &_d_a, &_d_isupper, &_d_w, &_d_z, &_d_rep, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "eigsubspacesolvedenses");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_w.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_w, ref w);
            if( w == null )
                w = new double[0];
            if( _d_z.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_z, ref z);
            if( z == null )
                z = new double[0,0];
            rep = null;
            x_eigsubspacereport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_w);
            x_matrix_clear(ref _d_z);
            x_eigsubspacereport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void eigsubspacesolvedenses(eigsubspacestate state, double[,] a, bool isupper, out double[] w, out double[,] z, out eigsubspacereport rep)
    {
        _core_eigsubspacesolvedenses( state,  a,  isupper, out  w, out  z, out  rep, 0x0);
    }
    
    public static void eigsubspacesolvedenses(eigsubspacestate state, double[,] a, bool isupper, out double[] w, out double[,] z, out eigsubspacereport rep, alglib.xparams _xparams)
    {
        _core_eigsubspacesolvedenses( state,  a,  isupper, out  w, out  z, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_eigsubspacesolvesparses(eigsubspacestate state, sparsematrix a, bool isupper, out double[] w, out double[,] z, out eigsubspacereport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        void *_d_a = a.ptr;
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_vector _d_w = new x_vector();
        x_matrix _d_z = new x_matrix();
        x_eigsubspacereport _d_rep = new x_eigsubspacereport();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_w, DT_REAL);
            w = null;
            x_matrix_create_empty(ref _d_z, DT_REAL);
            z = null;
            x_eigsubspacereport_init(ref _d_rep);
            _error_code = _i_xv2_eigsubspacesolvesparses(&_s_errormsg, &_d_state, &_d_a, &_d_isupper, &_d_w, &_d_z, &_d_rep, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "eigsubspacesolvesparses");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            ap.assert(a.ptr==_d_a, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_w.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_w, ref w);
            if( w == null )
                w = new double[0];
            if( _d_z.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_z, ref z);
            if( z == null )
                z = new double[0,0];
            rep = null;
            x_eigsubspacereport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_w);
            x_matrix_clear(ref _d_z);
            x_eigsubspacereport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void eigsubspacesolvesparses(eigsubspacestate state, sparsematrix a, bool isupper, out double[] w, out double[,] z, out eigsubspacereport rep)
    {
        _core_eigsubspacesolvesparses( state,  a,  isupper, out  w, out  z, out  rep, 0x0);
    }
    
    public static void eigsubspacesolvesparses(eigsubspacestate state, sparsematrix a, bool isupper, out double[] w, out double[,] z, out eigsubspacereport rep, alglib.xparams _xparams)
    {
        _core_eigsubspacesolvesparses( state,  a,  isupper, out  w, out  z, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe bool _core_smatrixevd(double[,] a, int n, int zneeded, bool isupper, out double[] d, out double[,] z, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        bool result;
        byte _d_result = (byte)0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        x_int _d_zneeded = new x_int(zneeded);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_vector _d_d = new x_vector();
        x_matrix _d_z = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_create_empty(ref _d_d, DT_REAL);
                d = null;
                x_matrix_create_empty(ref _d_z, DT_REAL);
                z = null;
                _error_code = _i_xv2_smatrixevd(&_s_errormsg, &_d_result, &_d_a, &_d_n, &_d_zneeded, &_d_isupper, &_d_d, &_d_z, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "smatrixevd");
            result = _d_result!=0;
            if( _d_d.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_d, ref d);
            if( d == null )
                d = new double[0];
            if( _d_z.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_z, ref z);
            if( z == null )
                z = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_d);
            x_matrix_clear(ref _d_z);
        }
        return result;
    }
    
    public static bool smatrixevd(double[,] a, int n, int zneeded, bool isupper, out double[] d, out double[,] z)
    {
        return _core_smatrixevd( a,  n,  zneeded,  isupper, out  d, out  z, 0x0);
    }
    
    public static bool smatrixevd(double[,] a, int n, int zneeded, bool isupper, out double[] d, out double[,] z, alglib.xparams _xparams)
    {
        return _core_smatrixevd( a,  n,  zneeded,  isupper, out  d, out  z, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe bool _core_smatrixevdr(double[,] a, int n, int zneeded, bool isupper, double b1, double b2, out int m, out double[] w, out double[,] z, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        bool result;
        byte _d_result = (byte)0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        x_int _d_zneeded = new x_int(zneeded);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        double _d_b1 = b1;
        double _d_b2 = b2;
        x_int _d_m = new x_int();
        x_vector _d_w = new x_vector();
        x_matrix _d_z = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_create_empty(ref _d_w, DT_REAL);
                w = null;
                x_matrix_create_empty(ref _d_z, DT_REAL);
                z = null;
                _error_code = _i_xv2_smatrixevdr(&_s_errormsg, &_d_result, &_d_a, &_d_n, &_d_zneeded, &_d_isupper, &_d_b1, &_d_b2, &_d_m, &_d_w, &_d_z, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "smatrixevdr");
            result = _d_result!=0;
            m = _d_m.intval;
            if( _d_w.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_w, ref w);
            if( w == null )
                w = new double[0];
            if( _d_z.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_z, ref z);
            if( z == null )
                z = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_w);
            x_matrix_clear(ref _d_z);
        }
        return result;
    }
    
    public static bool smatrixevdr(double[,] a, int n, int zneeded, bool isupper, double b1, double b2, out int m, out double[] w, out double[,] z)
    {
        return _core_smatrixevdr( a,  n,  zneeded,  isupper,  b1,  b2, out  m, out  w, out  z, 0x0);
    }
    
    public static bool smatrixevdr(double[,] a, int n, int zneeded, bool isupper, double b1, double b2, out int m, out double[] w, out double[,] z, alglib.xparams _xparams)
    {
        return _core_smatrixevdr( a,  n,  zneeded,  isupper,  b1,  b2, out  m, out  w, out  z, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe bool _core_smatrixevdi(double[,] a, int n, int zneeded, bool isupper, int i1, int i2, out double[] w, out double[,] z, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        bool result;
        byte _d_result = (byte)0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        x_int _d_zneeded = new x_int(zneeded);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_int _d_i1 = new x_int(i1);
        x_int _d_i2 = new x_int(i2);
        x_vector _d_w = new x_vector();
        x_matrix _d_z = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_create_empty(ref _d_w, DT_REAL);
                w = null;
                x_matrix_create_empty(ref _d_z, DT_REAL);
                z = null;
                _error_code = _i_xv2_smatrixevdi(&_s_errormsg, &_d_result, &_d_a, &_d_n, &_d_zneeded, &_d_isupper, &_d_i1, &_d_i2, &_d_w, &_d_z, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "smatrixevdi");
            result = _d_result!=0;
            if( _d_w.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_w, ref w);
            if( w == null )
                w = new double[0];
            if( _d_z.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_z, ref z);
            if( z == null )
                z = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_w);
            x_matrix_clear(ref _d_z);
        }
        return result;
    }
    
    public static bool smatrixevdi(double[,] a, int n, int zneeded, bool isupper, int i1, int i2, out double[] w, out double[,] z)
    {
        return _core_smatrixevdi( a,  n,  zneeded,  isupper,  i1,  i2, out  w, out  z, 0x0);
    }
    
    public static bool smatrixevdi(double[,] a, int n, int zneeded, bool isupper, int i1, int i2, out double[] w, out double[,] z, alglib.xparams _xparams)
    {
        return _core_smatrixevdi( a,  n,  zneeded,  isupper,  i1,  i2, out  w, out  z, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe bool _core_hmatrixevd(complex[,] a, int n, int zneeded, bool isupper, out double[] d, out complex[,] z, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        bool result;
        byte _d_result = (byte)0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        x_int _d_zneeded = new x_int(zneeded);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_vector _d_d = new x_vector();
        x_matrix _d_z = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_create_empty(ref _d_d, DT_REAL);
                d = null;
                x_matrix_create_empty(ref _d_z, DT_COMPLEX);
                z = null;
                _error_code = _i_xv2_hmatrixevd(&_s_errormsg, &_d_result, &_d_a, &_d_n, &_d_zneeded, &_d_isupper, &_d_d, &_d_z, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "hmatrixevd");
            result = _d_result!=0;
            if( _d_d.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_d, ref d);
            if( d == null )
                d = new double[0];
            if( _d_z.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_z, ref z);
            if( z == null )
                z = new alglib.complex[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_d);
            x_matrix_clear(ref _d_z);
        }
        return result;
    }
    
    public static bool hmatrixevd(complex[,] a, int n, int zneeded, bool isupper, out double[] d, out complex[,] z)
    {
        return _core_hmatrixevd( a,  n,  zneeded,  isupper, out  d, out  z, 0x0);
    }
    
    public static bool hmatrixevd(complex[,] a, int n, int zneeded, bool isupper, out double[] d, out complex[,] z, alglib.xparams _xparams)
    {
        return _core_hmatrixevd( a,  n,  zneeded,  isupper, out  d, out  z, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe bool _core_hmatrixevdr(complex[,] a, int n, int zneeded, bool isupper, double b1, double b2, out int m, out double[] w, out complex[,] z, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        bool result;
        byte _d_result = (byte)0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        x_int _d_zneeded = new x_int(zneeded);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        double _d_b1 = b1;
        double _d_b2 = b2;
        x_int _d_m = new x_int();
        x_vector _d_w = new x_vector();
        x_matrix _d_z = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_create_empty(ref _d_w, DT_REAL);
                w = null;
                x_matrix_create_empty(ref _d_z, DT_COMPLEX);
                z = null;
                _error_code = _i_xv2_hmatrixevdr(&_s_errormsg, &_d_result, &_d_a, &_d_n, &_d_zneeded, &_d_isupper, &_d_b1, &_d_b2, &_d_m, &_d_w, &_d_z, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "hmatrixevdr");
            result = _d_result!=0;
            m = _d_m.intval;
            if( _d_w.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_w, ref w);
            if( w == null )
                w = new double[0];
            if( _d_z.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_z, ref z);
            if( z == null )
                z = new alglib.complex[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_w);
            x_matrix_clear(ref _d_z);
        }
        return result;
    }
    
    public static bool hmatrixevdr(complex[,] a, int n, int zneeded, bool isupper, double b1, double b2, out int m, out double[] w, out complex[,] z)
    {
        return _core_hmatrixevdr( a,  n,  zneeded,  isupper,  b1,  b2, out  m, out  w, out  z, 0x0);
    }
    
    public static bool hmatrixevdr(complex[,] a, int n, int zneeded, bool isupper, double b1, double b2, out int m, out double[] w, out complex[,] z, alglib.xparams _xparams)
    {
        return _core_hmatrixevdr( a,  n,  zneeded,  isupper,  b1,  b2, out  m, out  w, out  z, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe bool _core_hmatrixevdi(complex[,] a, int n, int zneeded, bool isupper, int i1, int i2, out double[] w, out complex[,] z, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        bool result;
        byte _d_result = (byte)0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        x_int _d_zneeded = new x_int(zneeded);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_int _d_i1 = new x_int(i1);
        x_int _d_i2 = new x_int(i2);
        x_vector _d_w = new x_vector();
        x_matrix _d_z = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_create_empty(ref _d_w, DT_REAL);
                w = null;
                x_matrix_create_empty(ref _d_z, DT_COMPLEX);
                z = null;
                _error_code = _i_xv2_hmatrixevdi(&_s_errormsg, &_d_result, &_d_a, &_d_n, &_d_zneeded, &_d_isupper, &_d_i1, &_d_i2, &_d_w, &_d_z, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "hmatrixevdi");
            result = _d_result!=0;
            if( _d_w.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_w, ref w);
            if( w == null )
                w = new double[0];
            if( _d_z.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_z, ref z);
            if( z == null )
                z = new alglib.complex[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_w);
            x_matrix_clear(ref _d_z);
        }
        return result;
    }
    
    public static bool hmatrixevdi(complex[,] a, int n, int zneeded, bool isupper, int i1, int i2, out double[] w, out complex[,] z)
    {
        return _core_hmatrixevdi( a,  n,  zneeded,  isupper,  i1,  i2, out  w, out  z, 0x0);
    }
    
    public static bool hmatrixevdi(complex[,] a, int n, int zneeded, bool isupper, int i1, int i2, out double[] w, out complex[,] z, alglib.xparams _xparams)
    {
        return _core_hmatrixevdi( a,  n,  zneeded,  isupper,  i1,  i2, out  w, out  z, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe bool _core_smatrixtdevd(ref double[] d, double[] e, int n, int zneeded, ref double[,] z, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        bool result;
        byte _d_result = (byte)0;
        x_vector _d_d = new x_vector();
        x_vector _d_e = new x_vector();
        x_int _d_n = new x_int(n);
        x_int _d_zneeded = new x_int(zneeded);
        x_matrix _d_z = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_d = d, _fp_e = e, _fp_z = z){
                x_vector_attach_to_array(ref _d_d, _fp_d, ap.len(d));
                x_vector_attach_to_array(ref _d_e, _fp_e, ap.len(e));
                x_matrix_attach_to_array(ref _d_z, _fp_z, ap.rows(z), ap.cols(z));
                _error_code = _i_xv2_smatrixtdevd(&_s_errormsg, &_d_result, &_d_d, &_d_e, &_d_n, &_d_zneeded, &_d_z, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "smatrixtdevd");
            result = _d_result!=0;
            if( _d_d.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_d, ref d);
            if( d == null )
                d = new double[0];
            if( _d_z.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_z, ref z);
            if( z == null )
                z = new double[0,0];
        }
        finally
        {
            x_vector_clear(ref _d_d);
            x_vector_clear(ref _d_e);
            x_matrix_clear(ref _d_z);
        }
        return result;
    }
    
    public static bool smatrixtdevd(ref double[] d, double[] e, int n, int zneeded, ref double[,] z)
    {
        return _core_smatrixtdevd(ref  d,  e,  n,  zneeded, ref  z, 0x0);
    }
    
    public static bool smatrixtdevd(ref double[] d, double[] e, int n, int zneeded, ref double[,] z, alglib.xparams _xparams)
    {
        return _core_smatrixtdevd(ref  d,  e,  n,  zneeded, ref  z, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe bool _core_smatrixtdevdr(ref double[] d, double[] e, int n, int zneeded, double a, double b, out int m, ref double[,] z, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        bool result;
        byte _d_result = (byte)0;
        x_vector _d_d = new x_vector();
        x_vector _d_e = new x_vector();
        x_int _d_n = new x_int(n);
        x_int _d_zneeded = new x_int(zneeded);
        double _d_a = a;
        double _d_b = b;
        x_int _d_m = new x_int();
        x_matrix _d_z = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_d = d, _fp_e = e, _fp_z = z){
                x_vector_attach_to_array(ref _d_d, _fp_d, ap.len(d));
                x_vector_attach_to_array(ref _d_e, _fp_e, ap.len(e));
                x_matrix_attach_to_array(ref _d_z, _fp_z, ap.rows(z), ap.cols(z));
                _error_code = _i_xv2_smatrixtdevdr(&_s_errormsg, &_d_result, &_d_d, &_d_e, &_d_n, &_d_zneeded, &_d_a, &_d_b, &_d_m, &_d_z, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "smatrixtdevdr");
            result = _d_result!=0;
            if( _d_d.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_d, ref d);
            if( d == null )
                d = new double[0];
            m = _d_m.intval;
            if( _d_z.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_z, ref z);
            if( z == null )
                z = new double[0,0];
        }
        finally
        {
            x_vector_clear(ref _d_d);
            x_vector_clear(ref _d_e);
            x_matrix_clear(ref _d_z);
        }
        return result;
    }
    
    public static bool smatrixtdevdr(ref double[] d, double[] e, int n, int zneeded, double a, double b, out int m, ref double[,] z)
    {
        return _core_smatrixtdevdr(ref  d,  e,  n,  zneeded,  a,  b, out  m, ref  z, 0x0);
    }
    
    public static bool smatrixtdevdr(ref double[] d, double[] e, int n, int zneeded, double a, double b, out int m, ref double[,] z, alglib.xparams _xparams)
    {
        return _core_smatrixtdevdr(ref  d,  e,  n,  zneeded,  a,  b, out  m, ref  z, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe bool _core_smatrixtdevdi(ref double[] d, double[] e, int n, int zneeded, int i1, int i2, ref double[,] z, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        bool result;
        byte _d_result = (byte)0;
        x_vector _d_d = new x_vector();
        x_vector _d_e = new x_vector();
        x_int _d_n = new x_int(n);
        x_int _d_zneeded = new x_int(zneeded);
        x_int _d_i1 = new x_int(i1);
        x_int _d_i2 = new x_int(i2);
        x_matrix _d_z = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_d = d, _fp_e = e, _fp_z = z){
                x_vector_attach_to_array(ref _d_d, _fp_d, ap.len(d));
                x_vector_attach_to_array(ref _d_e, _fp_e, ap.len(e));
                x_matrix_attach_to_array(ref _d_z, _fp_z, ap.rows(z), ap.cols(z));
                _error_code = _i_xv2_smatrixtdevdi(&_s_errormsg, &_d_result, &_d_d, &_d_e, &_d_n, &_d_zneeded, &_d_i1, &_d_i2, &_d_z, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "smatrixtdevdi");
            result = _d_result!=0;
            if( _d_d.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_d, ref d);
            if( d == null )
                d = new double[0];
            if( _d_z.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_z, ref z);
            if( z == null )
                z = new double[0,0];
        }
        finally
        {
            x_vector_clear(ref _d_d);
            x_vector_clear(ref _d_e);
            x_matrix_clear(ref _d_z);
        }
        return result;
    }
    
    public static bool smatrixtdevdi(ref double[] d, double[] e, int n, int zneeded, int i1, int i2, ref double[,] z)
    {
        return _core_smatrixtdevdi(ref  d,  e,  n,  zneeded,  i1,  i2, ref  z, 0x0);
    }
    
    public static bool smatrixtdevdi(ref double[] d, double[] e, int n, int zneeded, int i1, int i2, ref double[,] z, alglib.xparams _xparams)
    {
        return _core_smatrixtdevdi(ref  d,  e,  n,  zneeded,  i1,  i2, ref  z, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe bool _core_rmatrixevd(double[,] a, int n, int vneeded, out double[] wr, out double[] wi, out double[,] vl, out double[,] vr, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        bool result;
        byte _d_result = (byte)0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        x_int _d_vneeded = new x_int(vneeded);
        x_vector _d_wr = new x_vector();
        x_vector _d_wi = new x_vector();
        x_matrix _d_vl = new x_matrix();
        x_matrix _d_vr = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_create_empty(ref _d_wr, DT_REAL);
                wr = null;
                x_vector_create_empty(ref _d_wi, DT_REAL);
                wi = null;
                x_matrix_create_empty(ref _d_vl, DT_REAL);
                vl = null;
                x_matrix_create_empty(ref _d_vr, DT_REAL);
                vr = null;
                _error_code = _i_xv2_rmatrixevd(&_s_errormsg, &_d_result, &_d_a, &_d_n, &_d_vneeded, &_d_wr, &_d_wi, &_d_vl, &_d_vr, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rmatrixevd");
            result = _d_result!=0;
            if( _d_wr.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_wr, ref wr);
            if( wr == null )
                wr = new double[0];
            if( _d_wi.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_wi, ref wi);
            if( wi == null )
                wi = new double[0];
            if( _d_vl.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_vl, ref vl);
            if( vl == null )
                vl = new double[0,0];
            if( _d_vr.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_vr, ref vr);
            if( vr == null )
                vr = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_wr);
            x_vector_clear(ref _d_wi);
            x_matrix_clear(ref _d_vl);
            x_matrix_clear(ref _d_vr);
        }
        return result;
    }
    
    public static bool rmatrixevd(double[,] a, int n, int vneeded, out double[] wr, out double[] wi, out double[,] vl, out double[,] vr)
    {
        return _core_rmatrixevd( a,  n,  vneeded, out  wr, out  wi, out  vl, out  vr, 0x0);
    }
    
    public static bool rmatrixevd(double[,] a, int n, int vneeded, out double[] wr, out double[] wi, out double[,] vl, out double[,] vr, alglib.xparams _xparams)
    {
        return _core_rmatrixevd( a,  n,  vneeded, out  wr, out  wi, out  vl, out  vr, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage dlu
    //
    
    
    
    //
    // Subpackage sptrf
    //
    
    
    
    //
    // Subpackage amdordering
    //
    
    
    
    //
    // Subpackage spchol
    //
    
    
    
    //
    // Subpackage trfac
    //
    

    public unsafe class sparsedecompositionanalysis : alglibobject
    {
        private void *_ptr;
        public sparsedecompositionanalysis(void *x)
        {
            _ptr = x;
        }
        ~sparsedecompositionanalysis()
        {
            _deallocate();
        }
        public void* ptr { get { return _ptr; } }
        public override alglib.alglibobject make_copy()
        {
            if( _ptr==null )
                return new sparsedecompositionanalysis(null);
            return new sparsedecompositionanalysis(_i_x_obj_copy_sparsedecompositionanalysis(_ptr));
        }
        public override void _deallocate()
        {
            if( _ptr!=null )
                _i_x_obj_free_sparsedecompositionanalysis(_ptr);
            _ptr = null;
            System.GC.SuppressFinalize(this);
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_sparsedecompositionanalysis(void *x);
    private static _d_x_obj_copy_sparsedecompositionanalysis _i_x_obj_copy_sparsedecompositionanalysis = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_obj_free_sparsedecompositionanalysis(void *x);
    private static _d_x_obj_free_sparsedecompositionanalysis _i_x_obj_free_sparsedecompositionanalysis = null;
    
    private static unsafe void _core_rmatrixlu(ref double[,] a, int m, int n, out int[] pivots, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_vector _d_pivots = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_create_empty(ref _d_pivots, DT_INT);
                pivots = null;
                _error_code = _i_xv2_rmatrixlu(&_s_errormsg, &_d_a, &_d_m, &_d_n, &_d_pivots, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rmatrixlu");
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new double[0,0];
            x_vector_to_array(ref _d_pivots, ref pivots);
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_pivots);
        }
        // This function returns no value.
    }
    
    public static void rmatrixlu(ref double[,] a, int m, int n, out int[] pivots)
    {
        _core_rmatrixlu(ref  a,  m,  n, out  pivots, 0x0);
    }
    
    public static void rmatrixlu(ref double[,] a, int m, int n, out int[] pivots, alglib.xparams _xparams)
    {
        _core_rmatrixlu(ref  a,  m,  n, out  pivots, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_cmatrixlu(ref complex[,] a, int m, int n, out int[] pivots, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_vector _d_pivots = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_create_empty(ref _d_pivots, DT_INT);
                pivots = null;
                _error_code = _i_xv2_cmatrixlu(&_s_errormsg, &_d_a, &_d_m, &_d_n, &_d_pivots, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "cmatrixlu");
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new alglib.complex[0,0];
            x_vector_to_array(ref _d_pivots, ref pivots);
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_pivots);
        }
        // This function returns no value.
    }
    
    public static void cmatrixlu(ref complex[,] a, int m, int n, out int[] pivots)
    {
        _core_cmatrixlu(ref  a,  m,  n, out  pivots, 0x0);
    }
    
    public static void cmatrixlu(ref complex[,] a, int m, int n, out int[] pivots, alglib.xparams _xparams)
    {
        _core_cmatrixlu(ref  a,  m,  n, out  pivots, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe bool _core_hpdmatrixcholesky(ref complex[,] a, int n, bool isupper, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        bool result;
        byte _d_result = (byte)0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                _error_code = _i_xv2_hpdmatrixcholesky(&_s_errormsg, &_d_result, &_d_a, &_d_n, &_d_isupper, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "hpdmatrixcholesky");
            result = _d_result!=0;
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new alglib.complex[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        return result;
    }
    
    public static bool hpdmatrixcholesky(ref complex[,] a, int n, bool isupper)
    {
        return _core_hpdmatrixcholesky(ref  a,  n,  isupper, 0x0);
    }
    
    public static bool hpdmatrixcholesky(ref complex[,] a, int n, bool isupper, alglib.xparams _xparams)
    {
        return _core_hpdmatrixcholesky(ref  a,  n,  isupper, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe bool _core_spdmatrixcholesky(ref double[,] a, int n, bool isupper, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        bool result;
        byte _d_result = (byte)0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                _error_code = _i_xv2_spdmatrixcholesky(&_s_errormsg, &_d_result, &_d_a, &_d_n, &_d_isupper, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spdmatrixcholesky");
            result = _d_result!=0;
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        return result;
    }
    
    public static bool spdmatrixcholesky(ref double[,] a, int n, bool isupper)
    {
        return _core_spdmatrixcholesky(ref  a,  n,  isupper, 0x0);
    }
    
    public static bool spdmatrixcholesky(ref double[,] a, int n, bool isupper, alglib.xparams _xparams)
    {
        return _core_spdmatrixcholesky(ref  a,  n,  isupper, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_spdmatrixcholeskyupdateadd1(ref double[,] a, int n, bool isupper, double[] u, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_vector _d_u = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a, _fp_u = u){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_attach_to_array(ref _d_u, _fp_u, ap.len(u));
                _error_code = _i_xv2_spdmatrixcholeskyupdateadd1(&_s_errormsg, &_d_a, &_d_n, &_d_isupper, &_d_u, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spdmatrixcholeskyupdateadd1");
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_u);
        }
        // This function returns no value.
    }
    
    public static void spdmatrixcholeskyupdateadd1(ref double[,] a, int n, bool isupper, double[] u)
    {
        _core_spdmatrixcholeskyupdateadd1(ref  a,  n,  isupper,  u, 0x0);
    }
    
    public static void spdmatrixcholeskyupdateadd1(ref double[,] a, int n, bool isupper, double[] u, alglib.xparams _xparams)
    {
        _core_spdmatrixcholeskyupdateadd1(ref  a,  n,  isupper,  u, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_spdmatrixcholeskyupdatefix(ref double[,] a, int n, bool isupper, bool[] fix, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_vector _d_fix = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){fixed(bool* _fp_fix = fix){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_attach_to_array(ref _d_fix, _fp_fix, ap.len(fix));
                _error_code = _i_xv2_spdmatrixcholeskyupdatefix(&_s_errormsg, &_d_a, &_d_n, &_d_isupper, &_d_fix, _xparams);
            }}
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spdmatrixcholeskyupdatefix");
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_fix);
        }
        // This function returns no value.
    }
    
    public static void spdmatrixcholeskyupdatefix(ref double[,] a, int n, bool isupper, bool[] fix)
    {
        _core_spdmatrixcholeskyupdatefix(ref  a,  n,  isupper,  fix, 0x0);
    }
    
    public static void spdmatrixcholeskyupdatefix(ref double[,] a, int n, bool isupper, bool[] fix, alglib.xparams _xparams)
    {
        _core_spdmatrixcholeskyupdatefix(ref  a,  n,  isupper,  fix, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_spdmatrixcholeskyupdateadd1buf(ref double[,] a, int n, bool isupper, double[] u, ref double[] bufr, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_vector _d_u = new x_vector();
        x_vector _d_bufr = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a, _fp_u = u, _fp_bufr = bufr){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_attach_to_array(ref _d_u, _fp_u, ap.len(u));
                x_vector_attach_to_array(ref _d_bufr, _fp_bufr, ap.len(bufr));
                _error_code = _i_xv2_spdmatrixcholeskyupdateadd1buf(&_s_errormsg, &_d_a, &_d_n, &_d_isupper, &_d_u, &_d_bufr, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spdmatrixcholeskyupdateadd1buf");
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new double[0,0];
            if( _d_bufr.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_bufr, ref bufr);
            if( bufr == null )
                bufr = new double[0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_u);
            x_vector_clear(ref _d_bufr);
        }
        // This function returns no value.
    }
    
    public static void spdmatrixcholeskyupdateadd1buf(ref double[,] a, int n, bool isupper, double[] u, ref double[] bufr)
    {
        _core_spdmatrixcholeskyupdateadd1buf(ref  a,  n,  isupper,  u, ref  bufr, 0x0);
    }
    
    public static void spdmatrixcholeskyupdateadd1buf(ref double[,] a, int n, bool isupper, double[] u, ref double[] bufr, alglib.xparams _xparams)
    {
        _core_spdmatrixcholeskyupdateadd1buf(ref  a,  n,  isupper,  u, ref  bufr, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_spdmatrixcholeskyupdatefixbuf(ref double[,] a, int n, bool isupper, bool[] fix, ref double[] bufr, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_vector _d_fix = new x_vector();
        x_vector _d_bufr = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a, _fp_bufr = bufr){fixed(bool* _fp_fix = fix){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_attach_to_array(ref _d_fix, _fp_fix, ap.len(fix));
                x_vector_attach_to_array(ref _d_bufr, _fp_bufr, ap.len(bufr));
                _error_code = _i_xv2_spdmatrixcholeskyupdatefixbuf(&_s_errormsg, &_d_a, &_d_n, &_d_isupper, &_d_fix, &_d_bufr, _xparams);
            }}
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spdmatrixcholeskyupdatefixbuf");
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new double[0,0];
            if( _d_bufr.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_bufr, ref bufr);
            if( bufr == null )
                bufr = new double[0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_fix);
            x_vector_clear(ref _d_bufr);
        }
        // This function returns no value.
    }
    
    public static void spdmatrixcholeskyupdatefixbuf(ref double[,] a, int n, bool isupper, bool[] fix, ref double[] bufr)
    {
        _core_spdmatrixcholeskyupdatefixbuf(ref  a,  n,  isupper,  fix, ref  bufr, 0x0);
    }
    
    public static void spdmatrixcholeskyupdatefixbuf(ref double[,] a, int n, bool isupper, bool[] fix, ref double[] bufr, alglib.xparams _xparams)
    {
        _core_spdmatrixcholeskyupdatefixbuf(ref  a,  n,  isupper,  fix, ref  bufr, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe bool _core_sparselu(sparsematrix a, int pivottype, out int[] p, out int[] q, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        bool result;
        byte _d_result = (byte)0;
        void *_d_a = a.ptr;
        x_int _d_pivottype = new x_int(pivottype);
        x_vector _d_p = new x_vector();
        x_vector _d_q = new x_vector();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_p, DT_INT);
            p = null;
            x_vector_create_empty(ref _d_q, DT_INT);
            q = null;
            _error_code = _i_xv2_sparselu(&_s_errormsg, &_d_result, &_d_a, &_d_pivottype, &_d_p, &_d_q, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparselu");
            result = _d_result!=0;
            ap.assert(a.ptr==_d_a, "ALGLIB: internal error (reference changed for non-out X-object)");
            x_vector_to_array(ref _d_p, ref p);
            x_vector_to_array(ref _d_q, ref q);
        }
        finally
        {
            x_vector_clear(ref _d_p);
            x_vector_clear(ref _d_q);
        }
        return result;
    }
    
    public static bool sparselu(sparsematrix a, int pivottype, out int[] p, out int[] q)
    {
        return _core_sparselu( a,  pivottype, out  p, out  q, 0x0);
    }
    
    public static bool sparselu(sparsematrix a, int pivottype, out int[] p, out int[] q, alglib.xparams _xparams)
    {
        return _core_sparselu( a,  pivottype, out  p, out  q, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe bool _core_sparsecholeskyskyline(sparsematrix a, int n, bool isupper, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        bool result;
        byte _d_result = (byte)0;
        void *_d_a = a.ptr;
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_sparsecholeskyskyline(&_s_errormsg, &_d_result, &_d_a, &_d_n, &_d_isupper, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparsecholeskyskyline");
            result = _d_result!=0;
            ap.assert(a.ptr==_d_a, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static bool sparsecholeskyskyline(sparsematrix a, int n, bool isupper)
    {
        return _core_sparsecholeskyskyline( a,  n,  isupper, 0x0);
    }
    
    public static bool sparsecholeskyskyline(sparsematrix a, int n, bool isupper, alglib.xparams _xparams)
    {
        return _core_sparsecholeskyskyline( a,  n,  isupper, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe bool _core_sparsecholesky(sparsematrix a, bool isupper, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        bool result;
        byte _d_result = (byte)0;
        void *_d_a = a.ptr;
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_sparsecholesky(&_s_errormsg, &_d_result, &_d_a, &_d_isupper, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparsecholesky");
            result = _d_result!=0;
            ap.assert(a.ptr==_d_a, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static bool sparsecholesky(sparsematrix a, bool isupper)
    {
        return _core_sparsecholesky( a,  isupper, 0x0);
    }
    
    public static bool sparsecholesky(sparsematrix a, bool isupper, alglib.xparams _xparams)
    {
        return _core_sparsecholesky( a,  isupper, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe bool _core_sparsecholeskyp(sparsematrix a, bool isupper, out int[] p, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        bool result;
        byte _d_result = (byte)0;
        void *_d_a = a.ptr;
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_vector _d_p = new x_vector();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_p, DT_INT);
            p = null;
            _error_code = _i_xv2_sparsecholeskyp(&_s_errormsg, &_d_result, &_d_a, &_d_isupper, &_d_p, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparsecholeskyp");
            result = _d_result!=0;
            ap.assert(a.ptr==_d_a, "ALGLIB: internal error (reference changed for non-out X-object)");
            x_vector_to_array(ref _d_p, ref p);
        }
        finally
        {
            x_vector_clear(ref _d_p);
        }
        return result;
    }
    
    public static bool sparsecholeskyp(sparsematrix a, bool isupper, out int[] p)
    {
        return _core_sparsecholeskyp( a,  isupper, out  p, 0x0);
    }
    
    public static bool sparsecholeskyp(sparsematrix a, bool isupper, out int[] p, alglib.xparams _xparams)
    {
        return _core_sparsecholeskyp( a,  isupper, out  p, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe bool _core_sparsecholeskyanalyze(sparsematrix a, bool isupper, int facttype, int permtype, out sparsedecompositionanalysis analysis, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        bool result;
        byte _d_result = (byte)0;
        void *_d_a = a.ptr;
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_int _d_facttype = new x_int(facttype);
        x_int _d_permtype = new x_int(permtype);
        void *_d_analysis = null;
        analysis = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_sparsecholeskyanalyze(&_s_errormsg, &_d_result, &_d_a, &_d_isupper, &_d_facttype, &_d_permtype, &_d_analysis, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparsecholeskyanalyze");
            result = _d_result!=0;
            ap.assert(a.ptr==_d_a, "ALGLIB: internal error (reference changed for non-out X-object)");
            analysis = new sparsedecompositionanalysis(_d_analysis);
        }
        finally
        {
            if( _d_analysis!=null && analysis==null)
                _i_x_obj_free_sparsedecompositionanalysis(_d_analysis); // on exception clean up X objects which were not attached to C# objects
        }
        return result;
    }
    
    public static bool sparsecholeskyanalyze(sparsematrix a, bool isupper, int facttype, int permtype, out sparsedecompositionanalysis analysis)
    {
        return _core_sparsecholeskyanalyze( a,  isupper,  facttype,  permtype, out  analysis, 0x0);
    }
    
    public static bool sparsecholeskyanalyze(sparsematrix a, bool isupper, int facttype, int permtype, out sparsedecompositionanalysis analysis, alglib.xparams _xparams)
    {
        return _core_sparsecholeskyanalyze( a,  isupper,  facttype,  permtype, out  analysis, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe bool _core_sparsecholeskyfactorize(sparsedecompositionanalysis analysis, bool needupper, out sparsematrix a, out double[] d, out int[] p, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        bool result;
        byte _d_result = (byte)0;
        void *_d_analysis = analysis.ptr;
        byte _d_needupper = (byte)(needupper ? 1 : 0);
        void *_d_a = null;
        a = null;
        x_vector _d_d = new x_vector();
        x_vector _d_p = new x_vector();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_d, DT_REAL);
            d = null;
            x_vector_create_empty(ref _d_p, DT_INT);
            p = null;
            _error_code = _i_xv2_sparsecholeskyfactorize(&_s_errormsg, &_d_result, &_d_analysis, &_d_needupper, &_d_a, &_d_d, &_d_p, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparsecholeskyfactorize");
            result = _d_result!=0;
            ap.assert(analysis.ptr==_d_analysis, "ALGLIB: internal error (reference changed for non-out X-object)");
            a = new sparsematrix(_d_a);
            if( _d_d.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_d, ref d);
            if( d == null )
                d = new double[0];
            x_vector_to_array(ref _d_p, ref p);
        }
        finally
        {
            if( _d_a!=null && a==null)
                _i_x_obj_free_sparsematrix(_d_a); // on exception clean up X objects which were not attached to C# objects
            x_vector_clear(ref _d_d);
            x_vector_clear(ref _d_p);
        }
        return result;
    }
    
    public static bool sparsecholeskyfactorize(sparsedecompositionanalysis analysis, bool needupper, out sparsematrix a, out double[] d, out int[] p)
    {
        return _core_sparsecholeskyfactorize( analysis,  needupper, out  a, out  d, out  p, 0x0);
    }
    
    public static bool sparsecholeskyfactorize(sparsedecompositionanalysis analysis, bool needupper, out sparsematrix a, out double[] d, out int[] p, alglib.xparams _xparams)
    {
        return _core_sparsecholeskyfactorize( analysis,  needupper, out  a, out  d, out  p, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_sparsecholeskyreload(sparsedecompositionanalysis analysis, sparsematrix a, bool isupper, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_analysis = analysis.ptr;
        void *_d_a = a.ptr;
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_sparsecholeskyreload(&_s_errormsg, &_d_analysis, &_d_a, &_d_isupper, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparsecholeskyreload");
            ap.assert(analysis.ptr==_d_analysis, "ALGLIB: internal error (reference changed for non-out X-object)");
            ap.assert(a.ptr==_d_a, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void sparsecholeskyreload(sparsedecompositionanalysis analysis, sparsematrix a, bool isupper)
    {
        _core_sparsecholeskyreload( analysis,  a,  isupper, 0x0);
    }
    
    public static void sparsecholeskyreload(sparsedecompositionanalysis analysis, sparsematrix a, bool isupper, alglib.xparams _xparams)
    {
        _core_sparsecholeskyreload( analysis,  a,  isupper, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage polynomialsolver
    //
    

    [StructLayout(LayoutKind.Sequential, Pack=8)]
    private struct x_polynomialsolverreport
    {
        public double maxerr;
    }

    public class polynomialsolverreport : alglibobject
    {
        public double maxerr;
        public override alglib.alglibobject make_copy()
        {
            polynomialsolverreport dst = new polynomialsolverreport();
            dst.maxerr = maxerr;
            return dst;
        }
    }

    // This function initializes X-structure (its previous content is ignored)
    private static void x_polynomialsolverreport_init(ref x_polynomialsolverreport x)
    {
        x.maxerr = 0;
    }

    // This function finalizes fields of X-structure (however, memory occupied by structure itself is not freed)
    // After destruction structure becomes unusable and should be re-initialized if you want to use it
    private static void x_polynomialsolverreport_clear(ref x_polynomialsolverreport x)
    {
    }

    // This function initializes X-structure by appropriate C# instance
    // (previous content of X structure is ignored)
    private static void x_polynomialsolverreport_init_from(ref x_polynomialsolverreport x, polynomialsolverreport v)
    {
        x.maxerr = v.maxerr;
    }

    // This function initializes C# structure by appropriate X instance
    // (previous content of C# structure is ignored).
    // This function may accept null v, in this case v is automatically allocated with new().
    private static void x_polynomialsolverreport_to_record(ref x_polynomialsolverreport x, ref polynomialsolverreport v)
    {
        if( v==null )
            v = new polynomialsolverreport();
        v.maxerr = x.maxerr;
    }
    
    private static unsafe void _core_polynomialsolve(double[] a, int n, out complex[] x, out polynomialsolverreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_a = new x_vector();
        x_int _d_n = new x_int(n);
        x_vector _d_x = new x_vector();
        x_polynomialsolverreport _d_rep = new x_polynomialsolverreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_vector_attach_to_array(ref _d_a, _fp_a, ap.len(a));
                x_vector_create_empty(ref _d_x, DT_COMPLEX);
                x = null;
                x_polynomialsolverreport_init(ref _d_rep);
                _error_code = _i_xv2_polynomialsolve(&_s_errormsg, &_d_a, &_d_n, &_d_x, &_d_rep, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "polynomialsolve");
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new alglib.complex[0];
            rep = null;
            x_polynomialsolverreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_a);
            x_vector_clear(ref _d_x);
            x_polynomialsolverreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void polynomialsolve(double[] a, int n, out complex[] x, out polynomialsolverreport rep)
    {
        _core_polynomialsolve( a,  n, out  x, out  rep, 0x0);
    }
    
    public static void polynomialsolve(double[] a, int n, out complex[] x, out polynomialsolverreport rep, alglib.xparams _xparams)
    {
        _core_polynomialsolve( a,  n, out  x, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage bdsvd
    //
    
    
    private static unsafe bool _core_rmatrixbdsvd(ref double[] d, double[] e, int n, bool isupper, bool isfractionalaccuracyrequired, ref double[,] u, int nru, ref double[,] c, int ncc, ref double[,] vt, int ncvt, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        bool result;
        byte _d_result = (byte)0;
        x_vector _d_d = new x_vector();
        x_vector _d_e = new x_vector();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        byte _d_isfractionalaccuracyrequired = (byte)(isfractionalaccuracyrequired ? 1 : 0);
        x_matrix _d_u = new x_matrix();
        x_int _d_nru = new x_int(nru);
        x_matrix _d_c = new x_matrix();
        x_int _d_ncc = new x_int(ncc);
        x_matrix _d_vt = new x_matrix();
        x_int _d_ncvt = new x_int(ncvt);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_d = d, _fp_e = e, _fp_u = u, _fp_c = c, _fp_vt = vt){
                x_vector_attach_to_array(ref _d_d, _fp_d, ap.len(d));
                x_vector_attach_to_array(ref _d_e, _fp_e, ap.len(e));
                x_matrix_attach_to_array(ref _d_u, _fp_u, ap.rows(u), ap.cols(u));
                x_matrix_attach_to_array(ref _d_c, _fp_c, ap.rows(c), ap.cols(c));
                x_matrix_attach_to_array(ref _d_vt, _fp_vt, ap.rows(vt), ap.cols(vt));
                _error_code = _i_xv2_rmatrixbdsvd(&_s_errormsg, &_d_result, &_d_d, &_d_e, &_d_n, &_d_isupper, &_d_isfractionalaccuracyrequired, &_d_u, &_d_nru, &_d_c, &_d_ncc, &_d_vt, &_d_ncvt, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rmatrixbdsvd");
            result = _d_result!=0;
            if( _d_d.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_d, ref d);
            if( d == null )
                d = new double[0];
            if( _d_u.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_u, ref u);
            if( u == null )
                u = new double[0,0];
            if( _d_c.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_c, ref c);
            if( c == null )
                c = new double[0,0];
            if( _d_vt.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_vt, ref vt);
            if( vt == null )
                vt = new double[0,0];
        }
        finally
        {
            x_vector_clear(ref _d_d);
            x_vector_clear(ref _d_e);
            x_matrix_clear(ref _d_u);
            x_matrix_clear(ref _d_c);
            x_matrix_clear(ref _d_vt);
        }
        return result;
    }
    
    public static bool rmatrixbdsvd(ref double[] d, double[] e, int n, bool isupper, bool isfractionalaccuracyrequired, ref double[,] u, int nru, ref double[,] c, int ncc, ref double[,] vt, int ncvt)
    {
        return _core_rmatrixbdsvd(ref  d,  e,  n,  isupper,  isfractionalaccuracyrequired, ref  u,  nru, ref  c,  ncc, ref  vt,  ncvt, 0x0);
    }
    
    public static bool rmatrixbdsvd(ref double[] d, double[] e, int n, bool isupper, bool isfractionalaccuracyrequired, ref double[,] u, int nru, ref double[,] c, int ncc, ref double[,] vt, int ncvt, alglib.xparams _xparams)
    {
        return _core_rmatrixbdsvd(ref  d,  e,  n,  isupper,  isfractionalaccuracyrequired, ref  u,  nru, ref  c,  ncc, ref  vt,  ncvt, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage svd
    //
    
    
    private static unsafe bool _core_rmatrixsvd(double[,] a, int m, int n, int uneeded, int vtneeded, int additionalmemory, out double[] w, out double[,] u, out double[,] vt, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        bool result;
        byte _d_result = (byte)0;
        x_matrix _d_a = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_int _d_uneeded = new x_int(uneeded);
        x_int _d_vtneeded = new x_int(vtneeded);
        x_int _d_additionalmemory = new x_int(additionalmemory);
        x_vector _d_w = new x_vector();
        x_matrix _d_u = new x_matrix();
        x_matrix _d_vt = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_create_empty(ref _d_w, DT_REAL);
                w = null;
                x_matrix_create_empty(ref _d_u, DT_REAL);
                u = null;
                x_matrix_create_empty(ref _d_vt, DT_REAL);
                vt = null;
                _error_code = _i_xv2_rmatrixsvd(&_s_errormsg, &_d_result, &_d_a, &_d_m, &_d_n, &_d_uneeded, &_d_vtneeded, &_d_additionalmemory, &_d_w, &_d_u, &_d_vt, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rmatrixsvd");
            result = _d_result!=0;
            if( _d_w.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_w, ref w);
            if( w == null )
                w = new double[0];
            if( _d_u.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_u, ref u);
            if( u == null )
                u = new double[0,0];
            if( _d_vt.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_vt, ref vt);
            if( vt == null )
                vt = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_w);
            x_matrix_clear(ref _d_u);
            x_matrix_clear(ref _d_vt);
        }
        return result;
    }
    
    public static bool rmatrixsvd(double[,] a, int m, int n, int uneeded, int vtneeded, int additionalmemory, out double[] w, out double[,] u, out double[,] vt)
    {
        return _core_rmatrixsvd( a,  m,  n,  uneeded,  vtneeded,  additionalmemory, out  w, out  u, out  vt, 0x0);
    }
    
    public static bool rmatrixsvd(double[,] a, int m, int n, int uneeded, int vtneeded, int additionalmemory, out double[] w, out double[,] u, out double[,] vt, alglib.xparams _xparams)
    {
        return _core_rmatrixsvd( a,  m,  n,  uneeded,  vtneeded,  additionalmemory, out  w, out  u, out  vt, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage rcond
    //
    
    
    private static unsafe double _core_rmatrixrcond1(double[,] a, int n, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                _error_code = _i_xv2_rmatrixrcond1(&_s_errormsg, &_d_result, &_d_a, &_d_n, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rmatrixrcond1");
            result = _d_result;
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        return result;
    }
    
    public static double rmatrixrcond1(double[,] a, int n)
    {
        return _core_rmatrixrcond1( a,  n, 0x0);
    }
    
    public static double rmatrixrcond1(double[,] a, int n, alglib.xparams _xparams)
    {
        return _core_rmatrixrcond1( a,  n, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_rmatrixrcondinf(double[,] a, int n, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                _error_code = _i_xv2_rmatrixrcondinf(&_s_errormsg, &_d_result, &_d_a, &_d_n, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rmatrixrcondinf");
            result = _d_result;
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        return result;
    }
    
    public static double rmatrixrcondinf(double[,] a, int n)
    {
        return _core_rmatrixrcondinf( a,  n, 0x0);
    }
    
    public static double rmatrixrcondinf(double[,] a, int n, alglib.xparams _xparams)
    {
        return _core_rmatrixrcondinf( a,  n, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_spdmatrixrcond(double[,] a, int n, bool isupper, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                _error_code = _i_xv2_spdmatrixrcond(&_s_errormsg, &_d_result, &_d_a, &_d_n, &_d_isupper, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spdmatrixrcond");
            result = _d_result;
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        return result;
    }
    
    public static double spdmatrixrcond(double[,] a, int n, bool isupper)
    {
        return _core_spdmatrixrcond( a,  n,  isupper, 0x0);
    }
    
    public static double spdmatrixrcond(double[,] a, int n, bool isupper, alglib.xparams _xparams)
    {
        return _core_spdmatrixrcond( a,  n,  isupper, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_rmatrixtrrcond1(double[,] a, int n, bool isupper, bool isunit, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        byte _d_isunit = (byte)(isunit ? 1 : 0);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                _error_code = _i_xv2_rmatrixtrrcond1(&_s_errormsg, &_d_result, &_d_a, &_d_n, &_d_isupper, &_d_isunit, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rmatrixtrrcond1");
            result = _d_result;
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        return result;
    }
    
    public static double rmatrixtrrcond1(double[,] a, int n, bool isupper, bool isunit)
    {
        return _core_rmatrixtrrcond1( a,  n,  isupper,  isunit, 0x0);
    }
    
    public static double rmatrixtrrcond1(double[,] a, int n, bool isupper, bool isunit, alglib.xparams _xparams)
    {
        return _core_rmatrixtrrcond1( a,  n,  isupper,  isunit, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_rmatrixtrrcondinf(double[,] a, int n, bool isupper, bool isunit, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        byte _d_isunit = (byte)(isunit ? 1 : 0);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                _error_code = _i_xv2_rmatrixtrrcondinf(&_s_errormsg, &_d_result, &_d_a, &_d_n, &_d_isupper, &_d_isunit, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rmatrixtrrcondinf");
            result = _d_result;
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        return result;
    }
    
    public static double rmatrixtrrcondinf(double[,] a, int n, bool isupper, bool isunit)
    {
        return _core_rmatrixtrrcondinf( a,  n,  isupper,  isunit, 0x0);
    }
    
    public static double rmatrixtrrcondinf(double[,] a, int n, bool isupper, bool isunit, alglib.xparams _xparams)
    {
        return _core_rmatrixtrrcondinf( a,  n,  isupper,  isunit, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_hpdmatrixrcond(complex[,] a, int n, bool isupper, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                _error_code = _i_xv2_hpdmatrixrcond(&_s_errormsg, &_d_result, &_d_a, &_d_n, &_d_isupper, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "hpdmatrixrcond");
            result = _d_result;
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        return result;
    }
    
    public static double hpdmatrixrcond(complex[,] a, int n, bool isupper)
    {
        return _core_hpdmatrixrcond( a,  n,  isupper, 0x0);
    }
    
    public static double hpdmatrixrcond(complex[,] a, int n, bool isupper, alglib.xparams _xparams)
    {
        return _core_hpdmatrixrcond( a,  n,  isupper, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_cmatrixrcond1(complex[,] a, int n, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                _error_code = _i_xv2_cmatrixrcond1(&_s_errormsg, &_d_result, &_d_a, &_d_n, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "cmatrixrcond1");
            result = _d_result;
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        return result;
    }
    
    public static double cmatrixrcond1(complex[,] a, int n)
    {
        return _core_cmatrixrcond1( a,  n, 0x0);
    }
    
    public static double cmatrixrcond1(complex[,] a, int n, alglib.xparams _xparams)
    {
        return _core_cmatrixrcond1( a,  n, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_cmatrixrcondinf(complex[,] a, int n, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                _error_code = _i_xv2_cmatrixrcondinf(&_s_errormsg, &_d_result, &_d_a, &_d_n, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "cmatrixrcondinf");
            result = _d_result;
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        return result;
    }
    
    public static double cmatrixrcondinf(complex[,] a, int n)
    {
        return _core_cmatrixrcondinf( a,  n, 0x0);
    }
    
    public static double cmatrixrcondinf(complex[,] a, int n, alglib.xparams _xparams)
    {
        return _core_cmatrixrcondinf( a,  n, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_rmatrixlurcond1(double[,] lua, int n, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_matrix _d_lua = new x_matrix();
        x_int _d_n = new x_int(n);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_lua = lua){
                x_matrix_attach_to_array(ref _d_lua, _fp_lua, ap.rows(lua), ap.cols(lua));
                _error_code = _i_xv2_rmatrixlurcond1(&_s_errormsg, &_d_result, &_d_lua, &_d_n, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rmatrixlurcond1");
            result = _d_result;
        }
        finally
        {
            x_matrix_clear(ref _d_lua);
        }
        return result;
    }
    
    public static double rmatrixlurcond1(double[,] lua, int n)
    {
        return _core_rmatrixlurcond1( lua,  n, 0x0);
    }
    
    public static double rmatrixlurcond1(double[,] lua, int n, alglib.xparams _xparams)
    {
        return _core_rmatrixlurcond1( lua,  n, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_rmatrixlurcondinf(double[,] lua, int n, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_matrix _d_lua = new x_matrix();
        x_int _d_n = new x_int(n);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_lua = lua){
                x_matrix_attach_to_array(ref _d_lua, _fp_lua, ap.rows(lua), ap.cols(lua));
                _error_code = _i_xv2_rmatrixlurcondinf(&_s_errormsg, &_d_result, &_d_lua, &_d_n, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rmatrixlurcondinf");
            result = _d_result;
        }
        finally
        {
            x_matrix_clear(ref _d_lua);
        }
        return result;
    }
    
    public static double rmatrixlurcondinf(double[,] lua, int n)
    {
        return _core_rmatrixlurcondinf( lua,  n, 0x0);
    }
    
    public static double rmatrixlurcondinf(double[,] lua, int n, alglib.xparams _xparams)
    {
        return _core_rmatrixlurcondinf( lua,  n, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_spdmatrixcholeskyrcond(double[,] a, int n, bool isupper, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                _error_code = _i_xv2_spdmatrixcholeskyrcond(&_s_errormsg, &_d_result, &_d_a, &_d_n, &_d_isupper, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spdmatrixcholeskyrcond");
            result = _d_result;
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        return result;
    }
    
    public static double spdmatrixcholeskyrcond(double[,] a, int n, bool isupper)
    {
        return _core_spdmatrixcholeskyrcond( a,  n,  isupper, 0x0);
    }
    
    public static double spdmatrixcholeskyrcond(double[,] a, int n, bool isupper, alglib.xparams _xparams)
    {
        return _core_spdmatrixcholeskyrcond( a,  n,  isupper, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_hpdmatrixcholeskyrcond(complex[,] a, int n, bool isupper, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                _error_code = _i_xv2_hpdmatrixcholeskyrcond(&_s_errormsg, &_d_result, &_d_a, &_d_n, &_d_isupper, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "hpdmatrixcholeskyrcond");
            result = _d_result;
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        return result;
    }
    
    public static double hpdmatrixcholeskyrcond(complex[,] a, int n, bool isupper)
    {
        return _core_hpdmatrixcholeskyrcond( a,  n,  isupper, 0x0);
    }
    
    public static double hpdmatrixcholeskyrcond(complex[,] a, int n, bool isupper, alglib.xparams _xparams)
    {
        return _core_hpdmatrixcholeskyrcond( a,  n,  isupper, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_cmatrixlurcond1(complex[,] lua, int n, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_matrix _d_lua = new x_matrix();
        x_int _d_n = new x_int(n);
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_lua = lua){
                x_matrix_attach_to_array(ref _d_lua, _fp_lua, ap.rows(lua), ap.cols(lua));
                _error_code = _i_xv2_cmatrixlurcond1(&_s_errormsg, &_d_result, &_d_lua, &_d_n, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "cmatrixlurcond1");
            result = _d_result;
        }
        finally
        {
            x_matrix_clear(ref _d_lua);
        }
        return result;
    }
    
    public static double cmatrixlurcond1(complex[,] lua, int n)
    {
        return _core_cmatrixlurcond1( lua,  n, 0x0);
    }
    
    public static double cmatrixlurcond1(complex[,] lua, int n, alglib.xparams _xparams)
    {
        return _core_cmatrixlurcond1( lua,  n, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_cmatrixlurcondinf(complex[,] lua, int n, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_matrix _d_lua = new x_matrix();
        x_int _d_n = new x_int(n);
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_lua = lua){
                x_matrix_attach_to_array(ref _d_lua, _fp_lua, ap.rows(lua), ap.cols(lua));
                _error_code = _i_xv2_cmatrixlurcondinf(&_s_errormsg, &_d_result, &_d_lua, &_d_n, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "cmatrixlurcondinf");
            result = _d_result;
        }
        finally
        {
            x_matrix_clear(ref _d_lua);
        }
        return result;
    }
    
    public static double cmatrixlurcondinf(complex[,] lua, int n)
    {
        return _core_cmatrixlurcondinf( lua,  n, 0x0);
    }
    
    public static double cmatrixlurcondinf(complex[,] lua, int n, alglib.xparams _xparams)
    {
        return _core_cmatrixlurcondinf( lua,  n, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_cmatrixtrrcond1(complex[,] a, int n, bool isupper, bool isunit, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        byte _d_isunit = (byte)(isunit ? 1 : 0);
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                _error_code = _i_xv2_cmatrixtrrcond1(&_s_errormsg, &_d_result, &_d_a, &_d_n, &_d_isupper, &_d_isunit, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "cmatrixtrrcond1");
            result = _d_result;
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        return result;
    }
    
    public static double cmatrixtrrcond1(complex[,] a, int n, bool isupper, bool isunit)
    {
        return _core_cmatrixtrrcond1( a,  n,  isupper,  isunit, 0x0);
    }
    
    public static double cmatrixtrrcond1(complex[,] a, int n, bool isupper, bool isunit, alglib.xparams _xparams)
    {
        return _core_cmatrixtrrcond1( a,  n,  isupper,  isunit, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_cmatrixtrrcondinf(complex[,] a, int n, bool isupper, bool isunit, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        byte _d_isunit = (byte)(isunit ? 1 : 0);
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                _error_code = _i_xv2_cmatrixtrrcondinf(&_s_errormsg, &_d_result, &_d_a, &_d_n, &_d_isupper, &_d_isunit, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "cmatrixtrrcondinf");
            result = _d_result;
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        return result;
    }
    
    public static double cmatrixtrrcondinf(complex[,] a, int n, bool isupper, bool isunit)
    {
        return _core_cmatrixtrrcondinf( a,  n,  isupper,  isunit, 0x0);
    }
    
    public static double cmatrixtrrcondinf(complex[,] a, int n, bool isupper, bool isunit, alglib.xparams _xparams)
    {
        return _core_cmatrixtrrcondinf( a,  n,  isupper,  isunit, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage directdensesolvers
    //
    

    [StructLayout(LayoutKind.Sequential, Pack=8)]
    private struct x_densesolverreport
    {
        public double r1;
        public double rinf;
    }

    public class densesolverreport : alglibobject
    {
        public double r1;
        public double rinf;
        public override alglib.alglibobject make_copy()
        {
            densesolverreport dst = new densesolverreport();
            dst.r1 = r1;
            dst.rinf = rinf;
            return dst;
        }
    }

    // This function initializes X-structure (its previous content is ignored)
    private static void x_densesolverreport_init(ref x_densesolverreport x)
    {
        x.r1 = 0;
        x.rinf = 0;
    }

    // This function finalizes fields of X-structure (however, memory occupied by structure itself is not freed)
    // After destruction structure becomes unusable and should be re-initialized if you want to use it
    private static void x_densesolverreport_clear(ref x_densesolverreport x)
    {
    }

    // This function initializes X-structure by appropriate C# instance
    // (previous content of X structure is ignored)
    private static void x_densesolverreport_init_from(ref x_densesolverreport x, densesolverreport v)
    {
        x.r1 = v.r1;
        x.rinf = v.rinf;
    }

    // This function initializes C# structure by appropriate X instance
    // (previous content of C# structure is ignored).
    // This function may accept null v, in this case v is automatically allocated with new().
    private static void x_densesolverreport_to_record(ref x_densesolverreport x, ref densesolverreport v)
    {
        if( v==null )
            v = new densesolverreport();
        v.r1 = x.r1;
        v.rinf = x.rinf;
    }

    [StructLayout(LayoutKind.Sequential, Pack=8)]
    private struct x_densesolverlsreport
    {
        public double r2;
        public x_matrix cx;
        public x_int n;
        public x_int k;
    }

    public class densesolverlsreport : alglibobject
    {
        public double r2;
        public double[,] cx;
        public int n;
        public int k;
        public override alglib.alglibobject make_copy()
        {
            densesolverlsreport dst = new densesolverlsreport();
            dst.r2 = r2;
            dst.cx = (double[,])cx.Clone();        dst.n = n;
            dst.k = k;
            return dst;
        }
    }

    // This function initializes X-structure (its previous content is ignored)
    private static void x_densesolverlsreport_init(ref x_densesolverlsreport x)
    {
        x.r2 = 0;
        x_matrix_create_empty(ref x.cx, DT_REAL);
        x.n.longval = 0;
        x.k.longval = 0;
    }

    // This function finalizes fields of X-structure (however, memory occupied by structure itself is not freed)
    // After destruction structure becomes unusable and should be re-initialized if you want to use it
    private static void x_densesolverlsreport_clear(ref x_densesolverlsreport x)
    {
        x_matrix_clear(ref x.cx);
    }

    // This function initializes X-structure by appropriate C# instance
    // (previous content of X structure is ignored)
    private static void x_densesolverlsreport_init_from(ref x_densesolverlsreport x, densesolverlsreport v)
    {
        x.r2 = v.r2;
        x_matrix_from_array(ref x.cx, v.cx, X_CREATE);
        x.n.longval = v.n;
        x.k.longval = v.k;
    }

    // This function initializes C# structure by appropriate X instance
    // (previous content of C# structure is ignored).
    // This function may accept null v, in this case v is automatically allocated with new().
    private static void x_densesolverlsreport_to_record(ref x_densesolverlsreport x, ref densesolverlsreport v)
    {
        if( v==null )
            v = new densesolverlsreport();
        v.r2 = x.r2;
        x_matrix_to_array(ref x.cx, ref v.cx);
        v.n = x.n.intval; // long is silently truncated to int
        v.k = x.k.intval; // long is silently truncated to int
    }
    
    private static unsafe void _core_rmatrixsolve(double[,] a, int n, double[] b, out int info, out densesolverreport rep, out double[] x, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        x_vector _d_b = new x_vector();
        x_int _d_info = new x_int();
        x_densesolverreport _d_rep = new x_densesolverreport();
        x_vector _d_x = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a, _fp_b = b){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_attach_to_array(ref _d_b, _fp_b, ap.len(b));
                x_densesolverreport_init(ref _d_rep);
                x_vector_create_empty(ref _d_x, DT_REAL);
                x = null;
                _error_code = _i_xv2_rmatrixsolve(&_s_errormsg, &_d_a, &_d_n, &_d_b, &_d_info, &_d_rep, &_d_x, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rmatrixsolve");
            info = _d_info.intval;
            rep = null;
            x_densesolverreport_to_record(ref _d_rep, ref rep);
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_b);
            x_densesolverreport_clear(ref _d_rep);
            x_vector_clear(ref _d_x);
        }
        // This function returns no value.
    }
    
    public static void rmatrixsolve(double[,] a, int n, double[] b, out int info, out densesolverreport rep, out double[] x)
    {
        _core_rmatrixsolve( a,  n,  b, out  info, out  rep, out  x, 0x0);
    }
    
    public static void rmatrixsolve(double[,] a, int n, double[] b, out int info, out densesolverreport rep, out double[] x, alglib.xparams _xparams)
    {
        _core_rmatrixsolve( a,  n,  b, out  info, out  rep, out  x, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_rmatrixsolvefast(double[,] a, int n, ref double[] b, out int info, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        x_vector _d_b = new x_vector();
        x_int _d_info = new x_int();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a, _fp_b = b){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_attach_to_array(ref _d_b, _fp_b, ap.len(b));
                _error_code = _i_xv2_rmatrixsolvefast(&_s_errormsg, &_d_a, &_d_n, &_d_b, &_d_info, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rmatrixsolvefast");
            if( _d_b.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_b, ref b);
            if( b == null )
                b = new double[0];
            info = _d_info.intval;
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_b);
        }
        // This function returns no value.
    }
    
    public static void rmatrixsolvefast(double[,] a, int n, ref double[] b, out int info)
    {
        _core_rmatrixsolvefast( a,  n, ref  b, out  info, 0x0);
    }
    
    public static void rmatrixsolvefast(double[,] a, int n, ref double[] b, out int info, alglib.xparams _xparams)
    {
        _core_rmatrixsolvefast( a,  n, ref  b, out  info, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_rmatrixsolvem(double[,] a, int n, double[,] b, int m, bool rfs, out int info, out densesolverreport rep, out double[,] x, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        x_matrix _d_b = new x_matrix();
        x_int _d_m = new x_int(m);
        byte _d_rfs = (byte)(rfs ? 1 : 0);
        x_int _d_info = new x_int();
        x_densesolverreport _d_rep = new x_densesolverreport();
        x_matrix _d_x = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a, _fp_b = b){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matrix_attach_to_array(ref _d_b, _fp_b, ap.rows(b), ap.cols(b));
                x_densesolverreport_init(ref _d_rep);
                x_matrix_create_empty(ref _d_x, DT_REAL);
                x = null;
                _error_code = _i_xv2_rmatrixsolvem(&_s_errormsg, &_d_a, &_d_n, &_d_b, &_d_m, &_d_rfs, &_d_info, &_d_rep, &_d_x, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rmatrixsolvem");
            info = _d_info.intval;
            rep = null;
            x_densesolverreport_to_record(ref _d_rep, ref rep);
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matrix_clear(ref _d_b);
            x_densesolverreport_clear(ref _d_rep);
            x_matrix_clear(ref _d_x);
        }
        // This function returns no value.
    }
    
    public static void rmatrixsolvem(double[,] a, int n, double[,] b, int m, bool rfs, out int info, out densesolverreport rep, out double[,] x)
    {
        _core_rmatrixsolvem( a,  n,  b,  m,  rfs, out  info, out  rep, out  x, 0x0);
    }
    
    public static void rmatrixsolvem(double[,] a, int n, double[,] b, int m, bool rfs, out int info, out densesolverreport rep, out double[,] x, alglib.xparams _xparams)
    {
        _core_rmatrixsolvem( a,  n,  b,  m,  rfs, out  info, out  rep, out  x, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_rmatrixsolvemfast(double[,] a, int n, ref double[,] b, int m, out int info, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        x_matrix _d_b = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_info = new x_int();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a, _fp_b = b){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matrix_attach_to_array(ref _d_b, _fp_b, ap.rows(b), ap.cols(b));
                _error_code = _i_xv2_rmatrixsolvemfast(&_s_errormsg, &_d_a, &_d_n, &_d_b, &_d_m, &_d_info, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rmatrixsolvemfast");
            if( _d_b.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_b, ref b);
            if( b == null )
                b = new double[0,0];
            info = _d_info.intval;
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matrix_clear(ref _d_b);
        }
        // This function returns no value.
    }
    
    public static void rmatrixsolvemfast(double[,] a, int n, ref double[,] b, int m, out int info)
    {
        _core_rmatrixsolvemfast( a,  n, ref  b,  m, out  info, 0x0);
    }
    
    public static void rmatrixsolvemfast(double[,] a, int n, ref double[,] b, int m, out int info, alglib.xparams _xparams)
    {
        _core_rmatrixsolvemfast( a,  n, ref  b,  m, out  info, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_rmatrixlusolve(double[,] lua, int[] p, int n, double[] b, out int info, out densesolverreport rep, out double[] x, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_lua = new x_matrix();
        x_vector _d_p = new x_vector();
        x_int _d_n = new x_int(n);
        x_vector _d_b = new x_vector();
        x_int _d_info = new x_int();
        x_densesolverreport _d_rep = new x_densesolverreport();
        x_vector _d_x = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_lua = lua, _fp_b = b){
                x_matrix_attach_to_array(ref _d_lua, _fp_lua, ap.rows(lua), ap.cols(lua));
                x_vector_from_array(ref _d_p, p, X_CREATE);
                x_vector_attach_to_array(ref _d_b, _fp_b, ap.len(b));
                x_densesolverreport_init(ref _d_rep);
                x_vector_create_empty(ref _d_x, DT_REAL);
                x = null;
                _error_code = _i_xv2_rmatrixlusolve(&_s_errormsg, &_d_lua, &_d_p, &_d_n, &_d_b, &_d_info, &_d_rep, &_d_x, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rmatrixlusolve");
            info = _d_info.intval;
            rep = null;
            x_densesolverreport_to_record(ref _d_rep, ref rep);
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
        }
        finally
        {
            x_matrix_clear(ref _d_lua);
            x_vector_clear(ref _d_p);
            x_vector_clear(ref _d_b);
            x_densesolverreport_clear(ref _d_rep);
            x_vector_clear(ref _d_x);
        }
        // This function returns no value.
    }
    
    public static void rmatrixlusolve(double[,] lua, int[] p, int n, double[] b, out int info, out densesolverreport rep, out double[] x)
    {
        _core_rmatrixlusolve( lua,  p,  n,  b, out  info, out  rep, out  x, 0x0);
    }
    
    public static void rmatrixlusolve(double[,] lua, int[] p, int n, double[] b, out int info, out densesolverreport rep, out double[] x, alglib.xparams _xparams)
    {
        _core_rmatrixlusolve( lua,  p,  n,  b, out  info, out  rep, out  x, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_rmatrixlusolvefast(double[,] lua, int[] p, int n, ref double[] b, out int info, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_lua = new x_matrix();
        x_vector _d_p = new x_vector();
        x_int _d_n = new x_int(n);
        x_vector _d_b = new x_vector();
        x_int _d_info = new x_int();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_lua = lua, _fp_b = b){
                x_matrix_attach_to_array(ref _d_lua, _fp_lua, ap.rows(lua), ap.cols(lua));
                x_vector_from_array(ref _d_p, p, X_CREATE);
                x_vector_attach_to_array(ref _d_b, _fp_b, ap.len(b));
                _error_code = _i_xv2_rmatrixlusolvefast(&_s_errormsg, &_d_lua, &_d_p, &_d_n, &_d_b, &_d_info, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rmatrixlusolvefast");
            if( _d_b.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_b, ref b);
            if( b == null )
                b = new double[0];
            info = _d_info.intval;
        }
        finally
        {
            x_matrix_clear(ref _d_lua);
            x_vector_clear(ref _d_p);
            x_vector_clear(ref _d_b);
        }
        // This function returns no value.
    }
    
    public static void rmatrixlusolvefast(double[,] lua, int[] p, int n, ref double[] b, out int info)
    {
        _core_rmatrixlusolvefast( lua,  p,  n, ref  b, out  info, 0x0);
    }
    
    public static void rmatrixlusolvefast(double[,] lua, int[] p, int n, ref double[] b, out int info, alglib.xparams _xparams)
    {
        _core_rmatrixlusolvefast( lua,  p,  n, ref  b, out  info, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_rmatrixlusolvem(double[,] lua, int[] p, int n, double[,] b, int m, out int info, out densesolverreport rep, out double[,] x, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_lua = new x_matrix();
        x_vector _d_p = new x_vector();
        x_int _d_n = new x_int(n);
        x_matrix _d_b = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_info = new x_int();
        x_densesolverreport _d_rep = new x_densesolverreport();
        x_matrix _d_x = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_lua = lua, _fp_b = b){
                x_matrix_attach_to_array(ref _d_lua, _fp_lua, ap.rows(lua), ap.cols(lua));
                x_vector_from_array(ref _d_p, p, X_CREATE);
                x_matrix_attach_to_array(ref _d_b, _fp_b, ap.rows(b), ap.cols(b));
                x_densesolverreport_init(ref _d_rep);
                x_matrix_create_empty(ref _d_x, DT_REAL);
                x = null;
                _error_code = _i_xv2_rmatrixlusolvem(&_s_errormsg, &_d_lua, &_d_p, &_d_n, &_d_b, &_d_m, &_d_info, &_d_rep, &_d_x, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rmatrixlusolvem");
            info = _d_info.intval;
            rep = null;
            x_densesolverreport_to_record(ref _d_rep, ref rep);
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_lua);
            x_vector_clear(ref _d_p);
            x_matrix_clear(ref _d_b);
            x_densesolverreport_clear(ref _d_rep);
            x_matrix_clear(ref _d_x);
        }
        // This function returns no value.
    }
    
    public static void rmatrixlusolvem(double[,] lua, int[] p, int n, double[,] b, int m, out int info, out densesolverreport rep, out double[,] x)
    {
        _core_rmatrixlusolvem( lua,  p,  n,  b,  m, out  info, out  rep, out  x, 0x0);
    }
    
    public static void rmatrixlusolvem(double[,] lua, int[] p, int n, double[,] b, int m, out int info, out densesolverreport rep, out double[,] x, alglib.xparams _xparams)
    {
        _core_rmatrixlusolvem( lua,  p,  n,  b,  m, out  info, out  rep, out  x, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_rmatrixlusolvemfast(double[,] lua, int[] p, int n, ref double[,] b, int m, out int info, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_lua = new x_matrix();
        x_vector _d_p = new x_vector();
        x_int _d_n = new x_int(n);
        x_matrix _d_b = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_info = new x_int();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_lua = lua, _fp_b = b){
                x_matrix_attach_to_array(ref _d_lua, _fp_lua, ap.rows(lua), ap.cols(lua));
                x_vector_from_array(ref _d_p, p, X_CREATE);
                x_matrix_attach_to_array(ref _d_b, _fp_b, ap.rows(b), ap.cols(b));
                _error_code = _i_xv2_rmatrixlusolvemfast(&_s_errormsg, &_d_lua, &_d_p, &_d_n, &_d_b, &_d_m, &_d_info, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rmatrixlusolvemfast");
            if( _d_b.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_b, ref b);
            if( b == null )
                b = new double[0,0];
            info = _d_info.intval;
        }
        finally
        {
            x_matrix_clear(ref _d_lua);
            x_vector_clear(ref _d_p);
            x_matrix_clear(ref _d_b);
        }
        // This function returns no value.
    }
    
    public static void rmatrixlusolvemfast(double[,] lua, int[] p, int n, ref double[,] b, int m, out int info)
    {
        _core_rmatrixlusolvemfast( lua,  p,  n, ref  b,  m, out  info, 0x0);
    }
    
    public static void rmatrixlusolvemfast(double[,] lua, int[] p, int n, ref double[,] b, int m, out int info, alglib.xparams _xparams)
    {
        _core_rmatrixlusolvemfast( lua,  p,  n, ref  b,  m, out  info, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_rmatrixmixedsolve(double[,] a, double[,] lua, int[] p, int n, double[] b, out int info, out densesolverreport rep, out double[] x, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_matrix _d_lua = new x_matrix();
        x_vector _d_p = new x_vector();
        x_int _d_n = new x_int(n);
        x_vector _d_b = new x_vector();
        x_int _d_info = new x_int();
        x_densesolverreport _d_rep = new x_densesolverreport();
        x_vector _d_x = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a, _fp_lua = lua, _fp_b = b){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matrix_attach_to_array(ref _d_lua, _fp_lua, ap.rows(lua), ap.cols(lua));
                x_vector_from_array(ref _d_p, p, X_CREATE);
                x_vector_attach_to_array(ref _d_b, _fp_b, ap.len(b));
                x_densesolverreport_init(ref _d_rep);
                x_vector_create_empty(ref _d_x, DT_REAL);
                x = null;
                _error_code = _i_xv2_rmatrixmixedsolve(&_s_errormsg, &_d_a, &_d_lua, &_d_p, &_d_n, &_d_b, &_d_info, &_d_rep, &_d_x, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rmatrixmixedsolve");
            info = _d_info.intval;
            rep = null;
            x_densesolverreport_to_record(ref _d_rep, ref rep);
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matrix_clear(ref _d_lua);
            x_vector_clear(ref _d_p);
            x_vector_clear(ref _d_b);
            x_densesolverreport_clear(ref _d_rep);
            x_vector_clear(ref _d_x);
        }
        // This function returns no value.
    }
    
    public static void rmatrixmixedsolve(double[,] a, double[,] lua, int[] p, int n, double[] b, out int info, out densesolverreport rep, out double[] x)
    {
        _core_rmatrixmixedsolve( a,  lua,  p,  n,  b, out  info, out  rep, out  x, 0x0);
    }
    
    public static void rmatrixmixedsolve(double[,] a, double[,] lua, int[] p, int n, double[] b, out int info, out densesolverreport rep, out double[] x, alglib.xparams _xparams)
    {
        _core_rmatrixmixedsolve( a,  lua,  p,  n,  b, out  info, out  rep, out  x, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_rmatrixmixedsolvem(double[,] a, double[,] lua, int[] p, int n, double[,] b, int m, out int info, out densesolverreport rep, out double[,] x, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_matrix _d_lua = new x_matrix();
        x_vector _d_p = new x_vector();
        x_int _d_n = new x_int(n);
        x_matrix _d_b = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_info = new x_int();
        x_densesolverreport _d_rep = new x_densesolverreport();
        x_matrix _d_x = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a, _fp_lua = lua, _fp_b = b){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matrix_attach_to_array(ref _d_lua, _fp_lua, ap.rows(lua), ap.cols(lua));
                x_vector_from_array(ref _d_p, p, X_CREATE);
                x_matrix_attach_to_array(ref _d_b, _fp_b, ap.rows(b), ap.cols(b));
                x_densesolverreport_init(ref _d_rep);
                x_matrix_create_empty(ref _d_x, DT_REAL);
                x = null;
                _error_code = _i_xv2_rmatrixmixedsolvem(&_s_errormsg, &_d_a, &_d_lua, &_d_p, &_d_n, &_d_b, &_d_m, &_d_info, &_d_rep, &_d_x, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rmatrixmixedsolvem");
            info = _d_info.intval;
            rep = null;
            x_densesolverreport_to_record(ref _d_rep, ref rep);
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matrix_clear(ref _d_lua);
            x_vector_clear(ref _d_p);
            x_matrix_clear(ref _d_b);
            x_densesolverreport_clear(ref _d_rep);
            x_matrix_clear(ref _d_x);
        }
        // This function returns no value.
    }
    
    public static void rmatrixmixedsolvem(double[,] a, double[,] lua, int[] p, int n, double[,] b, int m, out int info, out densesolverreport rep, out double[,] x)
    {
        _core_rmatrixmixedsolvem( a,  lua,  p,  n,  b,  m, out  info, out  rep, out  x, 0x0);
    }
    
    public static void rmatrixmixedsolvem(double[,] a, double[,] lua, int[] p, int n, double[,] b, int m, out int info, out densesolverreport rep, out double[,] x, alglib.xparams _xparams)
    {
        _core_rmatrixmixedsolvem( a,  lua,  p,  n,  b,  m, out  info, out  rep, out  x, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_cmatrixsolvem(complex[,] a, int n, complex[,] b, int m, bool rfs, out int info, out densesolverreport rep, out complex[,] x, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        x_matrix _d_b = new x_matrix();
        x_int _d_m = new x_int(m);
        byte _d_rfs = (byte)(rfs ? 1 : 0);
        x_int _d_info = new x_int();
        x_densesolverreport _d_rep = new x_densesolverreport();
        x_matrix _d_x = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a, _fp_b = b){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matrix_attach_to_array(ref _d_b, _fp_b, ap.rows(b), ap.cols(b));
                x_densesolverreport_init(ref _d_rep);
                x_matrix_create_empty(ref _d_x, DT_COMPLEX);
                x = null;
                _error_code = _i_xv2_cmatrixsolvem(&_s_errormsg, &_d_a, &_d_n, &_d_b, &_d_m, &_d_rfs, &_d_info, &_d_rep, &_d_x, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "cmatrixsolvem");
            info = _d_info.intval;
            rep = null;
            x_densesolverreport_to_record(ref _d_rep, ref rep);
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_x, ref x);
            if( x == null )
                x = new alglib.complex[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matrix_clear(ref _d_b);
            x_densesolverreport_clear(ref _d_rep);
            x_matrix_clear(ref _d_x);
        }
        // This function returns no value.
    }
    
    public static void cmatrixsolvem(complex[,] a, int n, complex[,] b, int m, bool rfs, out int info, out densesolverreport rep, out complex[,] x)
    {
        _core_cmatrixsolvem( a,  n,  b,  m,  rfs, out  info, out  rep, out  x, 0x0);
    }
    
    public static void cmatrixsolvem(complex[,] a, int n, complex[,] b, int m, bool rfs, out int info, out densesolverreport rep, out complex[,] x, alglib.xparams _xparams)
    {
        _core_cmatrixsolvem( a,  n,  b,  m,  rfs, out  info, out  rep, out  x, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_cmatrixsolvemfast(complex[,] a, int n, ref complex[,] b, int m, out int info, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        x_matrix _d_b = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_info = new x_int();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a, _fp_b = b){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matrix_attach_to_array(ref _d_b, _fp_b, ap.rows(b), ap.cols(b));
                _error_code = _i_xv2_cmatrixsolvemfast(&_s_errormsg, &_d_a, &_d_n, &_d_b, &_d_m, &_d_info, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "cmatrixsolvemfast");
            if( _d_b.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_b, ref b);
            if( b == null )
                b = new alglib.complex[0,0];
            info = _d_info.intval;
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matrix_clear(ref _d_b);
        }
        // This function returns no value.
    }
    
    public static void cmatrixsolvemfast(complex[,] a, int n, ref complex[,] b, int m, out int info)
    {
        _core_cmatrixsolvemfast( a,  n, ref  b,  m, out  info, 0x0);
    }
    
    public static void cmatrixsolvemfast(complex[,] a, int n, ref complex[,] b, int m, out int info, alglib.xparams _xparams)
    {
        _core_cmatrixsolvemfast( a,  n, ref  b,  m, out  info, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_cmatrixsolve(complex[,] a, int n, complex[] b, out int info, out densesolverreport rep, out complex[] x, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        x_vector _d_b = new x_vector();
        x_int _d_info = new x_int();
        x_densesolverreport _d_rep = new x_densesolverreport();
        x_vector _d_x = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a, _fp_b = b){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_attach_to_array(ref _d_b, _fp_b, ap.len(b));
                x_densesolverreport_init(ref _d_rep);
                x_vector_create_empty(ref _d_x, DT_COMPLEX);
                x = null;
                _error_code = _i_xv2_cmatrixsolve(&_s_errormsg, &_d_a, &_d_n, &_d_b, &_d_info, &_d_rep, &_d_x, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "cmatrixsolve");
            info = _d_info.intval;
            rep = null;
            x_densesolverreport_to_record(ref _d_rep, ref rep);
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new alglib.complex[0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_b);
            x_densesolverreport_clear(ref _d_rep);
            x_vector_clear(ref _d_x);
        }
        // This function returns no value.
    }
    
    public static void cmatrixsolve(complex[,] a, int n, complex[] b, out int info, out densesolverreport rep, out complex[] x)
    {
        _core_cmatrixsolve( a,  n,  b, out  info, out  rep, out  x, 0x0);
    }
    
    public static void cmatrixsolve(complex[,] a, int n, complex[] b, out int info, out densesolverreport rep, out complex[] x, alglib.xparams _xparams)
    {
        _core_cmatrixsolve( a,  n,  b, out  info, out  rep, out  x, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_cmatrixsolvefast(complex[,] a, int n, ref complex[] b, out int info, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        x_vector _d_b = new x_vector();
        x_int _d_info = new x_int();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a, _fp_b = b){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_attach_to_array(ref _d_b, _fp_b, ap.len(b));
                _error_code = _i_xv2_cmatrixsolvefast(&_s_errormsg, &_d_a, &_d_n, &_d_b, &_d_info, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "cmatrixsolvefast");
            if( _d_b.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_b, ref b);
            if( b == null )
                b = new alglib.complex[0];
            info = _d_info.intval;
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_b);
        }
        // This function returns no value.
    }
    
    public static void cmatrixsolvefast(complex[,] a, int n, ref complex[] b, out int info)
    {
        _core_cmatrixsolvefast( a,  n, ref  b, out  info, 0x0);
    }
    
    public static void cmatrixsolvefast(complex[,] a, int n, ref complex[] b, out int info, alglib.xparams _xparams)
    {
        _core_cmatrixsolvefast( a,  n, ref  b, out  info, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_cmatrixlusolvem(complex[,] lua, int[] p, int n, complex[,] b, int m, out int info, out densesolverreport rep, out complex[,] x, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_lua = new x_matrix();
        x_vector _d_p = new x_vector();
        x_int _d_n = new x_int(n);
        x_matrix _d_b = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_info = new x_int();
        x_densesolverreport _d_rep = new x_densesolverreport();
        x_matrix _d_x = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_lua = lua, _fp_b = b){
                x_matrix_attach_to_array(ref _d_lua, _fp_lua, ap.rows(lua), ap.cols(lua));
                x_vector_from_array(ref _d_p, p, X_CREATE);
                x_matrix_attach_to_array(ref _d_b, _fp_b, ap.rows(b), ap.cols(b));
                x_densesolverreport_init(ref _d_rep);
                x_matrix_create_empty(ref _d_x, DT_COMPLEX);
                x = null;
                _error_code = _i_xv2_cmatrixlusolvem(&_s_errormsg, &_d_lua, &_d_p, &_d_n, &_d_b, &_d_m, &_d_info, &_d_rep, &_d_x, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "cmatrixlusolvem");
            info = _d_info.intval;
            rep = null;
            x_densesolverreport_to_record(ref _d_rep, ref rep);
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_x, ref x);
            if( x == null )
                x = new alglib.complex[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_lua);
            x_vector_clear(ref _d_p);
            x_matrix_clear(ref _d_b);
            x_densesolverreport_clear(ref _d_rep);
            x_matrix_clear(ref _d_x);
        }
        // This function returns no value.
    }
    
    public static void cmatrixlusolvem(complex[,] lua, int[] p, int n, complex[,] b, int m, out int info, out densesolverreport rep, out complex[,] x)
    {
        _core_cmatrixlusolvem( lua,  p,  n,  b,  m, out  info, out  rep, out  x, 0x0);
    }
    
    public static void cmatrixlusolvem(complex[,] lua, int[] p, int n, complex[,] b, int m, out int info, out densesolverreport rep, out complex[,] x, alglib.xparams _xparams)
    {
        _core_cmatrixlusolvem( lua,  p,  n,  b,  m, out  info, out  rep, out  x, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_cmatrixlusolvemfast(complex[,] lua, int[] p, int n, ref complex[,] b, int m, out int info, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_lua = new x_matrix();
        x_vector _d_p = new x_vector();
        x_int _d_n = new x_int(n);
        x_matrix _d_b = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_info = new x_int();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_lua = lua, _fp_b = b){
                x_matrix_attach_to_array(ref _d_lua, _fp_lua, ap.rows(lua), ap.cols(lua));
                x_vector_from_array(ref _d_p, p, X_CREATE);
                x_matrix_attach_to_array(ref _d_b, _fp_b, ap.rows(b), ap.cols(b));
                _error_code = _i_xv2_cmatrixlusolvemfast(&_s_errormsg, &_d_lua, &_d_p, &_d_n, &_d_b, &_d_m, &_d_info, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "cmatrixlusolvemfast");
            if( _d_b.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_b, ref b);
            if( b == null )
                b = new alglib.complex[0,0];
            info = _d_info.intval;
        }
        finally
        {
            x_matrix_clear(ref _d_lua);
            x_vector_clear(ref _d_p);
            x_matrix_clear(ref _d_b);
        }
        // This function returns no value.
    }
    
    public static void cmatrixlusolvemfast(complex[,] lua, int[] p, int n, ref complex[,] b, int m, out int info)
    {
        _core_cmatrixlusolvemfast( lua,  p,  n, ref  b,  m, out  info, 0x0);
    }
    
    public static void cmatrixlusolvemfast(complex[,] lua, int[] p, int n, ref complex[,] b, int m, out int info, alglib.xparams _xparams)
    {
        _core_cmatrixlusolvemfast( lua,  p,  n, ref  b,  m, out  info, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_cmatrixlusolve(complex[,] lua, int[] p, int n, complex[] b, out int info, out densesolverreport rep, out complex[] x, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_lua = new x_matrix();
        x_vector _d_p = new x_vector();
        x_int _d_n = new x_int(n);
        x_vector _d_b = new x_vector();
        x_int _d_info = new x_int();
        x_densesolverreport _d_rep = new x_densesolverreport();
        x_vector _d_x = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_lua = lua, _fp_b = b){
                x_matrix_attach_to_array(ref _d_lua, _fp_lua, ap.rows(lua), ap.cols(lua));
                x_vector_from_array(ref _d_p, p, X_CREATE);
                x_vector_attach_to_array(ref _d_b, _fp_b, ap.len(b));
                x_densesolverreport_init(ref _d_rep);
                x_vector_create_empty(ref _d_x, DT_COMPLEX);
                x = null;
                _error_code = _i_xv2_cmatrixlusolve(&_s_errormsg, &_d_lua, &_d_p, &_d_n, &_d_b, &_d_info, &_d_rep, &_d_x, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "cmatrixlusolve");
            info = _d_info.intval;
            rep = null;
            x_densesolverreport_to_record(ref _d_rep, ref rep);
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new alglib.complex[0];
        }
        finally
        {
            x_matrix_clear(ref _d_lua);
            x_vector_clear(ref _d_p);
            x_vector_clear(ref _d_b);
            x_densesolverreport_clear(ref _d_rep);
            x_vector_clear(ref _d_x);
        }
        // This function returns no value.
    }
    
    public static void cmatrixlusolve(complex[,] lua, int[] p, int n, complex[] b, out int info, out densesolverreport rep, out complex[] x)
    {
        _core_cmatrixlusolve( lua,  p,  n,  b, out  info, out  rep, out  x, 0x0);
    }
    
    public static void cmatrixlusolve(complex[,] lua, int[] p, int n, complex[] b, out int info, out densesolverreport rep, out complex[] x, alglib.xparams _xparams)
    {
        _core_cmatrixlusolve( lua,  p,  n,  b, out  info, out  rep, out  x, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_cmatrixlusolvefast(complex[,] lua, int[] p, int n, ref complex[] b, out int info, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_lua = new x_matrix();
        x_vector _d_p = new x_vector();
        x_int _d_n = new x_int(n);
        x_vector _d_b = new x_vector();
        x_int _d_info = new x_int();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_lua = lua, _fp_b = b){
                x_matrix_attach_to_array(ref _d_lua, _fp_lua, ap.rows(lua), ap.cols(lua));
                x_vector_from_array(ref _d_p, p, X_CREATE);
                x_vector_attach_to_array(ref _d_b, _fp_b, ap.len(b));
                _error_code = _i_xv2_cmatrixlusolvefast(&_s_errormsg, &_d_lua, &_d_p, &_d_n, &_d_b, &_d_info, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "cmatrixlusolvefast");
            if( _d_b.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_b, ref b);
            if( b == null )
                b = new alglib.complex[0];
            info = _d_info.intval;
        }
        finally
        {
            x_matrix_clear(ref _d_lua);
            x_vector_clear(ref _d_p);
            x_vector_clear(ref _d_b);
        }
        // This function returns no value.
    }
    
    public static void cmatrixlusolvefast(complex[,] lua, int[] p, int n, ref complex[] b, out int info)
    {
        _core_cmatrixlusolvefast( lua,  p,  n, ref  b, out  info, 0x0);
    }
    
    public static void cmatrixlusolvefast(complex[,] lua, int[] p, int n, ref complex[] b, out int info, alglib.xparams _xparams)
    {
        _core_cmatrixlusolvefast( lua,  p,  n, ref  b, out  info, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_cmatrixmixedsolvem(complex[,] a, complex[,] lua, int[] p, int n, complex[,] b, int m, out int info, out densesolverreport rep, out complex[,] x, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_matrix _d_lua = new x_matrix();
        x_vector _d_p = new x_vector();
        x_int _d_n = new x_int(n);
        x_matrix _d_b = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_info = new x_int();
        x_densesolverreport _d_rep = new x_densesolverreport();
        x_matrix _d_x = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a, _fp_lua = lua, _fp_b = b){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matrix_attach_to_array(ref _d_lua, _fp_lua, ap.rows(lua), ap.cols(lua));
                x_vector_from_array(ref _d_p, p, X_CREATE);
                x_matrix_attach_to_array(ref _d_b, _fp_b, ap.rows(b), ap.cols(b));
                x_densesolverreport_init(ref _d_rep);
                x_matrix_create_empty(ref _d_x, DT_COMPLEX);
                x = null;
                _error_code = _i_xv2_cmatrixmixedsolvem(&_s_errormsg, &_d_a, &_d_lua, &_d_p, &_d_n, &_d_b, &_d_m, &_d_info, &_d_rep, &_d_x, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "cmatrixmixedsolvem");
            info = _d_info.intval;
            rep = null;
            x_densesolverreport_to_record(ref _d_rep, ref rep);
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_x, ref x);
            if( x == null )
                x = new alglib.complex[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matrix_clear(ref _d_lua);
            x_vector_clear(ref _d_p);
            x_matrix_clear(ref _d_b);
            x_densesolverreport_clear(ref _d_rep);
            x_matrix_clear(ref _d_x);
        }
        // This function returns no value.
    }
    
    public static void cmatrixmixedsolvem(complex[,] a, complex[,] lua, int[] p, int n, complex[,] b, int m, out int info, out densesolverreport rep, out complex[,] x)
    {
        _core_cmatrixmixedsolvem( a,  lua,  p,  n,  b,  m, out  info, out  rep, out  x, 0x0);
    }
    
    public static void cmatrixmixedsolvem(complex[,] a, complex[,] lua, int[] p, int n, complex[,] b, int m, out int info, out densesolverreport rep, out complex[,] x, alglib.xparams _xparams)
    {
        _core_cmatrixmixedsolvem( a,  lua,  p,  n,  b,  m, out  info, out  rep, out  x, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_cmatrixmixedsolve(complex[,] a, complex[,] lua, int[] p, int n, complex[] b, out int info, out densesolverreport rep, out complex[] x, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_matrix _d_lua = new x_matrix();
        x_vector _d_p = new x_vector();
        x_int _d_n = new x_int(n);
        x_vector _d_b = new x_vector();
        x_int _d_info = new x_int();
        x_densesolverreport _d_rep = new x_densesolverreport();
        x_vector _d_x = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a, _fp_lua = lua, _fp_b = b){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matrix_attach_to_array(ref _d_lua, _fp_lua, ap.rows(lua), ap.cols(lua));
                x_vector_from_array(ref _d_p, p, X_CREATE);
                x_vector_attach_to_array(ref _d_b, _fp_b, ap.len(b));
                x_densesolverreport_init(ref _d_rep);
                x_vector_create_empty(ref _d_x, DT_COMPLEX);
                x = null;
                _error_code = _i_xv2_cmatrixmixedsolve(&_s_errormsg, &_d_a, &_d_lua, &_d_p, &_d_n, &_d_b, &_d_info, &_d_rep, &_d_x, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "cmatrixmixedsolve");
            info = _d_info.intval;
            rep = null;
            x_densesolverreport_to_record(ref _d_rep, ref rep);
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new alglib.complex[0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matrix_clear(ref _d_lua);
            x_vector_clear(ref _d_p);
            x_vector_clear(ref _d_b);
            x_densesolverreport_clear(ref _d_rep);
            x_vector_clear(ref _d_x);
        }
        // This function returns no value.
    }
    
    public static void cmatrixmixedsolve(complex[,] a, complex[,] lua, int[] p, int n, complex[] b, out int info, out densesolverreport rep, out complex[] x)
    {
        _core_cmatrixmixedsolve( a,  lua,  p,  n,  b, out  info, out  rep, out  x, 0x0);
    }
    
    public static void cmatrixmixedsolve(complex[,] a, complex[,] lua, int[] p, int n, complex[] b, out int info, out densesolverreport rep, out complex[] x, alglib.xparams _xparams)
    {
        _core_cmatrixmixedsolve( a,  lua,  p,  n,  b, out  info, out  rep, out  x, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_spdmatrixsolvem(double[,] a, int n, bool isupper, double[,] b, int m, out int info, out densesolverreport rep, out double[,] x, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_matrix _d_b = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_info = new x_int();
        x_densesolverreport _d_rep = new x_densesolverreport();
        x_matrix _d_x = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a, _fp_b = b){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matrix_attach_to_array(ref _d_b, _fp_b, ap.rows(b), ap.cols(b));
                x_densesolverreport_init(ref _d_rep);
                x_matrix_create_empty(ref _d_x, DT_REAL);
                x = null;
                _error_code = _i_xv2_spdmatrixsolvem(&_s_errormsg, &_d_a, &_d_n, &_d_isupper, &_d_b, &_d_m, &_d_info, &_d_rep, &_d_x, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spdmatrixsolvem");
            info = _d_info.intval;
            rep = null;
            x_densesolverreport_to_record(ref _d_rep, ref rep);
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matrix_clear(ref _d_b);
            x_densesolverreport_clear(ref _d_rep);
            x_matrix_clear(ref _d_x);
        }
        // This function returns no value.
    }
    
    public static void spdmatrixsolvem(double[,] a, int n, bool isupper, double[,] b, int m, out int info, out densesolverreport rep, out double[,] x)
    {
        _core_spdmatrixsolvem( a,  n,  isupper,  b,  m, out  info, out  rep, out  x, 0x0);
    }
    
    public static void spdmatrixsolvem(double[,] a, int n, bool isupper, double[,] b, int m, out int info, out densesolverreport rep, out double[,] x, alglib.xparams _xparams)
    {
        _core_spdmatrixsolvem( a,  n,  isupper,  b,  m, out  info, out  rep, out  x, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_spdmatrixsolvemfast(double[,] a, int n, bool isupper, ref double[,] b, int m, out int info, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_matrix _d_b = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_info = new x_int();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a, _fp_b = b){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matrix_attach_to_array(ref _d_b, _fp_b, ap.rows(b), ap.cols(b));
                _error_code = _i_xv2_spdmatrixsolvemfast(&_s_errormsg, &_d_a, &_d_n, &_d_isupper, &_d_b, &_d_m, &_d_info, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spdmatrixsolvemfast");
            if( _d_b.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_b, ref b);
            if( b == null )
                b = new double[0,0];
            info = _d_info.intval;
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matrix_clear(ref _d_b);
        }
        // This function returns no value.
    }
    
    public static void spdmatrixsolvemfast(double[,] a, int n, bool isupper, ref double[,] b, int m, out int info)
    {
        _core_spdmatrixsolvemfast( a,  n,  isupper, ref  b,  m, out  info, 0x0);
    }
    
    public static void spdmatrixsolvemfast(double[,] a, int n, bool isupper, ref double[,] b, int m, out int info, alglib.xparams _xparams)
    {
        _core_spdmatrixsolvemfast( a,  n,  isupper, ref  b,  m, out  info, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_spdmatrixsolve(double[,] a, int n, bool isupper, double[] b, out int info, out densesolverreport rep, out double[] x, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_vector _d_b = new x_vector();
        x_int _d_info = new x_int();
        x_densesolverreport _d_rep = new x_densesolverreport();
        x_vector _d_x = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a, _fp_b = b){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_attach_to_array(ref _d_b, _fp_b, ap.len(b));
                x_densesolverreport_init(ref _d_rep);
                x_vector_create_empty(ref _d_x, DT_REAL);
                x = null;
                _error_code = _i_xv2_spdmatrixsolve(&_s_errormsg, &_d_a, &_d_n, &_d_isupper, &_d_b, &_d_info, &_d_rep, &_d_x, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spdmatrixsolve");
            info = _d_info.intval;
            rep = null;
            x_densesolverreport_to_record(ref _d_rep, ref rep);
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_b);
            x_densesolverreport_clear(ref _d_rep);
            x_vector_clear(ref _d_x);
        }
        // This function returns no value.
    }
    
    public static void spdmatrixsolve(double[,] a, int n, bool isupper, double[] b, out int info, out densesolverreport rep, out double[] x)
    {
        _core_spdmatrixsolve( a,  n,  isupper,  b, out  info, out  rep, out  x, 0x0);
    }
    
    public static void spdmatrixsolve(double[,] a, int n, bool isupper, double[] b, out int info, out densesolverreport rep, out double[] x, alglib.xparams _xparams)
    {
        _core_spdmatrixsolve( a,  n,  isupper,  b, out  info, out  rep, out  x, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_spdmatrixsolvefast(double[,] a, int n, bool isupper, ref double[] b, out int info, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_vector _d_b = new x_vector();
        x_int _d_info = new x_int();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a, _fp_b = b){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_attach_to_array(ref _d_b, _fp_b, ap.len(b));
                _error_code = _i_xv2_spdmatrixsolvefast(&_s_errormsg, &_d_a, &_d_n, &_d_isupper, &_d_b, &_d_info, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spdmatrixsolvefast");
            if( _d_b.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_b, ref b);
            if( b == null )
                b = new double[0];
            info = _d_info.intval;
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_b);
        }
        // This function returns no value.
    }
    
    public static void spdmatrixsolvefast(double[,] a, int n, bool isupper, ref double[] b, out int info)
    {
        _core_spdmatrixsolvefast( a,  n,  isupper, ref  b, out  info, 0x0);
    }
    
    public static void spdmatrixsolvefast(double[,] a, int n, bool isupper, ref double[] b, out int info, alglib.xparams _xparams)
    {
        _core_spdmatrixsolvefast( a,  n,  isupper, ref  b, out  info, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_spdmatrixcholeskysolvem(double[,] cha, int n, bool isupper, double[,] b, int m, out int info, out densesolverreport rep, out double[,] x, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_cha = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_matrix _d_b = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_info = new x_int();
        x_densesolverreport _d_rep = new x_densesolverreport();
        x_matrix _d_x = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_cha = cha, _fp_b = b){
                x_matrix_attach_to_array(ref _d_cha, _fp_cha, ap.rows(cha), ap.cols(cha));
                x_matrix_attach_to_array(ref _d_b, _fp_b, ap.rows(b), ap.cols(b));
                x_densesolverreport_init(ref _d_rep);
                x_matrix_create_empty(ref _d_x, DT_REAL);
                x = null;
                _error_code = _i_xv2_spdmatrixcholeskysolvem(&_s_errormsg, &_d_cha, &_d_n, &_d_isupper, &_d_b, &_d_m, &_d_info, &_d_rep, &_d_x, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spdmatrixcholeskysolvem");
            info = _d_info.intval;
            rep = null;
            x_densesolverreport_to_record(ref _d_rep, ref rep);
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_cha);
            x_matrix_clear(ref _d_b);
            x_densesolverreport_clear(ref _d_rep);
            x_matrix_clear(ref _d_x);
        }
        // This function returns no value.
    }
    
    public static void spdmatrixcholeskysolvem(double[,] cha, int n, bool isupper, double[,] b, int m, out int info, out densesolverreport rep, out double[,] x)
    {
        _core_spdmatrixcholeskysolvem( cha,  n,  isupper,  b,  m, out  info, out  rep, out  x, 0x0);
    }
    
    public static void spdmatrixcholeskysolvem(double[,] cha, int n, bool isupper, double[,] b, int m, out int info, out densesolverreport rep, out double[,] x, alglib.xparams _xparams)
    {
        _core_spdmatrixcholeskysolvem( cha,  n,  isupper,  b,  m, out  info, out  rep, out  x, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_spdmatrixcholeskysolvemfast(double[,] cha, int n, bool isupper, ref double[,] b, int m, out int info, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_cha = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_matrix _d_b = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_info = new x_int();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_cha = cha, _fp_b = b){
                x_matrix_attach_to_array(ref _d_cha, _fp_cha, ap.rows(cha), ap.cols(cha));
                x_matrix_attach_to_array(ref _d_b, _fp_b, ap.rows(b), ap.cols(b));
                _error_code = _i_xv2_spdmatrixcholeskysolvemfast(&_s_errormsg, &_d_cha, &_d_n, &_d_isupper, &_d_b, &_d_m, &_d_info, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spdmatrixcholeskysolvemfast");
            if( _d_b.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_b, ref b);
            if( b == null )
                b = new double[0,0];
            info = _d_info.intval;
        }
        finally
        {
            x_matrix_clear(ref _d_cha);
            x_matrix_clear(ref _d_b);
        }
        // This function returns no value.
    }
    
    public static void spdmatrixcholeskysolvemfast(double[,] cha, int n, bool isupper, ref double[,] b, int m, out int info)
    {
        _core_spdmatrixcholeskysolvemfast( cha,  n,  isupper, ref  b,  m, out  info, 0x0);
    }
    
    public static void spdmatrixcholeskysolvemfast(double[,] cha, int n, bool isupper, ref double[,] b, int m, out int info, alglib.xparams _xparams)
    {
        _core_spdmatrixcholeskysolvemfast( cha,  n,  isupper, ref  b,  m, out  info, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_spdmatrixcholeskysolve(double[,] cha, int n, bool isupper, double[] b, out int info, out densesolverreport rep, out double[] x, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_cha = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_vector _d_b = new x_vector();
        x_int _d_info = new x_int();
        x_densesolverreport _d_rep = new x_densesolverreport();
        x_vector _d_x = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_cha = cha, _fp_b = b){
                x_matrix_attach_to_array(ref _d_cha, _fp_cha, ap.rows(cha), ap.cols(cha));
                x_vector_attach_to_array(ref _d_b, _fp_b, ap.len(b));
                x_densesolverreport_init(ref _d_rep);
                x_vector_create_empty(ref _d_x, DT_REAL);
                x = null;
                _error_code = _i_xv2_spdmatrixcholeskysolve(&_s_errormsg, &_d_cha, &_d_n, &_d_isupper, &_d_b, &_d_info, &_d_rep, &_d_x, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spdmatrixcholeskysolve");
            info = _d_info.intval;
            rep = null;
            x_densesolverreport_to_record(ref _d_rep, ref rep);
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
        }
        finally
        {
            x_matrix_clear(ref _d_cha);
            x_vector_clear(ref _d_b);
            x_densesolverreport_clear(ref _d_rep);
            x_vector_clear(ref _d_x);
        }
        // This function returns no value.
    }
    
    public static void spdmatrixcholeskysolve(double[,] cha, int n, bool isupper, double[] b, out int info, out densesolverreport rep, out double[] x)
    {
        _core_spdmatrixcholeskysolve( cha,  n,  isupper,  b, out  info, out  rep, out  x, 0x0);
    }
    
    public static void spdmatrixcholeskysolve(double[,] cha, int n, bool isupper, double[] b, out int info, out densesolverreport rep, out double[] x, alglib.xparams _xparams)
    {
        _core_spdmatrixcholeskysolve( cha,  n,  isupper,  b, out  info, out  rep, out  x, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_spdmatrixcholeskysolvefast(double[,] cha, int n, bool isupper, ref double[] b, out int info, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_cha = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_vector _d_b = new x_vector();
        x_int _d_info = new x_int();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_cha = cha, _fp_b = b){
                x_matrix_attach_to_array(ref _d_cha, _fp_cha, ap.rows(cha), ap.cols(cha));
                x_vector_attach_to_array(ref _d_b, _fp_b, ap.len(b));
                _error_code = _i_xv2_spdmatrixcholeskysolvefast(&_s_errormsg, &_d_cha, &_d_n, &_d_isupper, &_d_b, &_d_info, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spdmatrixcholeskysolvefast");
            if( _d_b.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_b, ref b);
            if( b == null )
                b = new double[0];
            info = _d_info.intval;
        }
        finally
        {
            x_matrix_clear(ref _d_cha);
            x_vector_clear(ref _d_b);
        }
        // This function returns no value.
    }
    
    public static void spdmatrixcholeskysolvefast(double[,] cha, int n, bool isupper, ref double[] b, out int info)
    {
        _core_spdmatrixcholeskysolvefast( cha,  n,  isupper, ref  b, out  info, 0x0);
    }
    
    public static void spdmatrixcholeskysolvefast(double[,] cha, int n, bool isupper, ref double[] b, out int info, alglib.xparams _xparams)
    {
        _core_spdmatrixcholeskysolvefast( cha,  n,  isupper, ref  b, out  info, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_hpdmatrixsolvem(complex[,] a, int n, bool isupper, complex[,] b, int m, out int info, out densesolverreport rep, out complex[,] x, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_matrix _d_b = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_info = new x_int();
        x_densesolverreport _d_rep = new x_densesolverreport();
        x_matrix _d_x = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a, _fp_b = b){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matrix_attach_to_array(ref _d_b, _fp_b, ap.rows(b), ap.cols(b));
                x_densesolverreport_init(ref _d_rep);
                x_matrix_create_empty(ref _d_x, DT_COMPLEX);
                x = null;
                _error_code = _i_xv2_hpdmatrixsolvem(&_s_errormsg, &_d_a, &_d_n, &_d_isupper, &_d_b, &_d_m, &_d_info, &_d_rep, &_d_x, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "hpdmatrixsolvem");
            info = _d_info.intval;
            rep = null;
            x_densesolverreport_to_record(ref _d_rep, ref rep);
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_x, ref x);
            if( x == null )
                x = new alglib.complex[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matrix_clear(ref _d_b);
            x_densesolverreport_clear(ref _d_rep);
            x_matrix_clear(ref _d_x);
        }
        // This function returns no value.
    }
    
    public static void hpdmatrixsolvem(complex[,] a, int n, bool isupper, complex[,] b, int m, out int info, out densesolverreport rep, out complex[,] x)
    {
        _core_hpdmatrixsolvem( a,  n,  isupper,  b,  m, out  info, out  rep, out  x, 0x0);
    }
    
    public static void hpdmatrixsolvem(complex[,] a, int n, bool isupper, complex[,] b, int m, out int info, out densesolverreport rep, out complex[,] x, alglib.xparams _xparams)
    {
        _core_hpdmatrixsolvem( a,  n,  isupper,  b,  m, out  info, out  rep, out  x, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_hpdmatrixsolvemfast(complex[,] a, int n, bool isupper, ref complex[,] b, int m, out int info, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_matrix _d_b = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_info = new x_int();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a, _fp_b = b){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matrix_attach_to_array(ref _d_b, _fp_b, ap.rows(b), ap.cols(b));
                _error_code = _i_xv2_hpdmatrixsolvemfast(&_s_errormsg, &_d_a, &_d_n, &_d_isupper, &_d_b, &_d_m, &_d_info, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "hpdmatrixsolvemfast");
            if( _d_b.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_b, ref b);
            if( b == null )
                b = new alglib.complex[0,0];
            info = _d_info.intval;
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matrix_clear(ref _d_b);
        }
        // This function returns no value.
    }
    
    public static void hpdmatrixsolvemfast(complex[,] a, int n, bool isupper, ref complex[,] b, int m, out int info)
    {
        _core_hpdmatrixsolvemfast( a,  n,  isupper, ref  b,  m, out  info, 0x0);
    }
    
    public static void hpdmatrixsolvemfast(complex[,] a, int n, bool isupper, ref complex[,] b, int m, out int info, alglib.xparams _xparams)
    {
        _core_hpdmatrixsolvemfast( a,  n,  isupper, ref  b,  m, out  info, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_hpdmatrixsolve(complex[,] a, int n, bool isupper, complex[] b, out int info, out densesolverreport rep, out complex[] x, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_vector _d_b = new x_vector();
        x_int _d_info = new x_int();
        x_densesolverreport _d_rep = new x_densesolverreport();
        x_vector _d_x = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a, _fp_b = b){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_attach_to_array(ref _d_b, _fp_b, ap.len(b));
                x_densesolverreport_init(ref _d_rep);
                x_vector_create_empty(ref _d_x, DT_COMPLEX);
                x = null;
                _error_code = _i_xv2_hpdmatrixsolve(&_s_errormsg, &_d_a, &_d_n, &_d_isupper, &_d_b, &_d_info, &_d_rep, &_d_x, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "hpdmatrixsolve");
            info = _d_info.intval;
            rep = null;
            x_densesolverreport_to_record(ref _d_rep, ref rep);
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new alglib.complex[0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_b);
            x_densesolverreport_clear(ref _d_rep);
            x_vector_clear(ref _d_x);
        }
        // This function returns no value.
    }
    
    public static void hpdmatrixsolve(complex[,] a, int n, bool isupper, complex[] b, out int info, out densesolverreport rep, out complex[] x)
    {
        _core_hpdmatrixsolve( a,  n,  isupper,  b, out  info, out  rep, out  x, 0x0);
    }
    
    public static void hpdmatrixsolve(complex[,] a, int n, bool isupper, complex[] b, out int info, out densesolverreport rep, out complex[] x, alglib.xparams _xparams)
    {
        _core_hpdmatrixsolve( a,  n,  isupper,  b, out  info, out  rep, out  x, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_hpdmatrixsolvefast(complex[,] a, int n, bool isupper, ref complex[] b, out int info, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_vector _d_b = new x_vector();
        x_int _d_info = new x_int();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a, _fp_b = b){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_attach_to_array(ref _d_b, _fp_b, ap.len(b));
                _error_code = _i_xv2_hpdmatrixsolvefast(&_s_errormsg, &_d_a, &_d_n, &_d_isupper, &_d_b, &_d_info, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "hpdmatrixsolvefast");
            if( _d_b.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_b, ref b);
            if( b == null )
                b = new alglib.complex[0];
            info = _d_info.intval;
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_b);
        }
        // This function returns no value.
    }
    
    public static void hpdmatrixsolvefast(complex[,] a, int n, bool isupper, ref complex[] b, out int info)
    {
        _core_hpdmatrixsolvefast( a,  n,  isupper, ref  b, out  info, 0x0);
    }
    
    public static void hpdmatrixsolvefast(complex[,] a, int n, bool isupper, ref complex[] b, out int info, alglib.xparams _xparams)
    {
        _core_hpdmatrixsolvefast( a,  n,  isupper, ref  b, out  info, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_hpdmatrixcholeskysolvem(complex[,] cha, int n, bool isupper, complex[,] b, int m, out int info, out densesolverreport rep, out complex[,] x, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_cha = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_matrix _d_b = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_info = new x_int();
        x_densesolverreport _d_rep = new x_densesolverreport();
        x_matrix _d_x = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_cha = cha, _fp_b = b){
                x_matrix_attach_to_array(ref _d_cha, _fp_cha, ap.rows(cha), ap.cols(cha));
                x_matrix_attach_to_array(ref _d_b, _fp_b, ap.rows(b), ap.cols(b));
                x_densesolverreport_init(ref _d_rep);
                x_matrix_create_empty(ref _d_x, DT_COMPLEX);
                x = null;
                _error_code = _i_xv2_hpdmatrixcholeskysolvem(&_s_errormsg, &_d_cha, &_d_n, &_d_isupper, &_d_b, &_d_m, &_d_info, &_d_rep, &_d_x, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "hpdmatrixcholeskysolvem");
            info = _d_info.intval;
            rep = null;
            x_densesolverreport_to_record(ref _d_rep, ref rep);
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_x, ref x);
            if( x == null )
                x = new alglib.complex[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_cha);
            x_matrix_clear(ref _d_b);
            x_densesolverreport_clear(ref _d_rep);
            x_matrix_clear(ref _d_x);
        }
        // This function returns no value.
    }
    
    public static void hpdmatrixcholeskysolvem(complex[,] cha, int n, bool isupper, complex[,] b, int m, out int info, out densesolverreport rep, out complex[,] x)
    {
        _core_hpdmatrixcholeskysolvem( cha,  n,  isupper,  b,  m, out  info, out  rep, out  x, 0x0);
    }
    
    public static void hpdmatrixcholeskysolvem(complex[,] cha, int n, bool isupper, complex[,] b, int m, out int info, out densesolverreport rep, out complex[,] x, alglib.xparams _xparams)
    {
        _core_hpdmatrixcholeskysolvem( cha,  n,  isupper,  b,  m, out  info, out  rep, out  x, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_hpdmatrixcholeskysolvemfast(complex[,] cha, int n, bool isupper, ref complex[,] b, int m, out int info, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_cha = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_matrix _d_b = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_info = new x_int();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_cha = cha, _fp_b = b){
                x_matrix_attach_to_array(ref _d_cha, _fp_cha, ap.rows(cha), ap.cols(cha));
                x_matrix_attach_to_array(ref _d_b, _fp_b, ap.rows(b), ap.cols(b));
                _error_code = _i_xv2_hpdmatrixcholeskysolvemfast(&_s_errormsg, &_d_cha, &_d_n, &_d_isupper, &_d_b, &_d_m, &_d_info, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "hpdmatrixcholeskysolvemfast");
            if( _d_b.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_b, ref b);
            if( b == null )
                b = new alglib.complex[0,0];
            info = _d_info.intval;
        }
        finally
        {
            x_matrix_clear(ref _d_cha);
            x_matrix_clear(ref _d_b);
        }
        // This function returns no value.
    }
    
    public static void hpdmatrixcholeskysolvemfast(complex[,] cha, int n, bool isupper, ref complex[,] b, int m, out int info)
    {
        _core_hpdmatrixcholeskysolvemfast( cha,  n,  isupper, ref  b,  m, out  info, 0x0);
    }
    
    public static void hpdmatrixcholeskysolvemfast(complex[,] cha, int n, bool isupper, ref complex[,] b, int m, out int info, alglib.xparams _xparams)
    {
        _core_hpdmatrixcholeskysolvemfast( cha,  n,  isupper, ref  b,  m, out  info, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_hpdmatrixcholeskysolve(complex[,] cha, int n, bool isupper, complex[] b, out int info, out densesolverreport rep, out complex[] x, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_cha = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_vector _d_b = new x_vector();
        x_int _d_info = new x_int();
        x_densesolverreport _d_rep = new x_densesolverreport();
        x_vector _d_x = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_cha = cha, _fp_b = b){
                x_matrix_attach_to_array(ref _d_cha, _fp_cha, ap.rows(cha), ap.cols(cha));
                x_vector_attach_to_array(ref _d_b, _fp_b, ap.len(b));
                x_densesolverreport_init(ref _d_rep);
                x_vector_create_empty(ref _d_x, DT_COMPLEX);
                x = null;
                _error_code = _i_xv2_hpdmatrixcholeskysolve(&_s_errormsg, &_d_cha, &_d_n, &_d_isupper, &_d_b, &_d_info, &_d_rep, &_d_x, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "hpdmatrixcholeskysolve");
            info = _d_info.intval;
            rep = null;
            x_densesolverreport_to_record(ref _d_rep, ref rep);
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new alglib.complex[0];
        }
        finally
        {
            x_matrix_clear(ref _d_cha);
            x_vector_clear(ref _d_b);
            x_densesolverreport_clear(ref _d_rep);
            x_vector_clear(ref _d_x);
        }
        // This function returns no value.
    }
    
    public static void hpdmatrixcholeskysolve(complex[,] cha, int n, bool isupper, complex[] b, out int info, out densesolverreport rep, out complex[] x)
    {
        _core_hpdmatrixcholeskysolve( cha,  n,  isupper,  b, out  info, out  rep, out  x, 0x0);
    }
    
    public static void hpdmatrixcholeskysolve(complex[,] cha, int n, bool isupper, complex[] b, out int info, out densesolverreport rep, out complex[] x, alglib.xparams _xparams)
    {
        _core_hpdmatrixcholeskysolve( cha,  n,  isupper,  b, out  info, out  rep, out  x, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_hpdmatrixcholeskysolvefast(complex[,] cha, int n, bool isupper, ref complex[] b, out int info, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_cha = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_vector _d_b = new x_vector();
        x_int _d_info = new x_int();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_cha = cha, _fp_b = b){
                x_matrix_attach_to_array(ref _d_cha, _fp_cha, ap.rows(cha), ap.cols(cha));
                x_vector_attach_to_array(ref _d_b, _fp_b, ap.len(b));
                _error_code = _i_xv2_hpdmatrixcholeskysolvefast(&_s_errormsg, &_d_cha, &_d_n, &_d_isupper, &_d_b, &_d_info, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "hpdmatrixcholeskysolvefast");
            if( _d_b.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_b, ref b);
            if( b == null )
                b = new alglib.complex[0];
            info = _d_info.intval;
        }
        finally
        {
            x_matrix_clear(ref _d_cha);
            x_vector_clear(ref _d_b);
        }
        // This function returns no value.
    }
    
    public static void hpdmatrixcholeskysolvefast(complex[,] cha, int n, bool isupper, ref complex[] b, out int info)
    {
        _core_hpdmatrixcholeskysolvefast( cha,  n,  isupper, ref  b, out  info, 0x0);
    }
    
    public static void hpdmatrixcholeskysolvefast(complex[,] cha, int n, bool isupper, ref complex[] b, out int info, alglib.xparams _xparams)
    {
        _core_hpdmatrixcholeskysolvefast( cha,  n,  isupper, ref  b, out  info, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_rmatrixsolvels(double[,] a, int nrows, int ncols, double[] b, double threshold, out int info, out densesolverlsreport rep, out double[] x, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_nrows = new x_int(nrows);
        x_int _d_ncols = new x_int(ncols);
        x_vector _d_b = new x_vector();
        double _d_threshold = threshold;
        x_int _d_info = new x_int();
        x_densesolverlsreport _d_rep = new x_densesolverlsreport();
        x_vector _d_x = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a, _fp_b = b){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_attach_to_array(ref _d_b, _fp_b, ap.len(b));
                x_densesolverlsreport_init(ref _d_rep);
                x_vector_create_empty(ref _d_x, DT_REAL);
                x = null;
                _error_code = _i_xv2_rmatrixsolvels(&_s_errormsg, &_d_a, &_d_nrows, &_d_ncols, &_d_b, &_d_threshold, &_d_info, &_d_rep, &_d_x, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rmatrixsolvels");
            info = _d_info.intval;
            rep = null;
            x_densesolverlsreport_to_record(ref _d_rep, ref rep);
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_b);
            x_densesolverlsreport_clear(ref _d_rep);
            x_vector_clear(ref _d_x);
        }
        // This function returns no value.
    }
    
    public static void rmatrixsolvels(double[,] a, int nrows, int ncols, double[] b, double threshold, out int info, out densesolverlsreport rep, out double[] x)
    {
        _core_rmatrixsolvels( a,  nrows,  ncols,  b,  threshold, out  info, out  rep, out  x, 0x0);
    }
    
    public static void rmatrixsolvels(double[,] a, int nrows, int ncols, double[] b, double threshold, out int info, out densesolverlsreport rep, out double[] x, alglib.xparams _xparams)
    {
        _core_rmatrixsolvels( a,  nrows,  ncols,  b,  threshold, out  info, out  rep, out  x, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage directsparsesolvers
    //
    

    [StructLayout(LayoutKind.Sequential, Pack=8)]
    private struct x_sparsesolverreport
    {
        public x_int terminationtype;
        public x_int nmv;
        public x_int iterationscount;
        public double r2;
    }

    public class sparsesolverreport : alglibobject
    {
        public int terminationtype;
        public int nmv;
        public int iterationscount;
        public double r2;
        public override alglib.alglibobject make_copy()
        {
            sparsesolverreport dst = new sparsesolverreport();
            dst.terminationtype = terminationtype;
            dst.nmv = nmv;
            dst.iterationscount = iterationscount;
            dst.r2 = r2;
            return dst;
        }
    }

    // This function initializes X-structure (its previous content is ignored)
    private static void x_sparsesolverreport_init(ref x_sparsesolverreport x)
    {
        x.terminationtype.longval = 0;
        x.nmv.longval = 0;
        x.iterationscount.longval = 0;
        x.r2 = 0;
    }

    // This function finalizes fields of X-structure (however, memory occupied by structure itself is not freed)
    // After destruction structure becomes unusable and should be re-initialized if you want to use it
    private static void x_sparsesolverreport_clear(ref x_sparsesolverreport x)
    {
    }

    // This function initializes X-structure by appropriate C# instance
    // (previous content of X structure is ignored)
    private static void x_sparsesolverreport_init_from(ref x_sparsesolverreport x, sparsesolverreport v)
    {
        x.terminationtype.longval = v.terminationtype;
        x.nmv.longval = v.nmv;
        x.iterationscount.longval = v.iterationscount;
        x.r2 = v.r2;
    }

    // This function initializes C# structure by appropriate X instance
    // (previous content of C# structure is ignored).
    // This function may accept null v, in this case v is automatically allocated with new().
    private static void x_sparsesolverreport_to_record(ref x_sparsesolverreport x, ref sparsesolverreport v)
    {
        if( v==null )
            v = new sparsesolverreport();
        v.terminationtype = x.terminationtype.intval; // long is silently truncated to int
        v.nmv = x.nmv.intval; // long is silently truncated to int
        v.iterationscount = x.iterationscount.intval; // long is silently truncated to int
        v.r2 = x.r2;
    }
    
    private static unsafe void _core_sparsespdsolvesks(sparsematrix a, bool isupper, double[] b, out double[] x, out sparsesolverreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_a = a.ptr;
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_vector _d_b = new x_vector();
        x_vector _d_x = new x_vector();
        x_sparsesolverreport _d_rep = new x_sparsesolverreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_b = b){
                x_vector_attach_to_array(ref _d_b, _fp_b, ap.len(b));
                x_vector_create_empty(ref _d_x, DT_REAL);
                x = null;
                x_sparsesolverreport_init(ref _d_rep);
                _error_code = _i_xv2_sparsespdsolvesks(&_s_errormsg, &_d_a, &_d_isupper, &_d_b, &_d_x, &_d_rep, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparsespdsolvesks");
            ap.assert(a.ptr==_d_a, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
            rep = null;
            x_sparsesolverreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_b);
            x_vector_clear(ref _d_x);
            x_sparsesolverreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void sparsespdsolvesks(sparsematrix a, bool isupper, double[] b, out double[] x, out sparsesolverreport rep)
    {
        _core_sparsespdsolvesks( a,  isupper,  b, out  x, out  rep, 0x0);
    }
    
    public static void sparsespdsolvesks(sparsematrix a, bool isupper, double[] b, out double[] x, out sparsesolverreport rep, alglib.xparams _xparams)
    {
        _core_sparsespdsolvesks( a,  isupper,  b, out  x, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_sparsespdsolve(sparsematrix a, bool isupper, double[] b, out double[] x, out sparsesolverreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_a = a.ptr;
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_vector _d_b = new x_vector();
        x_vector _d_x = new x_vector();
        x_sparsesolverreport _d_rep = new x_sparsesolverreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_b = b){
                x_vector_attach_to_array(ref _d_b, _fp_b, ap.len(b));
                x_vector_create_empty(ref _d_x, DT_REAL);
                x = null;
                x_sparsesolverreport_init(ref _d_rep);
                _error_code = _i_xv2_sparsespdsolve(&_s_errormsg, &_d_a, &_d_isupper, &_d_b, &_d_x, &_d_rep, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparsespdsolve");
            ap.assert(a.ptr==_d_a, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
            rep = null;
            x_sparsesolverreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_b);
            x_vector_clear(ref _d_x);
            x_sparsesolverreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void sparsespdsolve(sparsematrix a, bool isupper, double[] b, out double[] x, out sparsesolverreport rep)
    {
        _core_sparsespdsolve( a,  isupper,  b, out  x, out  rep, 0x0);
    }
    
    public static void sparsespdsolve(sparsematrix a, bool isupper, double[] b, out double[] x, out sparsesolverreport rep, alglib.xparams _xparams)
    {
        _core_sparsespdsolve( a,  isupper,  b, out  x, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_sparsespdcholeskysolve(sparsematrix a, bool isupper, double[] b, out double[] x, out sparsesolverreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_a = a.ptr;
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_vector _d_b = new x_vector();
        x_vector _d_x = new x_vector();
        x_sparsesolverreport _d_rep = new x_sparsesolverreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_b = b){
                x_vector_attach_to_array(ref _d_b, _fp_b, ap.len(b));
                x_vector_create_empty(ref _d_x, DT_REAL);
                x = null;
                x_sparsesolverreport_init(ref _d_rep);
                _error_code = _i_xv2_sparsespdcholeskysolve(&_s_errormsg, &_d_a, &_d_isupper, &_d_b, &_d_x, &_d_rep, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparsespdcholeskysolve");
            ap.assert(a.ptr==_d_a, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
            rep = null;
            x_sparsesolverreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_b);
            x_vector_clear(ref _d_x);
            x_sparsesolverreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void sparsespdcholeskysolve(sparsematrix a, bool isupper, double[] b, out double[] x, out sparsesolverreport rep)
    {
        _core_sparsespdcholeskysolve( a,  isupper,  b, out  x, out  rep, 0x0);
    }
    
    public static void sparsespdcholeskysolve(sparsematrix a, bool isupper, double[] b, out double[] x, out sparsesolverreport rep, alglib.xparams _xparams)
    {
        _core_sparsespdcholeskysolve( a,  isupper,  b, out  x, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_sparsesolve(sparsematrix a, double[] b, out double[] x, out sparsesolverreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_a = a.ptr;
        x_vector _d_b = new x_vector();
        x_vector _d_x = new x_vector();
        x_sparsesolverreport _d_rep = new x_sparsesolverreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_b = b){
                x_vector_attach_to_array(ref _d_b, _fp_b, ap.len(b));
                x_vector_create_empty(ref _d_x, DT_REAL);
                x = null;
                x_sparsesolverreport_init(ref _d_rep);
                _error_code = _i_xv2_sparsesolve(&_s_errormsg, &_d_a, &_d_b, &_d_x, &_d_rep, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparsesolve");
            ap.assert(a.ptr==_d_a, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
            rep = null;
            x_sparsesolverreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_b);
            x_vector_clear(ref _d_x);
            x_sparsesolverreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void sparsesolve(sparsematrix a, double[] b, out double[] x, out sparsesolverreport rep)
    {
        _core_sparsesolve( a,  b, out  x, out  rep, 0x0);
    }
    
    public static void sparsesolve(sparsematrix a, double[] b, out double[] x, out sparsesolverreport rep, alglib.xparams _xparams)
    {
        _core_sparsesolve( a,  b, out  x, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_sparselusolve(sparsematrix a, int[] p, int[] q, double[] b, out double[] x, out sparsesolverreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_a = a.ptr;
        x_vector _d_p = new x_vector();
        x_vector _d_q = new x_vector();
        x_vector _d_b = new x_vector();
        x_vector _d_x = new x_vector();
        x_sparsesolverreport _d_rep = new x_sparsesolverreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_b = b){
                x_vector_from_array(ref _d_p, p, X_CREATE);
                x_vector_from_array(ref _d_q, q, X_CREATE);
                x_vector_attach_to_array(ref _d_b, _fp_b, ap.len(b));
                x_vector_create_empty(ref _d_x, DT_REAL);
                x = null;
                x_sparsesolverreport_init(ref _d_rep);
                _error_code = _i_xv2_sparselusolve(&_s_errormsg, &_d_a, &_d_p, &_d_q, &_d_b, &_d_x, &_d_rep, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparselusolve");
            ap.assert(a.ptr==_d_a, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
            rep = null;
            x_sparsesolverreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_p);
            x_vector_clear(ref _d_q);
            x_vector_clear(ref _d_b);
            x_vector_clear(ref _d_x);
            x_sparsesolverreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void sparselusolve(sparsematrix a, int[] p, int[] q, double[] b, out double[] x, out sparsesolverreport rep)
    {
        _core_sparselusolve( a,  p,  q,  b, out  x, out  rep, 0x0);
    }
    
    public static void sparselusolve(sparsematrix a, int[] p, int[] q, double[] b, out double[] x, out sparsesolverreport rep, alglib.xparams _xparams)
    {
        _core_sparselusolve( a,  p,  q,  b, out  x, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage fbls
    //
    
    
    
    //
    // Subpackage iterativesparse
    //
    

    public unsafe class sparsesolverstate : alglibobject
    {
        private void *_ptr;
        public sparsesolverstate(void *x)
        {
            _ptr = x;
        }
        ~sparsesolverstate()
        {
            _deallocate();
        }
        public void* ptr { get { return _ptr; } }
        public override alglib.alglibobject make_copy()
        {
            if( _ptr==null )
                return new sparsesolverstate(null);
            return new sparsesolverstate(_i_x_obj_copy_sparsesolverstate(_ptr));
        }
        public override void _deallocate()
        {
            if( _ptr!=null )
                _i_x_obj_free_sparsesolverstate(_ptr);
            _ptr = null;
            System.GC.SuppressFinalize(this);
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_sparsesolverstate(void *x);
    private static _d_x_obj_copy_sparsesolverstate _i_x_obj_copy_sparsesolverstate = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_obj_free_sparsesolverstate(void *x);
    private static _d_x_obj_free_sparsesolverstate _i_x_obj_free_sparsesolverstate = null;
    
    private static unsafe void _core_sparsesolvesymmetricgmres(sparsematrix a, bool isupper, double[] b, int k, double epsf, int maxits, out double[] x, out sparsesolverreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_a = a.ptr;
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_vector _d_b = new x_vector();
        x_int _d_k = new x_int(k);
        double _d_epsf = epsf;
        x_int _d_maxits = new x_int(maxits);
        x_vector _d_x = new x_vector();
        x_sparsesolverreport _d_rep = new x_sparsesolverreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_b = b){
                x_vector_attach_to_array(ref _d_b, _fp_b, ap.len(b));
                x_vector_create_empty(ref _d_x, DT_REAL);
                x = null;
                x_sparsesolverreport_init(ref _d_rep);
                _error_code = _i_xv2_sparsesolvesymmetricgmres(&_s_errormsg, &_d_a, &_d_isupper, &_d_b, &_d_k, &_d_epsf, &_d_maxits, &_d_x, &_d_rep, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparsesolvesymmetricgmres");
            ap.assert(a.ptr==_d_a, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
            rep = null;
            x_sparsesolverreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_b);
            x_vector_clear(ref _d_x);
            x_sparsesolverreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void sparsesolvesymmetricgmres(sparsematrix a, bool isupper, double[] b, int k, double epsf, int maxits, out double[] x, out sparsesolverreport rep)
    {
        _core_sparsesolvesymmetricgmres( a,  isupper,  b,  k,  epsf,  maxits, out  x, out  rep, 0x0);
    }
    
    public static void sparsesolvesymmetricgmres(sparsematrix a, bool isupper, double[] b, int k, double epsf, int maxits, out double[] x, out sparsesolverreport rep, alglib.xparams _xparams)
    {
        _core_sparsesolvesymmetricgmres( a,  isupper,  b,  k,  epsf,  maxits, out  x, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_sparsesolvegmres(sparsematrix a, double[] b, int k, double epsf, int maxits, out double[] x, out sparsesolverreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_a = a.ptr;
        x_vector _d_b = new x_vector();
        x_int _d_k = new x_int(k);
        double _d_epsf = epsf;
        x_int _d_maxits = new x_int(maxits);
        x_vector _d_x = new x_vector();
        x_sparsesolverreport _d_rep = new x_sparsesolverreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_b = b){
                x_vector_attach_to_array(ref _d_b, _fp_b, ap.len(b));
                x_vector_create_empty(ref _d_x, DT_REAL);
                x = null;
                x_sparsesolverreport_init(ref _d_rep);
                _error_code = _i_xv2_sparsesolvegmres(&_s_errormsg, &_d_a, &_d_b, &_d_k, &_d_epsf, &_d_maxits, &_d_x, &_d_rep, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparsesolvegmres");
            ap.assert(a.ptr==_d_a, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
            rep = null;
            x_sparsesolverreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_b);
            x_vector_clear(ref _d_x);
            x_sparsesolverreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void sparsesolvegmres(sparsematrix a, double[] b, int k, double epsf, int maxits, out double[] x, out sparsesolverreport rep)
    {
        _core_sparsesolvegmres( a,  b,  k,  epsf,  maxits, out  x, out  rep, 0x0);
    }
    
    public static void sparsesolvegmres(sparsematrix a, double[] b, int k, double epsf, int maxits, out double[] x, out sparsesolverreport rep, alglib.xparams _xparams)
    {
        _core_sparsesolvegmres( a,  b,  k,  epsf,  maxits, out  x, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_sparsesolvercreate(int n, out sparsesolverstate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        void *_d_state = null;
        state = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_sparsesolvercreate(&_s_errormsg, &_d_n, &_d_state, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparsesolvercreate");
            state = new sparsesolverstate(_d_state);
        }
        finally
        {
            if( _d_state!=null && state==null)
                _i_x_obj_free_sparsesolverstate(_d_state); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void sparsesolvercreate(int n, out sparsesolverstate state)
    {
        _core_sparsesolvercreate( n, out  state, 0x0);
    }
    
    public static void sparsesolvercreate(int n, out sparsesolverstate state, alglib.xparams _xparams)
    {
        _core_sparsesolvercreate( n, out  state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_sparsesolversetalgogmres(sparsesolverstate state, int k, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_int _d_k = new x_int(k);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_sparsesolversetalgogmres(&_s_errormsg, &_d_state, &_d_k, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparsesolversetalgogmres");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void sparsesolversetalgogmres(sparsesolverstate state, int k)
    {
        _core_sparsesolversetalgogmres( state,  k, 0x0);
    }
    
    public static void sparsesolversetalgogmres(sparsesolverstate state, int k, alglib.xparams _xparams)
    {
        _core_sparsesolversetalgogmres( state,  k, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_sparsesolversetstartingpoint(sparsesolverstate state, double[] x, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_x = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_xv2_sparsesolversetstartingpoint(&_s_errormsg, &_d_state, &_d_x, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparsesolversetstartingpoint");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_x);
        }
        // This function returns no value.
    }
    
    public static void sparsesolversetstartingpoint(sparsesolverstate state, double[] x)
    {
        _core_sparsesolversetstartingpoint( state,  x, 0x0);
    }
    
    public static void sparsesolversetstartingpoint(sparsesolverstate state, double[] x, alglib.xparams _xparams)
    {
        _core_sparsesolversetstartingpoint( state,  x, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_sparsesolversetcond(sparsesolverstate state, double epsf, int maxits, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_epsf = epsf;
        x_int _d_maxits = new x_int(maxits);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_sparsesolversetcond(&_s_errormsg, &_d_state, &_d_epsf, &_d_maxits, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparsesolversetcond");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void sparsesolversetcond(sparsesolverstate state, double epsf, int maxits)
    {
        _core_sparsesolversetcond( state,  epsf,  maxits, 0x0);
    }
    
    public static void sparsesolversetcond(sparsesolverstate state, double epsf, int maxits, alglib.xparams _xparams)
    {
        _core_sparsesolversetcond( state,  epsf,  maxits, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_sparsesolversolvesymmetric(sparsesolverstate state, sparsematrix a, bool isupper, double[] b, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        void *_d_a = a.ptr;
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_vector _d_b = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_b = b){
                x_vector_attach_to_array(ref _d_b, _fp_b, ap.len(b));
                _error_code = _i_xv2_sparsesolversolvesymmetric(&_s_errormsg, &_d_state, &_d_a, &_d_isupper, &_d_b, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparsesolversolvesymmetric");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            ap.assert(a.ptr==_d_a, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_b);
        }
        // This function returns no value.
    }
    
    public static void sparsesolversolvesymmetric(sparsesolverstate state, sparsematrix a, bool isupper, double[] b)
    {
        _core_sparsesolversolvesymmetric( state,  a,  isupper,  b, 0x0);
    }
    
    public static void sparsesolversolvesymmetric(sparsesolverstate state, sparsematrix a, bool isupper, double[] b, alglib.xparams _xparams)
    {
        _core_sparsesolversolvesymmetric( state,  a,  isupper,  b, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_sparsesolversolve(sparsesolverstate state, sparsematrix a, double[] b, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        void *_d_a = a.ptr;
        x_vector _d_b = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_b = b){
                x_vector_attach_to_array(ref _d_b, _fp_b, ap.len(b));
                _error_code = _i_xv2_sparsesolversolve(&_s_errormsg, &_d_state, &_d_a, &_d_b, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparsesolversolve");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            ap.assert(a.ptr==_d_a, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_b);
        }
        // This function returns no value.
    }
    
    public static void sparsesolversolve(sparsesolverstate state, sparsematrix a, double[] b)
    {
        _core_sparsesolversolve( state,  a,  b, 0x0);
    }
    
    public static void sparsesolversolve(sparsesolverstate state, sparsematrix a, double[] b, alglib.xparams _xparams)
    {
        _core_sparsesolversolve( state,  a,  b, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_sparsesolverresults(sparsesolverstate state, out double[] x, out sparsesolverreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_x = new x_vector();
        x_sparsesolverreport _d_rep = new x_sparsesolverreport();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_x, DT_REAL);
            x = null;
            x_sparsesolverreport_init(ref _d_rep);
            _error_code = _i_xv2_sparsesolverresults(&_s_errormsg, &_d_state, &_d_x, &_d_rep, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparsesolverresults");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
            rep = null;
            x_sparsesolverreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_sparsesolverreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void sparsesolverresults(sparsesolverstate state, out double[] x, out sparsesolverreport rep)
    {
        _core_sparsesolverresults( state, out  x, out  rep, 0x0);
    }
    
    public static void sparsesolverresults(sparsesolverstate state, out double[] x, out sparsesolverreport rep, alglib.xparams _xparams)
    {
        _core_sparsesolverresults( state, out  x, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_sparsesolversetxrep(sparsesolverstate state, bool needxrep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        byte _d_needxrep = (byte)(needxrep ? 1 : 0);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_sparsesolversetxrep(&_s_errormsg, &_d_state, &_d_needxrep, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparsesolversetxrep");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void sparsesolversetxrep(sparsesolverstate state, bool needxrep)
    {
        _core_sparsesolversetxrep( state,  needxrep, 0x0);
    }
    
    public static void sparsesolversetxrep(sparsesolverstate state, bool needxrep, alglib.xparams _xparams)
    {
        _core_sparsesolversetxrep( state,  needxrep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_sparsesolveroocstart(sparsesolverstate state, double[] b, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_b = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_b = b){
                x_vector_attach_to_array(ref _d_b, _fp_b, ap.len(b));
                _error_code = _i_xv2_sparsesolveroocstart(&_s_errormsg, &_d_state, &_d_b, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparsesolveroocstart");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_b);
        }
        // This function returns no value.
    }
    
    public static void sparsesolveroocstart(sparsesolverstate state, double[] b)
    {
        _core_sparsesolveroocstart( state,  b, 0x0);
    }
    
    public static void sparsesolveroocstart(sparsesolverstate state, double[] b, alglib.xparams _xparams)
    {
        _core_sparsesolveroocstart( state,  b, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe bool _core_sparsesolverooccontinue(sparsesolverstate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        bool result;
        byte _d_result = (byte)0;
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_sparsesolverooccontinue(&_s_errormsg, &_d_result, &_d_state, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparsesolverooccontinue");
            result = _d_result!=0;
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static bool sparsesolverooccontinue(sparsesolverstate state)
    {
        return _core_sparsesolverooccontinue( state, 0x0);
    }
    
    public static bool sparsesolverooccontinue(sparsesolverstate state, alglib.xparams _xparams)
    {
        return _core_sparsesolverooccontinue( state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_sparsesolveroocgetrequestinfo(sparsesolverstate state, out int requesttype, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_int _d_requesttype = new x_int();
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_sparsesolveroocgetrequestinfo(&_s_errormsg, &_d_state, &_d_requesttype, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparsesolveroocgetrequestinfo");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            requesttype = _d_requesttype.intval;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void sparsesolveroocgetrequestinfo(sparsesolverstate state, out int requesttype)
    {
        _core_sparsesolveroocgetrequestinfo( state, out  requesttype, 0x0);
    }
    
    public static void sparsesolveroocgetrequestinfo(sparsesolverstate state, out int requesttype, alglib.xparams _xparams)
    {
        _core_sparsesolveroocgetrequestinfo( state, out  requesttype, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_sparsesolveroocgetrequestdata(sparsesolverstate state, ref double[] x, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_x = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_xv2_sparsesolveroocgetrequestdata(&_s_errormsg, &_d_state, &_d_x, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparsesolveroocgetrequestdata");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
        }
        // This function returns no value.
    }
    
    public static void sparsesolveroocgetrequestdata(sparsesolverstate state, ref double[] x)
    {
        _core_sparsesolveroocgetrequestdata( state, ref  x, 0x0);
    }
    
    public static void sparsesolveroocgetrequestdata(sparsesolverstate state, ref double[] x, alglib.xparams _xparams)
    {
        _core_sparsesolveroocgetrequestdata( state, ref  x, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_sparsesolveroocgetrequestdata1(sparsesolverstate state, out double v, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_v = 0;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_sparsesolveroocgetrequestdata1(&_s_errormsg, &_d_state, &_d_v, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparsesolveroocgetrequestdata1");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            v = _d_v;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void sparsesolveroocgetrequestdata1(sparsesolverstate state, out double v)
    {
        _core_sparsesolveroocgetrequestdata1( state, out  v, 0x0);
    }
    
    public static void sparsesolveroocgetrequestdata1(sparsesolverstate state, out double v, alglib.xparams _xparams)
    {
        _core_sparsesolveroocgetrequestdata1( state, out  v, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_sparsesolveroocsendresult(sparsesolverstate state, double[] ax, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_ax = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_ax = ax){
                x_vector_attach_to_array(ref _d_ax, _fp_ax, ap.len(ax));
                _error_code = _i_xv2_sparsesolveroocsendresult(&_s_errormsg, &_d_state, &_d_ax, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparsesolveroocsendresult");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_ax);
        }
        // This function returns no value.
    }
    
    public static void sparsesolveroocsendresult(sparsesolverstate state, double[] ax)
    {
        _core_sparsesolveroocsendresult( state,  ax, 0x0);
    }
    
    public static void sparsesolveroocsendresult(sparsesolverstate state, double[] ax, alglib.xparams _xparams)
    {
        _core_sparsesolveroocsendresult( state,  ax, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_sparsesolveroocstop(sparsesolverstate state, out double[] x, out sparsesolverreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_x = new x_vector();
        x_sparsesolverreport _d_rep = new x_sparsesolverreport();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_x, DT_REAL);
            x = null;
            x_sparsesolverreport_init(ref _d_rep);
            _error_code = _i_xv2_sparsesolveroocstop(&_s_errormsg, &_d_state, &_d_x, &_d_rep, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparsesolveroocstop");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
            rep = null;
            x_sparsesolverreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_sparsesolverreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void sparsesolveroocstop(sparsesolverstate state, out double[] x, out sparsesolverreport rep)
    {
        _core_sparsesolveroocstop( state, out  x, out  rep, 0x0);
    }
    
    public static void sparsesolveroocstop(sparsesolverstate state, out double[] x, out sparsesolverreport rep, alglib.xparams _xparams)
    {
        _core_sparsesolveroocstop( state, out  x, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_sparsesolverrequesttermination(sparsesolverstate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_sparsesolverrequesttermination(&_s_errormsg, &_d_state, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sparsesolverrequesttermination");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void sparsesolverrequesttermination(sparsesolverstate state)
    {
        _core_sparsesolverrequesttermination( state, 0x0);
    }
    
    public static void sparsesolverrequesttermination(sparsesolverstate state, alglib.xparams _xparams)
    {
        _core_sparsesolverrequesttermination( state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage lincg
    //
    

    public unsafe class lincgstate : alglibobject
    {
        private void *_ptr;
        public lincgstate(void *x)
        {
            _ptr = x;
        }
        ~lincgstate()
        {
            _deallocate();
        }
        public void* ptr { get { return _ptr; } }
        public override alglib.alglibobject make_copy()
        {
            if( _ptr==null )
                return new lincgstate(null);
            return new lincgstate(_i_x_obj_copy_lincgstate(_ptr));
        }
        public override void _deallocate()
        {
            if( _ptr!=null )
                _i_x_obj_free_lincgstate(_ptr);
            _ptr = null;
            System.GC.SuppressFinalize(this);
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_lincgstate(void *x);
    private static _d_x_obj_copy_lincgstate _i_x_obj_copy_lincgstate = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_obj_free_lincgstate(void *x);
    private static _d_x_obj_free_lincgstate _i_x_obj_free_lincgstate = null;

    [StructLayout(LayoutKind.Sequential, Pack=8)]
    private struct x_lincgreport
    {
        public x_int iterationscount;
        public x_int nmv;
        public x_int terminationtype;
        public double r2;
    }

    public class lincgreport : alglibobject
    {
        public int iterationscount;
        public int nmv;
        public int terminationtype;
        public double r2;
        public override alglib.alglibobject make_copy()
        {
            lincgreport dst = new lincgreport();
            dst.iterationscount = iterationscount;
            dst.nmv = nmv;
            dst.terminationtype = terminationtype;
            dst.r2 = r2;
            return dst;
        }
    }

    // This function initializes X-structure (its previous content is ignored)
    private static void x_lincgreport_init(ref x_lincgreport x)
    {
        x.iterationscount.longval = 0;
        x.nmv.longval = 0;
        x.terminationtype.longval = 0;
        x.r2 = 0;
    }

    // This function finalizes fields of X-structure (however, memory occupied by structure itself is not freed)
    // After destruction structure becomes unusable and should be re-initialized if you want to use it
    private static void x_lincgreport_clear(ref x_lincgreport x)
    {
    }

    // This function initializes X-structure by appropriate C# instance
    // (previous content of X structure is ignored)
    private static void x_lincgreport_init_from(ref x_lincgreport x, lincgreport v)
    {
        x.iterationscount.longval = v.iterationscount;
        x.nmv.longval = v.nmv;
        x.terminationtype.longval = v.terminationtype;
        x.r2 = v.r2;
    }

    // This function initializes C# structure by appropriate X instance
    // (previous content of C# structure is ignored).
    // This function may accept null v, in this case v is automatically allocated with new().
    private static void x_lincgreport_to_record(ref x_lincgreport x, ref lincgreport v)
    {
        if( v==null )
            v = new lincgreport();
        v.iterationscount = x.iterationscount.intval; // long is silently truncated to int
        v.nmv = x.nmv.intval; // long is silently truncated to int
        v.terminationtype = x.terminationtype.intval; // long is silently truncated to int
        v.r2 = x.r2;
    }
    
    private static unsafe void _core_lincgcreate(int n, out lincgstate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        void *_d_state = null;
        state = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_lincgcreate(&_s_errormsg, &_d_n, &_d_state, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "lincgcreate");
            state = new lincgstate(_d_state);
        }
        finally
        {
            if( _d_state!=null && state==null)
                _i_x_obj_free_lincgstate(_d_state); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void lincgcreate(int n, out lincgstate state)
    {
        _core_lincgcreate( n, out  state, 0x0);
    }
    
    public static void lincgcreate(int n, out lincgstate state, alglib.xparams _xparams)
    {
        _core_lincgcreate( n, out  state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_lincgsetstartingpoint(lincgstate state, double[] x, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_x = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_xv2_lincgsetstartingpoint(&_s_errormsg, &_d_state, &_d_x, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "lincgsetstartingpoint");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_x);
        }
        // This function returns no value.
    }
    
    public static void lincgsetstartingpoint(lincgstate state, double[] x)
    {
        _core_lincgsetstartingpoint( state,  x, 0x0);
    }
    
    public static void lincgsetstartingpoint(lincgstate state, double[] x, alglib.xparams _xparams)
    {
        _core_lincgsetstartingpoint( state,  x, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_lincgsetprecunit(lincgstate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_lincgsetprecunit(&_s_errormsg, &_d_state, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "lincgsetprecunit");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void lincgsetprecunit(lincgstate state)
    {
        _core_lincgsetprecunit( state, 0x0);
    }
    
    public static void lincgsetprecunit(lincgstate state, alglib.xparams _xparams)
    {
        _core_lincgsetprecunit( state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_lincgsetprecdiag(lincgstate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_lincgsetprecdiag(&_s_errormsg, &_d_state, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "lincgsetprecdiag");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void lincgsetprecdiag(lincgstate state)
    {
        _core_lincgsetprecdiag( state, 0x0);
    }
    
    public static void lincgsetprecdiag(lincgstate state, alglib.xparams _xparams)
    {
        _core_lincgsetprecdiag( state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_lincgsetcond(lincgstate state, double epsf, int maxits, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_epsf = epsf;
        x_int _d_maxits = new x_int(maxits);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_lincgsetcond(&_s_errormsg, &_d_state, &_d_epsf, &_d_maxits, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "lincgsetcond");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void lincgsetcond(lincgstate state, double epsf, int maxits)
    {
        _core_lincgsetcond( state,  epsf,  maxits, 0x0);
    }
    
    public static void lincgsetcond(lincgstate state, double epsf, int maxits, alglib.xparams _xparams)
    {
        _core_lincgsetcond( state,  epsf,  maxits, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_lincgsolvesparse(lincgstate state, sparsematrix a, bool isupper, double[] b, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        void *_d_a = a.ptr;
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_vector _d_b = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_b = b){
                x_vector_attach_to_array(ref _d_b, _fp_b, ap.len(b));
                _error_code = _i_xv2_lincgsolvesparse(&_s_errormsg, &_d_state, &_d_a, &_d_isupper, &_d_b, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "lincgsolvesparse");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            ap.assert(a.ptr==_d_a, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_b);
        }
        // This function returns no value.
    }
    
    public static void lincgsolvesparse(lincgstate state, sparsematrix a, bool isupper, double[] b)
    {
        _core_lincgsolvesparse( state,  a,  isupper,  b, 0x0);
    }
    
    public static void lincgsolvesparse(lincgstate state, sparsematrix a, bool isupper, double[] b, alglib.xparams _xparams)
    {
        _core_lincgsolvesparse( state,  a,  isupper,  b, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_lincgresults(lincgstate state, out double[] x, out lincgreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_x = new x_vector();
        x_lincgreport _d_rep = new x_lincgreport();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_x, DT_REAL);
            x = null;
            x_lincgreport_init(ref _d_rep);
            _error_code = _i_xv2_lincgresults(&_s_errormsg, &_d_state, &_d_x, &_d_rep, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "lincgresults");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
            rep = null;
            x_lincgreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_lincgreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void lincgresults(lincgstate state, out double[] x, out lincgreport rep)
    {
        _core_lincgresults( state, out  x, out  rep, 0x0);
    }
    
    public static void lincgresults(lincgstate state, out double[] x, out lincgreport rep, alglib.xparams _xparams)
    {
        _core_lincgresults( state, out  x, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_lincgsetrestartfreq(lincgstate state, int srf, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_int _d_srf = new x_int(srf);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_lincgsetrestartfreq(&_s_errormsg, &_d_state, &_d_srf, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "lincgsetrestartfreq");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void lincgsetrestartfreq(lincgstate state, int srf)
    {
        _core_lincgsetrestartfreq( state,  srf, 0x0);
    }
    
    public static void lincgsetrestartfreq(lincgstate state, int srf, alglib.xparams _xparams)
    {
        _core_lincgsetrestartfreq( state,  srf, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_lincgsetrupdatefreq(lincgstate state, int freq, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_int _d_freq = new x_int(freq);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_lincgsetrupdatefreq(&_s_errormsg, &_d_state, &_d_freq, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "lincgsetrupdatefreq");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void lincgsetrupdatefreq(lincgstate state, int freq)
    {
        _core_lincgsetrupdatefreq( state,  freq, 0x0);
    }
    
    public static void lincgsetrupdatefreq(lincgstate state, int freq, alglib.xparams _xparams)
    {
        _core_lincgsetrupdatefreq( state,  freq, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_lincgsetxrep(lincgstate state, bool needxrep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        byte _d_needxrep = (byte)(needxrep ? 1 : 0);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_lincgsetxrep(&_s_errormsg, &_d_state, &_d_needxrep, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "lincgsetxrep");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void lincgsetxrep(lincgstate state, bool needxrep)
    {
        _core_lincgsetxrep( state,  needxrep, 0x0);
    }
    
    public static void lincgsetxrep(lincgstate state, bool needxrep, alglib.xparams _xparams)
    {
        _core_lincgsetxrep( state,  needxrep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage normestimator
    //
    

    public unsafe class normestimatorstate : alglibobject
    {
        private void *_ptr;
        public normestimatorstate(void *x)
        {
            _ptr = x;
        }
        ~normestimatorstate()
        {
            _deallocate();
        }
        public void* ptr { get { return _ptr; } }
        public override alglib.alglibobject make_copy()
        {
            if( _ptr==null )
                return new normestimatorstate(null);
            return new normestimatorstate(_i_x_obj_copy_normestimatorstate(_ptr));
        }
        public override void _deallocate()
        {
            if( _ptr!=null )
                _i_x_obj_free_normestimatorstate(_ptr);
            _ptr = null;
            System.GC.SuppressFinalize(this);
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_normestimatorstate(void *x);
    private static _d_x_obj_copy_normestimatorstate _i_x_obj_copy_normestimatorstate = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_obj_free_normestimatorstate(void *x);
    private static _d_x_obj_free_normestimatorstate _i_x_obj_free_normestimatorstate = null;
    
    private static unsafe void _core_normestimatorcreate(int m, int n, int nstart, int nits, out normestimatorstate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_int _d_nstart = new x_int(nstart);
        x_int _d_nits = new x_int(nits);
        void *_d_state = null;
        state = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_normestimatorcreate(&_s_errormsg, &_d_m, &_d_n, &_d_nstart, &_d_nits, &_d_state, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "normestimatorcreate");
            state = new normestimatorstate(_d_state);
        }
        finally
        {
            if( _d_state!=null && state==null)
                _i_x_obj_free_normestimatorstate(_d_state); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void normestimatorcreate(int m, int n, int nstart, int nits, out normestimatorstate state)
    {
        _core_normestimatorcreate( m,  n,  nstart,  nits, out  state, 0x0);
    }
    
    public static void normestimatorcreate(int m, int n, int nstart, int nits, out normestimatorstate state, alglib.xparams _xparams)
    {
        _core_normestimatorcreate( m,  n,  nstart,  nits, out  state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_normestimatorsetseed(normestimatorstate state, int seedval, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_int _d_seedval = new x_int(seedval);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_normestimatorsetseed(&_s_errormsg, &_d_state, &_d_seedval, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "normestimatorsetseed");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void normestimatorsetseed(normestimatorstate state, int seedval)
    {
        _core_normestimatorsetseed( state,  seedval, 0x0);
    }
    
    public static void normestimatorsetseed(normestimatorstate state, int seedval, alglib.xparams _xparams)
    {
        _core_normestimatorsetseed( state,  seedval, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_normestimatorestimatesparse(normestimatorstate state, sparsematrix a, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        void *_d_a = a.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_normestimatorestimatesparse(&_s_errormsg, &_d_state, &_d_a, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "normestimatorestimatesparse");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            ap.assert(a.ptr==_d_a, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void normestimatorestimatesparse(normestimatorstate state, sparsematrix a)
    {
        _core_normestimatorestimatesparse( state,  a, 0x0);
    }
    
    public static void normestimatorestimatesparse(normestimatorstate state, sparsematrix a, alglib.xparams _xparams)
    {
        _core_normestimatorestimatesparse( state,  a, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_normestimatorresults(normestimatorstate state, out double nrm, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_nrm = 0;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_normestimatorresults(&_s_errormsg, &_d_state, &_d_nrm, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "normestimatorresults");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            nrm = _d_nrm;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void normestimatorresults(normestimatorstate state, out double nrm)
    {
        _core_normestimatorresults( state, out  nrm, 0x0);
    }
    
    public static void normestimatorresults(normestimatorstate state, out double nrm, alglib.xparams _xparams)
    {
        _core_normestimatorresults( state, out  nrm, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage linlsqr
    //
    

    public unsafe class linlsqrstate : alglibobject
    {
        private void *_ptr;
        public linlsqrstate(void *x)
        {
            _ptr = x;
        }
        ~linlsqrstate()
        {
            _deallocate();
        }
        public void* ptr { get { return _ptr; } }
        public override alglib.alglibobject make_copy()
        {
            if( _ptr==null )
                return new linlsqrstate(null);
            return new linlsqrstate(_i_x_obj_copy_linlsqrstate(_ptr));
        }
        public override void _deallocate()
        {
            if( _ptr!=null )
                _i_x_obj_free_linlsqrstate(_ptr);
            _ptr = null;
            System.GC.SuppressFinalize(this);
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_linlsqrstate(void *x);
    private static _d_x_obj_copy_linlsqrstate _i_x_obj_copy_linlsqrstate = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_obj_free_linlsqrstate(void *x);
    private static _d_x_obj_free_linlsqrstate _i_x_obj_free_linlsqrstate = null;

    [StructLayout(LayoutKind.Sequential, Pack=8)]
    private struct x_linlsqrreport
    {
        public x_int iterationscount;
        public x_int nmv;
        public x_int terminationtype;
    }

    public class linlsqrreport : alglibobject
    {
        public int iterationscount;
        public int nmv;
        public int terminationtype;
        public override alglib.alglibobject make_copy()
        {
            linlsqrreport dst = new linlsqrreport();
            dst.iterationscount = iterationscount;
            dst.nmv = nmv;
            dst.terminationtype = terminationtype;
            return dst;
        }
    }

    // This function initializes X-structure (its previous content is ignored)
    private static void x_linlsqrreport_init(ref x_linlsqrreport x)
    {
        x.iterationscount.longval = 0;
        x.nmv.longval = 0;
        x.terminationtype.longval = 0;
    }

    // This function finalizes fields of X-structure (however, memory occupied by structure itself is not freed)
    // After destruction structure becomes unusable and should be re-initialized if you want to use it
    private static void x_linlsqrreport_clear(ref x_linlsqrreport x)
    {
    }

    // This function initializes X-structure by appropriate C# instance
    // (previous content of X structure is ignored)
    private static void x_linlsqrreport_init_from(ref x_linlsqrreport x, linlsqrreport v)
    {
        x.iterationscount.longval = v.iterationscount;
        x.nmv.longval = v.nmv;
        x.terminationtype.longval = v.terminationtype;
    }

    // This function initializes C# structure by appropriate X instance
    // (previous content of C# structure is ignored).
    // This function may accept null v, in this case v is automatically allocated with new().
    private static void x_linlsqrreport_to_record(ref x_linlsqrreport x, ref linlsqrreport v)
    {
        if( v==null )
            v = new linlsqrreport();
        v.iterationscount = x.iterationscount.intval; // long is silently truncated to int
        v.nmv = x.nmv.intval; // long is silently truncated to int
        v.terminationtype = x.terminationtype.intval; // long is silently truncated to int
    }
    
    private static unsafe void _core_linlsqrcreate(int m, int n, out linlsqrstate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        void *_d_state = null;
        state = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_linlsqrcreate(&_s_errormsg, &_d_m, &_d_n, &_d_state, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "linlsqrcreate");
            state = new linlsqrstate(_d_state);
        }
        finally
        {
            if( _d_state!=null && state==null)
                _i_x_obj_free_linlsqrstate(_d_state); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void linlsqrcreate(int m, int n, out linlsqrstate state)
    {
        _core_linlsqrcreate( m,  n, out  state, 0x0);
    }
    
    public static void linlsqrcreate(int m, int n, out linlsqrstate state, alglib.xparams _xparams)
    {
        _core_linlsqrcreate( m,  n, out  state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_linlsqrcreatebuf(int m, int n, linlsqrstate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_linlsqrcreatebuf(&_s_errormsg, &_d_m, &_d_n, &_d_state, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "linlsqrcreatebuf");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void linlsqrcreatebuf(int m, int n, linlsqrstate state)
    {
        _core_linlsqrcreatebuf( m,  n,  state, 0x0);
    }
    
    public static void linlsqrcreatebuf(int m, int n, linlsqrstate state, alglib.xparams _xparams)
    {
        _core_linlsqrcreatebuf( m,  n,  state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_linlsqrsetprecunit(linlsqrstate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_linlsqrsetprecunit(&_s_errormsg, &_d_state, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "linlsqrsetprecunit");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void linlsqrsetprecunit(linlsqrstate state)
    {
        _core_linlsqrsetprecunit( state, 0x0);
    }
    
    public static void linlsqrsetprecunit(linlsqrstate state, alglib.xparams _xparams)
    {
        _core_linlsqrsetprecunit( state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_linlsqrsetprecdiag(linlsqrstate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_linlsqrsetprecdiag(&_s_errormsg, &_d_state, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "linlsqrsetprecdiag");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void linlsqrsetprecdiag(linlsqrstate state)
    {
        _core_linlsqrsetprecdiag( state, 0x0);
    }
    
    public static void linlsqrsetprecdiag(linlsqrstate state, alglib.xparams _xparams)
    {
        _core_linlsqrsetprecdiag( state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_linlsqrsetlambdai(linlsqrstate state, double lambdai, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_lambdai = lambdai;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_linlsqrsetlambdai(&_s_errormsg, &_d_state, &_d_lambdai, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "linlsqrsetlambdai");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void linlsqrsetlambdai(linlsqrstate state, double lambdai)
    {
        _core_linlsqrsetlambdai( state,  lambdai, 0x0);
    }
    
    public static void linlsqrsetlambdai(linlsqrstate state, double lambdai, alglib.xparams _xparams)
    {
        _core_linlsqrsetlambdai( state,  lambdai, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_linlsqrsolvesparse(linlsqrstate state, sparsematrix a, double[] b, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        void *_d_a = a.ptr;
        x_vector _d_b = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_b = b){
                x_vector_attach_to_array(ref _d_b, _fp_b, ap.len(b));
                _error_code = _i_xv2_linlsqrsolvesparse(&_s_errormsg, &_d_state, &_d_a, &_d_b, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "linlsqrsolvesparse");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            ap.assert(a.ptr==_d_a, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_b);
        }
        // This function returns no value.
    }
    
    public static void linlsqrsolvesparse(linlsqrstate state, sparsematrix a, double[] b)
    {
        _core_linlsqrsolvesparse( state,  a,  b, 0x0);
    }
    
    public static void linlsqrsolvesparse(linlsqrstate state, sparsematrix a, double[] b, alglib.xparams _xparams)
    {
        _core_linlsqrsolvesparse( state,  a,  b, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_linlsqrsetcond(linlsqrstate state, double epsa, double epsb, int maxits, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_epsa = epsa;
        double _d_epsb = epsb;
        x_int _d_maxits = new x_int(maxits);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_linlsqrsetcond(&_s_errormsg, &_d_state, &_d_epsa, &_d_epsb, &_d_maxits, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "linlsqrsetcond");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void linlsqrsetcond(linlsqrstate state, double epsa, double epsb, int maxits)
    {
        _core_linlsqrsetcond( state,  epsa,  epsb,  maxits, 0x0);
    }
    
    public static void linlsqrsetcond(linlsqrstate state, double epsa, double epsb, int maxits, alglib.xparams _xparams)
    {
        _core_linlsqrsetcond( state,  epsa,  epsb,  maxits, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_linlsqrresults(linlsqrstate state, out double[] x, out linlsqrreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_x = new x_vector();
        x_linlsqrreport _d_rep = new x_linlsqrreport();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_x, DT_REAL);
            x = null;
            x_linlsqrreport_init(ref _d_rep);
            _error_code = _i_xv2_linlsqrresults(&_s_errormsg, &_d_state, &_d_x, &_d_rep, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "linlsqrresults");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
            rep = null;
            x_linlsqrreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_linlsqrreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void linlsqrresults(linlsqrstate state, out double[] x, out linlsqrreport rep)
    {
        _core_linlsqrresults( state, out  x, out  rep, 0x0);
    }
    
    public static void linlsqrresults(linlsqrstate state, out double[] x, out linlsqrreport rep, alglib.xparams _xparams)
    {
        _core_linlsqrresults( state, out  x, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_linlsqrsetxrep(linlsqrstate state, bool needxrep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        byte _d_needxrep = (byte)(needxrep ? 1 : 0);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_linlsqrsetxrep(&_s_errormsg, &_d_state, &_d_needxrep, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "linlsqrsetxrep");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void linlsqrsetxrep(linlsqrstate state, bool needxrep)
    {
        _core_linlsqrsetxrep( state,  needxrep, 0x0);
    }
    
    public static void linlsqrsetxrep(linlsqrstate state, bool needxrep, alglib.xparams _xparams)
    {
        _core_linlsqrsetxrep( state,  needxrep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe int _core_linlsqrpeekiterationscount(linlsqrstate s, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        int result;
        x_int _d_result = new x_int();
        void *_d_s = s.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_linlsqrpeekiterationscount(&_s_errormsg, &_d_result, &_d_s, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "linlsqrpeekiterationscount");
            result = _d_result.intval;
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static int linlsqrpeekiterationscount(linlsqrstate s)
    {
        return _core_linlsqrpeekiterationscount( s, 0x0);
    }
    
    public static int linlsqrpeekiterationscount(linlsqrstate s, alglib.xparams _xparams)
    {
        return _core_linlsqrpeekiterationscount( s, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_linlsqrrequesttermination(linlsqrstate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_linlsqrrequesttermination(&_s_errormsg, &_d_state, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "linlsqrrequesttermination");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void linlsqrrequesttermination(linlsqrstate state)
    {
        _core_linlsqrrequesttermination( state, 0x0);
    }
    
    public static void linlsqrrequesttermination(linlsqrstate state, alglib.xparams _xparams)
    {
        _core_linlsqrrequesttermination( state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage nleq
    //
    

    public unsafe class nleqstate : alglibobject
    {
        private void *_ptr;
        public nleqstate(void *x)
        {
            _ptr = x;
        }
        ~nleqstate()
        {
            _deallocate();
        }
        public void* ptr { get { return _ptr; } }
        public override alglib.alglibobject make_copy()
        {
            if( _ptr==null )
                return new nleqstate(null);
            return new nleqstate(_i_x_obj_copy_nleqstate(_ptr));
        }
        public override void _deallocate()
        {
            if( _ptr!=null )
                _i_x_obj_free_nleqstate(_ptr);
            _ptr = null;
            System.GC.SuppressFinalize(this);
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_nleqstate(void *x);
    private static _d_x_obj_copy_nleqstate _i_x_obj_copy_nleqstate = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_obj_free_nleqstate(void *x);
    private static _d_x_obj_free_nleqstate _i_x_obj_free_nleqstate = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_nleqstate_get_needf(void *x, byte *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_nleqstate_set_needf(void *x, byte *dst);
    private static _d_x_nleqstate_get_needf _i_x_nleqstate_get_needf = null;
    private static _d_x_nleqstate_set_needf _i_x_nleqstate_set_needf = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_nleqstate_get_needfij(void *x, byte *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_nleqstate_set_needfij(void *x, byte *dst);
    private static _d_x_nleqstate_get_needfij _i_x_nleqstate_get_needfij = null;
    private static _d_x_nleqstate_set_needfij _i_x_nleqstate_set_needfij = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_nleqstate_get_xupdated(void *x, byte *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_nleqstate_set_xupdated(void *x, byte *dst);
    private static _d_x_nleqstate_get_xupdated _i_x_nleqstate_get_xupdated = null;
    private static _d_x_nleqstate_set_xupdated _i_x_nleqstate_set_xupdated = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_nleqstate_get_f(void *x, double *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_nleqstate_set_f(void *x, double *dst);
    private static _d_x_nleqstate_get_f _i_x_nleqstate_get_f = null;
    private static _d_x_nleqstate_set_f _i_x_nleqstate_set_f = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_nleqstate_get_fi(void *x, x_vector *dst);
    private static _d_x_nleqstate_get_fi _i_x_nleqstate_get_fi = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_nleqstate_get_j(void *x, x_matrix *dst);
    private static _d_x_nleqstate_get_j _i_x_nleqstate_get_j = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_nleqstate_get_x(void *x, x_vector *dst);
    private static _d_x_nleqstate_get_x _i_x_nleqstate_get_x = null;

    [StructLayout(LayoutKind.Sequential, Pack=8)]
    private struct x_nleqreport
    {
        public x_int iterationscount;
        public x_int nfunc;
        public x_int njac;
        public x_int terminationtype;
    }

    public class nleqreport : alglibobject
    {
        public int iterationscount;
        public int nfunc;
        public int njac;
        public int terminationtype;
        public override alglib.alglibobject make_copy()
        {
            nleqreport dst = new nleqreport();
            dst.iterationscount = iterationscount;
            dst.nfunc = nfunc;
            dst.njac = njac;
            dst.terminationtype = terminationtype;
            return dst;
        }
    }

    // This function initializes X-structure (its previous content is ignored)
    private static void x_nleqreport_init(ref x_nleqreport x)
    {
        x.iterationscount.longval = 0;
        x.nfunc.longval = 0;
        x.njac.longval = 0;
        x.terminationtype.longval = 0;
    }

    // This function finalizes fields of X-structure (however, memory occupied by structure itself is not freed)
    // After destruction structure becomes unusable and should be re-initialized if you want to use it
    private static void x_nleqreport_clear(ref x_nleqreport x)
    {
    }

    // This function initializes X-structure by appropriate C# instance
    // (previous content of X structure is ignored)
    private static void x_nleqreport_init_from(ref x_nleqreport x, nleqreport v)
    {
        x.iterationscount.longval = v.iterationscount;
        x.nfunc.longval = v.nfunc;
        x.njac.longval = v.njac;
        x.terminationtype.longval = v.terminationtype;
    }

    // This function initializes C# structure by appropriate X instance
    // (previous content of C# structure is ignored).
    // This function may accept null v, in this case v is automatically allocated with new().
    private static void x_nleqreport_to_record(ref x_nleqreport x, ref nleqreport v)
    {
        if( v==null )
            v = new nleqreport();
        v.iterationscount = x.iterationscount.intval; // long is silently truncated to int
        v.nfunc = x.nfunc.intval; // long is silently truncated to int
        v.njac = x.njac.intval; // long is silently truncated to int
        v.terminationtype = x.terminationtype.intval; // long is silently truncated to int
    }
    
    private static unsafe void _core_nleqcreatelm(int n, int m, double[] x, out nleqstate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        x_int _d_m = new x_int(m);
        x_vector _d_x = new x_vector();
        void *_d_state = null;
        state = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_xv2_nleqcreatelm(&_s_errormsg, &_d_n, &_d_m, &_d_x, &_d_state, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "nleqcreatelm");
            state = new nleqstate(_d_state);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            if( _d_state!=null && state==null)
                _i_x_obj_free_nleqstate(_d_state); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void nleqcreatelm(int n, int m, double[] x, out nleqstate state)
    {
        _core_nleqcreatelm( n,  m,  x, out  state, 0x0);
    }
    
    public static void nleqcreatelm(int n, int m, double[] x, out nleqstate state, alglib.xparams _xparams)
    {
        _core_nleqcreatelm( n,  m,  x, out  state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void nleqcreatelm(int m, double[] x, out nleqstate state)
    {
        int n;
    
        n = ap.len(x);
        _core_nleqcreatelm( n,  m,  x, out  state, 0x0);
    
        
    }
    
    public static void nleqcreatelm(int m, double[] x, out nleqstate state, alglib.xparams _xparams)
    {
        int n;
    
        n = ap.len(x);
        _core_nleqcreatelm( n,  m,  x, out  state, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_nleqsetcond(nleqstate state, double epsf, int maxits, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_epsf = epsf;
        x_int _d_maxits = new x_int(maxits);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_nleqsetcond(&_s_errormsg, &_d_state, &_d_epsf, &_d_maxits, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "nleqsetcond");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void nleqsetcond(nleqstate state, double epsf, int maxits)
    {
        _core_nleqsetcond( state,  epsf,  maxits, 0x0);
    }
    
    public static void nleqsetcond(nleqstate state, double epsf, int maxits, alglib.xparams _xparams)
    {
        _core_nleqsetcond( state,  epsf,  maxits, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_nleqsetxrep(nleqstate state, bool needxrep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        byte _d_needxrep = (byte)(needxrep ? 1 : 0);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_nleqsetxrep(&_s_errormsg, &_d_state, &_d_needxrep, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "nleqsetxrep");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void nleqsetxrep(nleqstate state, bool needxrep)
    {
        _core_nleqsetxrep( state,  needxrep, 0x0);
    }
    
    public static void nleqsetxrep(nleqstate state, bool needxrep, alglib.xparams _xparams)
    {
        _core_nleqsetxrep( state,  needxrep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_nleqsetstpmax(nleqstate state, double stpmax, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_stpmax = stpmax;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_nleqsetstpmax(&_s_errormsg, &_d_state, &_d_stpmax, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "nleqsetstpmax");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void nleqsetstpmax(nleqstate state, double stpmax)
    {
        _core_nleqsetstpmax( state,  stpmax, 0x0);
    }
    
    public static void nleqsetstpmax(nleqstate state, double stpmax, alglib.xparams _xparams)
    {
        _core_nleqsetstpmax( state,  stpmax, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe bool _core_nleqiteration(nleqstate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        bool result;
        byte _d_result = (byte)0;
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_nleqiteration(&_s_errormsg, &_d_result, &_d_state, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "nleqiteration");
            result = _d_result!=0;
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static bool nleqiteration(nleqstate state)
    {
        return _core_nleqiteration( state, 0x0);
    }
    
    public static bool nleqiteration(nleqstate state, alglib.xparams _xparams)
    {
        return _core_nleqiteration( state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static unsafe void nleqsolve(nleqstate state, ndimensional_func func, ndimensional_jac  jac, ndimensional_rep rep, object obj)
    {
        nleqsolve(state, func, jac, rep, obj, null);
    }
    
    public static unsafe void nleqsolve(nleqstate state, ndimensional_func func, ndimensional_jac  jac, ndimensional_rep rep, object obj, alglib.xparams _xparams)
    {
        byte *_s_errormsg = null;
        int _error_code = 0;
        byte _b_result = (byte)0;
        byte _xc_xupdated = 0;
        void *_state = state.ptr;
        IntPtr _pre_ptr;
        x_vector _xc_arg = new x_vector();
        double[] _cs_arg = null;
        double _cs_f = 0;
        x_vector _xc_fi = new x_vector();
        double[] _cs_fi = null;
        x_matrix _xc_j = new x_matrix();
        double[,] _cs_j = null;
        byte _xc_needf= 0;
        byte _xc_needfij= 0;
    
        //
        // Check correctness of delegates
        //
        if( func==null )
            throw new alglibexception("ALGLIB: error in 'nleqsolve()' (func is null)");
        if( jac==null )
            throw new alglibexception("ALGLIB: error in 'nleqsolve()' (jac is null)");
    
        //
        // Attach x-structures to internal arrays
        //
        x_vector_create_empty(ref _xc_arg, DT_REAL);
        x_vector_create_empty(ref _xc_fi, DT_REAL);
        x_matrix_create_empty(ref _xc_j, DT_REAL);
        _i_x_nleqstate_get_x(_state, &_xc_arg);
        _i_x_nleqstate_get_fi(_state, &_xc_fi);
        _i_x_nleqstate_get_j(_state, &_xc_j);
        _cs_arg = new double[_xc_arg.cnt];
        _cs_fi = new double[_xc_fi.cnt];
        _cs_j = new double[_xc_j.rows,_xc_j.cols];
    
        //
        // Main loop
        //
        for(;;)
        {
            //
            // Call iteration function.
            // Terminate iterations if it returned false.
            //
            _error_code = _i_xv2_nleqiteration(&_s_errormsg, &_b_result, &_state, _xparams==null ? 0x0 : _xparams.flags);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "nleqiteration");
            ap.assert(_state==state.ptr, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _b_result==0 )
                break;
            
            //
            // Reverse communication interface:
            // * fetch flags
            // * make delegate calls
            //
            _i_x_nleqstate_get_xupdated(_state, &_xc_xupdated);
            _i_x_nleqstate_get_needf(_state, &_xc_needf);
            _i_x_nleqstate_get_needfij(_state, &_xc_needfij);
            x_vector_to_array(ref _xc_arg, ref _cs_arg);
            if( _xc_needf!=0 )
            {
                func(_cs_arg, ref _cs_f, obj);
                _i_x_nleqstate_set_f(_state, &_cs_f);
                continue;
            }
            if( _xc_needfij!=0 )
            {
                jac(_cs_arg, _cs_fi, _cs_j, obj);
                x_vector_from_array(ref _xc_fi, _cs_fi, X_REWRITE);
                x_matrix_from_array(ref _xc_j,  _cs_j,  X_REWRITE);
                continue;
            }
            if( _xc_xupdated!=0 )
            {
                if( rep!=null )
                {
                    double _local_f;
                    _i_x_nleqstate_get_f(_state, &_local_f);
                    rep(_cs_arg, _local_f, obj);
                }
                continue;
            }
            throw new alglibexception("ALGLIB: error in 'nleqsolve' (some derivatives were not provided?)");
        }
        
        //
        // Integrity post-check:
        // * make sure that no reverse communication array was reallocated during optimization
        //
        _pre_ptr = _xc_arg.xptr.ptr;
        _i_x_nleqstate_get_x(_state, &_xc_arg);
        alglib.ap.assert(_xc_arg.xptr.ptr==_pre_ptr, "ALGLIB: integrity check failed in nleqsolve()");
        _pre_ptr = _xc_fi.xptr.ptr;
        _i_x_nleqstate_get_fi(_state, &_xc_fi);
        alglib.ap.assert(_xc_fi.xptr.ptr==_pre_ptr, "ALGLIB: integrity check failed in nleqsolve()");
        _pre_ptr = _xc_j.xptr.ptr;
        _i_x_nleqstate_get_j(_state, &_xc_j);
        alglib.ap.assert(_xc_j.xptr.ptr==_pre_ptr, "ALGLIB: integrity check failed in nleqsolve()");
    }
    
    private static unsafe void _core_nleqresults(nleqstate state, out double[] x, out nleqreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_x = new x_vector();
        x_nleqreport _d_rep = new x_nleqreport();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_x, DT_REAL);
            x = null;
            x_nleqreport_init(ref _d_rep);
            _error_code = _i_xv2_nleqresults(&_s_errormsg, &_d_state, &_d_x, &_d_rep, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "nleqresults");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
            rep = null;
            x_nleqreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_nleqreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void nleqresults(nleqstate state, out double[] x, out nleqreport rep)
    {
        _core_nleqresults( state, out  x, out  rep, 0x0);
    }
    
    public static void nleqresults(nleqstate state, out double[] x, out nleqreport rep, alglib.xparams _xparams)
    {
        _core_nleqresults( state, out  x, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_nleqresultsbuf(nleqstate state, ref double[] x, nleqreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_x = new x_vector();
        x_nleqreport _d_rep = new x_nleqreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_nleqreport_init_from(ref _d_rep, rep);
                _error_code = _i_xv2_nleqresultsbuf(&_s_errormsg, &_d_state, &_d_x, &_d_rep, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "nleqresultsbuf");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
            x_nleqreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_nleqreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void nleqresultsbuf(nleqstate state, ref double[] x, nleqreport rep)
    {
        _core_nleqresultsbuf( state, ref  x,  rep, 0x0);
    }
    
    public static void nleqresultsbuf(nleqstate state, ref double[] x, nleqreport rep, alglib.xparams _xparams)
    {
        _core_nleqresultsbuf( state, ref  x,  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_nleqrestartfrom(nleqstate state, double[] x, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_x = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_xv2_nleqrestartfrom(&_s_errormsg, &_d_state, &_d_x, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "nleqrestartfrom");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_x);
        }
        // This function returns no value.
    }
    
    public static void nleqrestartfrom(nleqstate state, double[] x)
    {
        _core_nleqrestartfrom( state,  x, 0x0);
    }
    
    public static void nleqrestartfrom(nleqstate state, double[] x, alglib.xparams _xparams)
    {
        _core_nleqrestartfrom( state,  x, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage matinv
    //
    

    [StructLayout(LayoutKind.Sequential, Pack=8)]
    private struct x_matinvreport
    {
        public double r1;
        public double rinf;
    }

    public class matinvreport : alglibobject
    {
        public double r1;
        public double rinf;
        public override alglib.alglibobject make_copy()
        {
            matinvreport dst = new matinvreport();
            dst.r1 = r1;
            dst.rinf = rinf;
            return dst;
        }
    }

    // This function initializes X-structure (its previous content is ignored)
    private static void x_matinvreport_init(ref x_matinvreport x)
    {
        x.r1 = 0;
        x.rinf = 0;
    }

    // This function finalizes fields of X-structure (however, memory occupied by structure itself is not freed)
    // After destruction structure becomes unusable and should be re-initialized if you want to use it
    private static void x_matinvreport_clear(ref x_matinvreport x)
    {
    }

    // This function initializes X-structure by appropriate C# instance
    // (previous content of X structure is ignored)
    private static void x_matinvreport_init_from(ref x_matinvreport x, matinvreport v)
    {
        x.r1 = v.r1;
        x.rinf = v.rinf;
    }

    // This function initializes C# structure by appropriate X instance
    // (previous content of C# structure is ignored).
    // This function may accept null v, in this case v is automatically allocated with new().
    private static void x_matinvreport_to_record(ref x_matinvreport x, ref matinvreport v)
    {
        if( v==null )
            v = new matinvreport();
        v.r1 = x.r1;
        v.rinf = x.rinf;
    }
    
    private static unsafe void _core_rmatrixluinverse(ref double[,] a, int[] pivots, int n, out int info, out matinvreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_vector _d_pivots = new x_vector();
        x_int _d_n = new x_int(n);
        x_int _d_info = new x_int();
        x_matinvreport _d_rep = new x_matinvreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_from_array(ref _d_pivots, pivots, X_CREATE);
                x_matinvreport_init(ref _d_rep);
                _error_code = _i_xv2_rmatrixluinverse(&_s_errormsg, &_d_a, &_d_pivots, &_d_n, &_d_info, &_d_rep, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rmatrixluinverse");
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new double[0,0];
            info = _d_info.intval;
            rep = null;
            x_matinvreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_pivots);
            x_matinvreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void rmatrixluinverse(ref double[,] a, int[] pivots, int n, out int info, out matinvreport rep)
    {
        _core_rmatrixluinverse(ref  a,  pivots,  n, out  info, out  rep, 0x0);
    }
    
    public static void rmatrixluinverse(ref double[,] a, int[] pivots, int n, out int info, out matinvreport rep, alglib.xparams _xparams)
    {
        _core_rmatrixluinverse(ref  a,  pivots,  n, out  info, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void rmatrixluinverse(ref double[,] a, int[] pivots, out int info, out matinvreport rep)
    {
        int n;
        if( (ap.cols(a)!=ap.rows(a)) || (ap.cols(a)!=ap.len(pivots)))
            throw new alglibexception("Error while calling 'rmatrixluinverse': looks like one of arguments has wrong size");
        n = ap.cols(a);
        _core_rmatrixluinverse(ref  a,  pivots,  n, out  info, out  rep, 0x0);
    
        
    }
    
    public static void rmatrixluinverse(ref double[,] a, int[] pivots, out int info, out matinvreport rep, alglib.xparams _xparams)
    {
        int n;
        if( (ap.cols(a)!=ap.rows(a)) || (ap.cols(a)!=ap.len(pivots)))
            throw new alglibexception("Error while calling 'rmatrixluinverse': looks like one of arguments has wrong size");
        n = ap.cols(a);
        _core_rmatrixluinverse(ref  a,  pivots,  n, out  info, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_rmatrixinverse(ref double[,] a, int n, out int info, out matinvreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        x_int _d_info = new x_int();
        x_matinvreport _d_rep = new x_matinvreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matinvreport_init(ref _d_rep);
                _error_code = _i_xv2_rmatrixinverse(&_s_errormsg, &_d_a, &_d_n, &_d_info, &_d_rep, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rmatrixinverse");
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new double[0,0];
            info = _d_info.intval;
            rep = null;
            x_matinvreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matinvreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void rmatrixinverse(ref double[,] a, int n, out int info, out matinvreport rep)
    {
        _core_rmatrixinverse(ref  a,  n, out  info, out  rep, 0x0);
    }
    
    public static void rmatrixinverse(ref double[,] a, int n, out int info, out matinvreport rep, alglib.xparams _xparams)
    {
        _core_rmatrixinverse(ref  a,  n, out  info, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void rmatrixinverse(ref double[,] a, out int info, out matinvreport rep)
    {
        int n;
        if( (ap.cols(a)!=ap.rows(a)))
            throw new alglibexception("Error while calling 'rmatrixinverse': looks like one of arguments has wrong size");
        n = ap.cols(a);
        _core_rmatrixinverse(ref  a,  n, out  info, out  rep, 0x0);
    
        
    }
    
    public static void rmatrixinverse(ref double[,] a, out int info, out matinvreport rep, alglib.xparams _xparams)
    {
        int n;
        if( (ap.cols(a)!=ap.rows(a)))
            throw new alglibexception("Error while calling 'rmatrixinverse': looks like one of arguments has wrong size");
        n = ap.cols(a);
        _core_rmatrixinverse(ref  a,  n, out  info, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_cmatrixluinverse(ref complex[,] a, int[] pivots, int n, out int info, out matinvreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_vector _d_pivots = new x_vector();
        x_int _d_n = new x_int(n);
        x_int _d_info = new x_int();
        x_matinvreport _d_rep = new x_matinvreport();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_from_array(ref _d_pivots, pivots, X_CREATE);
                x_matinvreport_init(ref _d_rep);
                _error_code = _i_xv2_cmatrixluinverse(&_s_errormsg, &_d_a, &_d_pivots, &_d_n, &_d_info, &_d_rep, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "cmatrixluinverse");
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new alglib.complex[0,0];
            info = _d_info.intval;
            rep = null;
            x_matinvreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_pivots);
            x_matinvreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void cmatrixluinverse(ref complex[,] a, int[] pivots, int n, out int info, out matinvreport rep)
    {
        _core_cmatrixluinverse(ref  a,  pivots,  n, out  info, out  rep, 0x0);
    }
    
    public static void cmatrixluinverse(ref complex[,] a, int[] pivots, int n, out int info, out matinvreport rep, alglib.xparams _xparams)
    {
        _core_cmatrixluinverse(ref  a,  pivots,  n, out  info, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void cmatrixluinverse(ref complex[,] a, int[] pivots, out int info, out matinvreport rep)
    {
        int n;
        if( (ap.cols(a)!=ap.rows(a)) || (ap.cols(a)!=ap.len(pivots)))
            throw new alglibexception("Error while calling 'cmatrixluinverse': looks like one of arguments has wrong size");
        n = ap.cols(a);
        _core_cmatrixluinverse(ref  a,  pivots,  n, out  info, out  rep, 0x0);
    
        
    }
    
    public static void cmatrixluinverse(ref complex[,] a, int[] pivots, out int info, out matinvreport rep, alglib.xparams _xparams)
    {
        int n;
        if( (ap.cols(a)!=ap.rows(a)) || (ap.cols(a)!=ap.len(pivots)))
            throw new alglibexception("Error while calling 'cmatrixluinverse': looks like one of arguments has wrong size");
        n = ap.cols(a);
        _core_cmatrixluinverse(ref  a,  pivots,  n, out  info, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_cmatrixinverse(ref complex[,] a, int n, out int info, out matinvreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        x_int _d_info = new x_int();
        x_matinvreport _d_rep = new x_matinvreport();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matinvreport_init(ref _d_rep);
                _error_code = _i_xv2_cmatrixinverse(&_s_errormsg, &_d_a, &_d_n, &_d_info, &_d_rep, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "cmatrixinverse");
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new alglib.complex[0,0];
            info = _d_info.intval;
            rep = null;
            x_matinvreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matinvreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void cmatrixinverse(ref complex[,] a, int n, out int info, out matinvreport rep)
    {
        _core_cmatrixinverse(ref  a,  n, out  info, out  rep, 0x0);
    }
    
    public static void cmatrixinverse(ref complex[,] a, int n, out int info, out matinvreport rep, alglib.xparams _xparams)
    {
        _core_cmatrixinverse(ref  a,  n, out  info, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void cmatrixinverse(ref complex[,] a, out int info, out matinvreport rep)
    {
        int n;
        if( (ap.cols(a)!=ap.rows(a)))
            throw new alglibexception("Error while calling 'cmatrixinverse': looks like one of arguments has wrong size");
        n = ap.cols(a);
        _core_cmatrixinverse(ref  a,  n, out  info, out  rep, 0x0);
    
        
    }
    
    public static void cmatrixinverse(ref complex[,] a, out int info, out matinvreport rep, alglib.xparams _xparams)
    {
        int n;
        if( (ap.cols(a)!=ap.rows(a)))
            throw new alglibexception("Error while calling 'cmatrixinverse': looks like one of arguments has wrong size");
        n = ap.cols(a);
        _core_cmatrixinverse(ref  a,  n, out  info, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_spdmatrixcholeskyinverse(ref double[,] a, int n, bool isupper, out int info, out matinvreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_int _d_info = new x_int();
        x_matinvreport _d_rep = new x_matinvreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matinvreport_init(ref _d_rep);
                _error_code = _i_xv2_spdmatrixcholeskyinverse(&_s_errormsg, &_d_a, &_d_n, &_d_isupper, &_d_info, &_d_rep, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spdmatrixcholeskyinverse");
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new double[0,0];
            info = _d_info.intval;
            rep = null;
            x_matinvreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matinvreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void spdmatrixcholeskyinverse(ref double[,] a, int n, bool isupper, out int info, out matinvreport rep)
    {
        _core_spdmatrixcholeskyinverse(ref  a,  n,  isupper, out  info, out  rep, 0x0);
    }
    
    public static void spdmatrixcholeskyinverse(ref double[,] a, int n, bool isupper, out int info, out matinvreport rep, alglib.xparams _xparams)
    {
        _core_spdmatrixcholeskyinverse(ref  a,  n,  isupper, out  info, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void spdmatrixcholeskyinverse(ref double[,] a, out int info, out matinvreport rep)
    {
        int n;
        bool isupper;
        if( (ap.cols(a)!=ap.rows(a)))
            throw new alglibexception("Error while calling 'spdmatrixcholeskyinverse': looks like one of arguments has wrong size");
        n = ap.cols(a);
        isupper = false;
        _core_spdmatrixcholeskyinverse(ref  a,  n,  isupper, out  info, out  rep, 0x0);
    
        
    }
    
    public static void spdmatrixcholeskyinverse(ref double[,] a, out int info, out matinvreport rep, alglib.xparams _xparams)
    {
        int n;
        bool isupper;
        if( (ap.cols(a)!=ap.rows(a)))
            throw new alglibexception("Error while calling 'spdmatrixcholeskyinverse': looks like one of arguments has wrong size");
        n = ap.cols(a);
        isupper = false;
        _core_spdmatrixcholeskyinverse(ref  a,  n,  isupper, out  info, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_spdmatrixinverse(ref double[,] a, int n, bool isupper, out int info, out matinvreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_int _d_info = new x_int();
        x_matinvreport _d_rep = new x_matinvreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matinvreport_init(ref _d_rep);
                _error_code = _i_xv2_spdmatrixinverse(&_s_errormsg, &_d_a, &_d_n, &_d_isupper, &_d_info, &_d_rep, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spdmatrixinverse");
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new double[0,0];
            info = _d_info.intval;
            rep = null;
            x_matinvreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matinvreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void spdmatrixinverse(ref double[,] a, int n, bool isupper, out int info, out matinvreport rep)
    {
        _core_spdmatrixinverse(ref  a,  n,  isupper, out  info, out  rep, 0x0);
    }
    
    public static void spdmatrixinverse(ref double[,] a, int n, bool isupper, out int info, out matinvreport rep, alglib.xparams _xparams)
    {
        _core_spdmatrixinverse(ref  a,  n,  isupper, out  info, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void spdmatrixinverse(ref double[,] a, out int info, out matinvreport rep)
    {
        int n;
        bool isupper;
        if( !alglib.ap.issymmetric(a) )
            throw new alglibexception("'a' parameter is not symmetric matrix");
        if( (ap.cols(a)!=ap.rows(a)))
            throw new alglibexception("Error while calling 'spdmatrixinverse': looks like one of arguments has wrong size");
        n = ap.cols(a);
        isupper = false;
        _core_spdmatrixinverse(ref  a,  n,  isupper, out  info, out  rep, 0x0);
        if( !alglib.ap.forcesymmetric(a) )
            throw new alglibexception("Internal error while forcing symmetric properties for 'a' parameter");
        
    }
    
    public static void spdmatrixinverse(ref double[,] a, out int info, out matinvreport rep, alglib.xparams _xparams)
    {
        int n;
        bool isupper;
        if( !alglib.ap.issymmetric(a) )
            throw new alglibexception("'a' parameter is not symmetric matrix");
        if( (ap.cols(a)!=ap.rows(a)))
            throw new alglibexception("Error while calling 'spdmatrixinverse': looks like one of arguments has wrong size");
        n = ap.cols(a);
        isupper = false;
        _core_spdmatrixinverse(ref  a,  n,  isupper, out  info, out  rep, _xparams==null ? 0x0 : _xparams.flags);
        if( !alglib.ap.forcesymmetric(a) )
            throw new alglibexception("Internal error while forcing symmetric properties for 'a' parameter");
        
    }
    
    private static unsafe void _core_hpdmatrixcholeskyinverse(ref complex[,] a, int n, bool isupper, out int info, out matinvreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_int _d_info = new x_int();
        x_matinvreport _d_rep = new x_matinvreport();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matinvreport_init(ref _d_rep);
                _error_code = _i_xv2_hpdmatrixcholeskyinverse(&_s_errormsg, &_d_a, &_d_n, &_d_isupper, &_d_info, &_d_rep, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "hpdmatrixcholeskyinverse");
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new alglib.complex[0,0];
            info = _d_info.intval;
            rep = null;
            x_matinvreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matinvreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void hpdmatrixcholeskyinverse(ref complex[,] a, int n, bool isupper, out int info, out matinvreport rep)
    {
        _core_hpdmatrixcholeskyinverse(ref  a,  n,  isupper, out  info, out  rep, 0x0);
    }
    
    public static void hpdmatrixcholeskyinverse(ref complex[,] a, int n, bool isupper, out int info, out matinvreport rep, alglib.xparams _xparams)
    {
        _core_hpdmatrixcholeskyinverse(ref  a,  n,  isupper, out  info, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void hpdmatrixcholeskyinverse(ref complex[,] a, out int info, out matinvreport rep)
    {
        int n;
        bool isupper;
        if( (ap.cols(a)!=ap.rows(a)))
            throw new alglibexception("Error while calling 'hpdmatrixcholeskyinverse': looks like one of arguments has wrong size");
        n = ap.cols(a);
        isupper = false;
        _core_hpdmatrixcholeskyinverse(ref  a,  n,  isupper, out  info, out  rep, 0x0);
    
        
    }
    
    public static void hpdmatrixcholeskyinverse(ref complex[,] a, out int info, out matinvreport rep, alglib.xparams _xparams)
    {
        int n;
        bool isupper;
        if( (ap.cols(a)!=ap.rows(a)))
            throw new alglibexception("Error while calling 'hpdmatrixcholeskyinverse': looks like one of arguments has wrong size");
        n = ap.cols(a);
        isupper = false;
        _core_hpdmatrixcholeskyinverse(ref  a,  n,  isupper, out  info, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_hpdmatrixinverse(ref complex[,] a, int n, bool isupper, out int info, out matinvreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_int _d_info = new x_int();
        x_matinvreport _d_rep = new x_matinvreport();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matinvreport_init(ref _d_rep);
                _error_code = _i_xv2_hpdmatrixinverse(&_s_errormsg, &_d_a, &_d_n, &_d_isupper, &_d_info, &_d_rep, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "hpdmatrixinverse");
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new alglib.complex[0,0];
            info = _d_info.intval;
            rep = null;
            x_matinvreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matinvreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void hpdmatrixinverse(ref complex[,] a, int n, bool isupper, out int info, out matinvreport rep)
    {
        _core_hpdmatrixinverse(ref  a,  n,  isupper, out  info, out  rep, 0x0);
    }
    
    public static void hpdmatrixinverse(ref complex[,] a, int n, bool isupper, out int info, out matinvreport rep, alglib.xparams _xparams)
    {
        _core_hpdmatrixinverse(ref  a,  n,  isupper, out  info, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void hpdmatrixinverse(ref complex[,] a, out int info, out matinvreport rep)
    {
        int n;
        bool isupper;
        if( !alglib.ap.ishermitian(a) )
            throw new alglibexception("'a' parameter is not hermitian matrix");
        if( (ap.cols(a)!=ap.rows(a)))
            throw new alglibexception("Error while calling 'hpdmatrixinverse': looks like one of arguments has wrong size");
        n = ap.cols(a);
        isupper = false;
        _core_hpdmatrixinverse(ref  a,  n,  isupper, out  info, out  rep, 0x0);
        if( !alglib.ap.forcehermitian(a) )
            throw new alglibexception("Internal error while forcing hermitian properties for 'a' parameter");
        
    }
    
    public static void hpdmatrixinverse(ref complex[,] a, out int info, out matinvreport rep, alglib.xparams _xparams)
    {
        int n;
        bool isupper;
        if( !alglib.ap.ishermitian(a) )
            throw new alglibexception("'a' parameter is not hermitian matrix");
        if( (ap.cols(a)!=ap.rows(a)))
            throw new alglibexception("Error while calling 'hpdmatrixinverse': looks like one of arguments has wrong size");
        n = ap.cols(a);
        isupper = false;
        _core_hpdmatrixinverse(ref  a,  n,  isupper, out  info, out  rep, _xparams==null ? 0x0 : _xparams.flags);
        if( !alglib.ap.forcehermitian(a) )
            throw new alglibexception("Internal error while forcing hermitian properties for 'a' parameter");
        
    }
    
    private static unsafe void _core_rmatrixtrinverse(ref double[,] a, int n, bool isupper, bool isunit, out int info, out matinvreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        byte _d_isunit = (byte)(isunit ? 1 : 0);
        x_int _d_info = new x_int();
        x_matinvreport _d_rep = new x_matinvreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matinvreport_init(ref _d_rep);
                _error_code = _i_xv2_rmatrixtrinverse(&_s_errormsg, &_d_a, &_d_n, &_d_isupper, &_d_isunit, &_d_info, &_d_rep, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rmatrixtrinverse");
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new double[0,0];
            info = _d_info.intval;
            rep = null;
            x_matinvreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matinvreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void rmatrixtrinverse(ref double[,] a, int n, bool isupper, bool isunit, out int info, out matinvreport rep)
    {
        _core_rmatrixtrinverse(ref  a,  n,  isupper,  isunit, out  info, out  rep, 0x0);
    }
    
    public static void rmatrixtrinverse(ref double[,] a, int n, bool isupper, bool isunit, out int info, out matinvreport rep, alglib.xparams _xparams)
    {
        _core_rmatrixtrinverse(ref  a,  n,  isupper,  isunit, out  info, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void rmatrixtrinverse(ref double[,] a, bool isupper, out int info, out matinvreport rep)
    {
        int n;
        bool isunit;
        if( (ap.cols(a)!=ap.rows(a)))
            throw new alglibexception("Error while calling 'rmatrixtrinverse': looks like one of arguments has wrong size");
        n = ap.cols(a);
        isunit = false;
        _core_rmatrixtrinverse(ref  a,  n,  isupper,  isunit, out  info, out  rep, 0x0);
    
        
    }
    
    public static void rmatrixtrinverse(ref double[,] a, bool isupper, out int info, out matinvreport rep, alglib.xparams _xparams)
    {
        int n;
        bool isunit;
        if( (ap.cols(a)!=ap.rows(a)))
            throw new alglibexception("Error while calling 'rmatrixtrinverse': looks like one of arguments has wrong size");
        n = ap.cols(a);
        isunit = false;
        _core_rmatrixtrinverse(ref  a,  n,  isupper,  isunit, out  info, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_cmatrixtrinverse(ref complex[,] a, int n, bool isupper, bool isunit, out int info, out matinvreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        byte _d_isunit = (byte)(isunit ? 1 : 0);
        x_int _d_info = new x_int();
        x_matinvreport _d_rep = new x_matinvreport();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matinvreport_init(ref _d_rep);
                _error_code = _i_xv2_cmatrixtrinverse(&_s_errormsg, &_d_a, &_d_n, &_d_isupper, &_d_isunit, &_d_info, &_d_rep, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "cmatrixtrinverse");
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new alglib.complex[0,0];
            info = _d_info.intval;
            rep = null;
            x_matinvreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matinvreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void cmatrixtrinverse(ref complex[,] a, int n, bool isupper, bool isunit, out int info, out matinvreport rep)
    {
        _core_cmatrixtrinverse(ref  a,  n,  isupper,  isunit, out  info, out  rep, 0x0);
    }
    
    public static void cmatrixtrinverse(ref complex[,] a, int n, bool isupper, bool isunit, out int info, out matinvreport rep, alglib.xparams _xparams)
    {
        _core_cmatrixtrinverse(ref  a,  n,  isupper,  isunit, out  info, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void cmatrixtrinverse(ref complex[,] a, bool isupper, out int info, out matinvreport rep)
    {
        int n;
        bool isunit;
        if( (ap.cols(a)!=ap.rows(a)))
            throw new alglibexception("Error while calling 'cmatrixtrinverse': looks like one of arguments has wrong size");
        n = ap.cols(a);
        isunit = false;
        _core_cmatrixtrinverse(ref  a,  n,  isupper,  isunit, out  info, out  rep, 0x0);
    
        
    }
    
    public static void cmatrixtrinverse(ref complex[,] a, bool isupper, out int info, out matinvreport rep, alglib.xparams _xparams)
    {
        int n;
        bool isunit;
        if( (ap.cols(a)!=ap.rows(a)))
            throw new alglibexception("Error while calling 'cmatrixtrinverse': looks like one of arguments has wrong size");
        n = ap.cols(a);
        isunit = false;
        _core_cmatrixtrinverse(ref  a,  n,  isupper,  isunit, out  info, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    
    //
    // Subpackage optguardapi
    //
    

    [StructLayout(LayoutKind.Sequential, Pack=8)]
    private struct x_optguardreport
    {
        public ulong nonc0suspected;
        public ulong nonc0test0positive;
        public x_int nonc0fidx;
        public double nonc0lipschitzc;
        public ulong nonc1suspected;
        public ulong nonc1test0positive;
        public ulong nonc1test1positive;
        public x_int nonc1fidx;
        public double nonc1lipschitzc;
        public ulong badgradsuspected;
        public x_int badgradfidx;
        public x_int badgradvidx;
        public x_vector badgradxbase;
        public x_matrix badgraduser;
        public x_matrix badgradnum;
    }

    public class optguardreport : alglibobject
    {
        public bool nonc0suspected;
        public bool nonc0test0positive;
        public int nonc0fidx;
        public double nonc0lipschitzc;
        public bool nonc1suspected;
        public bool nonc1test0positive;
        public bool nonc1test1positive;
        public int nonc1fidx;
        public double nonc1lipschitzc;
        public bool badgradsuspected;
        public int badgradfidx;
        public int badgradvidx;
        public double[] badgradxbase;
        public double[,] badgraduser;
        public double[,] badgradnum;
        public override alglib.alglibobject make_copy()
        {
            optguardreport dst = new optguardreport();
            dst.nonc0suspected = nonc0suspected;
            dst.nonc0test0positive = nonc0test0positive;
            dst.nonc0fidx = nonc0fidx;
            dst.nonc0lipschitzc = nonc0lipschitzc;
            dst.nonc1suspected = nonc1suspected;
            dst.nonc1test0positive = nonc1test0positive;
            dst.nonc1test1positive = nonc1test1positive;
            dst.nonc1fidx = nonc1fidx;
            dst.nonc1lipschitzc = nonc1lipschitzc;
            dst.badgradsuspected = badgradsuspected;
            dst.badgradfidx = badgradfidx;
            dst.badgradvidx = badgradvidx;
            dst.badgradxbase = (double[])badgradxbase.Clone();        dst.badgraduser = (double[,])badgraduser.Clone();        dst.badgradnum = (double[,])badgradnum.Clone();        return dst;
        }
    }

    // This function initializes X-structure (its previous content is ignored)
    private static void x_optguardreport_init(ref x_optguardreport x)
    {
        x.nonc0suspected = 0;
        x.nonc0test0positive = 0;
        x.nonc0fidx.longval = 0;
        x.nonc0lipschitzc = 0;
        x.nonc1suspected = 0;
        x.nonc1test0positive = 0;
        x.nonc1test1positive = 0;
        x.nonc1fidx.longval = 0;
        x.nonc1lipschitzc = 0;
        x.badgradsuspected = 0;
        x.badgradfidx.longval = 0;
        x.badgradvidx.longval = 0;
        x_vector_create_empty(ref x.badgradxbase, DT_REAL);
        x_matrix_create_empty(ref x.badgraduser, DT_REAL);
        x_matrix_create_empty(ref x.badgradnum, DT_REAL);
    }

    // This function finalizes fields of X-structure (however, memory occupied by structure itself is not freed)
    // After destruction structure becomes unusable and should be re-initialized if you want to use it
    private static void x_optguardreport_clear(ref x_optguardreport x)
    {
        x_vector_clear(ref x.badgradxbase);
        x_matrix_clear(ref x.badgraduser);
        x_matrix_clear(ref x.badgradnum);
    }

    // This function initializes X-structure by appropriate C# instance
    // (previous content of X structure is ignored)
    private static void x_optguardreport_init_from(ref x_optguardreport x, optguardreport v)
    {
        x.nonc0suspected = v.nonc0suspected ? (ulong)1 : (ulong)0;
        x.nonc0test0positive = v.nonc0test0positive ? (ulong)1 : (ulong)0;
        x.nonc0fidx.longval = v.nonc0fidx;
        x.nonc0lipschitzc = v.nonc0lipschitzc;
        x.nonc1suspected = v.nonc1suspected ? (ulong)1 : (ulong)0;
        x.nonc1test0positive = v.nonc1test0positive ? (ulong)1 : (ulong)0;
        x.nonc1test1positive = v.nonc1test1positive ? (ulong)1 : (ulong)0;
        x.nonc1fidx.longval = v.nonc1fidx;
        x.nonc1lipschitzc = v.nonc1lipschitzc;
        x.badgradsuspected = v.badgradsuspected ? (ulong)1 : (ulong)0;
        x.badgradfidx.longval = v.badgradfidx;
        x.badgradvidx.longval = v.badgradvidx;
        x_vector_from_array(ref x.badgradxbase, v.badgradxbase, X_CREATE);
        x_matrix_from_array(ref x.badgraduser, v.badgraduser, X_CREATE);
        x_matrix_from_array(ref x.badgradnum, v.badgradnum, X_CREATE);
    }

    // This function initializes C# structure by appropriate X instance
    // (previous content of C# structure is ignored).
    // This function may accept null v, in this case v is automatically allocated with new().
    private static void x_optguardreport_to_record(ref x_optguardreport x, ref optguardreport v)
    {
        if( v==null )
            v = new optguardreport();
        v.nonc0suspected = x.nonc0suspected!=0;
        v.nonc0test0positive = x.nonc0test0positive!=0;
        v.nonc0fidx = x.nonc0fidx.intval; // long is silently truncated to int
        v.nonc0lipschitzc = x.nonc0lipschitzc;
        v.nonc1suspected = x.nonc1suspected!=0;
        v.nonc1test0positive = x.nonc1test0positive!=0;
        v.nonc1test1positive = x.nonc1test1positive!=0;
        v.nonc1fidx = x.nonc1fidx.intval; // long is silently truncated to int
        v.nonc1lipschitzc = x.nonc1lipschitzc;
        v.badgradsuspected = x.badgradsuspected!=0;
        v.badgradfidx = x.badgradfidx.intval; // long is silently truncated to int
        v.badgradvidx = x.badgradvidx.intval; // long is silently truncated to int
        x_vector_to_array(ref x.badgradxbase, ref v.badgradxbase);
        x_matrix_to_array(ref x.badgraduser, ref v.badgraduser);
        x_matrix_to_array(ref x.badgradnum, ref v.badgradnum);
    }

    [StructLayout(LayoutKind.Sequential, Pack=8)]
    private struct x_optguardnonc0report
    {
        public ulong positive;
        public x_int fidx;
        public x_vector x0;
        public x_vector d;
        public x_int n;
        public x_vector stp;
        public x_vector f;
        public x_int cnt;
        public x_int stpidxa;
        public x_int stpidxb;
        public x_int inneriter;
        public x_int outeriter;
    }

    public class optguardnonc0report : alglibobject
    {
        public bool positive;
        public int fidx;
        public double[] x0;
        public double[] d;
        public int n;
        public double[] stp;
        public double[] f;
        public int cnt;
        public int stpidxa;
        public int stpidxb;
        public int inneriter;
        public int outeriter;
        public override alglib.alglibobject make_copy()
        {
            optguardnonc0report dst = new optguardnonc0report();
            dst.positive = positive;
            dst.fidx = fidx;
            dst.x0 = (double[])x0.Clone();        dst.d = (double[])d.Clone();        dst.n = n;
            dst.stp = (double[])stp.Clone();        dst.f = (double[])f.Clone();        dst.cnt = cnt;
            dst.stpidxa = stpidxa;
            dst.stpidxb = stpidxb;
            dst.inneriter = inneriter;
            dst.outeriter = outeriter;
            return dst;
        }
    }

    // This function initializes X-structure (its previous content is ignored)
    private static void x_optguardnonc0report_init(ref x_optguardnonc0report x)
    {
        x.positive = 0;
        x.fidx.longval = 0;
        x_vector_create_empty(ref x.x0, DT_REAL);
        x_vector_create_empty(ref x.d, DT_REAL);
        x.n.longval = 0;
        x_vector_create_empty(ref x.stp, DT_REAL);
        x_vector_create_empty(ref x.f, DT_REAL);
        x.cnt.longval = 0;
        x.stpidxa.longval = 0;
        x.stpidxb.longval = 0;
        x.inneriter.longval = 0;
        x.outeriter.longval = 0;
    }

    // This function finalizes fields of X-structure (however, memory occupied by structure itself is not freed)
    // After destruction structure becomes unusable and should be re-initialized if you want to use it
    private static void x_optguardnonc0report_clear(ref x_optguardnonc0report x)
    {
        x_vector_clear(ref x.x0);
        x_vector_clear(ref x.d);
        x_vector_clear(ref x.stp);
        x_vector_clear(ref x.f);
    }

    // This function initializes X-structure by appropriate C# instance
    // (previous content of X structure is ignored)
    private static void x_optguardnonc0report_init_from(ref x_optguardnonc0report x, optguardnonc0report v)
    {
        x.positive = v.positive ? (ulong)1 : (ulong)0;
        x.fidx.longval = v.fidx;
        x_vector_from_array(ref x.x0, v.x0, X_CREATE);
        x_vector_from_array(ref x.d, v.d, X_CREATE);
        x.n.longval = v.n;
        x_vector_from_array(ref x.stp, v.stp, X_CREATE);
        x_vector_from_array(ref x.f, v.f, X_CREATE);
        x.cnt.longval = v.cnt;
        x.stpidxa.longval = v.stpidxa;
        x.stpidxb.longval = v.stpidxb;
        x.inneriter.longval = v.inneriter;
        x.outeriter.longval = v.outeriter;
    }

    // This function initializes C# structure by appropriate X instance
    // (previous content of C# structure is ignored).
    // This function may accept null v, in this case v is automatically allocated with new().
    private static void x_optguardnonc0report_to_record(ref x_optguardnonc0report x, ref optguardnonc0report v)
    {
        if( v==null )
            v = new optguardnonc0report();
        v.positive = x.positive!=0;
        v.fidx = x.fidx.intval; // long is silently truncated to int
        x_vector_to_array(ref x.x0, ref v.x0);
        x_vector_to_array(ref x.d, ref v.d);
        v.n = x.n.intval; // long is silently truncated to int
        x_vector_to_array(ref x.stp, ref v.stp);
        x_vector_to_array(ref x.f, ref v.f);
        v.cnt = x.cnt.intval; // long is silently truncated to int
        v.stpidxa = x.stpidxa.intval; // long is silently truncated to int
        v.stpidxb = x.stpidxb.intval; // long is silently truncated to int
        v.inneriter = x.inneriter.intval; // long is silently truncated to int
        v.outeriter = x.outeriter.intval; // long is silently truncated to int
    }

    [StructLayout(LayoutKind.Sequential, Pack=8)]
    private struct x_optguardnonc1test0report
    {
        public ulong positive;
        public x_int fidx;
        public x_vector x0;
        public x_vector d;
        public x_int n;
        public x_vector stp;
        public x_vector f;
        public x_int cnt;
        public x_int stpidxa;
        public x_int stpidxb;
        public x_int inneriter;
        public x_int outeriter;
    }

    public class optguardnonc1test0report : alglibobject
    {
        public bool positive;
        public int fidx;
        public double[] x0;
        public double[] d;
        public int n;
        public double[] stp;
        public double[] f;
        public int cnt;
        public int stpidxa;
        public int stpidxb;
        public int inneriter;
        public int outeriter;
        public override alglib.alglibobject make_copy()
        {
            optguardnonc1test0report dst = new optguardnonc1test0report();
            dst.positive = positive;
            dst.fidx = fidx;
            dst.x0 = (double[])x0.Clone();        dst.d = (double[])d.Clone();        dst.n = n;
            dst.stp = (double[])stp.Clone();        dst.f = (double[])f.Clone();        dst.cnt = cnt;
            dst.stpidxa = stpidxa;
            dst.stpidxb = stpidxb;
            dst.inneriter = inneriter;
            dst.outeriter = outeriter;
            return dst;
        }
    }

    // This function initializes X-structure (its previous content is ignored)
    private static void x_optguardnonc1test0report_init(ref x_optguardnonc1test0report x)
    {
        x.positive = 0;
        x.fidx.longval = 0;
        x_vector_create_empty(ref x.x0, DT_REAL);
        x_vector_create_empty(ref x.d, DT_REAL);
        x.n.longval = 0;
        x_vector_create_empty(ref x.stp, DT_REAL);
        x_vector_create_empty(ref x.f, DT_REAL);
        x.cnt.longval = 0;
        x.stpidxa.longval = 0;
        x.stpidxb.longval = 0;
        x.inneriter.longval = 0;
        x.outeriter.longval = 0;
    }

    // This function finalizes fields of X-structure (however, memory occupied by structure itself is not freed)
    // After destruction structure becomes unusable and should be re-initialized if you want to use it
    private static void x_optguardnonc1test0report_clear(ref x_optguardnonc1test0report x)
    {
        x_vector_clear(ref x.x0);
        x_vector_clear(ref x.d);
        x_vector_clear(ref x.stp);
        x_vector_clear(ref x.f);
    }

    // This function initializes X-structure by appropriate C# instance
    // (previous content of X structure is ignored)
    private static void x_optguardnonc1test0report_init_from(ref x_optguardnonc1test0report x, optguardnonc1test0report v)
    {
        x.positive = v.positive ? (ulong)1 : (ulong)0;
        x.fidx.longval = v.fidx;
        x_vector_from_array(ref x.x0, v.x0, X_CREATE);
        x_vector_from_array(ref x.d, v.d, X_CREATE);
        x.n.longval = v.n;
        x_vector_from_array(ref x.stp, v.stp, X_CREATE);
        x_vector_from_array(ref x.f, v.f, X_CREATE);
        x.cnt.longval = v.cnt;
        x.stpidxa.longval = v.stpidxa;
        x.stpidxb.longval = v.stpidxb;
        x.inneriter.longval = v.inneriter;
        x.outeriter.longval = v.outeriter;
    }

    // This function initializes C# structure by appropriate X instance
    // (previous content of C# structure is ignored).
    // This function may accept null v, in this case v is automatically allocated with new().
    private static void x_optguardnonc1test0report_to_record(ref x_optguardnonc1test0report x, ref optguardnonc1test0report v)
    {
        if( v==null )
            v = new optguardnonc1test0report();
        v.positive = x.positive!=0;
        v.fidx = x.fidx.intval; // long is silently truncated to int
        x_vector_to_array(ref x.x0, ref v.x0);
        x_vector_to_array(ref x.d, ref v.d);
        v.n = x.n.intval; // long is silently truncated to int
        x_vector_to_array(ref x.stp, ref v.stp);
        x_vector_to_array(ref x.f, ref v.f);
        v.cnt = x.cnt.intval; // long is silently truncated to int
        v.stpidxa = x.stpidxa.intval; // long is silently truncated to int
        v.stpidxb = x.stpidxb.intval; // long is silently truncated to int
        v.inneriter = x.inneriter.intval; // long is silently truncated to int
        v.outeriter = x.outeriter.intval; // long is silently truncated to int
    }

    [StructLayout(LayoutKind.Sequential, Pack=8)]
    private struct x_optguardnonc1test1report
    {
        public ulong positive;
        public x_int fidx;
        public x_int vidx;
        public x_vector x0;
        public x_vector d;
        public x_int n;
        public x_vector stp;
        public x_vector g;
        public x_int cnt;
        public x_int stpidxa;
        public x_int stpidxb;
        public x_int inneriter;
        public x_int outeriter;
    }

    public class optguardnonc1test1report : alglibobject
    {
        public bool positive;
        public int fidx;
        public int vidx;
        public double[] x0;
        public double[] d;
        public int n;
        public double[] stp;
        public double[] g;
        public int cnt;
        public int stpidxa;
        public int stpidxb;
        public int inneriter;
        public int outeriter;
        public override alglib.alglibobject make_copy()
        {
            optguardnonc1test1report dst = new optguardnonc1test1report();
            dst.positive = positive;
            dst.fidx = fidx;
            dst.vidx = vidx;
            dst.x0 = (double[])x0.Clone();        dst.d = (double[])d.Clone();        dst.n = n;
            dst.stp = (double[])stp.Clone();        dst.g = (double[])g.Clone();        dst.cnt = cnt;
            dst.stpidxa = stpidxa;
            dst.stpidxb = stpidxb;
            dst.inneriter = inneriter;
            dst.outeriter = outeriter;
            return dst;
        }
    }

    // This function initializes X-structure (its previous content is ignored)
    private static void x_optguardnonc1test1report_init(ref x_optguardnonc1test1report x)
    {
        x.positive = 0;
        x.fidx.longval = 0;
        x.vidx.longval = 0;
        x_vector_create_empty(ref x.x0, DT_REAL);
        x_vector_create_empty(ref x.d, DT_REAL);
        x.n.longval = 0;
        x_vector_create_empty(ref x.stp, DT_REAL);
        x_vector_create_empty(ref x.g, DT_REAL);
        x.cnt.longval = 0;
        x.stpidxa.longval = 0;
        x.stpidxb.longval = 0;
        x.inneriter.longval = 0;
        x.outeriter.longval = 0;
    }

    // This function finalizes fields of X-structure (however, memory occupied by structure itself is not freed)
    // After destruction structure becomes unusable and should be re-initialized if you want to use it
    private static void x_optguardnonc1test1report_clear(ref x_optguardnonc1test1report x)
    {
        x_vector_clear(ref x.x0);
        x_vector_clear(ref x.d);
        x_vector_clear(ref x.stp);
        x_vector_clear(ref x.g);
    }

    // This function initializes X-structure by appropriate C# instance
    // (previous content of X structure is ignored)
    private static void x_optguardnonc1test1report_init_from(ref x_optguardnonc1test1report x, optguardnonc1test1report v)
    {
        x.positive = v.positive ? (ulong)1 : (ulong)0;
        x.fidx.longval = v.fidx;
        x.vidx.longval = v.vidx;
        x_vector_from_array(ref x.x0, v.x0, X_CREATE);
        x_vector_from_array(ref x.d, v.d, X_CREATE);
        x.n.longval = v.n;
        x_vector_from_array(ref x.stp, v.stp, X_CREATE);
        x_vector_from_array(ref x.g, v.g, X_CREATE);
        x.cnt.longval = v.cnt;
        x.stpidxa.longval = v.stpidxa;
        x.stpidxb.longval = v.stpidxb;
        x.inneriter.longval = v.inneriter;
        x.outeriter.longval = v.outeriter;
    }

    // This function initializes C# structure by appropriate X instance
    // (previous content of C# structure is ignored).
    // This function may accept null v, in this case v is automatically allocated with new().
    private static void x_optguardnonc1test1report_to_record(ref x_optguardnonc1test1report x, ref optguardnonc1test1report v)
    {
        if( v==null )
            v = new optguardnonc1test1report();
        v.positive = x.positive!=0;
        v.fidx = x.fidx.intval; // long is silently truncated to int
        v.vidx = x.vidx.intval; // long is silently truncated to int
        x_vector_to_array(ref x.x0, ref v.x0);
        x_vector_to_array(ref x.d, ref v.d);
        v.n = x.n.intval; // long is silently truncated to int
        x_vector_to_array(ref x.stp, ref v.stp);
        x_vector_to_array(ref x.g, ref v.g);
        v.cnt = x.cnt.intval; // long is silently truncated to int
        v.stpidxa = x.stpidxa.intval; // long is silently truncated to int
        v.stpidxb = x.stpidxb.intval; // long is silently truncated to int
        v.inneriter = x.inneriter.intval; // long is silently truncated to int
        v.outeriter = x.outeriter.intval; // long is silently truncated to int
    }
    
    
    //
    // Subpackage optserv
    //
    
    
    
    //
    // Subpackage minlbfgs
    //
    

    public unsafe class minlbfgsstate : alglibobject
    {
        private void *_ptr;
        public minlbfgsstate(void *x)
        {
            _ptr = x;
        }
        ~minlbfgsstate()
        {
            _deallocate();
        }
        public void* ptr { get { return _ptr; } }
        public override alglib.alglibobject make_copy()
        {
            if( _ptr==null )
                return new minlbfgsstate(null);
            return new minlbfgsstate(_i_x_obj_copy_minlbfgsstate(_ptr));
        }
        public override void _deallocate()
        {
            if( _ptr!=null )
                _i_x_obj_free_minlbfgsstate(_ptr);
            _ptr = null;
            System.GC.SuppressFinalize(this);
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_minlbfgsstate(void *x);
    private static _d_x_obj_copy_minlbfgsstate _i_x_obj_copy_minlbfgsstate = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_obj_free_minlbfgsstate(void *x);
    private static _d_x_obj_free_minlbfgsstate _i_x_obj_free_minlbfgsstate = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_minlbfgsstate_get_needf(void *x, byte *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_minlbfgsstate_set_needf(void *x, byte *dst);
    private static _d_x_minlbfgsstate_get_needf _i_x_minlbfgsstate_get_needf = null;
    private static _d_x_minlbfgsstate_set_needf _i_x_minlbfgsstate_set_needf = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_minlbfgsstate_get_needfg(void *x, byte *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_minlbfgsstate_set_needfg(void *x, byte *dst);
    private static _d_x_minlbfgsstate_get_needfg _i_x_minlbfgsstate_get_needfg = null;
    private static _d_x_minlbfgsstate_set_needfg _i_x_minlbfgsstate_set_needfg = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_minlbfgsstate_get_xupdated(void *x, byte *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_minlbfgsstate_set_xupdated(void *x, byte *dst);
    private static _d_x_minlbfgsstate_get_xupdated _i_x_minlbfgsstate_get_xupdated = null;
    private static _d_x_minlbfgsstate_set_xupdated _i_x_minlbfgsstate_set_xupdated = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_minlbfgsstate_get_f(void *x, double *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_minlbfgsstate_set_f(void *x, double *dst);
    private static _d_x_minlbfgsstate_get_f _i_x_minlbfgsstate_get_f = null;
    private static _d_x_minlbfgsstate_set_f _i_x_minlbfgsstate_set_f = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_minlbfgsstate_get_g(void *x, x_vector *dst);
    private static _d_x_minlbfgsstate_get_g _i_x_minlbfgsstate_get_g = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_minlbfgsstate_get_x(void *x, x_vector *dst);
    private static _d_x_minlbfgsstate_get_x _i_x_minlbfgsstate_get_x = null;

    [StructLayout(LayoutKind.Sequential, Pack=8)]
    private struct x_minlbfgsreport
    {
        public x_int iterationscount;
        public x_int nfev;
        public x_int terminationtype;
    }

    public class minlbfgsreport : alglibobject
    {
        public int iterationscount;
        public int nfev;
        public int terminationtype;
        public override alglib.alglibobject make_copy()
        {
            minlbfgsreport dst = new minlbfgsreport();
            dst.iterationscount = iterationscount;
            dst.nfev = nfev;
            dst.terminationtype = terminationtype;
            return dst;
        }
    }

    // This function initializes X-structure (its previous content is ignored)
    private static void x_minlbfgsreport_init(ref x_minlbfgsreport x)
    {
        x.iterationscount.longval = 0;
        x.nfev.longval = 0;
        x.terminationtype.longval = 0;
    }

    // This function finalizes fields of X-structure (however, memory occupied by structure itself is not freed)
    // After destruction structure becomes unusable and should be re-initialized if you want to use it
    private static void x_minlbfgsreport_clear(ref x_minlbfgsreport x)
    {
    }

    // This function initializes X-structure by appropriate C# instance
    // (previous content of X structure is ignored)
    private static void x_minlbfgsreport_init_from(ref x_minlbfgsreport x, minlbfgsreport v)
    {
        x.iterationscount.longval = v.iterationscount;
        x.nfev.longval = v.nfev;
        x.terminationtype.longval = v.terminationtype;
    }

    // This function initializes C# structure by appropriate X instance
    // (previous content of C# structure is ignored).
    // This function may accept null v, in this case v is automatically allocated with new().
    private static void x_minlbfgsreport_to_record(ref x_minlbfgsreport x, ref minlbfgsreport v)
    {
        if( v==null )
            v = new minlbfgsreport();
        v.iterationscount = x.iterationscount.intval; // long is silently truncated to int
        v.nfev = x.nfev.intval; // long is silently truncated to int
        v.terminationtype = x.terminationtype.intval; // long is silently truncated to int
    }
    
    private static unsafe void _core_minlbfgscreate(int n, int m, double[] x, out minlbfgsstate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        x_int _d_m = new x_int(m);
        x_vector _d_x = new x_vector();
        void *_d_state = null;
        state = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_xv2_minlbfgscreate(&_s_errormsg, &_d_n, &_d_m, &_d_x, &_d_state, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minlbfgscreate");
            state = new minlbfgsstate(_d_state);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            if( _d_state!=null && state==null)
                _i_x_obj_free_minlbfgsstate(_d_state); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void minlbfgscreate(int n, int m, double[] x, out minlbfgsstate state)
    {
        _core_minlbfgscreate( n,  m,  x, out  state, 0x0);
    }
    
    public static void minlbfgscreate(int n, int m, double[] x, out minlbfgsstate state, alglib.xparams _xparams)
    {
        _core_minlbfgscreate( n,  m,  x, out  state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void minlbfgscreate(int m, double[] x, out minlbfgsstate state)
    {
        int n;
    
        n = ap.len(x);
        _core_minlbfgscreate( n,  m,  x, out  state, 0x0);
    
        
    }
    
    public static void minlbfgscreate(int m, double[] x, out minlbfgsstate state, alglib.xparams _xparams)
    {
        int n;
    
        n = ap.len(x);
        _core_minlbfgscreate( n,  m,  x, out  state, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_minlbfgscreatef(int n, int m, double[] x, double diffstep, out minlbfgsstate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        x_int _d_m = new x_int(m);
        x_vector _d_x = new x_vector();
        double _d_diffstep = diffstep;
        void *_d_state = null;
        state = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_xv2_minlbfgscreatef(&_s_errormsg, &_d_n, &_d_m, &_d_x, &_d_diffstep, &_d_state, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minlbfgscreatef");
            state = new minlbfgsstate(_d_state);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            if( _d_state!=null && state==null)
                _i_x_obj_free_minlbfgsstate(_d_state); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void minlbfgscreatef(int n, int m, double[] x, double diffstep, out minlbfgsstate state)
    {
        _core_minlbfgscreatef( n,  m,  x,  diffstep, out  state, 0x0);
    }
    
    public static void minlbfgscreatef(int n, int m, double[] x, double diffstep, out minlbfgsstate state, alglib.xparams _xparams)
    {
        _core_minlbfgscreatef( n,  m,  x,  diffstep, out  state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void minlbfgscreatef(int m, double[] x, double diffstep, out minlbfgsstate state)
    {
        int n;
    
        n = ap.len(x);
        _core_minlbfgscreatef( n,  m,  x,  diffstep, out  state, 0x0);
    
        
    }
    
    public static void minlbfgscreatef(int m, double[] x, double diffstep, out minlbfgsstate state, alglib.xparams _xparams)
    {
        int n;
    
        n = ap.len(x);
        _core_minlbfgscreatef( n,  m,  x,  diffstep, out  state, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_minlbfgssetcond(minlbfgsstate state, double epsg, double epsf, double epsx, int maxits, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_epsg = epsg;
        double _d_epsf = epsf;
        double _d_epsx = epsx;
        x_int _d_maxits = new x_int(maxits);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_minlbfgssetcond(&_s_errormsg, &_d_state, &_d_epsg, &_d_epsf, &_d_epsx, &_d_maxits, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minlbfgssetcond");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void minlbfgssetcond(minlbfgsstate state, double epsg, double epsf, double epsx, int maxits)
    {
        _core_minlbfgssetcond( state,  epsg,  epsf,  epsx,  maxits, 0x0);
    }
    
    public static void minlbfgssetcond(minlbfgsstate state, double epsg, double epsf, double epsx, int maxits, alglib.xparams _xparams)
    {
        _core_minlbfgssetcond( state,  epsg,  epsf,  epsx,  maxits, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minlbfgssetxrep(minlbfgsstate state, bool needxrep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        byte _d_needxrep = (byte)(needxrep ? 1 : 0);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_minlbfgssetxrep(&_s_errormsg, &_d_state, &_d_needxrep, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minlbfgssetxrep");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void minlbfgssetxrep(minlbfgsstate state, bool needxrep)
    {
        _core_minlbfgssetxrep( state,  needxrep, 0x0);
    }
    
    public static void minlbfgssetxrep(minlbfgsstate state, bool needxrep, alglib.xparams _xparams)
    {
        _core_minlbfgssetxrep( state,  needxrep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minlbfgssetstpmax(minlbfgsstate state, double stpmax, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_stpmax = stpmax;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_minlbfgssetstpmax(&_s_errormsg, &_d_state, &_d_stpmax, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minlbfgssetstpmax");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void minlbfgssetstpmax(minlbfgsstate state, double stpmax)
    {
        _core_minlbfgssetstpmax( state,  stpmax, 0x0);
    }
    
    public static void minlbfgssetstpmax(minlbfgsstate state, double stpmax, alglib.xparams _xparams)
    {
        _core_minlbfgssetstpmax( state,  stpmax, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minlbfgssetscale(minlbfgsstate state, double[] s, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_s = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_s = s){
                x_vector_attach_to_array(ref _d_s, _fp_s, ap.len(s));
                _error_code = _i_xv2_minlbfgssetscale(&_s_errormsg, &_d_state, &_d_s, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minlbfgssetscale");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_s);
        }
        // This function returns no value.
    }
    
    public static void minlbfgssetscale(minlbfgsstate state, double[] s)
    {
        _core_minlbfgssetscale( state,  s, 0x0);
    }
    
    public static void minlbfgssetscale(minlbfgsstate state, double[] s, alglib.xparams _xparams)
    {
        _core_minlbfgssetscale( state,  s, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minlbfgssetprecdefault(minlbfgsstate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_minlbfgssetprecdefault(&_s_errormsg, &_d_state, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minlbfgssetprecdefault");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void minlbfgssetprecdefault(minlbfgsstate state)
    {
        _core_minlbfgssetprecdefault( state, 0x0);
    }
    
    public static void minlbfgssetprecdefault(minlbfgsstate state, alglib.xparams _xparams)
    {
        _core_minlbfgssetprecdefault( state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minlbfgssetpreccholesky(minlbfgsstate state, double[,] p, bool isupper, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_matrix _d_p = new x_matrix();
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_p = p){
                x_matrix_attach_to_array(ref _d_p, _fp_p, ap.rows(p), ap.cols(p));
                _error_code = _i_xv2_minlbfgssetpreccholesky(&_s_errormsg, &_d_state, &_d_p, &_d_isupper, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minlbfgssetpreccholesky");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_p);
        }
        // This function returns no value.
    }
    
    public static void minlbfgssetpreccholesky(minlbfgsstate state, double[,] p, bool isupper)
    {
        _core_minlbfgssetpreccholesky( state,  p,  isupper, 0x0);
    }
    
    public static void minlbfgssetpreccholesky(minlbfgsstate state, double[,] p, bool isupper, alglib.xparams _xparams)
    {
        _core_minlbfgssetpreccholesky( state,  p,  isupper, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minlbfgssetprecdiag(minlbfgsstate state, double[] d, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_d = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_d = d){
                x_vector_attach_to_array(ref _d_d, _fp_d, ap.len(d));
                _error_code = _i_xv2_minlbfgssetprecdiag(&_s_errormsg, &_d_state, &_d_d, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minlbfgssetprecdiag");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_d);
        }
        // This function returns no value.
    }
    
    public static void minlbfgssetprecdiag(minlbfgsstate state, double[] d)
    {
        _core_minlbfgssetprecdiag( state,  d, 0x0);
    }
    
    public static void minlbfgssetprecdiag(minlbfgsstate state, double[] d, alglib.xparams _xparams)
    {
        _core_minlbfgssetprecdiag( state,  d, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minlbfgssetprecscale(minlbfgsstate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_minlbfgssetprecscale(&_s_errormsg, &_d_state, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minlbfgssetprecscale");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void minlbfgssetprecscale(minlbfgsstate state)
    {
        _core_minlbfgssetprecscale( state, 0x0);
    }
    
    public static void minlbfgssetprecscale(minlbfgsstate state, alglib.xparams _xparams)
    {
        _core_minlbfgssetprecscale( state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe bool _core_minlbfgsiteration(minlbfgsstate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        bool result;
        byte _d_result = (byte)0;
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_minlbfgsiteration(&_s_errormsg, &_d_result, &_d_state, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minlbfgsiteration");
            result = _d_result!=0;
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static bool minlbfgsiteration(minlbfgsstate state)
    {
        return _core_minlbfgsiteration( state, 0x0);
    }
    
    public static bool minlbfgsiteration(minlbfgsstate state, alglib.xparams _xparams)
    {
        return _core_minlbfgsiteration( state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static unsafe void minlbfgsoptimize(minlbfgsstate state, ndimensional_func func, ndimensional_rep rep, object obj)
    {
        minlbfgsoptimize(state, func, rep, obj, null);
    }
    
    public static unsafe void minlbfgsoptimize(minlbfgsstate state, ndimensional_func func, ndimensional_rep rep, object obj, alglib.xparams _xparams)
    {
        byte *_s_errormsg = null;
        int _error_code = 0;
        byte _b_result = (byte)0;
        byte _xc_xupdated = 0;
        void *_state = state.ptr;
        IntPtr _pre_ptr;
        x_vector _xc_arg = new x_vector();
        double[] _cs_arg = null;
        double _cs_f = 0;
        byte _xc_needf= 0;
    
        //
        // Check correctness of delegates
        //
        if( func==null )
            throw new alglibexception("ALGLIB: error in 'minlbfgsoptimize()' (func is null)");
    
        //
        // Attach x-structures to internal arrays
        //
        x_vector_create_empty(ref _xc_arg, DT_REAL);
        _i_x_minlbfgsstate_get_x(_state, &_xc_arg);
        _cs_arg = new double[_xc_arg.cnt];
    
        //
        // Main loop
        //
        for(;;)
        {
            //
            // Call iteration function.
            // Terminate iterations if it returned false.
            //
            _error_code = _i_xv2_minlbfgsiteration(&_s_errormsg, &_b_result, &_state, _xparams==null ? 0x0 : _xparams.flags);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minlbfgsiteration");
            ap.assert(_state==state.ptr, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _b_result==0 )
                break;
            
            //
            // Reverse communication interface:
            // * fetch flags
            // * make delegate calls
            //
            _i_x_minlbfgsstate_get_xupdated(_state, &_xc_xupdated);
            _i_x_minlbfgsstate_get_needf(_state, &_xc_needf);
            x_vector_to_array(ref _xc_arg, ref _cs_arg);
            if( _xc_needf!=0 )
            {
                func(_cs_arg, ref _cs_f, obj);
                _i_x_minlbfgsstate_set_f(_state, &_cs_f);
                continue;
            }
            if( _xc_xupdated!=0 )
            {
                if( rep!=null )
                {
                    double _local_f;
                    _i_x_minlbfgsstate_get_f(_state, &_local_f);
                    rep(_cs_arg, _local_f, obj);
                }
                continue;
            }
            throw new alglibexception("ALGLIB: error in 'minlbfgsoptimize' (some derivatives were not provided?)");
        }
        
        //
        // Integrity post-check:
        // * make sure that no reverse communication array was reallocated during optimization
        //
        _pre_ptr = _xc_arg.xptr.ptr;
        _i_x_minlbfgsstate_get_x(_state, &_xc_arg);
        alglib.ap.assert(_xc_arg.xptr.ptr==_pre_ptr, "ALGLIB: integrity check failed in minlbfgsoptimize()");
    }
    
    public static unsafe void minlbfgsoptimize(minlbfgsstate state, ndimensional_grad grad, ndimensional_rep rep, object obj)
    {
        minlbfgsoptimize(state, grad, rep, obj, null);
    }
    
    public static unsafe void minlbfgsoptimize(minlbfgsstate state, ndimensional_grad grad, ndimensional_rep rep, object obj, alglib.xparams _xparams)
    {
        byte *_s_errormsg = null;
        int _error_code = 0;
        byte _b_result = (byte)0;
        byte _xc_xupdated = 0;
        void *_state = state.ptr;
        IntPtr _pre_ptr;
        x_vector _xc_arg = new x_vector();
        double[] _cs_arg = null;
        double _cs_f = 0;
        x_vector _xc_g = new x_vector();
        double[] _cs_g = null;
        byte _xc_needfg= 0;
    
        //
        // Check correctness of delegates
        //
        if( grad==null )
            throw new alglibexception("ALGLIB: error in 'minlbfgsoptimize()' (grad is null)");
    
        //
        // Attach x-structures to internal arrays
        //
        x_vector_create_empty(ref _xc_arg, DT_REAL);
        x_vector_create_empty(ref _xc_g, DT_REAL);
        _i_x_minlbfgsstate_get_x(_state, &_xc_arg);
        _i_x_minlbfgsstate_get_g(_state, &_xc_g);
        _cs_arg = new double[_xc_arg.cnt];
        _cs_g = new double[_xc_g.cnt];
    
        //
        // Main loop
        //
        for(;;)
        {
            //
            // Call iteration function.
            // Terminate iterations if it returned false.
            //
            _error_code = _i_xv2_minlbfgsiteration(&_s_errormsg, &_b_result, &_state, _xparams==null ? 0x0 : _xparams.flags);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minlbfgsiteration");
            ap.assert(_state==state.ptr, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _b_result==0 )
                break;
            
            //
            // Reverse communication interface:
            // * fetch flags
            // * make delegate calls
            //
            _i_x_minlbfgsstate_get_xupdated(_state, &_xc_xupdated);
            _i_x_minlbfgsstate_get_needfg(_state, &_xc_needfg);
            x_vector_to_array(ref _xc_arg, ref _cs_arg);
            if( _xc_needfg!=0 )
            {
                grad(_cs_arg, ref _cs_f, _cs_g, obj);
                _i_x_minlbfgsstate_set_f(_state, &_cs_f);
                x_vector_from_array(ref _xc_g, _cs_g, X_REWRITE);
                continue;
            }
            if( _xc_xupdated!=0 )
            {
                if( rep!=null )
                {
                    double _local_f;
                    _i_x_minlbfgsstate_get_f(_state, &_local_f);
                    rep(_cs_arg, _local_f, obj);
                }
                continue;
            }
            throw new alglibexception("ALGLIB: error in 'minlbfgsoptimize' (some derivatives were not provided?)");
        }
        
        //
        // Integrity post-check:
        // * make sure that no reverse communication array was reallocated during optimization
        //
        _pre_ptr = _xc_arg.xptr.ptr;
        _i_x_minlbfgsstate_get_x(_state, &_xc_arg);
        alglib.ap.assert(_xc_arg.xptr.ptr==_pre_ptr, "ALGLIB: integrity check failed in minlbfgsoptimize()");
        _pre_ptr = _xc_g.xptr.ptr;
        _i_x_minlbfgsstate_get_g(_state, &_xc_g);
        alglib.ap.assert(_xc_g.xptr.ptr==_pre_ptr, "ALGLIB: integrity check failed in minlbfgsoptimize()");
    }
    
    private static unsafe void _core_minlbfgsoptguardgradient(minlbfgsstate state, double teststep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_teststep = teststep;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_minlbfgsoptguardgradient(&_s_errormsg, &_d_state, &_d_teststep, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minlbfgsoptguardgradient");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void minlbfgsoptguardgradient(minlbfgsstate state, double teststep)
    {
        _core_minlbfgsoptguardgradient( state,  teststep, 0x0);
    }
    
    public static void minlbfgsoptguardgradient(minlbfgsstate state, double teststep, alglib.xparams _xparams)
    {
        _core_minlbfgsoptguardgradient( state,  teststep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minlbfgsoptguardsmoothness(minlbfgsstate state, int level, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_int _d_level = new x_int(level);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_minlbfgsoptguardsmoothness(&_s_errormsg, &_d_state, &_d_level, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minlbfgsoptguardsmoothness");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void minlbfgsoptguardsmoothness(minlbfgsstate state, int level)
    {
        _core_minlbfgsoptguardsmoothness( state,  level, 0x0);
    }
    
    public static void minlbfgsoptguardsmoothness(minlbfgsstate state, int level, alglib.xparams _xparams)
    {
        _core_minlbfgsoptguardsmoothness( state,  level, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void minlbfgsoptguardsmoothness(minlbfgsstate state)
    {
        int level;
    
        level = 1;
        _core_minlbfgsoptguardsmoothness( state,  level, 0x0);
    
        
    }
    
    public static void minlbfgsoptguardsmoothness(minlbfgsstate state, alglib.xparams _xparams)
    {
        int level;
    
        level = 1;
        _core_minlbfgsoptguardsmoothness( state,  level, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_minlbfgsoptguardresults(minlbfgsstate state, out optguardreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_optguardreport _d_rep = new x_optguardreport();
        
        // Pack, call, unpack
        try
        {
            x_optguardreport_init(ref _d_rep);
            _error_code = _i_xv2_minlbfgsoptguardresults(&_s_errormsg, &_d_state, &_d_rep, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minlbfgsoptguardresults");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            rep = null;
            x_optguardreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_optguardreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void minlbfgsoptguardresults(minlbfgsstate state, out optguardreport rep)
    {
        _core_minlbfgsoptguardresults( state, out  rep, 0x0);
    }
    
    public static void minlbfgsoptguardresults(minlbfgsstate state, out optguardreport rep, alglib.xparams _xparams)
    {
        _core_minlbfgsoptguardresults( state, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minlbfgsoptguardnonc1test0results(minlbfgsstate state, out optguardnonc1test0report strrep, out optguardnonc1test0report lngrep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_optguardnonc1test0report _d_strrep = new x_optguardnonc1test0report();
        x_optguardnonc1test0report _d_lngrep = new x_optguardnonc1test0report();
        
        // Pack, call, unpack
        try
        {
            x_optguardnonc1test0report_init(ref _d_strrep);
            x_optguardnonc1test0report_init(ref _d_lngrep);
            _error_code = _i_xv2_minlbfgsoptguardnonc1test0results(&_s_errormsg, &_d_state, &_d_strrep, &_d_lngrep, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minlbfgsoptguardnonc1test0results");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            strrep = null;
            x_optguardnonc1test0report_to_record(ref _d_strrep, ref strrep);
            lngrep = null;
            x_optguardnonc1test0report_to_record(ref _d_lngrep, ref lngrep);
        }
        finally
        {
            x_optguardnonc1test0report_clear(ref _d_strrep);
            x_optguardnonc1test0report_clear(ref _d_lngrep);
        }
        // This function returns no value.
    }
    
    public static void minlbfgsoptguardnonc1test0results(minlbfgsstate state, out optguardnonc1test0report strrep, out optguardnonc1test0report lngrep)
    {
        _core_minlbfgsoptguardnonc1test0results( state, out  strrep, out  lngrep, 0x0);
    }
    
    public static void minlbfgsoptguardnonc1test0results(minlbfgsstate state, out optguardnonc1test0report strrep, out optguardnonc1test0report lngrep, alglib.xparams _xparams)
    {
        _core_minlbfgsoptguardnonc1test0results( state, out  strrep, out  lngrep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minlbfgsoptguardnonc1test1results(minlbfgsstate state, out optguardnonc1test1report strrep, out optguardnonc1test1report lngrep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_optguardnonc1test1report _d_strrep = new x_optguardnonc1test1report();
        x_optguardnonc1test1report _d_lngrep = new x_optguardnonc1test1report();
        
        // Pack, call, unpack
        try
        {
            x_optguardnonc1test1report_init(ref _d_strrep);
            x_optguardnonc1test1report_init(ref _d_lngrep);
            _error_code = _i_xv2_minlbfgsoptguardnonc1test1results(&_s_errormsg, &_d_state, &_d_strrep, &_d_lngrep, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minlbfgsoptguardnonc1test1results");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            strrep = null;
            x_optguardnonc1test1report_to_record(ref _d_strrep, ref strrep);
            lngrep = null;
            x_optguardnonc1test1report_to_record(ref _d_lngrep, ref lngrep);
        }
        finally
        {
            x_optguardnonc1test1report_clear(ref _d_strrep);
            x_optguardnonc1test1report_clear(ref _d_lngrep);
        }
        // This function returns no value.
    }
    
    public static void minlbfgsoptguardnonc1test1results(minlbfgsstate state, out optguardnonc1test1report strrep, out optguardnonc1test1report lngrep)
    {
        _core_minlbfgsoptguardnonc1test1results( state, out  strrep, out  lngrep, 0x0);
    }
    
    public static void minlbfgsoptguardnonc1test1results(minlbfgsstate state, out optguardnonc1test1report strrep, out optguardnonc1test1report lngrep, alglib.xparams _xparams)
    {
        _core_minlbfgsoptguardnonc1test1results( state, out  strrep, out  lngrep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minlbfgsresults(minlbfgsstate state, out double[] x, out minlbfgsreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_x = new x_vector();
        x_minlbfgsreport _d_rep = new x_minlbfgsreport();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_x, DT_REAL);
            x = null;
            x_minlbfgsreport_init(ref _d_rep);
            _error_code = _i_xv2_minlbfgsresults(&_s_errormsg, &_d_state, &_d_x, &_d_rep, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minlbfgsresults");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
            rep = null;
            x_minlbfgsreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_minlbfgsreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void minlbfgsresults(minlbfgsstate state, out double[] x, out minlbfgsreport rep)
    {
        _core_minlbfgsresults( state, out  x, out  rep, 0x0);
    }
    
    public static void minlbfgsresults(minlbfgsstate state, out double[] x, out minlbfgsreport rep, alglib.xparams _xparams)
    {
        _core_minlbfgsresults( state, out  x, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minlbfgsresultsbuf(minlbfgsstate state, ref double[] x, minlbfgsreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_x = new x_vector();
        x_minlbfgsreport _d_rep = new x_minlbfgsreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_minlbfgsreport_init_from(ref _d_rep, rep);
                _error_code = _i_xv2_minlbfgsresultsbuf(&_s_errormsg, &_d_state, &_d_x, &_d_rep, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minlbfgsresultsbuf");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
            x_minlbfgsreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_minlbfgsreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void minlbfgsresultsbuf(minlbfgsstate state, ref double[] x, minlbfgsreport rep)
    {
        _core_minlbfgsresultsbuf( state, ref  x,  rep, 0x0);
    }
    
    public static void minlbfgsresultsbuf(minlbfgsstate state, ref double[] x, minlbfgsreport rep, alglib.xparams _xparams)
    {
        _core_minlbfgsresultsbuf( state, ref  x,  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minlbfgsrestartfrom(minlbfgsstate state, double[] x, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_x = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_xv2_minlbfgsrestartfrom(&_s_errormsg, &_d_state, &_d_x, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minlbfgsrestartfrom");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_x);
        }
        // This function returns no value.
    }
    
    public static void minlbfgsrestartfrom(minlbfgsstate state, double[] x)
    {
        _core_minlbfgsrestartfrom( state,  x, 0x0);
    }
    
    public static void minlbfgsrestartfrom(minlbfgsstate state, double[] x, alglib.xparams _xparams)
    {
        _core_minlbfgsrestartfrom( state,  x, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minlbfgsrequesttermination(minlbfgsstate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_minlbfgsrequesttermination(&_s_errormsg, &_d_state, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minlbfgsrequesttermination");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void minlbfgsrequesttermination(minlbfgsstate state)
    {
        _core_minlbfgsrequesttermination( state, 0x0);
    }
    
    public static void minlbfgsrequesttermination(minlbfgsstate state, alglib.xparams _xparams)
    {
        _core_minlbfgsrequesttermination( state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage cqmodels
    //
    
    
    
    //
    // Subpackage lpqpserv
    //
    
    
    
    //
    // Subpackage snnls
    //
    
    
    
    //
    // Subpackage sactivesets
    //
    
    
    
    //
    // Subpackage qqpsolver
    //
    
    
    
    //
    // Subpackage qpdenseaulsolver
    //
    
    
    
    //
    // Subpackage minbleic
    //
    

    public unsafe class minbleicstate : alglibobject
    {
        private void *_ptr;
        public minbleicstate(void *x)
        {
            _ptr = x;
        }
        ~minbleicstate()
        {
            _deallocate();
        }
        public void* ptr { get { return _ptr; } }
        public override alglib.alglibobject make_copy()
        {
            if( _ptr==null )
                return new minbleicstate(null);
            return new minbleicstate(_i_x_obj_copy_minbleicstate(_ptr));
        }
        public override void _deallocate()
        {
            if( _ptr!=null )
                _i_x_obj_free_minbleicstate(_ptr);
            _ptr = null;
            System.GC.SuppressFinalize(this);
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_minbleicstate(void *x);
    private static _d_x_obj_copy_minbleicstate _i_x_obj_copy_minbleicstate = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_obj_free_minbleicstate(void *x);
    private static _d_x_obj_free_minbleicstate _i_x_obj_free_minbleicstate = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_minbleicstate_get_needf(void *x, byte *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_minbleicstate_set_needf(void *x, byte *dst);
    private static _d_x_minbleicstate_get_needf _i_x_minbleicstate_get_needf = null;
    private static _d_x_minbleicstate_set_needf _i_x_minbleicstate_set_needf = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_minbleicstate_get_needfg(void *x, byte *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_minbleicstate_set_needfg(void *x, byte *dst);
    private static _d_x_minbleicstate_get_needfg _i_x_minbleicstate_get_needfg = null;
    private static _d_x_minbleicstate_set_needfg _i_x_minbleicstate_set_needfg = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_minbleicstate_get_xupdated(void *x, byte *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_minbleicstate_set_xupdated(void *x, byte *dst);
    private static _d_x_minbleicstate_get_xupdated _i_x_minbleicstate_get_xupdated = null;
    private static _d_x_minbleicstate_set_xupdated _i_x_minbleicstate_set_xupdated = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_minbleicstate_get_f(void *x, double *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_minbleicstate_set_f(void *x, double *dst);
    private static _d_x_minbleicstate_get_f _i_x_minbleicstate_get_f = null;
    private static _d_x_minbleicstate_set_f _i_x_minbleicstate_set_f = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_minbleicstate_get_g(void *x, x_vector *dst);
    private static _d_x_minbleicstate_get_g _i_x_minbleicstate_get_g = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_minbleicstate_get_x(void *x, x_vector *dst);
    private static _d_x_minbleicstate_get_x _i_x_minbleicstate_get_x = null;

    [StructLayout(LayoutKind.Sequential, Pack=8)]
    private struct x_minbleicreport
    {
        public x_int iterationscount;
        public x_int nfev;
        public x_int varidx;
        public x_int terminationtype;
        public double debugeqerr;
        public double debugfs;
        public double debugff;
        public double debugdx;
        public x_int debugfeasqpits;
        public x_int debugfeasgpaits;
        public x_int inneriterationscount;
        public x_int outeriterationscount;
    }

    public class minbleicreport : alglibobject
    {
        public int iterationscount;
        public int nfev;
        public int varidx;
        public int terminationtype;
        public double debugeqerr;
        public double debugfs;
        public double debugff;
        public double debugdx;
        public int debugfeasqpits;
        public int debugfeasgpaits;
        public int inneriterationscount;
        public int outeriterationscount;
        public override alglib.alglibobject make_copy()
        {
            minbleicreport dst = new minbleicreport();
            dst.iterationscount = iterationscount;
            dst.nfev = nfev;
            dst.varidx = varidx;
            dst.terminationtype = terminationtype;
            dst.debugeqerr = debugeqerr;
            dst.debugfs = debugfs;
            dst.debugff = debugff;
            dst.debugdx = debugdx;
            dst.debugfeasqpits = debugfeasqpits;
            dst.debugfeasgpaits = debugfeasgpaits;
            dst.inneriterationscount = inneriterationscount;
            dst.outeriterationscount = outeriterationscount;
            return dst;
        }
    }

    // This function initializes X-structure (its previous content is ignored)
    private static void x_minbleicreport_init(ref x_minbleicreport x)
    {
        x.iterationscount.longval = 0;
        x.nfev.longval = 0;
        x.varidx.longval = 0;
        x.terminationtype.longval = 0;
        x.debugeqerr = 0;
        x.debugfs = 0;
        x.debugff = 0;
        x.debugdx = 0;
        x.debugfeasqpits.longval = 0;
        x.debugfeasgpaits.longval = 0;
        x.inneriterationscount.longval = 0;
        x.outeriterationscount.longval = 0;
    }

    // This function finalizes fields of X-structure (however, memory occupied by structure itself is not freed)
    // After destruction structure becomes unusable and should be re-initialized if you want to use it
    private static void x_minbleicreport_clear(ref x_minbleicreport x)
    {
    }

    // This function initializes X-structure by appropriate C# instance
    // (previous content of X structure is ignored)
    private static void x_minbleicreport_init_from(ref x_minbleicreport x, minbleicreport v)
    {
        x.iterationscount.longval = v.iterationscount;
        x.nfev.longval = v.nfev;
        x.varidx.longval = v.varidx;
        x.terminationtype.longval = v.terminationtype;
        x.debugeqerr = v.debugeqerr;
        x.debugfs = v.debugfs;
        x.debugff = v.debugff;
        x.debugdx = v.debugdx;
        x.debugfeasqpits.longval = v.debugfeasqpits;
        x.debugfeasgpaits.longval = v.debugfeasgpaits;
        x.inneriterationscount.longval = v.inneriterationscount;
        x.outeriterationscount.longval = v.outeriterationscount;
    }

    // This function initializes C# structure by appropriate X instance
    // (previous content of C# structure is ignored).
    // This function may accept null v, in this case v is automatically allocated with new().
    private static void x_minbleicreport_to_record(ref x_minbleicreport x, ref minbleicreport v)
    {
        if( v==null )
            v = new minbleicreport();
        v.iterationscount = x.iterationscount.intval; // long is silently truncated to int
        v.nfev = x.nfev.intval; // long is silently truncated to int
        v.varidx = x.varidx.intval; // long is silently truncated to int
        v.terminationtype = x.terminationtype.intval; // long is silently truncated to int
        v.debugeqerr = x.debugeqerr;
        v.debugfs = x.debugfs;
        v.debugff = x.debugff;
        v.debugdx = x.debugdx;
        v.debugfeasqpits = x.debugfeasqpits.intval; // long is silently truncated to int
        v.debugfeasgpaits = x.debugfeasgpaits.intval; // long is silently truncated to int
        v.inneriterationscount = x.inneriterationscount.intval; // long is silently truncated to int
        v.outeriterationscount = x.outeriterationscount.intval; // long is silently truncated to int
    }
    
    private static unsafe void _core_minbleiccreate(int n, double[] x, out minbleicstate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        x_vector _d_x = new x_vector();
        void *_d_state = null;
        state = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_xv2_minbleiccreate(&_s_errormsg, &_d_n, &_d_x, &_d_state, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minbleiccreate");
            state = new minbleicstate(_d_state);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            if( _d_state!=null && state==null)
                _i_x_obj_free_minbleicstate(_d_state); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void minbleiccreate(int n, double[] x, out minbleicstate state)
    {
        _core_minbleiccreate( n,  x, out  state, 0x0);
    }
    
    public static void minbleiccreate(int n, double[] x, out minbleicstate state, alglib.xparams _xparams)
    {
        _core_minbleiccreate( n,  x, out  state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void minbleiccreate(double[] x, out minbleicstate state)
    {
        int n;
    
        n = ap.len(x);
        _core_minbleiccreate( n,  x, out  state, 0x0);
    
        
    }
    
    public static void minbleiccreate(double[] x, out minbleicstate state, alglib.xparams _xparams)
    {
        int n;
    
        n = ap.len(x);
        _core_minbleiccreate( n,  x, out  state, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_minbleiccreatef(int n, double[] x, double diffstep, out minbleicstate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        x_vector _d_x = new x_vector();
        double _d_diffstep = diffstep;
        void *_d_state = null;
        state = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_xv2_minbleiccreatef(&_s_errormsg, &_d_n, &_d_x, &_d_diffstep, &_d_state, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minbleiccreatef");
            state = new minbleicstate(_d_state);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            if( _d_state!=null && state==null)
                _i_x_obj_free_minbleicstate(_d_state); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void minbleiccreatef(int n, double[] x, double diffstep, out minbleicstate state)
    {
        _core_minbleiccreatef( n,  x,  diffstep, out  state, 0x0);
    }
    
    public static void minbleiccreatef(int n, double[] x, double diffstep, out minbleicstate state, alglib.xparams _xparams)
    {
        _core_minbleiccreatef( n,  x,  diffstep, out  state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void minbleiccreatef(double[] x, double diffstep, out minbleicstate state)
    {
        int n;
    
        n = ap.len(x);
        _core_minbleiccreatef( n,  x,  diffstep, out  state, 0x0);
    
        
    }
    
    public static void minbleiccreatef(double[] x, double diffstep, out minbleicstate state, alglib.xparams _xparams)
    {
        int n;
    
        n = ap.len(x);
        _core_minbleiccreatef( n,  x,  diffstep, out  state, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_minbleicsetbc(minbleicstate state, double[] bndl, double[] bndu, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_bndl = new x_vector();
        x_vector _d_bndu = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_bndl = bndl, _fp_bndu = bndu){
                x_vector_attach_to_array(ref _d_bndl, _fp_bndl, ap.len(bndl));
                x_vector_attach_to_array(ref _d_bndu, _fp_bndu, ap.len(bndu));
                _error_code = _i_xv2_minbleicsetbc(&_s_errormsg, &_d_state, &_d_bndl, &_d_bndu, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minbleicsetbc");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_bndl);
            x_vector_clear(ref _d_bndu);
        }
        // This function returns no value.
    }
    
    public static void minbleicsetbc(minbleicstate state, double[] bndl, double[] bndu)
    {
        _core_minbleicsetbc( state,  bndl,  bndu, 0x0);
    }
    
    public static void minbleicsetbc(minbleicstate state, double[] bndl, double[] bndu, alglib.xparams _xparams)
    {
        _core_minbleicsetbc( state,  bndl,  bndu, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minbleicsetlc(minbleicstate state, double[,] c, int[] ct, int k, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_matrix _d_c = new x_matrix();
        x_vector _d_ct = new x_vector();
        x_int _d_k = new x_int(k);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_c = c){
                x_matrix_attach_to_array(ref _d_c, _fp_c, ap.rows(c), ap.cols(c));
                x_vector_from_array(ref _d_ct, ct, X_CREATE);
                _error_code = _i_xv2_minbleicsetlc(&_s_errormsg, &_d_state, &_d_c, &_d_ct, &_d_k, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minbleicsetlc");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_c);
            x_vector_clear(ref _d_ct);
        }
        // This function returns no value.
    }
    
    public static void minbleicsetlc(minbleicstate state, double[,] c, int[] ct, int k)
    {
        _core_minbleicsetlc( state,  c,  ct,  k, 0x0);
    }
    
    public static void minbleicsetlc(minbleicstate state, double[,] c, int[] ct, int k, alglib.xparams _xparams)
    {
        _core_minbleicsetlc( state,  c,  ct,  k, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void minbleicsetlc(minbleicstate state, double[,] c, int[] ct)
    {
        int k;
        if( (ap.rows(c)!=ap.len(ct)))
            throw new alglibexception("Error while calling 'minbleicsetlc': looks like one of arguments has wrong size");
        k = ap.rows(c);
        _core_minbleicsetlc( state,  c,  ct,  k, 0x0);
    
        
    }
    
    public static void minbleicsetlc(minbleicstate state, double[,] c, int[] ct, alglib.xparams _xparams)
    {
        int k;
        if( (ap.rows(c)!=ap.len(ct)))
            throw new alglibexception("Error while calling 'minbleicsetlc': looks like one of arguments has wrong size");
        k = ap.rows(c);
        _core_minbleicsetlc( state,  c,  ct,  k, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_minbleicsetcond(minbleicstate state, double epsg, double epsf, double epsx, int maxits, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_epsg = epsg;
        double _d_epsf = epsf;
        double _d_epsx = epsx;
        x_int _d_maxits = new x_int(maxits);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_minbleicsetcond(&_s_errormsg, &_d_state, &_d_epsg, &_d_epsf, &_d_epsx, &_d_maxits, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minbleicsetcond");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void minbleicsetcond(minbleicstate state, double epsg, double epsf, double epsx, int maxits)
    {
        _core_minbleicsetcond( state,  epsg,  epsf,  epsx,  maxits, 0x0);
    }
    
    public static void minbleicsetcond(minbleicstate state, double epsg, double epsf, double epsx, int maxits, alglib.xparams _xparams)
    {
        _core_minbleicsetcond( state,  epsg,  epsf,  epsx,  maxits, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minbleicsetscale(minbleicstate state, double[] s, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_s = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_s = s){
                x_vector_attach_to_array(ref _d_s, _fp_s, ap.len(s));
                _error_code = _i_xv2_minbleicsetscale(&_s_errormsg, &_d_state, &_d_s, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minbleicsetscale");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_s);
        }
        // This function returns no value.
    }
    
    public static void minbleicsetscale(minbleicstate state, double[] s)
    {
        _core_minbleicsetscale( state,  s, 0x0);
    }
    
    public static void minbleicsetscale(minbleicstate state, double[] s, alglib.xparams _xparams)
    {
        _core_minbleicsetscale( state,  s, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minbleicsetprecdefault(minbleicstate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_minbleicsetprecdefault(&_s_errormsg, &_d_state, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minbleicsetprecdefault");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void minbleicsetprecdefault(minbleicstate state)
    {
        _core_minbleicsetprecdefault( state, 0x0);
    }
    
    public static void minbleicsetprecdefault(minbleicstate state, alglib.xparams _xparams)
    {
        _core_minbleicsetprecdefault( state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minbleicsetprecdiag(minbleicstate state, double[] d, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_d = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_d = d){
                x_vector_attach_to_array(ref _d_d, _fp_d, ap.len(d));
                _error_code = _i_xv2_minbleicsetprecdiag(&_s_errormsg, &_d_state, &_d_d, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minbleicsetprecdiag");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_d);
        }
        // This function returns no value.
    }
    
    public static void minbleicsetprecdiag(minbleicstate state, double[] d)
    {
        _core_minbleicsetprecdiag( state,  d, 0x0);
    }
    
    public static void minbleicsetprecdiag(minbleicstate state, double[] d, alglib.xparams _xparams)
    {
        _core_minbleicsetprecdiag( state,  d, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minbleicsetprecscale(minbleicstate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_minbleicsetprecscale(&_s_errormsg, &_d_state, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minbleicsetprecscale");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void minbleicsetprecscale(minbleicstate state)
    {
        _core_minbleicsetprecscale( state, 0x0);
    }
    
    public static void minbleicsetprecscale(minbleicstate state, alglib.xparams _xparams)
    {
        _core_minbleicsetprecscale( state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minbleicsetxrep(minbleicstate state, bool needxrep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        byte _d_needxrep = (byte)(needxrep ? 1 : 0);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_minbleicsetxrep(&_s_errormsg, &_d_state, &_d_needxrep, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minbleicsetxrep");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void minbleicsetxrep(minbleicstate state, bool needxrep)
    {
        _core_minbleicsetxrep( state,  needxrep, 0x0);
    }
    
    public static void minbleicsetxrep(minbleicstate state, bool needxrep, alglib.xparams _xparams)
    {
        _core_minbleicsetxrep( state,  needxrep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minbleicsetstpmax(minbleicstate state, double stpmax, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_stpmax = stpmax;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_minbleicsetstpmax(&_s_errormsg, &_d_state, &_d_stpmax, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minbleicsetstpmax");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void minbleicsetstpmax(minbleicstate state, double stpmax)
    {
        _core_minbleicsetstpmax( state,  stpmax, 0x0);
    }
    
    public static void minbleicsetstpmax(minbleicstate state, double stpmax, alglib.xparams _xparams)
    {
        _core_minbleicsetstpmax( state,  stpmax, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe bool _core_minbleiciteration(minbleicstate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        bool result;
        byte _d_result = (byte)0;
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_minbleiciteration(&_s_errormsg, &_d_result, &_d_state, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minbleiciteration");
            result = _d_result!=0;
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static bool minbleiciteration(minbleicstate state)
    {
        return _core_minbleiciteration( state, 0x0);
    }
    
    public static bool minbleiciteration(minbleicstate state, alglib.xparams _xparams)
    {
        return _core_minbleiciteration( state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static unsafe void minbleicoptimize(minbleicstate state, ndimensional_func func, ndimensional_rep rep, object obj)
    {
        minbleicoptimize(state, func, rep, obj, null);
    }
    
    public static unsafe void minbleicoptimize(minbleicstate state, ndimensional_func func, ndimensional_rep rep, object obj, alglib.xparams _xparams)
    {
        byte *_s_errormsg = null;
        int _error_code = 0;
        byte _b_result = (byte)0;
        byte _xc_xupdated = 0;
        void *_state = state.ptr;
        IntPtr _pre_ptr;
        x_vector _xc_arg = new x_vector();
        double[] _cs_arg = null;
        double _cs_f = 0;
        byte _xc_needf= 0;
    
        //
        // Check correctness of delegates
        //
        if( func==null )
            throw new alglibexception("ALGLIB: error in 'minbleicoptimize()' (func is null)");
    
        //
        // Attach x-structures to internal arrays
        //
        x_vector_create_empty(ref _xc_arg, DT_REAL);
        _i_x_minbleicstate_get_x(_state, &_xc_arg);
        _cs_arg = new double[_xc_arg.cnt];
    
        //
        // Main loop
        //
        for(;;)
        {
            //
            // Call iteration function.
            // Terminate iterations if it returned false.
            //
            _error_code = _i_xv2_minbleiciteration(&_s_errormsg, &_b_result, &_state, _xparams==null ? 0x0 : _xparams.flags);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minbleiciteration");
            ap.assert(_state==state.ptr, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _b_result==0 )
                break;
            
            //
            // Reverse communication interface:
            // * fetch flags
            // * make delegate calls
            //
            _i_x_minbleicstate_get_xupdated(_state, &_xc_xupdated);
            _i_x_minbleicstate_get_needf(_state, &_xc_needf);
            x_vector_to_array(ref _xc_arg, ref _cs_arg);
            if( _xc_needf!=0 )
            {
                func(_cs_arg, ref _cs_f, obj);
                _i_x_minbleicstate_set_f(_state, &_cs_f);
                continue;
            }
            if( _xc_xupdated!=0 )
            {
                if( rep!=null )
                {
                    double _local_f;
                    _i_x_minbleicstate_get_f(_state, &_local_f);
                    rep(_cs_arg, _local_f, obj);
                }
                continue;
            }
            throw new alglibexception("ALGLIB: error in 'minbleicoptimize' (some derivatives were not provided?)");
        }
        
        //
        // Integrity post-check:
        // * make sure that no reverse communication array was reallocated during optimization
        //
        _pre_ptr = _xc_arg.xptr.ptr;
        _i_x_minbleicstate_get_x(_state, &_xc_arg);
        alglib.ap.assert(_xc_arg.xptr.ptr==_pre_ptr, "ALGLIB: integrity check failed in minbleicoptimize()");
    }
    
    public static unsafe void minbleicoptimize(minbleicstate state, ndimensional_grad grad, ndimensional_rep rep, object obj)
    {
        minbleicoptimize(state, grad, rep, obj, null);
    }
    
    public static unsafe void minbleicoptimize(minbleicstate state, ndimensional_grad grad, ndimensional_rep rep, object obj, alglib.xparams _xparams)
    {
        byte *_s_errormsg = null;
        int _error_code = 0;
        byte _b_result = (byte)0;
        byte _xc_xupdated = 0;
        void *_state = state.ptr;
        IntPtr _pre_ptr;
        x_vector _xc_arg = new x_vector();
        double[] _cs_arg = null;
        double _cs_f = 0;
        x_vector _xc_g = new x_vector();
        double[] _cs_g = null;
        byte _xc_needfg= 0;
    
        //
        // Check correctness of delegates
        //
        if( grad==null )
            throw new alglibexception("ALGLIB: error in 'minbleicoptimize()' (grad is null)");
    
        //
        // Attach x-structures to internal arrays
        //
        x_vector_create_empty(ref _xc_arg, DT_REAL);
        x_vector_create_empty(ref _xc_g, DT_REAL);
        _i_x_minbleicstate_get_x(_state, &_xc_arg);
        _i_x_minbleicstate_get_g(_state, &_xc_g);
        _cs_arg = new double[_xc_arg.cnt];
        _cs_g = new double[_xc_g.cnt];
    
        //
        // Main loop
        //
        for(;;)
        {
            //
            // Call iteration function.
            // Terminate iterations if it returned false.
            //
            _error_code = _i_xv2_minbleiciteration(&_s_errormsg, &_b_result, &_state, _xparams==null ? 0x0 : _xparams.flags);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minbleiciteration");
            ap.assert(_state==state.ptr, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _b_result==0 )
                break;
            
            //
            // Reverse communication interface:
            // * fetch flags
            // * make delegate calls
            //
            _i_x_minbleicstate_get_xupdated(_state, &_xc_xupdated);
            _i_x_minbleicstate_get_needfg(_state, &_xc_needfg);
            x_vector_to_array(ref _xc_arg, ref _cs_arg);
            if( _xc_needfg!=0 )
            {
                grad(_cs_arg, ref _cs_f, _cs_g, obj);
                _i_x_minbleicstate_set_f(_state, &_cs_f);
                x_vector_from_array(ref _xc_g, _cs_g, X_REWRITE);
                continue;
            }
            if( _xc_xupdated!=0 )
            {
                if( rep!=null )
                {
                    double _local_f;
                    _i_x_minbleicstate_get_f(_state, &_local_f);
                    rep(_cs_arg, _local_f, obj);
                }
                continue;
            }
            throw new alglibexception("ALGLIB: error in 'minbleicoptimize' (some derivatives were not provided?)");
        }
        
        //
        // Integrity post-check:
        // * make sure that no reverse communication array was reallocated during optimization
        //
        _pre_ptr = _xc_arg.xptr.ptr;
        _i_x_minbleicstate_get_x(_state, &_xc_arg);
        alglib.ap.assert(_xc_arg.xptr.ptr==_pre_ptr, "ALGLIB: integrity check failed in minbleicoptimize()");
        _pre_ptr = _xc_g.xptr.ptr;
        _i_x_minbleicstate_get_g(_state, &_xc_g);
        alglib.ap.assert(_xc_g.xptr.ptr==_pre_ptr, "ALGLIB: integrity check failed in minbleicoptimize()");
    }
    
    private static unsafe void _core_minbleicoptguardgradient(minbleicstate state, double teststep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_teststep = teststep;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_minbleicoptguardgradient(&_s_errormsg, &_d_state, &_d_teststep, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minbleicoptguardgradient");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void minbleicoptguardgradient(minbleicstate state, double teststep)
    {
        _core_minbleicoptguardgradient( state,  teststep, 0x0);
    }
    
    public static void minbleicoptguardgradient(minbleicstate state, double teststep, alglib.xparams _xparams)
    {
        _core_minbleicoptguardgradient( state,  teststep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minbleicoptguardsmoothness(minbleicstate state, int level, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_int _d_level = new x_int(level);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_minbleicoptguardsmoothness(&_s_errormsg, &_d_state, &_d_level, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minbleicoptguardsmoothness");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void minbleicoptguardsmoothness(minbleicstate state, int level)
    {
        _core_minbleicoptguardsmoothness( state,  level, 0x0);
    }
    
    public static void minbleicoptguardsmoothness(minbleicstate state, int level, alglib.xparams _xparams)
    {
        _core_minbleicoptguardsmoothness( state,  level, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void minbleicoptguardsmoothness(minbleicstate state)
    {
        int level;
    
        level = 1;
        _core_minbleicoptguardsmoothness( state,  level, 0x0);
    
        
    }
    
    public static void minbleicoptguardsmoothness(minbleicstate state, alglib.xparams _xparams)
    {
        int level;
    
        level = 1;
        _core_minbleicoptguardsmoothness( state,  level, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_minbleicoptguardresults(minbleicstate state, out optguardreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_optguardreport _d_rep = new x_optguardreport();
        
        // Pack, call, unpack
        try
        {
            x_optguardreport_init(ref _d_rep);
            _error_code = _i_xv2_minbleicoptguardresults(&_s_errormsg, &_d_state, &_d_rep, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minbleicoptguardresults");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            rep = null;
            x_optguardreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_optguardreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void minbleicoptguardresults(minbleicstate state, out optguardreport rep)
    {
        _core_minbleicoptguardresults( state, out  rep, 0x0);
    }
    
    public static void minbleicoptguardresults(minbleicstate state, out optguardreport rep, alglib.xparams _xparams)
    {
        _core_minbleicoptguardresults( state, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minbleicoptguardnonc1test0results(minbleicstate state, out optguardnonc1test0report strrep, out optguardnonc1test0report lngrep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_optguardnonc1test0report _d_strrep = new x_optguardnonc1test0report();
        x_optguardnonc1test0report _d_lngrep = new x_optguardnonc1test0report();
        
        // Pack, call, unpack
        try
        {
            x_optguardnonc1test0report_init(ref _d_strrep);
            x_optguardnonc1test0report_init(ref _d_lngrep);
            _error_code = _i_xv2_minbleicoptguardnonc1test0results(&_s_errormsg, &_d_state, &_d_strrep, &_d_lngrep, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minbleicoptguardnonc1test0results");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            strrep = null;
            x_optguardnonc1test0report_to_record(ref _d_strrep, ref strrep);
            lngrep = null;
            x_optguardnonc1test0report_to_record(ref _d_lngrep, ref lngrep);
        }
        finally
        {
            x_optguardnonc1test0report_clear(ref _d_strrep);
            x_optguardnonc1test0report_clear(ref _d_lngrep);
        }
        // This function returns no value.
    }
    
    public static void minbleicoptguardnonc1test0results(minbleicstate state, out optguardnonc1test0report strrep, out optguardnonc1test0report lngrep)
    {
        _core_minbleicoptguardnonc1test0results( state, out  strrep, out  lngrep, 0x0);
    }
    
    public static void minbleicoptguardnonc1test0results(minbleicstate state, out optguardnonc1test0report strrep, out optguardnonc1test0report lngrep, alglib.xparams _xparams)
    {
        _core_minbleicoptguardnonc1test0results( state, out  strrep, out  lngrep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minbleicoptguardnonc1test1results(minbleicstate state, out optguardnonc1test1report strrep, out optguardnonc1test1report lngrep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_optguardnonc1test1report _d_strrep = new x_optguardnonc1test1report();
        x_optguardnonc1test1report _d_lngrep = new x_optguardnonc1test1report();
        
        // Pack, call, unpack
        try
        {
            x_optguardnonc1test1report_init(ref _d_strrep);
            x_optguardnonc1test1report_init(ref _d_lngrep);
            _error_code = _i_xv2_minbleicoptguardnonc1test1results(&_s_errormsg, &_d_state, &_d_strrep, &_d_lngrep, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minbleicoptguardnonc1test1results");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            strrep = null;
            x_optguardnonc1test1report_to_record(ref _d_strrep, ref strrep);
            lngrep = null;
            x_optguardnonc1test1report_to_record(ref _d_lngrep, ref lngrep);
        }
        finally
        {
            x_optguardnonc1test1report_clear(ref _d_strrep);
            x_optguardnonc1test1report_clear(ref _d_lngrep);
        }
        // This function returns no value.
    }
    
    public static void minbleicoptguardnonc1test1results(minbleicstate state, out optguardnonc1test1report strrep, out optguardnonc1test1report lngrep)
    {
        _core_minbleicoptguardnonc1test1results( state, out  strrep, out  lngrep, 0x0);
    }
    
    public static void minbleicoptguardnonc1test1results(minbleicstate state, out optguardnonc1test1report strrep, out optguardnonc1test1report lngrep, alglib.xparams _xparams)
    {
        _core_minbleicoptguardnonc1test1results( state, out  strrep, out  lngrep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minbleicresults(minbleicstate state, out double[] x, out minbleicreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_x = new x_vector();
        x_minbleicreport _d_rep = new x_minbleicreport();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_x, DT_REAL);
            x = null;
            x_minbleicreport_init(ref _d_rep);
            _error_code = _i_xv2_minbleicresults(&_s_errormsg, &_d_state, &_d_x, &_d_rep, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minbleicresults");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
            rep = null;
            x_minbleicreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_minbleicreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void minbleicresults(minbleicstate state, out double[] x, out minbleicreport rep)
    {
        _core_minbleicresults( state, out  x, out  rep, 0x0);
    }
    
    public static void minbleicresults(minbleicstate state, out double[] x, out minbleicreport rep, alglib.xparams _xparams)
    {
        _core_minbleicresults( state, out  x, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minbleicresultsbuf(minbleicstate state, ref double[] x, minbleicreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_x = new x_vector();
        x_minbleicreport _d_rep = new x_minbleicreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_minbleicreport_init_from(ref _d_rep, rep);
                _error_code = _i_xv2_minbleicresultsbuf(&_s_errormsg, &_d_state, &_d_x, &_d_rep, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minbleicresultsbuf");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
            x_minbleicreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_minbleicreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void minbleicresultsbuf(minbleicstate state, ref double[] x, minbleicreport rep)
    {
        _core_minbleicresultsbuf( state, ref  x,  rep, 0x0);
    }
    
    public static void minbleicresultsbuf(minbleicstate state, ref double[] x, minbleicreport rep, alglib.xparams _xparams)
    {
        _core_minbleicresultsbuf( state, ref  x,  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minbleicrestartfrom(minbleicstate state, double[] x, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_x = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_xv2_minbleicrestartfrom(&_s_errormsg, &_d_state, &_d_x, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minbleicrestartfrom");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_x);
        }
        // This function returns no value.
    }
    
    public static void minbleicrestartfrom(minbleicstate state, double[] x)
    {
        _core_minbleicrestartfrom( state,  x, 0x0);
    }
    
    public static void minbleicrestartfrom(minbleicstate state, double[] x, alglib.xparams _xparams)
    {
        _core_minbleicrestartfrom( state,  x, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minbleicrequesttermination(minbleicstate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_minbleicrequesttermination(&_s_errormsg, &_d_state, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minbleicrequesttermination");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void minbleicrequesttermination(minbleicstate state)
    {
        _core_minbleicrequesttermination( state, 0x0);
    }
    
    public static void minbleicrequesttermination(minbleicstate state, alglib.xparams _xparams)
    {
        _core_minbleicrequesttermination( state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage qpbleicsolver
    //
    
    
    
    //
    // Subpackage vipmsolver
    //
    
    
    
    //
    // Subpackage minqp
    //
    

    public unsafe class minqpstate : alglibobject
    {
        private void *_ptr;
        public minqpstate(void *x)
        {
            _ptr = x;
        }
        ~minqpstate()
        {
            _deallocate();
        }
        public void* ptr { get { return _ptr; } }
        public override alglib.alglibobject make_copy()
        {
            if( _ptr==null )
                return new minqpstate(null);
            return new minqpstate(_i_x_obj_copy_minqpstate(_ptr));
        }
        public override void _deallocate()
        {
            if( _ptr!=null )
                _i_x_obj_free_minqpstate(_ptr);
            _ptr = null;
            System.GC.SuppressFinalize(this);
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_minqpstate(void *x);
    private static _d_x_obj_copy_minqpstate _i_x_obj_copy_minqpstate = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_obj_free_minqpstate(void *x);
    private static _d_x_obj_free_minqpstate _i_x_obj_free_minqpstate = null;

    [StructLayout(LayoutKind.Sequential, Pack=8)]
    private struct x_minqpreport
    {
        public x_int inneriterationscount;
        public x_int outeriterationscount;
        public x_int nmv;
        public x_int ncholesky;
        public x_int terminationtype;
        public x_vector lagbc;
        public x_vector laglc;
    }

    public class minqpreport : alglibobject
    {
        public int inneriterationscount;
        public int outeriterationscount;
        public int nmv;
        public int ncholesky;
        public int terminationtype;
        public double[] lagbc;
        public double[] laglc;
        public override alglib.alglibobject make_copy()
        {
            minqpreport dst = new minqpreport();
            dst.inneriterationscount = inneriterationscount;
            dst.outeriterationscount = outeriterationscount;
            dst.nmv = nmv;
            dst.ncholesky = ncholesky;
            dst.terminationtype = terminationtype;
            dst.lagbc = (double[])lagbc.Clone();        dst.laglc = (double[])laglc.Clone();        return dst;
        }
    }

    // This function initializes X-structure (its previous content is ignored)
    private static void x_minqpreport_init(ref x_minqpreport x)
    {
        x.inneriterationscount.longval = 0;
        x.outeriterationscount.longval = 0;
        x.nmv.longval = 0;
        x.ncholesky.longval = 0;
        x.terminationtype.longval = 0;
        x_vector_create_empty(ref x.lagbc, DT_REAL);
        x_vector_create_empty(ref x.laglc, DT_REAL);
    }

    // This function finalizes fields of X-structure (however, memory occupied by structure itself is not freed)
    // After destruction structure becomes unusable and should be re-initialized if you want to use it
    private static void x_minqpreport_clear(ref x_minqpreport x)
    {
        x_vector_clear(ref x.lagbc);
        x_vector_clear(ref x.laglc);
    }

    // This function initializes X-structure by appropriate C# instance
    // (previous content of X structure is ignored)
    private static void x_minqpreport_init_from(ref x_minqpreport x, minqpreport v)
    {
        x.inneriterationscount.longval = v.inneriterationscount;
        x.outeriterationscount.longval = v.outeriterationscount;
        x.nmv.longval = v.nmv;
        x.ncholesky.longval = v.ncholesky;
        x.terminationtype.longval = v.terminationtype;
        x_vector_from_array(ref x.lagbc, v.lagbc, X_CREATE);
        x_vector_from_array(ref x.laglc, v.laglc, X_CREATE);
    }

    // This function initializes C# structure by appropriate X instance
    // (previous content of C# structure is ignored).
    // This function may accept null v, in this case v is automatically allocated with new().
    private static void x_minqpreport_to_record(ref x_minqpreport x, ref minqpreport v)
    {
        if( v==null )
            v = new minqpreport();
        v.inneriterationscount = x.inneriterationscount.intval; // long is silently truncated to int
        v.outeriterationscount = x.outeriterationscount.intval; // long is silently truncated to int
        v.nmv = x.nmv.intval; // long is silently truncated to int
        v.ncholesky = x.ncholesky.intval; // long is silently truncated to int
        v.terminationtype = x.terminationtype.intval; // long is silently truncated to int
        x_vector_to_array(ref x.lagbc, ref v.lagbc);
        x_vector_to_array(ref x.laglc, ref v.laglc);
    }
    
    private static unsafe void _core_minqpcreate(int n, out minqpstate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        void *_d_state = null;
        state = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_minqpcreate(&_s_errormsg, &_d_n, &_d_state, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minqpcreate");
            state = new minqpstate(_d_state);
        }
        finally
        {
            if( _d_state!=null && state==null)
                _i_x_obj_free_minqpstate(_d_state); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void minqpcreate(int n, out minqpstate state)
    {
        _core_minqpcreate( n, out  state, 0x0);
    }
    
    public static void minqpcreate(int n, out minqpstate state, alglib.xparams _xparams)
    {
        _core_minqpcreate( n, out  state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minqpsetlinearterm(minqpstate state, double[] b, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_b = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_b = b){
                x_vector_attach_to_array(ref _d_b, _fp_b, ap.len(b));
                _error_code = _i_xv2_minqpsetlinearterm(&_s_errormsg, &_d_state, &_d_b, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minqpsetlinearterm");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_b);
        }
        // This function returns no value.
    }
    
    public static void minqpsetlinearterm(minqpstate state, double[] b)
    {
        _core_minqpsetlinearterm( state,  b, 0x0);
    }
    
    public static void minqpsetlinearterm(minqpstate state, double[] b, alglib.xparams _xparams)
    {
        _core_minqpsetlinearterm( state,  b, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minqpsetquadraticterm(minqpstate state, double[,] a, bool isupper, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_matrix _d_a = new x_matrix();
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                _error_code = _i_xv2_minqpsetquadraticterm(&_s_errormsg, &_d_state, &_d_a, &_d_isupper, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minqpsetquadraticterm");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        // This function returns no value.
    }
    
    public static void minqpsetquadraticterm(minqpstate state, double[,] a, bool isupper)
    {
        _core_minqpsetquadraticterm( state,  a,  isupper, 0x0);
    }
    
    public static void minqpsetquadraticterm(minqpstate state, double[,] a, bool isupper, alglib.xparams _xparams)
    {
        _core_minqpsetquadraticterm( state,  a,  isupper, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void minqpsetquadraticterm(minqpstate state, double[,] a)
    {
        bool isupper;
        if( !alglib.ap.issymmetric(a) )
            throw new alglibexception("'a' parameter is not symmetric matrix");
        isupper = false;
        _core_minqpsetquadraticterm( state,  a,  isupper, 0x0);
    
        
    }
    
    public static void minqpsetquadraticterm(minqpstate state, double[,] a, alglib.xparams _xparams)
    {
        bool isupper;
        if( !alglib.ap.issymmetric(a) )
            throw new alglibexception("'a' parameter is not symmetric matrix");
        isupper = false;
        _core_minqpsetquadraticterm( state,  a,  isupper, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_minqpsetquadratictermsparse(minqpstate state, sparsematrix a, bool isupper, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        void *_d_a = a.ptr;
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_minqpsetquadratictermsparse(&_s_errormsg, &_d_state, &_d_a, &_d_isupper, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minqpsetquadratictermsparse");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            ap.assert(a.ptr==_d_a, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void minqpsetquadratictermsparse(minqpstate state, sparsematrix a, bool isupper)
    {
        _core_minqpsetquadratictermsparse( state,  a,  isupper, 0x0);
    }
    
    public static void minqpsetquadratictermsparse(minqpstate state, sparsematrix a, bool isupper, alglib.xparams _xparams)
    {
        _core_minqpsetquadratictermsparse( state,  a,  isupper, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minqpsetstartingpoint(minqpstate state, double[] x, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_x = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_xv2_minqpsetstartingpoint(&_s_errormsg, &_d_state, &_d_x, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minqpsetstartingpoint");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_x);
        }
        // This function returns no value.
    }
    
    public static void minqpsetstartingpoint(minqpstate state, double[] x)
    {
        _core_minqpsetstartingpoint( state,  x, 0x0);
    }
    
    public static void minqpsetstartingpoint(minqpstate state, double[] x, alglib.xparams _xparams)
    {
        _core_minqpsetstartingpoint( state,  x, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minqpsetorigin(minqpstate state, double[] xorigin, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_xorigin = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xorigin = xorigin){
                x_vector_attach_to_array(ref _d_xorigin, _fp_xorigin, ap.len(xorigin));
                _error_code = _i_xv2_minqpsetorigin(&_s_errormsg, &_d_state, &_d_xorigin, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minqpsetorigin");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_xorigin);
        }
        // This function returns no value.
    }
    
    public static void minqpsetorigin(minqpstate state, double[] xorigin)
    {
        _core_minqpsetorigin( state,  xorigin, 0x0);
    }
    
    public static void minqpsetorigin(minqpstate state, double[] xorigin, alglib.xparams _xparams)
    {
        _core_minqpsetorigin( state,  xorigin, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minqpsetscale(minqpstate state, double[] s, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_s = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_s = s){
                x_vector_attach_to_array(ref _d_s, _fp_s, ap.len(s));
                _error_code = _i_xv2_minqpsetscale(&_s_errormsg, &_d_state, &_d_s, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minqpsetscale");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_s);
        }
        // This function returns no value.
    }
    
    public static void minqpsetscale(minqpstate state, double[] s)
    {
        _core_minqpsetscale( state,  s, 0x0);
    }
    
    public static void minqpsetscale(minqpstate state, double[] s, alglib.xparams _xparams)
    {
        _core_minqpsetscale( state,  s, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minqpsetscaleautodiag(minqpstate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_minqpsetscaleautodiag(&_s_errormsg, &_d_state, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minqpsetscaleautodiag");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void minqpsetscaleautodiag(minqpstate state)
    {
        _core_minqpsetscaleautodiag( state, 0x0);
    }
    
    public static void minqpsetscaleautodiag(minqpstate state, alglib.xparams _xparams)
    {
        _core_minqpsetscaleautodiag( state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minqpsetalgobleic(minqpstate state, double epsg, double epsf, double epsx, int maxits, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_epsg = epsg;
        double _d_epsf = epsf;
        double _d_epsx = epsx;
        x_int _d_maxits = new x_int(maxits);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_minqpsetalgobleic(&_s_errormsg, &_d_state, &_d_epsg, &_d_epsf, &_d_epsx, &_d_maxits, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minqpsetalgobleic");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void minqpsetalgobleic(minqpstate state, double epsg, double epsf, double epsx, int maxits)
    {
        _core_minqpsetalgobleic( state,  epsg,  epsf,  epsx,  maxits, 0x0);
    }
    
    public static void minqpsetalgobleic(minqpstate state, double epsg, double epsf, double epsx, int maxits, alglib.xparams _xparams)
    {
        _core_minqpsetalgobleic( state,  epsg,  epsf,  epsx,  maxits, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minqpsetalgodenseaul(minqpstate state, double epsx, double rho, int itscnt, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_epsx = epsx;
        double _d_rho = rho;
        x_int _d_itscnt = new x_int(itscnt);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_minqpsetalgodenseaul(&_s_errormsg, &_d_state, &_d_epsx, &_d_rho, &_d_itscnt, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minqpsetalgodenseaul");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void minqpsetalgodenseaul(minqpstate state, double epsx, double rho, int itscnt)
    {
        _core_minqpsetalgodenseaul( state,  epsx,  rho,  itscnt, 0x0);
    }
    
    public static void minqpsetalgodenseaul(minqpstate state, double epsx, double rho, int itscnt, alglib.xparams _xparams)
    {
        _core_minqpsetalgodenseaul( state,  epsx,  rho,  itscnt, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minqpsetalgodenseipm(minqpstate state, double eps, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_eps = eps;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_minqpsetalgodenseipm(&_s_errormsg, &_d_state, &_d_eps, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minqpsetalgodenseipm");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void minqpsetalgodenseipm(minqpstate state, double eps)
    {
        _core_minqpsetalgodenseipm( state,  eps, 0x0);
    }
    
    public static void minqpsetalgodenseipm(minqpstate state, double eps, alglib.xparams _xparams)
    {
        _core_minqpsetalgodenseipm( state,  eps, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minqpsetalgosparseipm(minqpstate state, double eps, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_eps = eps;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_minqpsetalgosparseipm(&_s_errormsg, &_d_state, &_d_eps, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minqpsetalgosparseipm");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void minqpsetalgosparseipm(minqpstate state, double eps)
    {
        _core_minqpsetalgosparseipm( state,  eps, 0x0);
    }
    
    public static void minqpsetalgosparseipm(minqpstate state, double eps, alglib.xparams _xparams)
    {
        _core_minqpsetalgosparseipm( state,  eps, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minqpsetalgoquickqp(minqpstate state, double epsg, double epsf, double epsx, int maxouterits, bool usenewton, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_epsg = epsg;
        double _d_epsf = epsf;
        double _d_epsx = epsx;
        x_int _d_maxouterits = new x_int(maxouterits);
        byte _d_usenewton = (byte)(usenewton ? 1 : 0);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_minqpsetalgoquickqp(&_s_errormsg, &_d_state, &_d_epsg, &_d_epsf, &_d_epsx, &_d_maxouterits, &_d_usenewton, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minqpsetalgoquickqp");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void minqpsetalgoquickqp(minqpstate state, double epsg, double epsf, double epsx, int maxouterits, bool usenewton)
    {
        _core_minqpsetalgoquickqp( state,  epsg,  epsf,  epsx,  maxouterits,  usenewton, 0x0);
    }
    
    public static void minqpsetalgoquickqp(minqpstate state, double epsg, double epsf, double epsx, int maxouterits, bool usenewton, alglib.xparams _xparams)
    {
        _core_minqpsetalgoquickqp( state,  epsg,  epsf,  epsx,  maxouterits,  usenewton, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minqpsetbc(minqpstate state, double[] bndl, double[] bndu, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_bndl = new x_vector();
        x_vector _d_bndu = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_bndl = bndl, _fp_bndu = bndu){
                x_vector_attach_to_array(ref _d_bndl, _fp_bndl, ap.len(bndl));
                x_vector_attach_to_array(ref _d_bndu, _fp_bndu, ap.len(bndu));
                _error_code = _i_xv2_minqpsetbc(&_s_errormsg, &_d_state, &_d_bndl, &_d_bndu, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minqpsetbc");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_bndl);
            x_vector_clear(ref _d_bndu);
        }
        // This function returns no value.
    }
    
    public static void minqpsetbc(minqpstate state, double[] bndl, double[] bndu)
    {
        _core_minqpsetbc( state,  bndl,  bndu, 0x0);
    }
    
    public static void minqpsetbc(minqpstate state, double[] bndl, double[] bndu, alglib.xparams _xparams)
    {
        _core_minqpsetbc( state,  bndl,  bndu, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minqpsetbcall(minqpstate state, double bndl, double bndu, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_bndl = bndl;
        double _d_bndu = bndu;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_minqpsetbcall(&_s_errormsg, &_d_state, &_d_bndl, &_d_bndu, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minqpsetbcall");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void minqpsetbcall(minqpstate state, double bndl, double bndu)
    {
        _core_minqpsetbcall( state,  bndl,  bndu, 0x0);
    }
    
    public static void minqpsetbcall(minqpstate state, double bndl, double bndu, alglib.xparams _xparams)
    {
        _core_minqpsetbcall( state,  bndl,  bndu, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minqpsetbci(minqpstate state, int i, double bndl, double bndu, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_int _d_i = new x_int(i);
        double _d_bndl = bndl;
        double _d_bndu = bndu;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_minqpsetbci(&_s_errormsg, &_d_state, &_d_i, &_d_bndl, &_d_bndu, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minqpsetbci");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void minqpsetbci(minqpstate state, int i, double bndl, double bndu)
    {
        _core_minqpsetbci( state,  i,  bndl,  bndu, 0x0);
    }
    
    public static void minqpsetbci(minqpstate state, int i, double bndl, double bndu, alglib.xparams _xparams)
    {
        _core_minqpsetbci( state,  i,  bndl,  bndu, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minqpsetlc(minqpstate state, double[,] c, int[] ct, int k, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_matrix _d_c = new x_matrix();
        x_vector _d_ct = new x_vector();
        x_int _d_k = new x_int(k);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_c = c){
                x_matrix_attach_to_array(ref _d_c, _fp_c, ap.rows(c), ap.cols(c));
                x_vector_from_array(ref _d_ct, ct, X_CREATE);
                _error_code = _i_xv2_minqpsetlc(&_s_errormsg, &_d_state, &_d_c, &_d_ct, &_d_k, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minqpsetlc");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_c);
            x_vector_clear(ref _d_ct);
        }
        // This function returns no value.
    }
    
    public static void minqpsetlc(minqpstate state, double[,] c, int[] ct, int k)
    {
        _core_minqpsetlc( state,  c,  ct,  k, 0x0);
    }
    
    public static void minqpsetlc(minqpstate state, double[,] c, int[] ct, int k, alglib.xparams _xparams)
    {
        _core_minqpsetlc( state,  c,  ct,  k, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void minqpsetlc(minqpstate state, double[,] c, int[] ct)
    {
        int k;
        if( (ap.rows(c)!=ap.len(ct)))
            throw new alglibexception("Error while calling 'minqpsetlc': looks like one of arguments has wrong size");
        k = ap.rows(c);
        _core_minqpsetlc( state,  c,  ct,  k, 0x0);
    
        
    }
    
    public static void minqpsetlc(minqpstate state, double[,] c, int[] ct, alglib.xparams _xparams)
    {
        int k;
        if( (ap.rows(c)!=ap.len(ct)))
            throw new alglibexception("Error while calling 'minqpsetlc': looks like one of arguments has wrong size");
        k = ap.rows(c);
        _core_minqpsetlc( state,  c,  ct,  k, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_minqpsetlcsparse(minqpstate state, sparsematrix c, int[] ct, int k, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        void *_d_c = c.ptr;
        x_vector _d_ct = new x_vector();
        x_int _d_k = new x_int(k);
        
        // Pack, call, unpack
        try
        {
            x_vector_from_array(ref _d_ct, ct, X_CREATE);
            _error_code = _i_xv2_minqpsetlcsparse(&_s_errormsg, &_d_state, &_d_c, &_d_ct, &_d_k, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minqpsetlcsparse");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            ap.assert(c.ptr==_d_c, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_ct);
        }
        // This function returns no value.
    }
    
    public static void minqpsetlcsparse(minqpstate state, sparsematrix c, int[] ct, int k)
    {
        _core_minqpsetlcsparse( state,  c,  ct,  k, 0x0);
    }
    
    public static void minqpsetlcsparse(minqpstate state, sparsematrix c, int[] ct, int k, alglib.xparams _xparams)
    {
        _core_minqpsetlcsparse( state,  c,  ct,  k, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minqpsetlcmixed(minqpstate state, sparsematrix sparsec, int[] sparsect, int sparsek, double[,] densec, int[] densect, int densek, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        void *_d_sparsec = sparsec.ptr;
        x_vector _d_sparsect = new x_vector();
        x_int _d_sparsek = new x_int(sparsek);
        x_matrix _d_densec = new x_matrix();
        x_vector _d_densect = new x_vector();
        x_int _d_densek = new x_int(densek);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_densec = densec){
                x_vector_from_array(ref _d_sparsect, sparsect, X_CREATE);
                x_matrix_attach_to_array(ref _d_densec, _fp_densec, ap.rows(densec), ap.cols(densec));
                x_vector_from_array(ref _d_densect, densect, X_CREATE);
                _error_code = _i_xv2_minqpsetlcmixed(&_s_errormsg, &_d_state, &_d_sparsec, &_d_sparsect, &_d_sparsek, &_d_densec, &_d_densect, &_d_densek, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minqpsetlcmixed");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            ap.assert(sparsec.ptr==_d_sparsec, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_sparsect);
            x_matrix_clear(ref _d_densec);
            x_vector_clear(ref _d_densect);
        }
        // This function returns no value.
    }
    
    public static void minqpsetlcmixed(minqpstate state, sparsematrix sparsec, int[] sparsect, int sparsek, double[,] densec, int[] densect, int densek)
    {
        _core_minqpsetlcmixed( state,  sparsec,  sparsect,  sparsek,  densec,  densect,  densek, 0x0);
    }
    
    public static void minqpsetlcmixed(minqpstate state, sparsematrix sparsec, int[] sparsect, int sparsek, double[,] densec, int[] densect, int densek, alglib.xparams _xparams)
    {
        _core_minqpsetlcmixed( state,  sparsec,  sparsect,  sparsek,  densec,  densect,  densek, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minqpsetlcmixedlegacy(minqpstate state, double[,] densec, int[] densect, int densek, sparsematrix sparsec, int[] sparsect, int sparsek, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_matrix _d_densec = new x_matrix();
        x_vector _d_densect = new x_vector();
        x_int _d_densek = new x_int(densek);
        void *_d_sparsec = sparsec.ptr;
        x_vector _d_sparsect = new x_vector();
        x_int _d_sparsek = new x_int(sparsek);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_densec = densec){
                x_matrix_attach_to_array(ref _d_densec, _fp_densec, ap.rows(densec), ap.cols(densec));
                x_vector_from_array(ref _d_densect, densect, X_CREATE);
                x_vector_from_array(ref _d_sparsect, sparsect, X_CREATE);
                _error_code = _i_xv2_minqpsetlcmixedlegacy(&_s_errormsg, &_d_state, &_d_densec, &_d_densect, &_d_densek, &_d_sparsec, &_d_sparsect, &_d_sparsek, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minqpsetlcmixedlegacy");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            ap.assert(sparsec.ptr==_d_sparsec, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_densec);
            x_vector_clear(ref _d_densect);
            x_vector_clear(ref _d_sparsect);
        }
        // This function returns no value.
    }
    
    public static void minqpsetlcmixedlegacy(minqpstate state, double[,] densec, int[] densect, int densek, sparsematrix sparsec, int[] sparsect, int sparsek)
    {
        _core_minqpsetlcmixedlegacy( state,  densec,  densect,  densek,  sparsec,  sparsect,  sparsek, 0x0);
    }
    
    public static void minqpsetlcmixedlegacy(minqpstate state, double[,] densec, int[] densect, int densek, sparsematrix sparsec, int[] sparsect, int sparsek, alglib.xparams _xparams)
    {
        _core_minqpsetlcmixedlegacy( state,  densec,  densect,  densek,  sparsec,  sparsect,  sparsek, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minqpsetlc2dense(minqpstate state, double[,] a, double[] al, double[] au, int k, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_matrix _d_a = new x_matrix();
        x_vector _d_al = new x_vector();
        x_vector _d_au = new x_vector();
        x_int _d_k = new x_int(k);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a, _fp_al = al, _fp_au = au){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_attach_to_array(ref _d_al, _fp_al, ap.len(al));
                x_vector_attach_to_array(ref _d_au, _fp_au, ap.len(au));
                _error_code = _i_xv2_minqpsetlc2dense(&_s_errormsg, &_d_state, &_d_a, &_d_al, &_d_au, &_d_k, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minqpsetlc2dense");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_al);
            x_vector_clear(ref _d_au);
        }
        // This function returns no value.
    }
    
    public static void minqpsetlc2dense(minqpstate state, double[,] a, double[] al, double[] au, int k)
    {
        _core_minqpsetlc2dense( state,  a,  al,  au,  k, 0x0);
    }
    
    public static void minqpsetlc2dense(minqpstate state, double[,] a, double[] al, double[] au, int k, alglib.xparams _xparams)
    {
        _core_minqpsetlc2dense( state,  a,  al,  au,  k, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void minqpsetlc2dense(minqpstate state, double[,] a, double[] al, double[] au)
    {
        int k;
        if( (ap.rows(a)!=ap.len(al)) || (ap.rows(a)!=ap.len(au)))
            throw new alglibexception("Error while calling 'minqpsetlc2dense': looks like one of arguments has wrong size");
        k = ap.rows(a);
        _core_minqpsetlc2dense( state,  a,  al,  au,  k, 0x0);
    
        
    }
    
    public static void minqpsetlc2dense(minqpstate state, double[,] a, double[] al, double[] au, alglib.xparams _xparams)
    {
        int k;
        if( (ap.rows(a)!=ap.len(al)) || (ap.rows(a)!=ap.len(au)))
            throw new alglibexception("Error while calling 'minqpsetlc2dense': looks like one of arguments has wrong size");
        k = ap.rows(a);
        _core_minqpsetlc2dense( state,  a,  al,  au,  k, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_minqpsetlc2(minqpstate state, sparsematrix a, double[] al, double[] au, int k, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        void *_d_a = a.ptr;
        x_vector _d_al = new x_vector();
        x_vector _d_au = new x_vector();
        x_int _d_k = new x_int(k);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_al = al, _fp_au = au){
                x_vector_attach_to_array(ref _d_al, _fp_al, ap.len(al));
                x_vector_attach_to_array(ref _d_au, _fp_au, ap.len(au));
                _error_code = _i_xv2_minqpsetlc2(&_s_errormsg, &_d_state, &_d_a, &_d_al, &_d_au, &_d_k, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minqpsetlc2");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            ap.assert(a.ptr==_d_a, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_al);
            x_vector_clear(ref _d_au);
        }
        // This function returns no value.
    }
    
    public static void minqpsetlc2(minqpstate state, sparsematrix a, double[] al, double[] au, int k)
    {
        _core_minqpsetlc2( state,  a,  al,  au,  k, 0x0);
    }
    
    public static void minqpsetlc2(minqpstate state, sparsematrix a, double[] al, double[] au, int k, alglib.xparams _xparams)
    {
        _core_minqpsetlc2( state,  a,  al,  au,  k, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minqpsetlc2mixed(minqpstate state, sparsematrix sparsea, int ksparse, double[,] densea, int kdense, double[] al, double[] au, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        void *_d_sparsea = sparsea.ptr;
        x_int _d_ksparse = new x_int(ksparse);
        x_matrix _d_densea = new x_matrix();
        x_int _d_kdense = new x_int(kdense);
        x_vector _d_al = new x_vector();
        x_vector _d_au = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_densea = densea, _fp_al = al, _fp_au = au){
                x_matrix_attach_to_array(ref _d_densea, _fp_densea, ap.rows(densea), ap.cols(densea));
                x_vector_attach_to_array(ref _d_al, _fp_al, ap.len(al));
                x_vector_attach_to_array(ref _d_au, _fp_au, ap.len(au));
                _error_code = _i_xv2_minqpsetlc2mixed(&_s_errormsg, &_d_state, &_d_sparsea, &_d_ksparse, &_d_densea, &_d_kdense, &_d_al, &_d_au, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minqpsetlc2mixed");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            ap.assert(sparsea.ptr==_d_sparsea, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_densea);
            x_vector_clear(ref _d_al);
            x_vector_clear(ref _d_au);
        }
        // This function returns no value.
    }
    
    public static void minqpsetlc2mixed(minqpstate state, sparsematrix sparsea, int ksparse, double[,] densea, int kdense, double[] al, double[] au)
    {
        _core_minqpsetlc2mixed( state,  sparsea,  ksparse,  densea,  kdense,  al,  au, 0x0);
    }
    
    public static void minqpsetlc2mixed(minqpstate state, sparsematrix sparsea, int ksparse, double[,] densea, int kdense, double[] al, double[] au, alglib.xparams _xparams)
    {
        _core_minqpsetlc2mixed( state,  sparsea,  ksparse,  densea,  kdense,  al,  au, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minqpaddlc2dense(minqpstate state, double[] a, double al, double au, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_a = new x_vector();
        double _d_al = al;
        double _d_au = au;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_vector_attach_to_array(ref _d_a, _fp_a, ap.len(a));
                _error_code = _i_xv2_minqpaddlc2dense(&_s_errormsg, &_d_state, &_d_a, &_d_al, &_d_au, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minqpaddlc2dense");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_a);
        }
        // This function returns no value.
    }
    
    public static void minqpaddlc2dense(minqpstate state, double[] a, double al, double au)
    {
        _core_minqpaddlc2dense( state,  a,  al,  au, 0x0);
    }
    
    public static void minqpaddlc2dense(minqpstate state, double[] a, double al, double au, alglib.xparams _xparams)
    {
        _core_minqpaddlc2dense( state,  a,  al,  au, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minqpaddlc2(minqpstate state, int[] idxa, double[] vala, int nnz, double al, double au, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_idxa = new x_vector();
        x_vector _d_vala = new x_vector();
        x_int _d_nnz = new x_int(nnz);
        double _d_al = al;
        double _d_au = au;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_vala = vala){
                x_vector_from_array(ref _d_idxa, idxa, X_CREATE);
                x_vector_attach_to_array(ref _d_vala, _fp_vala, ap.len(vala));
                _error_code = _i_xv2_minqpaddlc2(&_s_errormsg, &_d_state, &_d_idxa, &_d_vala, &_d_nnz, &_d_al, &_d_au, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minqpaddlc2");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_idxa);
            x_vector_clear(ref _d_vala);
        }
        // This function returns no value.
    }
    
    public static void minqpaddlc2(minqpstate state, int[] idxa, double[] vala, int nnz, double al, double au)
    {
        _core_minqpaddlc2( state,  idxa,  vala,  nnz,  al,  au, 0x0);
    }
    
    public static void minqpaddlc2(minqpstate state, int[] idxa, double[] vala, int nnz, double al, double au, alglib.xparams _xparams)
    {
        _core_minqpaddlc2( state,  idxa,  vala,  nnz,  al,  au, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minqpaddlc2sparsefromdense(minqpstate state, double[] da, double al, double au, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_da = new x_vector();
        double _d_al = al;
        double _d_au = au;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_da = da){
                x_vector_attach_to_array(ref _d_da, _fp_da, ap.len(da));
                _error_code = _i_xv2_minqpaddlc2sparsefromdense(&_s_errormsg, &_d_state, &_d_da, &_d_al, &_d_au, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minqpaddlc2sparsefromdense");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_da);
        }
        // This function returns no value.
    }
    
    public static void minqpaddlc2sparsefromdense(minqpstate state, double[] da, double al, double au)
    {
        _core_minqpaddlc2sparsefromdense( state,  da,  al,  au, 0x0);
    }
    
    public static void minqpaddlc2sparsefromdense(minqpstate state, double[] da, double al, double au, alglib.xparams _xparams)
    {
        _core_minqpaddlc2sparsefromdense( state,  da,  al,  au, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minqpoptimize(minqpstate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_minqpoptimize(&_s_errormsg, &_d_state, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minqpoptimize");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void minqpoptimize(minqpstate state)
    {
        _core_minqpoptimize( state, 0x0);
    }
    
    public static void minqpoptimize(minqpstate state, alglib.xparams _xparams)
    {
        _core_minqpoptimize( state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minqpresults(minqpstate state, out double[] x, out minqpreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_x = new x_vector();
        x_minqpreport _d_rep = new x_minqpreport();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_x, DT_REAL);
            x = null;
            x_minqpreport_init(ref _d_rep);
            _error_code = _i_xv2_minqpresults(&_s_errormsg, &_d_state, &_d_x, &_d_rep, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minqpresults");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
            rep = null;
            x_minqpreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_minqpreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void minqpresults(minqpstate state, out double[] x, out minqpreport rep)
    {
        _core_minqpresults( state, out  x, out  rep, 0x0);
    }
    
    public static void minqpresults(minqpstate state, out double[] x, out minqpreport rep, alglib.xparams _xparams)
    {
        _core_minqpresults( state, out  x, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minqpresultsbuf(minqpstate state, ref double[] x, minqpreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_x = new x_vector();
        x_minqpreport _d_rep = new x_minqpreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_minqpreport_init_from(ref _d_rep, rep);
                _error_code = _i_xv2_minqpresultsbuf(&_s_errormsg, &_d_state, &_d_x, &_d_rep, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minqpresultsbuf");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
            x_minqpreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_minqpreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void minqpresultsbuf(minqpstate state, ref double[] x, minqpreport rep)
    {
        _core_minqpresultsbuf( state, ref  x,  rep, 0x0);
    }
    
    public static void minqpresultsbuf(minqpstate state, ref double[] x, minqpreport rep, alglib.xparams _xparams)
    {
        _core_minqpresultsbuf( state, ref  x,  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage minlm
    //
    

    public unsafe class minlmstate : alglibobject
    {
        private void *_ptr;
        public minlmstate(void *x)
        {
            _ptr = x;
        }
        ~minlmstate()
        {
            _deallocate();
        }
        public void* ptr { get { return _ptr; } }
        public override alglib.alglibobject make_copy()
        {
            if( _ptr==null )
                return new minlmstate(null);
            return new minlmstate(_i_x_obj_copy_minlmstate(_ptr));
        }
        public override void _deallocate()
        {
            if( _ptr!=null )
                _i_x_obj_free_minlmstate(_ptr);
            _ptr = null;
            System.GC.SuppressFinalize(this);
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_minlmstate(void *x);
    private static _d_x_obj_copy_minlmstate _i_x_obj_copy_minlmstate = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_obj_free_minlmstate(void *x);
    private static _d_x_obj_free_minlmstate _i_x_obj_free_minlmstate = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_minlmstate_get_needf(void *x, byte *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_minlmstate_set_needf(void *x, byte *dst);
    private static _d_x_minlmstate_get_needf _i_x_minlmstate_get_needf = null;
    private static _d_x_minlmstate_set_needf _i_x_minlmstate_set_needf = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_minlmstate_get_needfg(void *x, byte *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_minlmstate_set_needfg(void *x, byte *dst);
    private static _d_x_minlmstate_get_needfg _i_x_minlmstate_get_needfg = null;
    private static _d_x_minlmstate_set_needfg _i_x_minlmstate_set_needfg = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_minlmstate_get_needfgh(void *x, byte *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_minlmstate_set_needfgh(void *x, byte *dst);
    private static _d_x_minlmstate_get_needfgh _i_x_minlmstate_get_needfgh = null;
    private static _d_x_minlmstate_set_needfgh _i_x_minlmstate_set_needfgh = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_minlmstate_get_needfi(void *x, byte *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_minlmstate_set_needfi(void *x, byte *dst);
    private static _d_x_minlmstate_get_needfi _i_x_minlmstate_get_needfi = null;
    private static _d_x_minlmstate_set_needfi _i_x_minlmstate_set_needfi = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_minlmstate_get_needfij(void *x, byte *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_minlmstate_set_needfij(void *x, byte *dst);
    private static _d_x_minlmstate_get_needfij _i_x_minlmstate_get_needfij = null;
    private static _d_x_minlmstate_set_needfij _i_x_minlmstate_set_needfij = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_minlmstate_get_xupdated(void *x, byte *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_minlmstate_set_xupdated(void *x, byte *dst);
    private static _d_x_minlmstate_get_xupdated _i_x_minlmstate_get_xupdated = null;
    private static _d_x_minlmstate_set_xupdated _i_x_minlmstate_set_xupdated = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_minlmstate_get_f(void *x, double *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_minlmstate_set_f(void *x, double *dst);
    private static _d_x_minlmstate_get_f _i_x_minlmstate_get_f = null;
    private static _d_x_minlmstate_set_f _i_x_minlmstate_set_f = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_minlmstate_get_fi(void *x, x_vector *dst);
    private static _d_x_minlmstate_get_fi _i_x_minlmstate_get_fi = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_minlmstate_get_g(void *x, x_vector *dst);
    private static _d_x_minlmstate_get_g _i_x_minlmstate_get_g = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_minlmstate_get_h(void *x, x_matrix *dst);
    private static _d_x_minlmstate_get_h _i_x_minlmstate_get_h = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_minlmstate_get_j(void *x, x_matrix *dst);
    private static _d_x_minlmstate_get_j _i_x_minlmstate_get_j = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_minlmstate_get_x(void *x, x_vector *dst);
    private static _d_x_minlmstate_get_x _i_x_minlmstate_get_x = null;

    [StructLayout(LayoutKind.Sequential, Pack=8)]
    private struct x_minlmreport
    {
        public x_int iterationscount;
        public x_int terminationtype;
        public x_int nfunc;
        public x_int njac;
        public x_int ngrad;
        public x_int nhess;
        public x_int ncholesky;
    }

    public class minlmreport : alglibobject
    {
        public int iterationscount;
        public int terminationtype;
        public int nfunc;
        public int njac;
        public int ngrad;
        public int nhess;
        public int ncholesky;
        public override alglib.alglibobject make_copy()
        {
            minlmreport dst = new minlmreport();
            dst.iterationscount = iterationscount;
            dst.terminationtype = terminationtype;
            dst.nfunc = nfunc;
            dst.njac = njac;
            dst.ngrad = ngrad;
            dst.nhess = nhess;
            dst.ncholesky = ncholesky;
            return dst;
        }
    }

    // This function initializes X-structure (its previous content is ignored)
    private static void x_minlmreport_init(ref x_minlmreport x)
    {
        x.iterationscount.longval = 0;
        x.terminationtype.longval = 0;
        x.nfunc.longval = 0;
        x.njac.longval = 0;
        x.ngrad.longval = 0;
        x.nhess.longval = 0;
        x.ncholesky.longval = 0;
    }

    // This function finalizes fields of X-structure (however, memory occupied by structure itself is not freed)
    // After destruction structure becomes unusable and should be re-initialized if you want to use it
    private static void x_minlmreport_clear(ref x_minlmreport x)
    {
    }

    // This function initializes X-structure by appropriate C# instance
    // (previous content of X structure is ignored)
    private static void x_minlmreport_init_from(ref x_minlmreport x, minlmreport v)
    {
        x.iterationscount.longval = v.iterationscount;
        x.terminationtype.longval = v.terminationtype;
        x.nfunc.longval = v.nfunc;
        x.njac.longval = v.njac;
        x.ngrad.longval = v.ngrad;
        x.nhess.longval = v.nhess;
        x.ncholesky.longval = v.ncholesky;
    }

    // This function initializes C# structure by appropriate X instance
    // (previous content of C# structure is ignored).
    // This function may accept null v, in this case v is automatically allocated with new().
    private static void x_minlmreport_to_record(ref x_minlmreport x, ref minlmreport v)
    {
        if( v==null )
            v = new minlmreport();
        v.iterationscount = x.iterationscount.intval; // long is silently truncated to int
        v.terminationtype = x.terminationtype.intval; // long is silently truncated to int
        v.nfunc = x.nfunc.intval; // long is silently truncated to int
        v.njac = x.njac.intval; // long is silently truncated to int
        v.ngrad = x.ngrad.intval; // long is silently truncated to int
        v.nhess = x.nhess.intval; // long is silently truncated to int
        v.ncholesky = x.ncholesky.intval; // long is silently truncated to int
    }
    
    private static unsafe void _core_minlmcreatevj(int n, int m, double[] x, out minlmstate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        x_int _d_m = new x_int(m);
        x_vector _d_x = new x_vector();
        void *_d_state = null;
        state = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_xv2_minlmcreatevj(&_s_errormsg, &_d_n, &_d_m, &_d_x, &_d_state, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minlmcreatevj");
            state = new minlmstate(_d_state);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            if( _d_state!=null && state==null)
                _i_x_obj_free_minlmstate(_d_state); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void minlmcreatevj(int n, int m, double[] x, out minlmstate state)
    {
        _core_minlmcreatevj( n,  m,  x, out  state, 0x0);
    }
    
    public static void minlmcreatevj(int n, int m, double[] x, out minlmstate state, alglib.xparams _xparams)
    {
        _core_minlmcreatevj( n,  m,  x, out  state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void minlmcreatevj(int m, double[] x, out minlmstate state)
    {
        int n;
    
        n = ap.len(x);
        _core_minlmcreatevj( n,  m,  x, out  state, 0x0);
    
        
    }
    
    public static void minlmcreatevj(int m, double[] x, out minlmstate state, alglib.xparams _xparams)
    {
        int n;
    
        n = ap.len(x);
        _core_minlmcreatevj( n,  m,  x, out  state, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_minlmcreatev(int n, int m, double[] x, double diffstep, out minlmstate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        x_int _d_m = new x_int(m);
        x_vector _d_x = new x_vector();
        double _d_diffstep = diffstep;
        void *_d_state = null;
        state = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_xv2_minlmcreatev(&_s_errormsg, &_d_n, &_d_m, &_d_x, &_d_diffstep, &_d_state, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minlmcreatev");
            state = new minlmstate(_d_state);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            if( _d_state!=null && state==null)
                _i_x_obj_free_minlmstate(_d_state); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void minlmcreatev(int n, int m, double[] x, double diffstep, out minlmstate state)
    {
        _core_minlmcreatev( n,  m,  x,  diffstep, out  state, 0x0);
    }
    
    public static void minlmcreatev(int n, int m, double[] x, double diffstep, out minlmstate state, alglib.xparams _xparams)
    {
        _core_minlmcreatev( n,  m,  x,  diffstep, out  state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void minlmcreatev(int m, double[] x, double diffstep, out minlmstate state)
    {
        int n;
    
        n = ap.len(x);
        _core_minlmcreatev( n,  m,  x,  diffstep, out  state, 0x0);
    
        
    }
    
    public static void minlmcreatev(int m, double[] x, double diffstep, out minlmstate state, alglib.xparams _xparams)
    {
        int n;
    
        n = ap.len(x);
        _core_minlmcreatev( n,  m,  x,  diffstep, out  state, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_minlmcreatefgh(int n, double[] x, out minlmstate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        x_vector _d_x = new x_vector();
        void *_d_state = null;
        state = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_xv2_minlmcreatefgh(&_s_errormsg, &_d_n, &_d_x, &_d_state, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minlmcreatefgh");
            state = new minlmstate(_d_state);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            if( _d_state!=null && state==null)
                _i_x_obj_free_minlmstate(_d_state); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void minlmcreatefgh(int n, double[] x, out minlmstate state)
    {
        _core_minlmcreatefgh( n,  x, out  state, 0x0);
    }
    
    public static void minlmcreatefgh(int n, double[] x, out minlmstate state, alglib.xparams _xparams)
    {
        _core_minlmcreatefgh( n,  x, out  state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void minlmcreatefgh(double[] x, out minlmstate state)
    {
        int n;
    
        n = ap.len(x);
        _core_minlmcreatefgh( n,  x, out  state, 0x0);
    
        
    }
    
    public static void minlmcreatefgh(double[] x, out minlmstate state, alglib.xparams _xparams)
    {
        int n;
    
        n = ap.len(x);
        _core_minlmcreatefgh( n,  x, out  state, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_minlmsetcond(minlmstate state, double epsx, int maxits, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_epsx = epsx;
        x_int _d_maxits = new x_int(maxits);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_minlmsetcond(&_s_errormsg, &_d_state, &_d_epsx, &_d_maxits, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minlmsetcond");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void minlmsetcond(minlmstate state, double epsx, int maxits)
    {
        _core_minlmsetcond( state,  epsx,  maxits, 0x0);
    }
    
    public static void minlmsetcond(minlmstate state, double epsx, int maxits, alglib.xparams _xparams)
    {
        _core_minlmsetcond( state,  epsx,  maxits, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minlmsetxrep(minlmstate state, bool needxrep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        byte _d_needxrep = (byte)(needxrep ? 1 : 0);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_minlmsetxrep(&_s_errormsg, &_d_state, &_d_needxrep, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minlmsetxrep");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void minlmsetxrep(minlmstate state, bool needxrep)
    {
        _core_minlmsetxrep( state,  needxrep, 0x0);
    }
    
    public static void minlmsetxrep(minlmstate state, bool needxrep, alglib.xparams _xparams)
    {
        _core_minlmsetxrep( state,  needxrep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minlmsetstpmax(minlmstate state, double stpmax, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_stpmax = stpmax;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_minlmsetstpmax(&_s_errormsg, &_d_state, &_d_stpmax, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minlmsetstpmax");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void minlmsetstpmax(minlmstate state, double stpmax)
    {
        _core_minlmsetstpmax( state,  stpmax, 0x0);
    }
    
    public static void minlmsetstpmax(minlmstate state, double stpmax, alglib.xparams _xparams)
    {
        _core_minlmsetstpmax( state,  stpmax, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minlmsetscale(minlmstate state, double[] s, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_s = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_s = s){
                x_vector_attach_to_array(ref _d_s, _fp_s, ap.len(s));
                _error_code = _i_xv2_minlmsetscale(&_s_errormsg, &_d_state, &_d_s, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minlmsetscale");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_s);
        }
        // This function returns no value.
    }
    
    public static void minlmsetscale(minlmstate state, double[] s)
    {
        _core_minlmsetscale( state,  s, 0x0);
    }
    
    public static void minlmsetscale(minlmstate state, double[] s, alglib.xparams _xparams)
    {
        _core_minlmsetscale( state,  s, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minlmsetbc(minlmstate state, double[] bndl, double[] bndu, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_bndl = new x_vector();
        x_vector _d_bndu = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_bndl = bndl, _fp_bndu = bndu){
                x_vector_attach_to_array(ref _d_bndl, _fp_bndl, ap.len(bndl));
                x_vector_attach_to_array(ref _d_bndu, _fp_bndu, ap.len(bndu));
                _error_code = _i_xv2_minlmsetbc(&_s_errormsg, &_d_state, &_d_bndl, &_d_bndu, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minlmsetbc");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_bndl);
            x_vector_clear(ref _d_bndu);
        }
        // This function returns no value.
    }
    
    public static void minlmsetbc(minlmstate state, double[] bndl, double[] bndu)
    {
        _core_minlmsetbc( state,  bndl,  bndu, 0x0);
    }
    
    public static void minlmsetbc(minlmstate state, double[] bndl, double[] bndu, alglib.xparams _xparams)
    {
        _core_minlmsetbc( state,  bndl,  bndu, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minlmsetlc(minlmstate state, double[,] c, int[] ct, int k, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_matrix _d_c = new x_matrix();
        x_vector _d_ct = new x_vector();
        x_int _d_k = new x_int(k);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_c = c){
                x_matrix_attach_to_array(ref _d_c, _fp_c, ap.rows(c), ap.cols(c));
                x_vector_from_array(ref _d_ct, ct, X_CREATE);
                _error_code = _i_xv2_minlmsetlc(&_s_errormsg, &_d_state, &_d_c, &_d_ct, &_d_k, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minlmsetlc");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_c);
            x_vector_clear(ref _d_ct);
        }
        // This function returns no value.
    }
    
    public static void minlmsetlc(minlmstate state, double[,] c, int[] ct, int k)
    {
        _core_minlmsetlc( state,  c,  ct,  k, 0x0);
    }
    
    public static void minlmsetlc(minlmstate state, double[,] c, int[] ct, int k, alglib.xparams _xparams)
    {
        _core_minlmsetlc( state,  c,  ct,  k, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void minlmsetlc(minlmstate state, double[,] c, int[] ct)
    {
        int k;
        if( (ap.rows(c)!=ap.len(ct)))
            throw new alglibexception("Error while calling 'minlmsetlc': looks like one of arguments has wrong size");
        k = ap.rows(c);
        _core_minlmsetlc( state,  c,  ct,  k, 0x0);
    
        
    }
    
    public static void minlmsetlc(minlmstate state, double[,] c, int[] ct, alglib.xparams _xparams)
    {
        int k;
        if( (ap.rows(c)!=ap.len(ct)))
            throw new alglibexception("Error while calling 'minlmsetlc': looks like one of arguments has wrong size");
        k = ap.rows(c);
        _core_minlmsetlc( state,  c,  ct,  k, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_minlmsetacctype(minlmstate state, int acctype, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_int _d_acctype = new x_int(acctype);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_minlmsetacctype(&_s_errormsg, &_d_state, &_d_acctype, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minlmsetacctype");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void minlmsetacctype(minlmstate state, int acctype)
    {
        _core_minlmsetacctype( state,  acctype, 0x0);
    }
    
    public static void minlmsetacctype(minlmstate state, int acctype, alglib.xparams _xparams)
    {
        _core_minlmsetacctype( state,  acctype, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe bool _core_minlmiteration(minlmstate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        bool result;
        byte _d_result = (byte)0;
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_minlmiteration(&_s_errormsg, &_d_result, &_d_state, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minlmiteration");
            result = _d_result!=0;
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static bool minlmiteration(minlmstate state)
    {
        return _core_minlmiteration( state, 0x0);
    }
    
    public static bool minlmiteration(minlmstate state, alglib.xparams _xparams)
    {
        return _core_minlmiteration( state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static unsafe void minlmoptimize(minlmstate state, ndimensional_fvec  fvec, ndimensional_rep rep, object obj)
    {
        minlmoptimize(state, fvec, rep, obj, null);
    }
    
    public static unsafe void minlmoptimize(minlmstate state, ndimensional_fvec  fvec, ndimensional_rep rep, object obj, alglib.xparams _xparams)
    {
        byte *_s_errormsg = null;
        int _error_code = 0;
        byte _b_result = (byte)0;
        byte _xc_xupdated = 0;
        void *_state = state.ptr;
        IntPtr _pre_ptr;
        x_vector _xc_arg = new x_vector();
        double[] _cs_arg = null;
        x_vector _xc_fi = new x_vector();
        double[] _cs_fi = null;
        byte _xc_needfi= 0;
    
        //
        // Check correctness of delegates
        //
        if( fvec==null )
            throw new alglibexception("ALGLIB: error in 'minlmoptimize()' (fvec is null)");
    
        //
        // Attach x-structures to internal arrays
        //
        x_vector_create_empty(ref _xc_arg, DT_REAL);
        x_vector_create_empty(ref _xc_fi, DT_REAL);
        _i_x_minlmstate_get_x(_state, &_xc_arg);
        _i_x_minlmstate_get_fi(_state, &_xc_fi);
        _cs_arg = new double[_xc_arg.cnt];
        _cs_fi = new double[_xc_fi.cnt];
    
        //
        // Main loop
        //
        for(;;)
        {
            //
            // Call iteration function.
            // Terminate iterations if it returned false.
            //
            _error_code = _i_xv2_minlmiteration(&_s_errormsg, &_b_result, &_state, _xparams==null ? 0x0 : _xparams.flags);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minlmiteration");
            ap.assert(_state==state.ptr, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _b_result==0 )
                break;
            
            //
            // Reverse communication interface:
            // * fetch flags
            // * make delegate calls
            //
            _i_x_minlmstate_get_xupdated(_state, &_xc_xupdated);
            _i_x_minlmstate_get_needfi(_state, &_xc_needfi);
            x_vector_to_array(ref _xc_arg, ref _cs_arg);
            if( _xc_needfi!=0 )
            {
                fvec(_cs_arg, _cs_fi, obj);
                x_vector_from_array(ref _xc_fi, _cs_fi, X_REWRITE);
                continue;
            }
            if( _xc_xupdated!=0 )
            {
                if( rep!=null )
                {
                    double _local_f;
                    _i_x_minlmstate_get_f(_state, &_local_f);
                    rep(_cs_arg, _local_f, obj);
                }
                continue;
            }
            throw new alglibexception("ALGLIB: error in 'minlmoptimize' (some derivatives were not provided?)");
        }
        
        //
        // Integrity post-check:
        // * make sure that no reverse communication array was reallocated during optimization
        //
        _pre_ptr = _xc_arg.xptr.ptr;
        _i_x_minlmstate_get_x(_state, &_xc_arg);
        alglib.ap.assert(_xc_arg.xptr.ptr==_pre_ptr, "ALGLIB: integrity check failed in minlmoptimize()");
        _pre_ptr = _xc_fi.xptr.ptr;
        _i_x_minlmstate_get_fi(_state, &_xc_fi);
        alglib.ap.assert(_xc_fi.xptr.ptr==_pre_ptr, "ALGLIB: integrity check failed in minlmoptimize()");
    }
    
    public static unsafe void minlmoptimize(minlmstate state, ndimensional_fvec  fvec, ndimensional_jac  jac, ndimensional_rep rep, object obj)
    {
        minlmoptimize(state, fvec, jac, rep, obj, null);
    }
    
    public static unsafe void minlmoptimize(minlmstate state, ndimensional_fvec  fvec, ndimensional_jac  jac, ndimensional_rep rep, object obj, alglib.xparams _xparams)
    {
        byte *_s_errormsg = null;
        int _error_code = 0;
        byte _b_result = (byte)0;
        byte _xc_xupdated = 0;
        void *_state = state.ptr;
        IntPtr _pre_ptr;
        x_vector _xc_arg = new x_vector();
        double[] _cs_arg = null;
        x_vector _xc_fi = new x_vector();
        double[] _cs_fi = null;
        x_matrix _xc_j = new x_matrix();
        double[,] _cs_j = null;
        byte _xc_needfi= 0;
        byte _xc_needfij= 0;
    
        //
        // Check correctness of delegates
        //
        if( fvec==null )
            throw new alglibexception("ALGLIB: error in 'minlmoptimize()' (fvec is null)");
        if( jac==null )
            throw new alglibexception("ALGLIB: error in 'minlmoptimize()' (jac is null)");
    
        //
        // Attach x-structures to internal arrays
        //
        x_vector_create_empty(ref _xc_arg, DT_REAL);
        x_vector_create_empty(ref _xc_fi, DT_REAL);
        x_matrix_create_empty(ref _xc_j, DT_REAL);
        _i_x_minlmstate_get_x(_state, &_xc_arg);
        _i_x_minlmstate_get_fi(_state, &_xc_fi);
        _i_x_minlmstate_get_j(_state, &_xc_j);
        _cs_arg = new double[_xc_arg.cnt];
        _cs_fi = new double[_xc_fi.cnt];
        _cs_j = new double[_xc_j.rows,_xc_j.cols];
    
        //
        // Main loop
        //
        for(;;)
        {
            //
            // Call iteration function.
            // Terminate iterations if it returned false.
            //
            _error_code = _i_xv2_minlmiteration(&_s_errormsg, &_b_result, &_state, _xparams==null ? 0x0 : _xparams.flags);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minlmiteration");
            ap.assert(_state==state.ptr, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _b_result==0 )
                break;
            
            //
            // Reverse communication interface:
            // * fetch flags
            // * make delegate calls
            //
            _i_x_minlmstate_get_xupdated(_state, &_xc_xupdated);
            _i_x_minlmstate_get_needfi(_state, &_xc_needfi);
            _i_x_minlmstate_get_needfij(_state, &_xc_needfij);
            x_vector_to_array(ref _xc_arg, ref _cs_arg);
            if( _xc_needfi!=0 )
            {
                fvec(_cs_arg, _cs_fi, obj);
                x_vector_from_array(ref _xc_fi, _cs_fi, X_REWRITE);
                continue;
            }
            if( _xc_needfij!=0 )
            {
                jac(_cs_arg, _cs_fi, _cs_j, obj);
                x_vector_from_array(ref _xc_fi, _cs_fi, X_REWRITE);
                x_matrix_from_array(ref _xc_j,  _cs_j,  X_REWRITE);
                continue;
            }
            if( _xc_xupdated!=0 )
            {
                if( rep!=null )
                {
                    double _local_f;
                    _i_x_minlmstate_get_f(_state, &_local_f);
                    rep(_cs_arg, _local_f, obj);
                }
                continue;
            }
            throw new alglibexception("ALGLIB: error in 'minlmoptimize' (some derivatives were not provided?)");
        }
        
        //
        // Integrity post-check:
        // * make sure that no reverse communication array was reallocated during optimization
        //
        _pre_ptr = _xc_arg.xptr.ptr;
        _i_x_minlmstate_get_x(_state, &_xc_arg);
        alglib.ap.assert(_xc_arg.xptr.ptr==_pre_ptr, "ALGLIB: integrity check failed in minlmoptimize()");
        _pre_ptr = _xc_fi.xptr.ptr;
        _i_x_minlmstate_get_fi(_state, &_xc_fi);
        alglib.ap.assert(_xc_fi.xptr.ptr==_pre_ptr, "ALGLIB: integrity check failed in minlmoptimize()");
        _pre_ptr = _xc_j.xptr.ptr;
        _i_x_minlmstate_get_j(_state, &_xc_j);
        alglib.ap.assert(_xc_j.xptr.ptr==_pre_ptr, "ALGLIB: integrity check failed in minlmoptimize()");
    }
    
    public static unsafe void minlmoptimize(minlmstate state, ndimensional_func func, ndimensional_grad grad, ndimensional_hess hess, ndimensional_rep rep, object obj)
    {
        minlmoptimize(state, func, grad, hess, rep, obj, null);
    }
    
    public static unsafe void minlmoptimize(minlmstate state, ndimensional_func func, ndimensional_grad grad, ndimensional_hess hess, ndimensional_rep rep, object obj, alglib.xparams _xparams)
    {
        byte *_s_errormsg = null;
        int _error_code = 0;
        byte _b_result = (byte)0;
        byte _xc_xupdated = 0;
        void *_state = state.ptr;
        IntPtr _pre_ptr;
        x_vector _xc_arg = new x_vector();
        double[] _cs_arg = null;
        double _cs_f = 0;
        x_vector _xc_g = new x_vector();
        double[] _cs_g = null;
        x_matrix _xc_h = new x_matrix();
        double[,] _cs_h = null;
        byte _xc_needf= 0;
        byte _xc_needfg= 0;
        byte _xc_needfgh= 0;
    
        //
        // Check correctness of delegates
        //
        if( func==null )
            throw new alglibexception("ALGLIB: error in 'minlmoptimize()' (func is null)");
        if( grad==null )
            throw new alglibexception("ALGLIB: error in 'minlmoptimize()' (grad is null)");
        if( hess==null )
            throw new alglibexception("ALGLIB: error in 'minlmoptimize()' (hess is null)");
    
        //
        // Attach x-structures to internal arrays
        //
        x_vector_create_empty(ref _xc_arg, DT_REAL);
        x_vector_create_empty(ref _xc_g, DT_REAL);
        x_matrix_create_empty(ref _xc_h, DT_REAL);
        _i_x_minlmstate_get_x(_state, &_xc_arg);
        _i_x_minlmstate_get_g(_state, &_xc_g);
        _i_x_minlmstate_get_h(_state, &_xc_h);
        _cs_arg = new double[_xc_arg.cnt];
        _cs_g = new double[_xc_g.cnt];
        _cs_h = new double[_xc_h.rows,_xc_h.cols];
    
        //
        // Main loop
        //
        for(;;)
        {
            //
            // Call iteration function.
            // Terminate iterations if it returned false.
            //
            _error_code = _i_xv2_minlmiteration(&_s_errormsg, &_b_result, &_state, _xparams==null ? 0x0 : _xparams.flags);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minlmiteration");
            ap.assert(_state==state.ptr, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _b_result==0 )
                break;
            
            //
            // Reverse communication interface:
            // * fetch flags
            // * make delegate calls
            //
            _i_x_minlmstate_get_xupdated(_state, &_xc_xupdated);
            _i_x_minlmstate_get_needf(_state, &_xc_needf);
            _i_x_minlmstate_get_needfg(_state, &_xc_needfg);
            _i_x_minlmstate_get_needfgh(_state, &_xc_needfgh);
            x_vector_to_array(ref _xc_arg, ref _cs_arg);
            if( _xc_needf!=0 )
            {
                func(_cs_arg, ref _cs_f, obj);
                _i_x_minlmstate_set_f(_state, &_cs_f);
                continue;
            }
            if( _xc_needfg!=0 )
            {
                grad(_cs_arg, ref _cs_f, _cs_g, obj);
                _i_x_minlmstate_set_f(_state, &_cs_f);
                x_vector_from_array(ref _xc_g, _cs_g, X_REWRITE);
                continue;
            }
            if( _xc_needfgh!=0 )
            {
                hess(_cs_arg, ref _cs_f, _cs_g, _cs_h, obj);
                _i_x_minlmstate_set_f(_state, &_cs_f);
                x_vector_from_array(ref _xc_g, _cs_g, X_REWRITE);
                x_matrix_from_array(ref _xc_h, _cs_h, X_REWRITE);
                continue;
            }
            if( _xc_xupdated!=0 )
            {
                if( rep!=null )
                {
                    double _local_f;
                    _i_x_minlmstate_get_f(_state, &_local_f);
                    rep(_cs_arg, _local_f, obj);
                }
                continue;
            }
            throw new alglibexception("ALGLIB: error in 'minlmoptimize' (some derivatives were not provided?)");
        }
        
        //
        // Integrity post-check:
        // * make sure that no reverse communication array was reallocated during optimization
        //
        _pre_ptr = _xc_arg.xptr.ptr;
        _i_x_minlmstate_get_x(_state, &_xc_arg);
        alglib.ap.assert(_xc_arg.xptr.ptr==_pre_ptr, "ALGLIB: integrity check failed in minlmoptimize()");
        _pre_ptr = _xc_g.xptr.ptr;
        _i_x_minlmstate_get_g(_state, &_xc_g);
        alglib.ap.assert(_xc_g.xptr.ptr==_pre_ptr, "ALGLIB: integrity check failed in minlmoptimize()");
        _pre_ptr = _xc_h.xptr.ptr;
        _i_x_minlmstate_get_h(_state, &_xc_h);
        alglib.ap.assert(_xc_h.xptr.ptr==_pre_ptr, "ALGLIB: integrity check failed in minlmoptimize()");
    }
    
    public static unsafe void minlmoptimize(minlmstate state, ndimensional_func func, ndimensional_jac  jac, ndimensional_rep rep, object obj)
    {
        minlmoptimize(state, func, jac, rep, obj, null);
    }
    
    public static unsafe void minlmoptimize(minlmstate state, ndimensional_func func, ndimensional_jac  jac, ndimensional_rep rep, object obj, alglib.xparams _xparams)
    {
        byte *_s_errormsg = null;
        int _error_code = 0;
        byte _b_result = (byte)0;
        byte _xc_xupdated = 0;
        void *_state = state.ptr;
        IntPtr _pre_ptr;
        x_vector _xc_arg = new x_vector();
        double[] _cs_arg = null;
        double _cs_f = 0;
        x_vector _xc_fi = new x_vector();
        double[] _cs_fi = null;
        x_matrix _xc_j = new x_matrix();
        double[,] _cs_j = null;
        byte _xc_needf= 0;
        byte _xc_needfij= 0;
    
        //
        // Check correctness of delegates
        //
        if( func==null )
            throw new alglibexception("ALGLIB: error in 'minlmoptimize()' (func is null)");
        if( jac==null )
            throw new alglibexception("ALGLIB: error in 'minlmoptimize()' (jac is null)");
    
        //
        // Attach x-structures to internal arrays
        //
        x_vector_create_empty(ref _xc_arg, DT_REAL);
        x_vector_create_empty(ref _xc_fi, DT_REAL);
        x_matrix_create_empty(ref _xc_j, DT_REAL);
        _i_x_minlmstate_get_x(_state, &_xc_arg);
        _i_x_minlmstate_get_fi(_state, &_xc_fi);
        _i_x_minlmstate_get_j(_state, &_xc_j);
        _cs_arg = new double[_xc_arg.cnt];
        _cs_fi = new double[_xc_fi.cnt];
        _cs_j = new double[_xc_j.rows,_xc_j.cols];
    
        //
        // Main loop
        //
        for(;;)
        {
            //
            // Call iteration function.
            // Terminate iterations if it returned false.
            //
            _error_code = _i_xv2_minlmiteration(&_s_errormsg, &_b_result, &_state, _xparams==null ? 0x0 : _xparams.flags);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minlmiteration");
            ap.assert(_state==state.ptr, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _b_result==0 )
                break;
            
            //
            // Reverse communication interface:
            // * fetch flags
            // * make delegate calls
            //
            _i_x_minlmstate_get_xupdated(_state, &_xc_xupdated);
            _i_x_minlmstate_get_needf(_state, &_xc_needf);
            _i_x_minlmstate_get_needfij(_state, &_xc_needfij);
            x_vector_to_array(ref _xc_arg, ref _cs_arg);
            if( _xc_needf!=0 )
            {
                func(_cs_arg, ref _cs_f, obj);
                _i_x_minlmstate_set_f(_state, &_cs_f);
                continue;
            }
            if( _xc_needfij!=0 )
            {
                jac(_cs_arg, _cs_fi, _cs_j, obj);
                x_vector_from_array(ref _xc_fi, _cs_fi, X_REWRITE);
                x_matrix_from_array(ref _xc_j,  _cs_j,  X_REWRITE);
                continue;
            }
            if( _xc_xupdated!=0 )
            {
                if( rep!=null )
                {
                    double _local_f;
                    _i_x_minlmstate_get_f(_state, &_local_f);
                    rep(_cs_arg, _local_f, obj);
                }
                continue;
            }
            throw new alglibexception("ALGLIB: error in 'minlmoptimize' (some derivatives were not provided?)");
        }
        
        //
        // Integrity post-check:
        // * make sure that no reverse communication array was reallocated during optimization
        //
        _pre_ptr = _xc_arg.xptr.ptr;
        _i_x_minlmstate_get_x(_state, &_xc_arg);
        alglib.ap.assert(_xc_arg.xptr.ptr==_pre_ptr, "ALGLIB: integrity check failed in minlmoptimize()");
        _pre_ptr = _xc_fi.xptr.ptr;
        _i_x_minlmstate_get_fi(_state, &_xc_fi);
        alglib.ap.assert(_xc_fi.xptr.ptr==_pre_ptr, "ALGLIB: integrity check failed in minlmoptimize()");
        _pre_ptr = _xc_j.xptr.ptr;
        _i_x_minlmstate_get_j(_state, &_xc_j);
        alglib.ap.assert(_xc_j.xptr.ptr==_pre_ptr, "ALGLIB: integrity check failed in minlmoptimize()");
    }
    
    public static unsafe void minlmoptimize(minlmstate state, ndimensional_func func, ndimensional_grad grad, ndimensional_jac  jac, ndimensional_rep rep, object obj)
    {
        minlmoptimize(state, func, grad, jac, rep, obj, null);
    }
    
    public static unsafe void minlmoptimize(minlmstate state, ndimensional_func func, ndimensional_grad grad, ndimensional_jac  jac, ndimensional_rep rep, object obj, alglib.xparams _xparams)
    {
        byte *_s_errormsg = null;
        int _error_code = 0;
        byte _b_result = (byte)0;
        byte _xc_xupdated = 0;
        void *_state = state.ptr;
        IntPtr _pre_ptr;
        x_vector _xc_arg = new x_vector();
        double[] _cs_arg = null;
        double _cs_f = 0;
        x_vector _xc_g = new x_vector();
        double[] _cs_g = null;
        x_vector _xc_fi = new x_vector();
        double[] _cs_fi = null;
        x_matrix _xc_j = new x_matrix();
        double[,] _cs_j = null;
        byte _xc_needf= 0;
        byte _xc_needfg= 0;
        byte _xc_needfij= 0;
    
        //
        // Check correctness of delegates
        //
        if( func==null )
            throw new alglibexception("ALGLIB: error in 'minlmoptimize()' (func is null)");
        if( grad==null )
            throw new alglibexception("ALGLIB: error in 'minlmoptimize()' (grad is null)");
        if( jac==null )
            throw new alglibexception("ALGLIB: error in 'minlmoptimize()' (jac is null)");
    
        //
        // Attach x-structures to internal arrays
        //
        x_vector_create_empty(ref _xc_arg, DT_REAL);
        x_vector_create_empty(ref _xc_g, DT_REAL);
        x_vector_create_empty(ref _xc_fi, DT_REAL);
        x_matrix_create_empty(ref _xc_j, DT_REAL);
        _i_x_minlmstate_get_x(_state, &_xc_arg);
        _i_x_minlmstate_get_g(_state, &_xc_g);
        _i_x_minlmstate_get_fi(_state, &_xc_fi);
        _i_x_minlmstate_get_j(_state, &_xc_j);
        _cs_arg = new double[_xc_arg.cnt];
        _cs_g = new double[_xc_g.cnt];
        _cs_fi = new double[_xc_fi.cnt];
        _cs_j = new double[_xc_j.rows,_xc_j.cols];
    
        //
        // Main loop
        //
        for(;;)
        {
            //
            // Call iteration function.
            // Terminate iterations if it returned false.
            //
            _error_code = _i_xv2_minlmiteration(&_s_errormsg, &_b_result, &_state, _xparams==null ? 0x0 : _xparams.flags);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minlmiteration");
            ap.assert(_state==state.ptr, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _b_result==0 )
                break;
            
            //
            // Reverse communication interface:
            // * fetch flags
            // * make delegate calls
            //
            _i_x_minlmstate_get_xupdated(_state, &_xc_xupdated);
            _i_x_minlmstate_get_needf(_state, &_xc_needf);
            _i_x_minlmstate_get_needfg(_state, &_xc_needfg);
            _i_x_minlmstate_get_needfij(_state, &_xc_needfij);
            x_vector_to_array(ref _xc_arg, ref _cs_arg);
            if( _xc_needf!=0 )
            {
                func(_cs_arg, ref _cs_f, obj);
                _i_x_minlmstate_set_f(_state, &_cs_f);
                continue;
            }
            if( _xc_needfg!=0 )
            {
                grad(_cs_arg, ref _cs_f, _cs_g, obj);
                _i_x_minlmstate_set_f(_state, &_cs_f);
                x_vector_from_array(ref _xc_g, _cs_g, X_REWRITE);
                continue;
            }
            if( _xc_needfij!=0 )
            {
                jac(_cs_arg, _cs_fi, _cs_j, obj);
                x_vector_from_array(ref _xc_fi, _cs_fi, X_REWRITE);
                x_matrix_from_array(ref _xc_j,  _cs_j,  X_REWRITE);
                continue;
            }
            if( _xc_xupdated!=0 )
            {
                if( rep!=null )
                {
                    double _local_f;
                    _i_x_minlmstate_get_f(_state, &_local_f);
                    rep(_cs_arg, _local_f, obj);
                }
                continue;
            }
            throw new alglibexception("ALGLIB: error in 'minlmoptimize' (some derivatives were not provided?)");
        }
        
        //
        // Integrity post-check:
        // * make sure that no reverse communication array was reallocated during optimization
        //
        _pre_ptr = _xc_arg.xptr.ptr;
        _i_x_minlmstate_get_x(_state, &_xc_arg);
        alglib.ap.assert(_xc_arg.xptr.ptr==_pre_ptr, "ALGLIB: integrity check failed in minlmoptimize()");
        _pre_ptr = _xc_g.xptr.ptr;
        _i_x_minlmstate_get_g(_state, &_xc_g);
        alglib.ap.assert(_xc_g.xptr.ptr==_pre_ptr, "ALGLIB: integrity check failed in minlmoptimize()");
        _pre_ptr = _xc_fi.xptr.ptr;
        _i_x_minlmstate_get_fi(_state, &_xc_fi);
        alglib.ap.assert(_xc_fi.xptr.ptr==_pre_ptr, "ALGLIB: integrity check failed in minlmoptimize()");
        _pre_ptr = _xc_j.xptr.ptr;
        _i_x_minlmstate_get_j(_state, &_xc_j);
        alglib.ap.assert(_xc_j.xptr.ptr==_pre_ptr, "ALGLIB: integrity check failed in minlmoptimize()");
    }
    
    private static unsafe void _core_minlmoptguardgradient(minlmstate state, double teststep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_teststep = teststep;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_minlmoptguardgradient(&_s_errormsg, &_d_state, &_d_teststep, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minlmoptguardgradient");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void minlmoptguardgradient(minlmstate state, double teststep)
    {
        _core_minlmoptguardgradient( state,  teststep, 0x0);
    }
    
    public static void minlmoptguardgradient(minlmstate state, double teststep, alglib.xparams _xparams)
    {
        _core_minlmoptguardgradient( state,  teststep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minlmoptguardresults(minlmstate state, out optguardreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_optguardreport _d_rep = new x_optguardreport();
        
        // Pack, call, unpack
        try
        {
            x_optguardreport_init(ref _d_rep);
            _error_code = _i_xv2_minlmoptguardresults(&_s_errormsg, &_d_state, &_d_rep, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minlmoptguardresults");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            rep = null;
            x_optguardreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_optguardreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void minlmoptguardresults(minlmstate state, out optguardreport rep)
    {
        _core_minlmoptguardresults( state, out  rep, 0x0);
    }
    
    public static void minlmoptguardresults(minlmstate state, out optguardreport rep, alglib.xparams _xparams)
    {
        _core_minlmoptguardresults( state, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minlmresults(minlmstate state, out double[] x, out minlmreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_x = new x_vector();
        x_minlmreport _d_rep = new x_minlmreport();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_x, DT_REAL);
            x = null;
            x_minlmreport_init(ref _d_rep);
            _error_code = _i_xv2_minlmresults(&_s_errormsg, &_d_state, &_d_x, &_d_rep, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minlmresults");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
            rep = null;
            x_minlmreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_minlmreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void minlmresults(minlmstate state, out double[] x, out minlmreport rep)
    {
        _core_minlmresults( state, out  x, out  rep, 0x0);
    }
    
    public static void minlmresults(minlmstate state, out double[] x, out minlmreport rep, alglib.xparams _xparams)
    {
        _core_minlmresults( state, out  x, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minlmresultsbuf(minlmstate state, ref double[] x, minlmreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_x = new x_vector();
        x_minlmreport _d_rep = new x_minlmreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_minlmreport_init_from(ref _d_rep, rep);
                _error_code = _i_xv2_minlmresultsbuf(&_s_errormsg, &_d_state, &_d_x, &_d_rep, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minlmresultsbuf");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
            x_minlmreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_minlmreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void minlmresultsbuf(minlmstate state, ref double[] x, minlmreport rep)
    {
        _core_minlmresultsbuf( state, ref  x,  rep, 0x0);
    }
    
    public static void minlmresultsbuf(minlmstate state, ref double[] x, minlmreport rep, alglib.xparams _xparams)
    {
        _core_minlmresultsbuf( state, ref  x,  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minlmrestartfrom(minlmstate state, double[] x, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_x = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_xv2_minlmrestartfrom(&_s_errormsg, &_d_state, &_d_x, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minlmrestartfrom");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_x);
        }
        // This function returns no value.
    }
    
    public static void minlmrestartfrom(minlmstate state, double[] x)
    {
        _core_minlmrestartfrom( state,  x, 0x0);
    }
    
    public static void minlmrestartfrom(minlmstate state, double[] x, alglib.xparams _xparams)
    {
        _core_minlmrestartfrom( state,  x, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minlmrequesttermination(minlmstate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_minlmrequesttermination(&_s_errormsg, &_d_state, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minlmrequesttermination");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void minlmrequesttermination(minlmstate state)
    {
        _core_minlmrequesttermination( state, 0x0);
    }
    
    public static void minlmrequesttermination(minlmstate state, alglib.xparams _xparams)
    {
        _core_minlmrequesttermination( state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minlmcreatevgj(int n, int m, double[] x, out minlmstate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        x_int _d_m = new x_int(m);
        x_vector _d_x = new x_vector();
        void *_d_state = null;
        state = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_xv2_minlmcreatevgj(&_s_errormsg, &_d_n, &_d_m, &_d_x, &_d_state, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minlmcreatevgj");
            state = new minlmstate(_d_state);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            if( _d_state!=null && state==null)
                _i_x_obj_free_minlmstate(_d_state); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void minlmcreatevgj(int n, int m, double[] x, out minlmstate state)
    {
        _core_minlmcreatevgj( n,  m,  x, out  state, 0x0);
    }
    
    public static void minlmcreatevgj(int n, int m, double[] x, out minlmstate state, alglib.xparams _xparams)
    {
        _core_minlmcreatevgj( n,  m,  x, out  state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void minlmcreatevgj(int m, double[] x, out minlmstate state)
    {
        int n;
    
        n = ap.len(x);
        _core_minlmcreatevgj( n,  m,  x, out  state, 0x0);
    
        
    }
    
    public static void minlmcreatevgj(int m, double[] x, out minlmstate state, alglib.xparams _xparams)
    {
        int n;
    
        n = ap.len(x);
        _core_minlmcreatevgj( n,  m,  x, out  state, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_minlmcreatefgj(int n, int m, double[] x, out minlmstate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        x_int _d_m = new x_int(m);
        x_vector _d_x = new x_vector();
        void *_d_state = null;
        state = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_xv2_minlmcreatefgj(&_s_errormsg, &_d_n, &_d_m, &_d_x, &_d_state, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minlmcreatefgj");
            state = new minlmstate(_d_state);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            if( _d_state!=null && state==null)
                _i_x_obj_free_minlmstate(_d_state); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void minlmcreatefgj(int n, int m, double[] x, out minlmstate state)
    {
        _core_minlmcreatefgj( n,  m,  x, out  state, 0x0);
    }
    
    public static void minlmcreatefgj(int n, int m, double[] x, out minlmstate state, alglib.xparams _xparams)
    {
        _core_minlmcreatefgj( n,  m,  x, out  state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void minlmcreatefgj(int m, double[] x, out minlmstate state)
    {
        int n;
    
        n = ap.len(x);
        _core_minlmcreatefgj( n,  m,  x, out  state, 0x0);
    
        
    }
    
    public static void minlmcreatefgj(int m, double[] x, out minlmstate state, alglib.xparams _xparams)
    {
        int n;
    
        n = ap.len(x);
        _core_minlmcreatefgj( n,  m,  x, out  state, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_minlmcreatefj(int n, int m, double[] x, out minlmstate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        x_int _d_m = new x_int(m);
        x_vector _d_x = new x_vector();
        void *_d_state = null;
        state = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_xv2_minlmcreatefj(&_s_errormsg, &_d_n, &_d_m, &_d_x, &_d_state, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minlmcreatefj");
            state = new minlmstate(_d_state);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            if( _d_state!=null && state==null)
                _i_x_obj_free_minlmstate(_d_state); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void minlmcreatefj(int n, int m, double[] x, out minlmstate state)
    {
        _core_minlmcreatefj( n,  m,  x, out  state, 0x0);
    }
    
    public static void minlmcreatefj(int n, int m, double[] x, out minlmstate state, alglib.xparams _xparams)
    {
        _core_minlmcreatefj( n,  m,  x, out  state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void minlmcreatefj(int m, double[] x, out minlmstate state)
    {
        int n;
    
        n = ap.len(x);
        _core_minlmcreatefj( n,  m,  x, out  state, 0x0);
    
        
    }
    
    public static void minlmcreatefj(int m, double[] x, out minlmstate state, alglib.xparams _xparams)
    {
        int n;
    
        n = ap.len(x);
        _core_minlmcreatefj( n,  m,  x, out  state, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    
    //
    // Subpackage mincg
    //
    

    public unsafe class mincgstate : alglibobject
    {
        private void *_ptr;
        public mincgstate(void *x)
        {
            _ptr = x;
        }
        ~mincgstate()
        {
            _deallocate();
        }
        public void* ptr { get { return _ptr; } }
        public override alglib.alglibobject make_copy()
        {
            if( _ptr==null )
                return new mincgstate(null);
            return new mincgstate(_i_x_obj_copy_mincgstate(_ptr));
        }
        public override void _deallocate()
        {
            if( _ptr!=null )
                _i_x_obj_free_mincgstate(_ptr);
            _ptr = null;
            System.GC.SuppressFinalize(this);
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_mincgstate(void *x);
    private static _d_x_obj_copy_mincgstate _i_x_obj_copy_mincgstate = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_obj_free_mincgstate(void *x);
    private static _d_x_obj_free_mincgstate _i_x_obj_free_mincgstate = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_mincgstate_get_needf(void *x, byte *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_mincgstate_set_needf(void *x, byte *dst);
    private static _d_x_mincgstate_get_needf _i_x_mincgstate_get_needf = null;
    private static _d_x_mincgstate_set_needf _i_x_mincgstate_set_needf = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_mincgstate_get_needfg(void *x, byte *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_mincgstate_set_needfg(void *x, byte *dst);
    private static _d_x_mincgstate_get_needfg _i_x_mincgstate_get_needfg = null;
    private static _d_x_mincgstate_set_needfg _i_x_mincgstate_set_needfg = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_mincgstate_get_xupdated(void *x, byte *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_mincgstate_set_xupdated(void *x, byte *dst);
    private static _d_x_mincgstate_get_xupdated _i_x_mincgstate_get_xupdated = null;
    private static _d_x_mincgstate_set_xupdated _i_x_mincgstate_set_xupdated = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_mincgstate_get_f(void *x, double *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_mincgstate_set_f(void *x, double *dst);
    private static _d_x_mincgstate_get_f _i_x_mincgstate_get_f = null;
    private static _d_x_mincgstate_set_f _i_x_mincgstate_set_f = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_mincgstate_get_g(void *x, x_vector *dst);
    private static _d_x_mincgstate_get_g _i_x_mincgstate_get_g = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_mincgstate_get_x(void *x, x_vector *dst);
    private static _d_x_mincgstate_get_x _i_x_mincgstate_get_x = null;

    [StructLayout(LayoutKind.Sequential, Pack=8)]
    private struct x_mincgreport
    {
        public x_int iterationscount;
        public x_int nfev;
        public x_int terminationtype;
    }

    public class mincgreport : alglibobject
    {
        public int iterationscount;
        public int nfev;
        public int terminationtype;
        public override alglib.alglibobject make_copy()
        {
            mincgreport dst = new mincgreport();
            dst.iterationscount = iterationscount;
            dst.nfev = nfev;
            dst.terminationtype = terminationtype;
            return dst;
        }
    }

    // This function initializes X-structure (its previous content is ignored)
    private static void x_mincgreport_init(ref x_mincgreport x)
    {
        x.iterationscount.longval = 0;
        x.nfev.longval = 0;
        x.terminationtype.longval = 0;
    }

    // This function finalizes fields of X-structure (however, memory occupied by structure itself is not freed)
    // After destruction structure becomes unusable and should be re-initialized if you want to use it
    private static void x_mincgreport_clear(ref x_mincgreport x)
    {
    }

    // This function initializes X-structure by appropriate C# instance
    // (previous content of X structure is ignored)
    private static void x_mincgreport_init_from(ref x_mincgreport x, mincgreport v)
    {
        x.iterationscount.longval = v.iterationscount;
        x.nfev.longval = v.nfev;
        x.terminationtype.longval = v.terminationtype;
    }

    // This function initializes C# structure by appropriate X instance
    // (previous content of C# structure is ignored).
    // This function may accept null v, in this case v is automatically allocated with new().
    private static void x_mincgreport_to_record(ref x_mincgreport x, ref mincgreport v)
    {
        if( v==null )
            v = new mincgreport();
        v.iterationscount = x.iterationscount.intval; // long is silently truncated to int
        v.nfev = x.nfev.intval; // long is silently truncated to int
        v.terminationtype = x.terminationtype.intval; // long is silently truncated to int
    }
    
    private static unsafe void _core_mincgcreate(int n, double[] x, out mincgstate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        x_vector _d_x = new x_vector();
        void *_d_state = null;
        state = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_xv2_mincgcreate(&_s_errormsg, &_d_n, &_d_x, &_d_state, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mincgcreate");
            state = new mincgstate(_d_state);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            if( _d_state!=null && state==null)
                _i_x_obj_free_mincgstate(_d_state); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void mincgcreate(int n, double[] x, out mincgstate state)
    {
        _core_mincgcreate( n,  x, out  state, 0x0);
    }
    
    public static void mincgcreate(int n, double[] x, out mincgstate state, alglib.xparams _xparams)
    {
        _core_mincgcreate( n,  x, out  state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void mincgcreate(double[] x, out mincgstate state)
    {
        int n;
    
        n = ap.len(x);
        _core_mincgcreate( n,  x, out  state, 0x0);
    
        
    }
    
    public static void mincgcreate(double[] x, out mincgstate state, alglib.xparams _xparams)
    {
        int n;
    
        n = ap.len(x);
        _core_mincgcreate( n,  x, out  state, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_mincgcreatef(int n, double[] x, double diffstep, out mincgstate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        x_vector _d_x = new x_vector();
        double _d_diffstep = diffstep;
        void *_d_state = null;
        state = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_xv2_mincgcreatef(&_s_errormsg, &_d_n, &_d_x, &_d_diffstep, &_d_state, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mincgcreatef");
            state = new mincgstate(_d_state);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            if( _d_state!=null && state==null)
                _i_x_obj_free_mincgstate(_d_state); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void mincgcreatef(int n, double[] x, double diffstep, out mincgstate state)
    {
        _core_mincgcreatef( n,  x,  diffstep, out  state, 0x0);
    }
    
    public static void mincgcreatef(int n, double[] x, double diffstep, out mincgstate state, alglib.xparams _xparams)
    {
        _core_mincgcreatef( n,  x,  diffstep, out  state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void mincgcreatef(double[] x, double diffstep, out mincgstate state)
    {
        int n;
    
        n = ap.len(x);
        _core_mincgcreatef( n,  x,  diffstep, out  state, 0x0);
    
        
    }
    
    public static void mincgcreatef(double[] x, double diffstep, out mincgstate state, alglib.xparams _xparams)
    {
        int n;
    
        n = ap.len(x);
        _core_mincgcreatef( n,  x,  diffstep, out  state, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_mincgsetcond(mincgstate state, double epsg, double epsf, double epsx, int maxits, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_epsg = epsg;
        double _d_epsf = epsf;
        double _d_epsx = epsx;
        x_int _d_maxits = new x_int(maxits);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_mincgsetcond(&_s_errormsg, &_d_state, &_d_epsg, &_d_epsf, &_d_epsx, &_d_maxits, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mincgsetcond");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void mincgsetcond(mincgstate state, double epsg, double epsf, double epsx, int maxits)
    {
        _core_mincgsetcond( state,  epsg,  epsf,  epsx,  maxits, 0x0);
    }
    
    public static void mincgsetcond(mincgstate state, double epsg, double epsf, double epsx, int maxits, alglib.xparams _xparams)
    {
        _core_mincgsetcond( state,  epsg,  epsf,  epsx,  maxits, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mincgsetscale(mincgstate state, double[] s, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_s = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_s = s){
                x_vector_attach_to_array(ref _d_s, _fp_s, ap.len(s));
                _error_code = _i_xv2_mincgsetscale(&_s_errormsg, &_d_state, &_d_s, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mincgsetscale");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_s);
        }
        // This function returns no value.
    }
    
    public static void mincgsetscale(mincgstate state, double[] s)
    {
        _core_mincgsetscale( state,  s, 0x0);
    }
    
    public static void mincgsetscale(mincgstate state, double[] s, alglib.xparams _xparams)
    {
        _core_mincgsetscale( state,  s, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mincgsetxrep(mincgstate state, bool needxrep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        byte _d_needxrep = (byte)(needxrep ? 1 : 0);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_mincgsetxrep(&_s_errormsg, &_d_state, &_d_needxrep, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mincgsetxrep");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void mincgsetxrep(mincgstate state, bool needxrep)
    {
        _core_mincgsetxrep( state,  needxrep, 0x0);
    }
    
    public static void mincgsetxrep(mincgstate state, bool needxrep, alglib.xparams _xparams)
    {
        _core_mincgsetxrep( state,  needxrep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mincgsetcgtype(mincgstate state, int cgtype, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_int _d_cgtype = new x_int(cgtype);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_mincgsetcgtype(&_s_errormsg, &_d_state, &_d_cgtype, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mincgsetcgtype");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void mincgsetcgtype(mincgstate state, int cgtype)
    {
        _core_mincgsetcgtype( state,  cgtype, 0x0);
    }
    
    public static void mincgsetcgtype(mincgstate state, int cgtype, alglib.xparams _xparams)
    {
        _core_mincgsetcgtype( state,  cgtype, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mincgsetstpmax(mincgstate state, double stpmax, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_stpmax = stpmax;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_mincgsetstpmax(&_s_errormsg, &_d_state, &_d_stpmax, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mincgsetstpmax");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void mincgsetstpmax(mincgstate state, double stpmax)
    {
        _core_mincgsetstpmax( state,  stpmax, 0x0);
    }
    
    public static void mincgsetstpmax(mincgstate state, double stpmax, alglib.xparams _xparams)
    {
        _core_mincgsetstpmax( state,  stpmax, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mincgsuggeststep(mincgstate state, double stp, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_stp = stp;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_mincgsuggeststep(&_s_errormsg, &_d_state, &_d_stp, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mincgsuggeststep");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void mincgsuggeststep(mincgstate state, double stp)
    {
        _core_mincgsuggeststep( state,  stp, 0x0);
    }
    
    public static void mincgsuggeststep(mincgstate state, double stp, alglib.xparams _xparams)
    {
        _core_mincgsuggeststep( state,  stp, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mincgsetprecdefault(mincgstate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_mincgsetprecdefault(&_s_errormsg, &_d_state, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mincgsetprecdefault");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void mincgsetprecdefault(mincgstate state)
    {
        _core_mincgsetprecdefault( state, 0x0);
    }
    
    public static void mincgsetprecdefault(mincgstate state, alglib.xparams _xparams)
    {
        _core_mincgsetprecdefault( state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mincgsetprecdiag(mincgstate state, double[] d, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_d = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_d = d){
                x_vector_attach_to_array(ref _d_d, _fp_d, ap.len(d));
                _error_code = _i_xv2_mincgsetprecdiag(&_s_errormsg, &_d_state, &_d_d, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mincgsetprecdiag");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_d);
        }
        // This function returns no value.
    }
    
    public static void mincgsetprecdiag(mincgstate state, double[] d)
    {
        _core_mincgsetprecdiag( state,  d, 0x0);
    }
    
    public static void mincgsetprecdiag(mincgstate state, double[] d, alglib.xparams _xparams)
    {
        _core_mincgsetprecdiag( state,  d, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mincgsetprecscale(mincgstate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_mincgsetprecscale(&_s_errormsg, &_d_state, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mincgsetprecscale");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void mincgsetprecscale(mincgstate state)
    {
        _core_mincgsetprecscale( state, 0x0);
    }
    
    public static void mincgsetprecscale(mincgstate state, alglib.xparams _xparams)
    {
        _core_mincgsetprecscale( state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe bool _core_mincgiteration(mincgstate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        bool result;
        byte _d_result = (byte)0;
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_mincgiteration(&_s_errormsg, &_d_result, &_d_state, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mincgiteration");
            result = _d_result!=0;
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static bool mincgiteration(mincgstate state)
    {
        return _core_mincgiteration( state, 0x0);
    }
    
    public static bool mincgiteration(mincgstate state, alglib.xparams _xparams)
    {
        return _core_mincgiteration( state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static unsafe void mincgoptimize(mincgstate state, ndimensional_func func, ndimensional_rep rep, object obj)
    {
        mincgoptimize(state, func, rep, obj, null);
    }
    
    public static unsafe void mincgoptimize(mincgstate state, ndimensional_func func, ndimensional_rep rep, object obj, alglib.xparams _xparams)
    {
        byte *_s_errormsg = null;
        int _error_code = 0;
        byte _b_result = (byte)0;
        byte _xc_xupdated = 0;
        void *_state = state.ptr;
        IntPtr _pre_ptr;
        x_vector _xc_arg = new x_vector();
        double[] _cs_arg = null;
        double _cs_f = 0;
        byte _xc_needf= 0;
    
        //
        // Check correctness of delegates
        //
        if( func==null )
            throw new alglibexception("ALGLIB: error in 'mincgoptimize()' (func is null)");
    
        //
        // Attach x-structures to internal arrays
        //
        x_vector_create_empty(ref _xc_arg, DT_REAL);
        _i_x_mincgstate_get_x(_state, &_xc_arg);
        _cs_arg = new double[_xc_arg.cnt];
    
        //
        // Main loop
        //
        for(;;)
        {
            //
            // Call iteration function.
            // Terminate iterations if it returned false.
            //
            _error_code = _i_xv2_mincgiteration(&_s_errormsg, &_b_result, &_state, _xparams==null ? 0x0 : _xparams.flags);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mincgiteration");
            ap.assert(_state==state.ptr, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _b_result==0 )
                break;
            
            //
            // Reverse communication interface:
            // * fetch flags
            // * make delegate calls
            //
            _i_x_mincgstate_get_xupdated(_state, &_xc_xupdated);
            _i_x_mincgstate_get_needf(_state, &_xc_needf);
            x_vector_to_array(ref _xc_arg, ref _cs_arg);
            if( _xc_needf!=0 )
            {
                func(_cs_arg, ref _cs_f, obj);
                _i_x_mincgstate_set_f(_state, &_cs_f);
                continue;
            }
            if( _xc_xupdated!=0 )
            {
                if( rep!=null )
                {
                    double _local_f;
                    _i_x_mincgstate_get_f(_state, &_local_f);
                    rep(_cs_arg, _local_f, obj);
                }
                continue;
            }
            throw new alglibexception("ALGLIB: error in 'mincgoptimize' (some derivatives were not provided?)");
        }
        
        //
        // Integrity post-check:
        // * make sure that no reverse communication array was reallocated during optimization
        //
        _pre_ptr = _xc_arg.xptr.ptr;
        _i_x_mincgstate_get_x(_state, &_xc_arg);
        alglib.ap.assert(_xc_arg.xptr.ptr==_pre_ptr, "ALGLIB: integrity check failed in mincgoptimize()");
    }
    
    public static unsafe void mincgoptimize(mincgstate state, ndimensional_grad grad, ndimensional_rep rep, object obj)
    {
        mincgoptimize(state, grad, rep, obj, null);
    }
    
    public static unsafe void mincgoptimize(mincgstate state, ndimensional_grad grad, ndimensional_rep rep, object obj, alglib.xparams _xparams)
    {
        byte *_s_errormsg = null;
        int _error_code = 0;
        byte _b_result = (byte)0;
        byte _xc_xupdated = 0;
        void *_state = state.ptr;
        IntPtr _pre_ptr;
        x_vector _xc_arg = new x_vector();
        double[] _cs_arg = null;
        double _cs_f = 0;
        x_vector _xc_g = new x_vector();
        double[] _cs_g = null;
        byte _xc_needfg= 0;
    
        //
        // Check correctness of delegates
        //
        if( grad==null )
            throw new alglibexception("ALGLIB: error in 'mincgoptimize()' (grad is null)");
    
        //
        // Attach x-structures to internal arrays
        //
        x_vector_create_empty(ref _xc_arg, DT_REAL);
        x_vector_create_empty(ref _xc_g, DT_REAL);
        _i_x_mincgstate_get_x(_state, &_xc_arg);
        _i_x_mincgstate_get_g(_state, &_xc_g);
        _cs_arg = new double[_xc_arg.cnt];
        _cs_g = new double[_xc_g.cnt];
    
        //
        // Main loop
        //
        for(;;)
        {
            //
            // Call iteration function.
            // Terminate iterations if it returned false.
            //
            _error_code = _i_xv2_mincgiteration(&_s_errormsg, &_b_result, &_state, _xparams==null ? 0x0 : _xparams.flags);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mincgiteration");
            ap.assert(_state==state.ptr, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _b_result==0 )
                break;
            
            //
            // Reverse communication interface:
            // * fetch flags
            // * make delegate calls
            //
            _i_x_mincgstate_get_xupdated(_state, &_xc_xupdated);
            _i_x_mincgstate_get_needfg(_state, &_xc_needfg);
            x_vector_to_array(ref _xc_arg, ref _cs_arg);
            if( _xc_needfg!=0 )
            {
                grad(_cs_arg, ref _cs_f, _cs_g, obj);
                _i_x_mincgstate_set_f(_state, &_cs_f);
                x_vector_from_array(ref _xc_g, _cs_g, X_REWRITE);
                continue;
            }
            if( _xc_xupdated!=0 )
            {
                if( rep!=null )
                {
                    double _local_f;
                    _i_x_mincgstate_get_f(_state, &_local_f);
                    rep(_cs_arg, _local_f, obj);
                }
                continue;
            }
            throw new alglibexception("ALGLIB: error in 'mincgoptimize' (some derivatives were not provided?)");
        }
        
        //
        // Integrity post-check:
        // * make sure that no reverse communication array was reallocated during optimization
        //
        _pre_ptr = _xc_arg.xptr.ptr;
        _i_x_mincgstate_get_x(_state, &_xc_arg);
        alglib.ap.assert(_xc_arg.xptr.ptr==_pre_ptr, "ALGLIB: integrity check failed in mincgoptimize()");
        _pre_ptr = _xc_g.xptr.ptr;
        _i_x_mincgstate_get_g(_state, &_xc_g);
        alglib.ap.assert(_xc_g.xptr.ptr==_pre_ptr, "ALGLIB: integrity check failed in mincgoptimize()");
    }
    
    private static unsafe void _core_mincgoptguardgradient(mincgstate state, double teststep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_teststep = teststep;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_mincgoptguardgradient(&_s_errormsg, &_d_state, &_d_teststep, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mincgoptguardgradient");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void mincgoptguardgradient(mincgstate state, double teststep)
    {
        _core_mincgoptguardgradient( state,  teststep, 0x0);
    }
    
    public static void mincgoptguardgradient(mincgstate state, double teststep, alglib.xparams _xparams)
    {
        _core_mincgoptguardgradient( state,  teststep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mincgoptguardsmoothness(mincgstate state, int level, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_int _d_level = new x_int(level);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_mincgoptguardsmoothness(&_s_errormsg, &_d_state, &_d_level, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mincgoptguardsmoothness");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void mincgoptguardsmoothness(mincgstate state, int level)
    {
        _core_mincgoptguardsmoothness( state,  level, 0x0);
    }
    
    public static void mincgoptguardsmoothness(mincgstate state, int level, alglib.xparams _xparams)
    {
        _core_mincgoptguardsmoothness( state,  level, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void mincgoptguardsmoothness(mincgstate state)
    {
        int level;
    
        level = 1;
        _core_mincgoptguardsmoothness( state,  level, 0x0);
    
        
    }
    
    public static void mincgoptguardsmoothness(mincgstate state, alglib.xparams _xparams)
    {
        int level;
    
        level = 1;
        _core_mincgoptguardsmoothness( state,  level, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_mincgoptguardresults(mincgstate state, out optguardreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_optguardreport _d_rep = new x_optguardreport();
        
        // Pack, call, unpack
        try
        {
            x_optguardreport_init(ref _d_rep);
            _error_code = _i_xv2_mincgoptguardresults(&_s_errormsg, &_d_state, &_d_rep, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mincgoptguardresults");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            rep = null;
            x_optguardreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_optguardreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void mincgoptguardresults(mincgstate state, out optguardreport rep)
    {
        _core_mincgoptguardresults( state, out  rep, 0x0);
    }
    
    public static void mincgoptguardresults(mincgstate state, out optguardreport rep, alglib.xparams _xparams)
    {
        _core_mincgoptguardresults( state, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mincgoptguardnonc1test0results(mincgstate state, out optguardnonc1test0report strrep, out optguardnonc1test0report lngrep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_optguardnonc1test0report _d_strrep = new x_optguardnonc1test0report();
        x_optguardnonc1test0report _d_lngrep = new x_optguardnonc1test0report();
        
        // Pack, call, unpack
        try
        {
            x_optguardnonc1test0report_init(ref _d_strrep);
            x_optguardnonc1test0report_init(ref _d_lngrep);
            _error_code = _i_xv2_mincgoptguardnonc1test0results(&_s_errormsg, &_d_state, &_d_strrep, &_d_lngrep, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mincgoptguardnonc1test0results");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            strrep = null;
            x_optguardnonc1test0report_to_record(ref _d_strrep, ref strrep);
            lngrep = null;
            x_optguardnonc1test0report_to_record(ref _d_lngrep, ref lngrep);
        }
        finally
        {
            x_optguardnonc1test0report_clear(ref _d_strrep);
            x_optguardnonc1test0report_clear(ref _d_lngrep);
        }
        // This function returns no value.
    }
    
    public static void mincgoptguardnonc1test0results(mincgstate state, out optguardnonc1test0report strrep, out optguardnonc1test0report lngrep)
    {
        _core_mincgoptguardnonc1test0results( state, out  strrep, out  lngrep, 0x0);
    }
    
    public static void mincgoptguardnonc1test0results(mincgstate state, out optguardnonc1test0report strrep, out optguardnonc1test0report lngrep, alglib.xparams _xparams)
    {
        _core_mincgoptguardnonc1test0results( state, out  strrep, out  lngrep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mincgoptguardnonc1test1results(mincgstate state, out optguardnonc1test1report strrep, out optguardnonc1test1report lngrep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_optguardnonc1test1report _d_strrep = new x_optguardnonc1test1report();
        x_optguardnonc1test1report _d_lngrep = new x_optguardnonc1test1report();
        
        // Pack, call, unpack
        try
        {
            x_optguardnonc1test1report_init(ref _d_strrep);
            x_optguardnonc1test1report_init(ref _d_lngrep);
            _error_code = _i_xv2_mincgoptguardnonc1test1results(&_s_errormsg, &_d_state, &_d_strrep, &_d_lngrep, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mincgoptguardnonc1test1results");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            strrep = null;
            x_optguardnonc1test1report_to_record(ref _d_strrep, ref strrep);
            lngrep = null;
            x_optguardnonc1test1report_to_record(ref _d_lngrep, ref lngrep);
        }
        finally
        {
            x_optguardnonc1test1report_clear(ref _d_strrep);
            x_optguardnonc1test1report_clear(ref _d_lngrep);
        }
        // This function returns no value.
    }
    
    public static void mincgoptguardnonc1test1results(mincgstate state, out optguardnonc1test1report strrep, out optguardnonc1test1report lngrep)
    {
        _core_mincgoptguardnonc1test1results( state, out  strrep, out  lngrep, 0x0);
    }
    
    public static void mincgoptguardnonc1test1results(mincgstate state, out optguardnonc1test1report strrep, out optguardnonc1test1report lngrep, alglib.xparams _xparams)
    {
        _core_mincgoptguardnonc1test1results( state, out  strrep, out  lngrep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mincgresults(mincgstate state, out double[] x, out mincgreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_x = new x_vector();
        x_mincgreport _d_rep = new x_mincgreport();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_x, DT_REAL);
            x = null;
            x_mincgreport_init(ref _d_rep);
            _error_code = _i_xv2_mincgresults(&_s_errormsg, &_d_state, &_d_x, &_d_rep, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mincgresults");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
            rep = null;
            x_mincgreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_mincgreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void mincgresults(mincgstate state, out double[] x, out mincgreport rep)
    {
        _core_mincgresults( state, out  x, out  rep, 0x0);
    }
    
    public static void mincgresults(mincgstate state, out double[] x, out mincgreport rep, alglib.xparams _xparams)
    {
        _core_mincgresults( state, out  x, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mincgresultsbuf(mincgstate state, ref double[] x, mincgreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_x = new x_vector();
        x_mincgreport _d_rep = new x_mincgreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_mincgreport_init_from(ref _d_rep, rep);
                _error_code = _i_xv2_mincgresultsbuf(&_s_errormsg, &_d_state, &_d_x, &_d_rep, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mincgresultsbuf");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
            x_mincgreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_mincgreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void mincgresultsbuf(mincgstate state, ref double[] x, mincgreport rep)
    {
        _core_mincgresultsbuf( state, ref  x,  rep, 0x0);
    }
    
    public static void mincgresultsbuf(mincgstate state, ref double[] x, mincgreport rep, alglib.xparams _xparams)
    {
        _core_mincgresultsbuf( state, ref  x,  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mincgrestartfrom(mincgstate state, double[] x, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_x = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_xv2_mincgrestartfrom(&_s_errormsg, &_d_state, &_d_x, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mincgrestartfrom");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_x);
        }
        // This function returns no value.
    }
    
    public static void mincgrestartfrom(mincgstate state, double[] x)
    {
        _core_mincgrestartfrom( state,  x, 0x0);
    }
    
    public static void mincgrestartfrom(mincgstate state, double[] x, alglib.xparams _xparams)
    {
        _core_mincgrestartfrom( state,  x, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mincgrequesttermination(mincgstate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_mincgrequesttermination(&_s_errormsg, &_d_state, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mincgrequesttermination");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void mincgrequesttermination(mincgstate state)
    {
        _core_mincgrequesttermination( state, 0x0);
    }
    
    public static void mincgrequesttermination(mincgstate state, alglib.xparams _xparams)
    {
        _core_mincgrequesttermination( state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage nlcsqp
    //
    
    
    
    //
    // Subpackage lpqppresolve
    //
    
    
    
    //
    // Subpackage reviseddualsimplex
    //
    
    
    
    //
    // Subpackage minlp
    //
    

    public unsafe class minlpstate : alglibobject
    {
        private void *_ptr;
        public minlpstate(void *x)
        {
            _ptr = x;
        }
        ~minlpstate()
        {
            _deallocate();
        }
        public void* ptr { get { return _ptr; } }
        public override alglib.alglibobject make_copy()
        {
            if( _ptr==null )
                return new minlpstate(null);
            return new minlpstate(_i_x_obj_copy_minlpstate(_ptr));
        }
        public override void _deallocate()
        {
            if( _ptr!=null )
                _i_x_obj_free_minlpstate(_ptr);
            _ptr = null;
            System.GC.SuppressFinalize(this);
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_minlpstate(void *x);
    private static _d_x_obj_copy_minlpstate _i_x_obj_copy_minlpstate = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_obj_free_minlpstate(void *x);
    private static _d_x_obj_free_minlpstate _i_x_obj_free_minlpstate = null;

    [StructLayout(LayoutKind.Sequential, Pack=8)]
    private struct x_minlpreport
    {
        public double f;
        public x_vector lagbc;
        public x_vector laglc;
        public x_vector y;
        public x_vector stats;
        public double primalerror;
        public double dualerror;
        public double slackerror;
        public x_int iterationscount;
        public x_int terminationtype;
    }

    public class minlpreport : alglibobject
    {
        public double f;
        public double[] lagbc;
        public double[] laglc;
        public double[] y;
        public int[] stats;
        public double primalerror;
        public double dualerror;
        public double slackerror;
        public int iterationscount;
        public int terminationtype;
        public override alglib.alglibobject make_copy()
        {
            minlpreport dst = new minlpreport();
            dst.f = f;
            dst.lagbc = (double[])lagbc.Clone();        dst.laglc = (double[])laglc.Clone();        dst.y = (double[])y.Clone();        dst.stats = (int[])stats.Clone();        dst.primalerror = primalerror;
            dst.dualerror = dualerror;
            dst.slackerror = slackerror;
            dst.iterationscount = iterationscount;
            dst.terminationtype = terminationtype;
            return dst;
        }
    }

    // This function initializes X-structure (its previous content is ignored)
    private static void x_minlpreport_init(ref x_minlpreport x)
    {
        x.f = 0;
        x_vector_create_empty(ref x.lagbc, DT_REAL);
        x_vector_create_empty(ref x.laglc, DT_REAL);
        x_vector_create_empty(ref x.y, DT_REAL);
        x_vector_create_empty(ref x.stats, DT_INT);
        x.primalerror = 0;
        x.dualerror = 0;
        x.slackerror = 0;
        x.iterationscount.longval = 0;
        x.terminationtype.longval = 0;
    }

    // This function finalizes fields of X-structure (however, memory occupied by structure itself is not freed)
    // After destruction structure becomes unusable and should be re-initialized if you want to use it
    private static void x_minlpreport_clear(ref x_minlpreport x)
    {
        x_vector_clear(ref x.lagbc);
        x_vector_clear(ref x.laglc);
        x_vector_clear(ref x.y);
        x_vector_clear(ref x.stats);
    }

    // This function initializes X-structure by appropriate C# instance
    // (previous content of X structure is ignored)
    private static void x_minlpreport_init_from(ref x_minlpreport x, minlpreport v)
    {
        x.f = v.f;
        x_vector_from_array(ref x.lagbc, v.lagbc, X_CREATE);
        x_vector_from_array(ref x.laglc, v.laglc, X_CREATE);
        x_vector_from_array(ref x.y, v.y, X_CREATE);
        x_vector_from_array(ref x.stats, v.stats, X_CREATE);
        x.primalerror = v.primalerror;
        x.dualerror = v.dualerror;
        x.slackerror = v.slackerror;
        x.iterationscount.longval = v.iterationscount;
        x.terminationtype.longval = v.terminationtype;
    }

    // This function initializes C# structure by appropriate X instance
    // (previous content of C# structure is ignored).
    // This function may accept null v, in this case v is automatically allocated with new().
    private static void x_minlpreport_to_record(ref x_minlpreport x, ref minlpreport v)
    {
        if( v==null )
            v = new minlpreport();
        v.f = x.f;
        x_vector_to_array(ref x.lagbc, ref v.lagbc);
        x_vector_to_array(ref x.laglc, ref v.laglc);
        x_vector_to_array(ref x.y, ref v.y);
        x_vector_to_array(ref x.stats, ref v.stats);
        v.primalerror = x.primalerror;
        v.dualerror = x.dualerror;
        v.slackerror = x.slackerror;
        v.iterationscount = x.iterationscount.intval; // long is silently truncated to int
        v.terminationtype = x.terminationtype.intval; // long is silently truncated to int
    }
    
    private static unsafe void _core_minlpcreate(int n, out minlpstate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        void *_d_state = null;
        state = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_minlpcreate(&_s_errormsg, &_d_n, &_d_state, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minlpcreate");
            state = new minlpstate(_d_state);
        }
        finally
        {
            if( _d_state!=null && state==null)
                _i_x_obj_free_minlpstate(_d_state); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void minlpcreate(int n, out minlpstate state)
    {
        _core_minlpcreate( n, out  state, 0x0);
    }
    
    public static void minlpcreate(int n, out minlpstate state, alglib.xparams _xparams)
    {
        _core_minlpcreate( n, out  state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minlpsetalgodss(minlpstate state, double eps, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_eps = eps;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_minlpsetalgodss(&_s_errormsg, &_d_state, &_d_eps, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minlpsetalgodss");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void minlpsetalgodss(minlpstate state, double eps)
    {
        _core_minlpsetalgodss( state,  eps, 0x0);
    }
    
    public static void minlpsetalgodss(minlpstate state, double eps, alglib.xparams _xparams)
    {
        _core_minlpsetalgodss( state,  eps, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minlpsetalgoipm(minlpstate state, double eps, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_eps = eps;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_minlpsetalgoipm(&_s_errormsg, &_d_state, &_d_eps, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minlpsetalgoipm");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void minlpsetalgoipm(minlpstate state, double eps)
    {
        _core_minlpsetalgoipm( state,  eps, 0x0);
    }
    
    public static void minlpsetalgoipm(minlpstate state, double eps, alglib.xparams _xparams)
    {
        _core_minlpsetalgoipm( state,  eps, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void minlpsetalgoipm(minlpstate state)
    {
        double eps;
    
        eps = 0.0;
        _core_minlpsetalgoipm( state,  eps, 0x0);
    
        
    }
    
    public static void minlpsetalgoipm(minlpstate state, alglib.xparams _xparams)
    {
        double eps;
    
        eps = 0.0;
        _core_minlpsetalgoipm( state,  eps, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_minlpsetcost(minlpstate state, double[] c, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_c = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_c = c){
                x_vector_attach_to_array(ref _d_c, _fp_c, ap.len(c));
                _error_code = _i_xv2_minlpsetcost(&_s_errormsg, &_d_state, &_d_c, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minlpsetcost");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_c);
        }
        // This function returns no value.
    }
    
    public static void minlpsetcost(minlpstate state, double[] c)
    {
        _core_minlpsetcost( state,  c, 0x0);
    }
    
    public static void minlpsetcost(minlpstate state, double[] c, alglib.xparams _xparams)
    {
        _core_minlpsetcost( state,  c, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minlpsetscale(minlpstate state, double[] s, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_s = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_s = s){
                x_vector_attach_to_array(ref _d_s, _fp_s, ap.len(s));
                _error_code = _i_xv2_minlpsetscale(&_s_errormsg, &_d_state, &_d_s, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minlpsetscale");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_s);
        }
        // This function returns no value.
    }
    
    public static void minlpsetscale(minlpstate state, double[] s)
    {
        _core_minlpsetscale( state,  s, 0x0);
    }
    
    public static void minlpsetscale(minlpstate state, double[] s, alglib.xparams _xparams)
    {
        _core_minlpsetscale( state,  s, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minlpsetbc(minlpstate state, double[] bndl, double[] bndu, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_bndl = new x_vector();
        x_vector _d_bndu = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_bndl = bndl, _fp_bndu = bndu){
                x_vector_attach_to_array(ref _d_bndl, _fp_bndl, ap.len(bndl));
                x_vector_attach_to_array(ref _d_bndu, _fp_bndu, ap.len(bndu));
                _error_code = _i_xv2_minlpsetbc(&_s_errormsg, &_d_state, &_d_bndl, &_d_bndu, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minlpsetbc");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_bndl);
            x_vector_clear(ref _d_bndu);
        }
        // This function returns no value.
    }
    
    public static void minlpsetbc(minlpstate state, double[] bndl, double[] bndu)
    {
        _core_minlpsetbc( state,  bndl,  bndu, 0x0);
    }
    
    public static void minlpsetbc(minlpstate state, double[] bndl, double[] bndu, alglib.xparams _xparams)
    {
        _core_minlpsetbc( state,  bndl,  bndu, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minlpsetbcall(minlpstate state, double bndl, double bndu, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_bndl = bndl;
        double _d_bndu = bndu;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_minlpsetbcall(&_s_errormsg, &_d_state, &_d_bndl, &_d_bndu, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minlpsetbcall");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void minlpsetbcall(minlpstate state, double bndl, double bndu)
    {
        _core_minlpsetbcall( state,  bndl,  bndu, 0x0);
    }
    
    public static void minlpsetbcall(minlpstate state, double bndl, double bndu, alglib.xparams _xparams)
    {
        _core_minlpsetbcall( state,  bndl,  bndu, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minlpsetbci(minlpstate state, int i, double bndl, double bndu, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_int _d_i = new x_int(i);
        double _d_bndl = bndl;
        double _d_bndu = bndu;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_minlpsetbci(&_s_errormsg, &_d_state, &_d_i, &_d_bndl, &_d_bndu, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minlpsetbci");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void minlpsetbci(minlpstate state, int i, double bndl, double bndu)
    {
        _core_minlpsetbci( state,  i,  bndl,  bndu, 0x0);
    }
    
    public static void minlpsetbci(minlpstate state, int i, double bndl, double bndu, alglib.xparams _xparams)
    {
        _core_minlpsetbci( state,  i,  bndl,  bndu, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minlpsetlc(minlpstate state, double[,] a, int[] ct, int k, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_matrix _d_a = new x_matrix();
        x_vector _d_ct = new x_vector();
        x_int _d_k = new x_int(k);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_from_array(ref _d_ct, ct, X_CREATE);
                _error_code = _i_xv2_minlpsetlc(&_s_errormsg, &_d_state, &_d_a, &_d_ct, &_d_k, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minlpsetlc");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_ct);
        }
        // This function returns no value.
    }
    
    public static void minlpsetlc(minlpstate state, double[,] a, int[] ct, int k)
    {
        _core_minlpsetlc( state,  a,  ct,  k, 0x0);
    }
    
    public static void minlpsetlc(minlpstate state, double[,] a, int[] ct, int k, alglib.xparams _xparams)
    {
        _core_minlpsetlc( state,  a,  ct,  k, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void minlpsetlc(minlpstate state, double[,] a, int[] ct)
    {
        int k;
        if( (ap.rows(a)!=ap.len(ct)))
            throw new alglibexception("Error while calling 'minlpsetlc': looks like one of arguments has wrong size");
        k = ap.rows(a);
        _core_minlpsetlc( state,  a,  ct,  k, 0x0);
    
        
    }
    
    public static void minlpsetlc(minlpstate state, double[,] a, int[] ct, alglib.xparams _xparams)
    {
        int k;
        if( (ap.rows(a)!=ap.len(ct)))
            throw new alglibexception("Error while calling 'minlpsetlc': looks like one of arguments has wrong size");
        k = ap.rows(a);
        _core_minlpsetlc( state,  a,  ct,  k, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_minlpsetlc2dense(minlpstate state, double[,] a, double[] al, double[] au, int k, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_matrix _d_a = new x_matrix();
        x_vector _d_al = new x_vector();
        x_vector _d_au = new x_vector();
        x_int _d_k = new x_int(k);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a, _fp_al = al, _fp_au = au){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_attach_to_array(ref _d_al, _fp_al, ap.len(al));
                x_vector_attach_to_array(ref _d_au, _fp_au, ap.len(au));
                _error_code = _i_xv2_minlpsetlc2dense(&_s_errormsg, &_d_state, &_d_a, &_d_al, &_d_au, &_d_k, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minlpsetlc2dense");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_al);
            x_vector_clear(ref _d_au);
        }
        // This function returns no value.
    }
    
    public static void minlpsetlc2dense(minlpstate state, double[,] a, double[] al, double[] au, int k)
    {
        _core_minlpsetlc2dense( state,  a,  al,  au,  k, 0x0);
    }
    
    public static void minlpsetlc2dense(minlpstate state, double[,] a, double[] al, double[] au, int k, alglib.xparams _xparams)
    {
        _core_minlpsetlc2dense( state,  a,  al,  au,  k, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void minlpsetlc2dense(minlpstate state, double[,] a, double[] al, double[] au)
    {
        int k;
        if( (ap.rows(a)!=ap.len(al)) || (ap.rows(a)!=ap.len(au)))
            throw new alglibexception("Error while calling 'minlpsetlc2dense': looks like one of arguments has wrong size");
        k = ap.rows(a);
        _core_minlpsetlc2dense( state,  a,  al,  au,  k, 0x0);
    
        
    }
    
    public static void minlpsetlc2dense(minlpstate state, double[,] a, double[] al, double[] au, alglib.xparams _xparams)
    {
        int k;
        if( (ap.rows(a)!=ap.len(al)) || (ap.rows(a)!=ap.len(au)))
            throw new alglibexception("Error while calling 'minlpsetlc2dense': looks like one of arguments has wrong size");
        k = ap.rows(a);
        _core_minlpsetlc2dense( state,  a,  al,  au,  k, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_minlpsetlc2(minlpstate state, sparsematrix a, double[] al, double[] au, int k, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        void *_d_a = a.ptr;
        x_vector _d_al = new x_vector();
        x_vector _d_au = new x_vector();
        x_int _d_k = new x_int(k);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_al = al, _fp_au = au){
                x_vector_attach_to_array(ref _d_al, _fp_al, ap.len(al));
                x_vector_attach_to_array(ref _d_au, _fp_au, ap.len(au));
                _error_code = _i_xv2_minlpsetlc2(&_s_errormsg, &_d_state, &_d_a, &_d_al, &_d_au, &_d_k, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minlpsetlc2");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            ap.assert(a.ptr==_d_a, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_al);
            x_vector_clear(ref _d_au);
        }
        // This function returns no value.
    }
    
    public static void minlpsetlc2(minlpstate state, sparsematrix a, double[] al, double[] au, int k)
    {
        _core_minlpsetlc2( state,  a,  al,  au,  k, 0x0);
    }
    
    public static void minlpsetlc2(minlpstate state, sparsematrix a, double[] al, double[] au, int k, alglib.xparams _xparams)
    {
        _core_minlpsetlc2( state,  a,  al,  au,  k, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minlpaddlc2dense(minlpstate state, double[] a, double al, double au, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_a = new x_vector();
        double _d_al = al;
        double _d_au = au;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_vector_attach_to_array(ref _d_a, _fp_a, ap.len(a));
                _error_code = _i_xv2_minlpaddlc2dense(&_s_errormsg, &_d_state, &_d_a, &_d_al, &_d_au, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minlpaddlc2dense");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_a);
        }
        // This function returns no value.
    }
    
    public static void minlpaddlc2dense(minlpstate state, double[] a, double al, double au)
    {
        _core_minlpaddlc2dense( state,  a,  al,  au, 0x0);
    }
    
    public static void minlpaddlc2dense(minlpstate state, double[] a, double al, double au, alglib.xparams _xparams)
    {
        _core_minlpaddlc2dense( state,  a,  al,  au, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minlpaddlc2(minlpstate state, int[] idxa, double[] vala, int nnz, double al, double au, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_idxa = new x_vector();
        x_vector _d_vala = new x_vector();
        x_int _d_nnz = new x_int(nnz);
        double _d_al = al;
        double _d_au = au;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_vala = vala){
                x_vector_from_array(ref _d_idxa, idxa, X_CREATE);
                x_vector_attach_to_array(ref _d_vala, _fp_vala, ap.len(vala));
                _error_code = _i_xv2_minlpaddlc2(&_s_errormsg, &_d_state, &_d_idxa, &_d_vala, &_d_nnz, &_d_al, &_d_au, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minlpaddlc2");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_idxa);
            x_vector_clear(ref _d_vala);
        }
        // This function returns no value.
    }
    
    public static void minlpaddlc2(minlpstate state, int[] idxa, double[] vala, int nnz, double al, double au)
    {
        _core_minlpaddlc2( state,  idxa,  vala,  nnz,  al,  au, 0x0);
    }
    
    public static void minlpaddlc2(minlpstate state, int[] idxa, double[] vala, int nnz, double al, double au, alglib.xparams _xparams)
    {
        _core_minlpaddlc2( state,  idxa,  vala,  nnz,  al,  au, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minlpoptimize(minlpstate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_minlpoptimize(&_s_errormsg, &_d_state, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minlpoptimize");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void minlpoptimize(minlpstate state)
    {
        _core_minlpoptimize( state, 0x0);
    }
    
    public static void minlpoptimize(minlpstate state, alglib.xparams _xparams)
    {
        _core_minlpoptimize( state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minlpresults(minlpstate state, out double[] x, out minlpreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_x = new x_vector();
        x_minlpreport _d_rep = new x_minlpreport();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_x, DT_REAL);
            x = null;
            x_minlpreport_init(ref _d_rep);
            _error_code = _i_xv2_minlpresults(&_s_errormsg, &_d_state, &_d_x, &_d_rep, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minlpresults");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
            rep = null;
            x_minlpreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_minlpreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void minlpresults(minlpstate state, out double[] x, out minlpreport rep)
    {
        _core_minlpresults( state, out  x, out  rep, 0x0);
    }
    
    public static void minlpresults(minlpstate state, out double[] x, out minlpreport rep, alglib.xparams _xparams)
    {
        _core_minlpresults( state, out  x, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minlpresultsbuf(minlpstate state, ref double[] x, minlpreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_x = new x_vector();
        x_minlpreport _d_rep = new x_minlpreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_minlpreport_init_from(ref _d_rep, rep);
                _error_code = _i_xv2_minlpresultsbuf(&_s_errormsg, &_d_state, &_d_x, &_d_rep, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minlpresultsbuf");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
            x_minlpreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_minlpreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void minlpresultsbuf(minlpstate state, ref double[] x, minlpreport rep)
    {
        _core_minlpresultsbuf( state, ref  x,  rep, 0x0);
    }
    
    public static void minlpresultsbuf(minlpstate state, ref double[] x, minlpreport rep, alglib.xparams _xparams)
    {
        _core_minlpresultsbuf( state, ref  x,  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage nlcslp
    //
    
    
    
    //
    // Subpackage minnlc
    //
    

    public unsafe class minnlcstate : alglibobject
    {
        private void *_ptr;
        public minnlcstate(void *x)
        {
            _ptr = x;
        }
        ~minnlcstate()
        {
            _deallocate();
        }
        public void* ptr { get { return _ptr; } }
        public override alglib.alglibobject make_copy()
        {
            if( _ptr==null )
                return new minnlcstate(null);
            return new minnlcstate(_i_x_obj_copy_minnlcstate(_ptr));
        }
        public override void _deallocate()
        {
            if( _ptr!=null )
                _i_x_obj_free_minnlcstate(_ptr);
            _ptr = null;
            System.GC.SuppressFinalize(this);
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_minnlcstate(void *x);
    private static _d_x_obj_copy_minnlcstate _i_x_obj_copy_minnlcstate = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_obj_free_minnlcstate(void *x);
    private static _d_x_obj_free_minnlcstate _i_x_obj_free_minnlcstate = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_minnlcstate_get_needfi(void *x, byte *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_minnlcstate_set_needfi(void *x, byte *dst);
    private static _d_x_minnlcstate_get_needfi _i_x_minnlcstate_get_needfi = null;
    private static _d_x_minnlcstate_set_needfi _i_x_minnlcstate_set_needfi = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_minnlcstate_get_needfij(void *x, byte *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_minnlcstate_set_needfij(void *x, byte *dst);
    private static _d_x_minnlcstate_get_needfij _i_x_minnlcstate_get_needfij = null;
    private static _d_x_minnlcstate_set_needfij _i_x_minnlcstate_set_needfij = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_minnlcstate_get_xupdated(void *x, byte *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_minnlcstate_set_xupdated(void *x, byte *dst);
    private static _d_x_minnlcstate_get_xupdated _i_x_minnlcstate_get_xupdated = null;
    private static _d_x_minnlcstate_set_xupdated _i_x_minnlcstate_set_xupdated = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_minnlcstate_get_f(void *x, double *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_minnlcstate_set_f(void *x, double *dst);
    private static _d_x_minnlcstate_get_f _i_x_minnlcstate_get_f = null;
    private static _d_x_minnlcstate_set_f _i_x_minnlcstate_set_f = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_minnlcstate_get_fi(void *x, x_vector *dst);
    private static _d_x_minnlcstate_get_fi _i_x_minnlcstate_get_fi = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_minnlcstate_get_j(void *x, x_matrix *dst);
    private static _d_x_minnlcstate_get_j _i_x_minnlcstate_get_j = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_minnlcstate_get_x(void *x, x_vector *dst);
    private static _d_x_minnlcstate_get_x _i_x_minnlcstate_get_x = null;

    [StructLayout(LayoutKind.Sequential, Pack=8)]
    private struct x_minnlcreport
    {
        public x_int iterationscount;
        public x_int nfev;
        public x_int terminationtype;
        public double bcerr;
        public x_int bcidx;
        public double lcerr;
        public x_int lcidx;
        public double nlcerr;
        public x_int nlcidx;
        public x_int dbgphase0its;
    }

    public class minnlcreport : alglibobject
    {
        public int iterationscount;
        public int nfev;
        public int terminationtype;
        public double bcerr;
        public int bcidx;
        public double lcerr;
        public int lcidx;
        public double nlcerr;
        public int nlcidx;
        public int dbgphase0its;
        public override alglib.alglibobject make_copy()
        {
            minnlcreport dst = new minnlcreport();
            dst.iterationscount = iterationscount;
            dst.nfev = nfev;
            dst.terminationtype = terminationtype;
            dst.bcerr = bcerr;
            dst.bcidx = bcidx;
            dst.lcerr = lcerr;
            dst.lcidx = lcidx;
            dst.nlcerr = nlcerr;
            dst.nlcidx = nlcidx;
            dst.dbgphase0its = dbgphase0its;
            return dst;
        }
    }

    // This function initializes X-structure (its previous content is ignored)
    private static void x_minnlcreport_init(ref x_minnlcreport x)
    {
        x.iterationscount.longval = 0;
        x.nfev.longval = 0;
        x.terminationtype.longval = 0;
        x.bcerr = 0;
        x.bcidx.longval = 0;
        x.lcerr = 0;
        x.lcidx.longval = 0;
        x.nlcerr = 0;
        x.nlcidx.longval = 0;
        x.dbgphase0its.longval = 0;
    }

    // This function finalizes fields of X-structure (however, memory occupied by structure itself is not freed)
    // After destruction structure becomes unusable and should be re-initialized if you want to use it
    private static void x_minnlcreport_clear(ref x_minnlcreport x)
    {
    }

    // This function initializes X-structure by appropriate C# instance
    // (previous content of X structure is ignored)
    private static void x_minnlcreport_init_from(ref x_minnlcreport x, minnlcreport v)
    {
        x.iterationscount.longval = v.iterationscount;
        x.nfev.longval = v.nfev;
        x.terminationtype.longval = v.terminationtype;
        x.bcerr = v.bcerr;
        x.bcidx.longval = v.bcidx;
        x.lcerr = v.lcerr;
        x.lcidx.longval = v.lcidx;
        x.nlcerr = v.nlcerr;
        x.nlcidx.longval = v.nlcidx;
        x.dbgphase0its.longval = v.dbgphase0its;
    }

    // This function initializes C# structure by appropriate X instance
    // (previous content of C# structure is ignored).
    // This function may accept null v, in this case v is automatically allocated with new().
    private static void x_minnlcreport_to_record(ref x_minnlcreport x, ref minnlcreport v)
    {
        if( v==null )
            v = new minnlcreport();
        v.iterationscount = x.iterationscount.intval; // long is silently truncated to int
        v.nfev = x.nfev.intval; // long is silently truncated to int
        v.terminationtype = x.terminationtype.intval; // long is silently truncated to int
        v.bcerr = x.bcerr;
        v.bcidx = x.bcidx.intval; // long is silently truncated to int
        v.lcerr = x.lcerr;
        v.lcidx = x.lcidx.intval; // long is silently truncated to int
        v.nlcerr = x.nlcerr;
        v.nlcidx = x.nlcidx.intval; // long is silently truncated to int
        v.dbgphase0its = x.dbgphase0its.intval; // long is silently truncated to int
    }
    
    private static unsafe void _core_minnlccreate(int n, double[] x, out minnlcstate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        x_vector _d_x = new x_vector();
        void *_d_state = null;
        state = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_xv2_minnlccreate(&_s_errormsg, &_d_n, &_d_x, &_d_state, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minnlccreate");
            state = new minnlcstate(_d_state);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            if( _d_state!=null && state==null)
                _i_x_obj_free_minnlcstate(_d_state); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void minnlccreate(int n, double[] x, out minnlcstate state)
    {
        _core_minnlccreate( n,  x, out  state, 0x0);
    }
    
    public static void minnlccreate(int n, double[] x, out minnlcstate state, alglib.xparams _xparams)
    {
        _core_minnlccreate( n,  x, out  state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void minnlccreate(double[] x, out minnlcstate state)
    {
        int n;
    
        n = ap.len(x);
        _core_minnlccreate( n,  x, out  state, 0x0);
    
        
    }
    
    public static void minnlccreate(double[] x, out minnlcstate state, alglib.xparams _xparams)
    {
        int n;
    
        n = ap.len(x);
        _core_minnlccreate( n,  x, out  state, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_minnlccreatef(int n, double[] x, double diffstep, out minnlcstate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        x_vector _d_x = new x_vector();
        double _d_diffstep = diffstep;
        void *_d_state = null;
        state = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_xv2_minnlccreatef(&_s_errormsg, &_d_n, &_d_x, &_d_diffstep, &_d_state, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minnlccreatef");
            state = new minnlcstate(_d_state);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            if( _d_state!=null && state==null)
                _i_x_obj_free_minnlcstate(_d_state); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void minnlccreatef(int n, double[] x, double diffstep, out minnlcstate state)
    {
        _core_minnlccreatef( n,  x,  diffstep, out  state, 0x0);
    }
    
    public static void minnlccreatef(int n, double[] x, double diffstep, out minnlcstate state, alglib.xparams _xparams)
    {
        _core_minnlccreatef( n,  x,  diffstep, out  state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void minnlccreatef(double[] x, double diffstep, out minnlcstate state)
    {
        int n;
    
        n = ap.len(x);
        _core_minnlccreatef( n,  x,  diffstep, out  state, 0x0);
    
        
    }
    
    public static void minnlccreatef(double[] x, double diffstep, out minnlcstate state, alglib.xparams _xparams)
    {
        int n;
    
        n = ap.len(x);
        _core_minnlccreatef( n,  x,  diffstep, out  state, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_minnlcsetbc(minnlcstate state, double[] bndl, double[] bndu, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_bndl = new x_vector();
        x_vector _d_bndu = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_bndl = bndl, _fp_bndu = bndu){
                x_vector_attach_to_array(ref _d_bndl, _fp_bndl, ap.len(bndl));
                x_vector_attach_to_array(ref _d_bndu, _fp_bndu, ap.len(bndu));
                _error_code = _i_xv2_minnlcsetbc(&_s_errormsg, &_d_state, &_d_bndl, &_d_bndu, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minnlcsetbc");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_bndl);
            x_vector_clear(ref _d_bndu);
        }
        // This function returns no value.
    }
    
    public static void minnlcsetbc(minnlcstate state, double[] bndl, double[] bndu)
    {
        _core_minnlcsetbc( state,  bndl,  bndu, 0x0);
    }
    
    public static void minnlcsetbc(minnlcstate state, double[] bndl, double[] bndu, alglib.xparams _xparams)
    {
        _core_minnlcsetbc( state,  bndl,  bndu, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minnlcsetlc(minnlcstate state, double[,] c, int[] ct, int k, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_matrix _d_c = new x_matrix();
        x_vector _d_ct = new x_vector();
        x_int _d_k = new x_int(k);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_c = c){
                x_matrix_attach_to_array(ref _d_c, _fp_c, ap.rows(c), ap.cols(c));
                x_vector_from_array(ref _d_ct, ct, X_CREATE);
                _error_code = _i_xv2_minnlcsetlc(&_s_errormsg, &_d_state, &_d_c, &_d_ct, &_d_k, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minnlcsetlc");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_c);
            x_vector_clear(ref _d_ct);
        }
        // This function returns no value.
    }
    
    public static void minnlcsetlc(minnlcstate state, double[,] c, int[] ct, int k)
    {
        _core_minnlcsetlc( state,  c,  ct,  k, 0x0);
    }
    
    public static void minnlcsetlc(minnlcstate state, double[,] c, int[] ct, int k, alglib.xparams _xparams)
    {
        _core_minnlcsetlc( state,  c,  ct,  k, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void minnlcsetlc(minnlcstate state, double[,] c, int[] ct)
    {
        int k;
        if( (ap.rows(c)!=ap.len(ct)))
            throw new alglibexception("Error while calling 'minnlcsetlc': looks like one of arguments has wrong size");
        k = ap.rows(c);
        _core_minnlcsetlc( state,  c,  ct,  k, 0x0);
    
        
    }
    
    public static void minnlcsetlc(minnlcstate state, double[,] c, int[] ct, alglib.xparams _xparams)
    {
        int k;
        if( (ap.rows(c)!=ap.len(ct)))
            throw new alglibexception("Error while calling 'minnlcsetlc': looks like one of arguments has wrong size");
        k = ap.rows(c);
        _core_minnlcsetlc( state,  c,  ct,  k, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_minnlcsetnlc(minnlcstate state, int nlec, int nlic, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_int _d_nlec = new x_int(nlec);
        x_int _d_nlic = new x_int(nlic);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_minnlcsetnlc(&_s_errormsg, &_d_state, &_d_nlec, &_d_nlic, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minnlcsetnlc");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void minnlcsetnlc(minnlcstate state, int nlec, int nlic)
    {
        _core_minnlcsetnlc( state,  nlec,  nlic, 0x0);
    }
    
    public static void minnlcsetnlc(minnlcstate state, int nlec, int nlic, alglib.xparams _xparams)
    {
        _core_minnlcsetnlc( state,  nlec,  nlic, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minnlcsetcond(minnlcstate state, double epsx, int maxits, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_epsx = epsx;
        x_int _d_maxits = new x_int(maxits);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_minnlcsetcond(&_s_errormsg, &_d_state, &_d_epsx, &_d_maxits, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minnlcsetcond");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void minnlcsetcond(minnlcstate state, double epsx, int maxits)
    {
        _core_minnlcsetcond( state,  epsx,  maxits, 0x0);
    }
    
    public static void minnlcsetcond(minnlcstate state, double epsx, int maxits, alglib.xparams _xparams)
    {
        _core_minnlcsetcond( state,  epsx,  maxits, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minnlcsetscale(minnlcstate state, double[] s, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_s = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_s = s){
                x_vector_attach_to_array(ref _d_s, _fp_s, ap.len(s));
                _error_code = _i_xv2_minnlcsetscale(&_s_errormsg, &_d_state, &_d_s, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minnlcsetscale");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_s);
        }
        // This function returns no value.
    }
    
    public static void minnlcsetscale(minnlcstate state, double[] s)
    {
        _core_minnlcsetscale( state,  s, 0x0);
    }
    
    public static void minnlcsetscale(minnlcstate state, double[] s, alglib.xparams _xparams)
    {
        _core_minnlcsetscale( state,  s, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minnlcsetprecinexact(minnlcstate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_minnlcsetprecinexact(&_s_errormsg, &_d_state, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minnlcsetprecinexact");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void minnlcsetprecinexact(minnlcstate state)
    {
        _core_minnlcsetprecinexact( state, 0x0);
    }
    
    public static void minnlcsetprecinexact(minnlcstate state, alglib.xparams _xparams)
    {
        _core_minnlcsetprecinexact( state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minnlcsetprecexactlowrank(minnlcstate state, int updatefreq, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_int _d_updatefreq = new x_int(updatefreq);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_minnlcsetprecexactlowrank(&_s_errormsg, &_d_state, &_d_updatefreq, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minnlcsetprecexactlowrank");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void minnlcsetprecexactlowrank(minnlcstate state, int updatefreq)
    {
        _core_minnlcsetprecexactlowrank( state,  updatefreq, 0x0);
    }
    
    public static void minnlcsetprecexactlowrank(minnlcstate state, int updatefreq, alglib.xparams _xparams)
    {
        _core_minnlcsetprecexactlowrank( state,  updatefreq, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minnlcsetprecexactrobust(minnlcstate state, int updatefreq, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_int _d_updatefreq = new x_int(updatefreq);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_minnlcsetprecexactrobust(&_s_errormsg, &_d_state, &_d_updatefreq, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minnlcsetprecexactrobust");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void minnlcsetprecexactrobust(minnlcstate state, int updatefreq)
    {
        _core_minnlcsetprecexactrobust( state,  updatefreq, 0x0);
    }
    
    public static void minnlcsetprecexactrobust(minnlcstate state, int updatefreq, alglib.xparams _xparams)
    {
        _core_minnlcsetprecexactrobust( state,  updatefreq, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minnlcsetprecnone(minnlcstate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_minnlcsetprecnone(&_s_errormsg, &_d_state, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minnlcsetprecnone");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void minnlcsetprecnone(minnlcstate state)
    {
        _core_minnlcsetprecnone( state, 0x0);
    }
    
    public static void minnlcsetprecnone(minnlcstate state, alglib.xparams _xparams)
    {
        _core_minnlcsetprecnone( state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minnlcsetstpmax(minnlcstate state, double stpmax, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_stpmax = stpmax;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_minnlcsetstpmax(&_s_errormsg, &_d_state, &_d_stpmax, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minnlcsetstpmax");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void minnlcsetstpmax(minnlcstate state, double stpmax)
    {
        _core_minnlcsetstpmax( state,  stpmax, 0x0);
    }
    
    public static void minnlcsetstpmax(minnlcstate state, double stpmax, alglib.xparams _xparams)
    {
        _core_minnlcsetstpmax( state,  stpmax, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minnlcsetalgoaul(minnlcstate state, double rho, int itscnt, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_rho = rho;
        x_int _d_itscnt = new x_int(itscnt);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_minnlcsetalgoaul(&_s_errormsg, &_d_state, &_d_rho, &_d_itscnt, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minnlcsetalgoaul");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void minnlcsetalgoaul(minnlcstate state, double rho, int itscnt)
    {
        _core_minnlcsetalgoaul( state,  rho,  itscnt, 0x0);
    }
    
    public static void minnlcsetalgoaul(minnlcstate state, double rho, int itscnt, alglib.xparams _xparams)
    {
        _core_minnlcsetalgoaul( state,  rho,  itscnt, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minnlcsetalgoslp(minnlcstate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_minnlcsetalgoslp(&_s_errormsg, &_d_state, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minnlcsetalgoslp");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void minnlcsetalgoslp(minnlcstate state)
    {
        _core_minnlcsetalgoslp( state, 0x0);
    }
    
    public static void minnlcsetalgoslp(minnlcstate state, alglib.xparams _xparams)
    {
        _core_minnlcsetalgoslp( state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minnlcsetalgosqp(minnlcstate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_minnlcsetalgosqp(&_s_errormsg, &_d_state, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minnlcsetalgosqp");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void minnlcsetalgosqp(minnlcstate state)
    {
        _core_minnlcsetalgosqp( state, 0x0);
    }
    
    public static void minnlcsetalgosqp(minnlcstate state, alglib.xparams _xparams)
    {
        _core_minnlcsetalgosqp( state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minnlcsetxrep(minnlcstate state, bool needxrep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        byte _d_needxrep = (byte)(needxrep ? 1 : 0);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_minnlcsetxrep(&_s_errormsg, &_d_state, &_d_needxrep, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minnlcsetxrep");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void minnlcsetxrep(minnlcstate state, bool needxrep)
    {
        _core_minnlcsetxrep( state,  needxrep, 0x0);
    }
    
    public static void minnlcsetxrep(minnlcstate state, bool needxrep, alglib.xparams _xparams)
    {
        _core_minnlcsetxrep( state,  needxrep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe bool _core_minnlciteration(minnlcstate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        bool result;
        byte _d_result = (byte)0;
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_minnlciteration(&_s_errormsg, &_d_result, &_d_state, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minnlciteration");
            result = _d_result!=0;
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static bool minnlciteration(minnlcstate state)
    {
        return _core_minnlciteration( state, 0x0);
    }
    
    public static bool minnlciteration(minnlcstate state, alglib.xparams _xparams)
    {
        return _core_minnlciteration( state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static unsafe void minnlcoptimize(minnlcstate state, ndimensional_fvec  fvec, ndimensional_rep rep, object obj)
    {
        minnlcoptimize(state, fvec, rep, obj, null);
    }
    
    public static unsafe void minnlcoptimize(minnlcstate state, ndimensional_fvec  fvec, ndimensional_rep rep, object obj, alglib.xparams _xparams)
    {
        byte *_s_errormsg = null;
        int _error_code = 0;
        byte _b_result = (byte)0;
        byte _xc_xupdated = 0;
        void *_state = state.ptr;
        IntPtr _pre_ptr;
        x_vector _xc_arg = new x_vector();
        double[] _cs_arg = null;
        x_vector _xc_fi = new x_vector();
        double[] _cs_fi = null;
        byte _xc_needfi= 0;
    
        //
        // Check correctness of delegates
        //
        if( fvec==null )
            throw new alglibexception("ALGLIB: error in 'minnlcoptimize()' (fvec is null)");
    
        //
        // Attach x-structures to internal arrays
        //
        x_vector_create_empty(ref _xc_arg, DT_REAL);
        x_vector_create_empty(ref _xc_fi, DT_REAL);
        _i_x_minnlcstate_get_x(_state, &_xc_arg);
        _i_x_minnlcstate_get_fi(_state, &_xc_fi);
        _cs_arg = new double[_xc_arg.cnt];
        _cs_fi = new double[_xc_fi.cnt];
    
        //
        // Main loop
        //
        for(;;)
        {
            //
            // Call iteration function.
            // Terminate iterations if it returned false.
            //
            _error_code = _i_xv2_minnlciteration(&_s_errormsg, &_b_result, &_state, _xparams==null ? 0x0 : _xparams.flags);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minnlciteration");
            ap.assert(_state==state.ptr, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _b_result==0 )
                break;
            
            //
            // Reverse communication interface:
            // * fetch flags
            // * make delegate calls
            //
            _i_x_minnlcstate_get_xupdated(_state, &_xc_xupdated);
            _i_x_minnlcstate_get_needfi(_state, &_xc_needfi);
            x_vector_to_array(ref _xc_arg, ref _cs_arg);
            if( _xc_needfi!=0 )
            {
                fvec(_cs_arg, _cs_fi, obj);
                x_vector_from_array(ref _xc_fi, _cs_fi, X_REWRITE);
                continue;
            }
            if( _xc_xupdated!=0 )
            {
                if( rep!=null )
                {
                    double _local_f;
                    _i_x_minnlcstate_get_f(_state, &_local_f);
                    rep(_cs_arg, _local_f, obj);
                }
                continue;
            }
            throw new alglibexception("ALGLIB: error in 'minnlcoptimize' (some derivatives were not provided?)");
        }
        
        //
        // Integrity post-check:
        // * make sure that no reverse communication array was reallocated during optimization
        //
        _pre_ptr = _xc_arg.xptr.ptr;
        _i_x_minnlcstate_get_x(_state, &_xc_arg);
        alglib.ap.assert(_xc_arg.xptr.ptr==_pre_ptr, "ALGLIB: integrity check failed in minnlcoptimize()");
        _pre_ptr = _xc_fi.xptr.ptr;
        _i_x_minnlcstate_get_fi(_state, &_xc_fi);
        alglib.ap.assert(_xc_fi.xptr.ptr==_pre_ptr, "ALGLIB: integrity check failed in minnlcoptimize()");
    }
    
    public static unsafe void minnlcoptimize(minnlcstate state, ndimensional_jac  jac, ndimensional_rep rep, object obj)
    {
        minnlcoptimize(state, jac, rep, obj, null);
    }
    
    public static unsafe void minnlcoptimize(minnlcstate state, ndimensional_jac  jac, ndimensional_rep rep, object obj, alglib.xparams _xparams)
    {
        byte *_s_errormsg = null;
        int _error_code = 0;
        byte _b_result = (byte)0;
        byte _xc_xupdated = 0;
        void *_state = state.ptr;
        IntPtr _pre_ptr;
        x_vector _xc_arg = new x_vector();
        double[] _cs_arg = null;
        x_vector _xc_fi = new x_vector();
        double[] _cs_fi = null;
        x_matrix _xc_j = new x_matrix();
        double[,] _cs_j = null;
        byte _xc_needfij= 0;
    
        //
        // Check correctness of delegates
        //
        if( jac==null )
            throw new alglibexception("ALGLIB: error in 'minnlcoptimize()' (jac is null)");
    
        //
        // Attach x-structures to internal arrays
        //
        x_vector_create_empty(ref _xc_arg, DT_REAL);
        x_vector_create_empty(ref _xc_fi, DT_REAL);
        x_matrix_create_empty(ref _xc_j, DT_REAL);
        _i_x_minnlcstate_get_x(_state, &_xc_arg);
        _i_x_minnlcstate_get_fi(_state, &_xc_fi);
        _i_x_minnlcstate_get_j(_state, &_xc_j);
        _cs_arg = new double[_xc_arg.cnt];
        _cs_fi = new double[_xc_fi.cnt];
        _cs_j = new double[_xc_j.rows,_xc_j.cols];
    
        //
        // Main loop
        //
        for(;;)
        {
            //
            // Call iteration function.
            // Terminate iterations if it returned false.
            //
            _error_code = _i_xv2_minnlciteration(&_s_errormsg, &_b_result, &_state, _xparams==null ? 0x0 : _xparams.flags);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minnlciteration");
            ap.assert(_state==state.ptr, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _b_result==0 )
                break;
            
            //
            // Reverse communication interface:
            // * fetch flags
            // * make delegate calls
            //
            _i_x_minnlcstate_get_xupdated(_state, &_xc_xupdated);
            _i_x_minnlcstate_get_needfij(_state, &_xc_needfij);
            x_vector_to_array(ref _xc_arg, ref _cs_arg);
            if( _xc_needfij!=0 )
            {
                jac(_cs_arg, _cs_fi, _cs_j, obj);
                x_vector_from_array(ref _xc_fi, _cs_fi, X_REWRITE);
                x_matrix_from_array(ref _xc_j,  _cs_j,  X_REWRITE);
                continue;
            }
            if( _xc_xupdated!=0 )
            {
                if( rep!=null )
                {
                    double _local_f;
                    _i_x_minnlcstate_get_f(_state, &_local_f);
                    rep(_cs_arg, _local_f, obj);
                }
                continue;
            }
            throw new alglibexception("ALGLIB: error in 'minnlcoptimize' (some derivatives were not provided?)");
        }
        
        //
        // Integrity post-check:
        // * make sure that no reverse communication array was reallocated during optimization
        //
        _pre_ptr = _xc_arg.xptr.ptr;
        _i_x_minnlcstate_get_x(_state, &_xc_arg);
        alglib.ap.assert(_xc_arg.xptr.ptr==_pre_ptr, "ALGLIB: integrity check failed in minnlcoptimize()");
        _pre_ptr = _xc_fi.xptr.ptr;
        _i_x_minnlcstate_get_fi(_state, &_xc_fi);
        alglib.ap.assert(_xc_fi.xptr.ptr==_pre_ptr, "ALGLIB: integrity check failed in minnlcoptimize()");
        _pre_ptr = _xc_j.xptr.ptr;
        _i_x_minnlcstate_get_j(_state, &_xc_j);
        alglib.ap.assert(_xc_j.xptr.ptr==_pre_ptr, "ALGLIB: integrity check failed in minnlcoptimize()");
    }
    
    private static unsafe void _core_minnlcoptguardgradient(minnlcstate state, double teststep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_teststep = teststep;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_minnlcoptguardgradient(&_s_errormsg, &_d_state, &_d_teststep, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minnlcoptguardgradient");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void minnlcoptguardgradient(minnlcstate state, double teststep)
    {
        _core_minnlcoptguardgradient( state,  teststep, 0x0);
    }
    
    public static void minnlcoptguardgradient(minnlcstate state, double teststep, alglib.xparams _xparams)
    {
        _core_minnlcoptguardgradient( state,  teststep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minnlcoptguardsmoothness(minnlcstate state, int level, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_int _d_level = new x_int(level);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_minnlcoptguardsmoothness(&_s_errormsg, &_d_state, &_d_level, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minnlcoptguardsmoothness");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void minnlcoptguardsmoothness(minnlcstate state, int level)
    {
        _core_minnlcoptguardsmoothness( state,  level, 0x0);
    }
    
    public static void minnlcoptguardsmoothness(minnlcstate state, int level, alglib.xparams _xparams)
    {
        _core_minnlcoptguardsmoothness( state,  level, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void minnlcoptguardsmoothness(minnlcstate state)
    {
        int level;
    
        level = 1;
        _core_minnlcoptguardsmoothness( state,  level, 0x0);
    
        
    }
    
    public static void minnlcoptguardsmoothness(minnlcstate state, alglib.xparams _xparams)
    {
        int level;
    
        level = 1;
        _core_minnlcoptguardsmoothness( state,  level, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_minnlcoptguardresults(minnlcstate state, out optguardreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_optguardreport _d_rep = new x_optguardreport();
        
        // Pack, call, unpack
        try
        {
            x_optguardreport_init(ref _d_rep);
            _error_code = _i_xv2_minnlcoptguardresults(&_s_errormsg, &_d_state, &_d_rep, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minnlcoptguardresults");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            rep = null;
            x_optguardreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_optguardreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void minnlcoptguardresults(minnlcstate state, out optguardreport rep)
    {
        _core_minnlcoptguardresults( state, out  rep, 0x0);
    }
    
    public static void minnlcoptguardresults(minnlcstate state, out optguardreport rep, alglib.xparams _xparams)
    {
        _core_minnlcoptguardresults( state, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minnlcoptguardnonc1test0results(minnlcstate state, out optguardnonc1test0report strrep, out optguardnonc1test0report lngrep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_optguardnonc1test0report _d_strrep = new x_optguardnonc1test0report();
        x_optguardnonc1test0report _d_lngrep = new x_optguardnonc1test0report();
        
        // Pack, call, unpack
        try
        {
            x_optguardnonc1test0report_init(ref _d_strrep);
            x_optguardnonc1test0report_init(ref _d_lngrep);
            _error_code = _i_xv2_minnlcoptguardnonc1test0results(&_s_errormsg, &_d_state, &_d_strrep, &_d_lngrep, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minnlcoptguardnonc1test0results");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            strrep = null;
            x_optguardnonc1test0report_to_record(ref _d_strrep, ref strrep);
            lngrep = null;
            x_optguardnonc1test0report_to_record(ref _d_lngrep, ref lngrep);
        }
        finally
        {
            x_optguardnonc1test0report_clear(ref _d_strrep);
            x_optguardnonc1test0report_clear(ref _d_lngrep);
        }
        // This function returns no value.
    }
    
    public static void minnlcoptguardnonc1test0results(minnlcstate state, out optguardnonc1test0report strrep, out optguardnonc1test0report lngrep)
    {
        _core_minnlcoptguardnonc1test0results( state, out  strrep, out  lngrep, 0x0);
    }
    
    public static void minnlcoptguardnonc1test0results(minnlcstate state, out optguardnonc1test0report strrep, out optguardnonc1test0report lngrep, alglib.xparams _xparams)
    {
        _core_minnlcoptguardnonc1test0results( state, out  strrep, out  lngrep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minnlcoptguardnonc1test1results(minnlcstate state, out optguardnonc1test1report strrep, out optguardnonc1test1report lngrep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_optguardnonc1test1report _d_strrep = new x_optguardnonc1test1report();
        x_optguardnonc1test1report _d_lngrep = new x_optguardnonc1test1report();
        
        // Pack, call, unpack
        try
        {
            x_optguardnonc1test1report_init(ref _d_strrep);
            x_optguardnonc1test1report_init(ref _d_lngrep);
            _error_code = _i_xv2_minnlcoptguardnonc1test1results(&_s_errormsg, &_d_state, &_d_strrep, &_d_lngrep, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minnlcoptguardnonc1test1results");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            strrep = null;
            x_optguardnonc1test1report_to_record(ref _d_strrep, ref strrep);
            lngrep = null;
            x_optguardnonc1test1report_to_record(ref _d_lngrep, ref lngrep);
        }
        finally
        {
            x_optguardnonc1test1report_clear(ref _d_strrep);
            x_optguardnonc1test1report_clear(ref _d_lngrep);
        }
        // This function returns no value.
    }
    
    public static void minnlcoptguardnonc1test1results(minnlcstate state, out optguardnonc1test1report strrep, out optguardnonc1test1report lngrep)
    {
        _core_minnlcoptguardnonc1test1results( state, out  strrep, out  lngrep, 0x0);
    }
    
    public static void minnlcoptguardnonc1test1results(minnlcstate state, out optguardnonc1test1report strrep, out optguardnonc1test1report lngrep, alglib.xparams _xparams)
    {
        _core_minnlcoptguardnonc1test1results( state, out  strrep, out  lngrep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minnlcresults(minnlcstate state, out double[] x, out minnlcreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_x = new x_vector();
        x_minnlcreport _d_rep = new x_minnlcreport();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_x, DT_REAL);
            x = null;
            x_minnlcreport_init(ref _d_rep);
            _error_code = _i_xv2_minnlcresults(&_s_errormsg, &_d_state, &_d_x, &_d_rep, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minnlcresults");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
            rep = null;
            x_minnlcreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_minnlcreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void minnlcresults(minnlcstate state, out double[] x, out minnlcreport rep)
    {
        _core_minnlcresults( state, out  x, out  rep, 0x0);
    }
    
    public static void minnlcresults(minnlcstate state, out double[] x, out minnlcreport rep, alglib.xparams _xparams)
    {
        _core_minnlcresults( state, out  x, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minnlcresultsbuf(minnlcstate state, ref double[] x, minnlcreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_x = new x_vector();
        x_minnlcreport _d_rep = new x_minnlcreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_minnlcreport_init_from(ref _d_rep, rep);
                _error_code = _i_xv2_minnlcresultsbuf(&_s_errormsg, &_d_state, &_d_x, &_d_rep, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minnlcresultsbuf");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
            x_minnlcreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_minnlcreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void minnlcresultsbuf(minnlcstate state, ref double[] x, minnlcreport rep)
    {
        _core_minnlcresultsbuf( state, ref  x,  rep, 0x0);
    }
    
    public static void minnlcresultsbuf(minnlcstate state, ref double[] x, minnlcreport rep, alglib.xparams _xparams)
    {
        _core_minnlcresultsbuf( state, ref  x,  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minnlcrequesttermination(minnlcstate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_minnlcrequesttermination(&_s_errormsg, &_d_state, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minnlcrequesttermination");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void minnlcrequesttermination(minnlcstate state)
    {
        _core_minnlcrequesttermination( state, 0x0);
    }
    
    public static void minnlcrequesttermination(minnlcstate state, alglib.xparams _xparams)
    {
        _core_minnlcrequesttermination( state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minnlcrestartfrom(minnlcstate state, double[] x, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_x = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_xv2_minnlcrestartfrom(&_s_errormsg, &_d_state, &_d_x, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minnlcrestartfrom");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_x);
        }
        // This function returns no value.
    }
    
    public static void minnlcrestartfrom(minnlcstate state, double[] x)
    {
        _core_minnlcrestartfrom( state,  x, 0x0);
    }
    
    public static void minnlcrestartfrom(minnlcstate state, double[] x, alglib.xparams _xparams)
    {
        _core_minnlcrestartfrom( state,  x, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage minns
    //
    

    public unsafe class minnsstate : alglibobject
    {
        private void *_ptr;
        public minnsstate(void *x)
        {
            _ptr = x;
        }
        ~minnsstate()
        {
            _deallocate();
        }
        public void* ptr { get { return _ptr; } }
        public override alglib.alglibobject make_copy()
        {
            if( _ptr==null )
                return new minnsstate(null);
            return new minnsstate(_i_x_obj_copy_minnsstate(_ptr));
        }
        public override void _deallocate()
        {
            if( _ptr!=null )
                _i_x_obj_free_minnsstate(_ptr);
            _ptr = null;
            System.GC.SuppressFinalize(this);
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_minnsstate(void *x);
    private static _d_x_obj_copy_minnsstate _i_x_obj_copy_minnsstate = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_obj_free_minnsstate(void *x);
    private static _d_x_obj_free_minnsstate _i_x_obj_free_minnsstate = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_minnsstate_get_needfi(void *x, byte *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_minnsstate_set_needfi(void *x, byte *dst);
    private static _d_x_minnsstate_get_needfi _i_x_minnsstate_get_needfi = null;
    private static _d_x_minnsstate_set_needfi _i_x_minnsstate_set_needfi = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_minnsstate_get_needfij(void *x, byte *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_minnsstate_set_needfij(void *x, byte *dst);
    private static _d_x_minnsstate_get_needfij _i_x_minnsstate_get_needfij = null;
    private static _d_x_minnsstate_set_needfij _i_x_minnsstate_set_needfij = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_minnsstate_get_xupdated(void *x, byte *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_minnsstate_set_xupdated(void *x, byte *dst);
    private static _d_x_minnsstate_get_xupdated _i_x_minnsstate_get_xupdated = null;
    private static _d_x_minnsstate_set_xupdated _i_x_minnsstate_set_xupdated = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_minnsstate_get_f(void *x, double *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_minnsstate_set_f(void *x, double *dst);
    private static _d_x_minnsstate_get_f _i_x_minnsstate_get_f = null;
    private static _d_x_minnsstate_set_f _i_x_minnsstate_set_f = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_minnsstate_get_fi(void *x, x_vector *dst);
    private static _d_x_minnsstate_get_fi _i_x_minnsstate_get_fi = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_minnsstate_get_j(void *x, x_matrix *dst);
    private static _d_x_minnsstate_get_j _i_x_minnsstate_get_j = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_minnsstate_get_x(void *x, x_vector *dst);
    private static _d_x_minnsstate_get_x _i_x_minnsstate_get_x = null;

    [StructLayout(LayoutKind.Sequential, Pack=8)]
    private struct x_minnsreport
    {
        public x_int iterationscount;
        public x_int nfev;
        public double cerr;
        public double lcerr;
        public double nlcerr;
        public x_int terminationtype;
        public x_int varidx;
        public x_int funcidx;
    }

    public class minnsreport : alglibobject
    {
        public int iterationscount;
        public int nfev;
        public double cerr;
        public double lcerr;
        public double nlcerr;
        public int terminationtype;
        public int varidx;
        public int funcidx;
        public override alglib.alglibobject make_copy()
        {
            minnsreport dst = new minnsreport();
            dst.iterationscount = iterationscount;
            dst.nfev = nfev;
            dst.cerr = cerr;
            dst.lcerr = lcerr;
            dst.nlcerr = nlcerr;
            dst.terminationtype = terminationtype;
            dst.varidx = varidx;
            dst.funcidx = funcidx;
            return dst;
        }
    }

    // This function initializes X-structure (its previous content is ignored)
    private static void x_minnsreport_init(ref x_minnsreport x)
    {
        x.iterationscount.longval = 0;
        x.nfev.longval = 0;
        x.cerr = 0;
        x.lcerr = 0;
        x.nlcerr = 0;
        x.terminationtype.longval = 0;
        x.varidx.longval = 0;
        x.funcidx.longval = 0;
    }

    // This function finalizes fields of X-structure (however, memory occupied by structure itself is not freed)
    // After destruction structure becomes unusable and should be re-initialized if you want to use it
    private static void x_minnsreport_clear(ref x_minnsreport x)
    {
    }

    // This function initializes X-structure by appropriate C# instance
    // (previous content of X structure is ignored)
    private static void x_minnsreport_init_from(ref x_minnsreport x, minnsreport v)
    {
        x.iterationscount.longval = v.iterationscount;
        x.nfev.longval = v.nfev;
        x.cerr = v.cerr;
        x.lcerr = v.lcerr;
        x.nlcerr = v.nlcerr;
        x.terminationtype.longval = v.terminationtype;
        x.varidx.longval = v.varidx;
        x.funcidx.longval = v.funcidx;
    }

    // This function initializes C# structure by appropriate X instance
    // (previous content of C# structure is ignored).
    // This function may accept null v, in this case v is automatically allocated with new().
    private static void x_minnsreport_to_record(ref x_minnsreport x, ref minnsreport v)
    {
        if( v==null )
            v = new minnsreport();
        v.iterationscount = x.iterationscount.intval; // long is silently truncated to int
        v.nfev = x.nfev.intval; // long is silently truncated to int
        v.cerr = x.cerr;
        v.lcerr = x.lcerr;
        v.nlcerr = x.nlcerr;
        v.terminationtype = x.terminationtype.intval; // long is silently truncated to int
        v.varidx = x.varidx.intval; // long is silently truncated to int
        v.funcidx = x.funcidx.intval; // long is silently truncated to int
    }
    
    private static unsafe void _core_minnscreate(int n, double[] x, out minnsstate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        x_vector _d_x = new x_vector();
        void *_d_state = null;
        state = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_xv2_minnscreate(&_s_errormsg, &_d_n, &_d_x, &_d_state, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minnscreate");
            state = new minnsstate(_d_state);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            if( _d_state!=null && state==null)
                _i_x_obj_free_minnsstate(_d_state); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void minnscreate(int n, double[] x, out minnsstate state)
    {
        _core_minnscreate( n,  x, out  state, 0x0);
    }
    
    public static void minnscreate(int n, double[] x, out minnsstate state, alglib.xparams _xparams)
    {
        _core_minnscreate( n,  x, out  state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void minnscreate(double[] x, out minnsstate state)
    {
        int n;
    
        n = ap.len(x);
        _core_minnscreate( n,  x, out  state, 0x0);
    
        
    }
    
    public static void minnscreate(double[] x, out minnsstate state, alglib.xparams _xparams)
    {
        int n;
    
        n = ap.len(x);
        _core_minnscreate( n,  x, out  state, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_minnscreatef(int n, double[] x, double diffstep, out minnsstate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        x_vector _d_x = new x_vector();
        double _d_diffstep = diffstep;
        void *_d_state = null;
        state = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_xv2_minnscreatef(&_s_errormsg, &_d_n, &_d_x, &_d_diffstep, &_d_state, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minnscreatef");
            state = new minnsstate(_d_state);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            if( _d_state!=null && state==null)
                _i_x_obj_free_minnsstate(_d_state); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void minnscreatef(int n, double[] x, double diffstep, out minnsstate state)
    {
        _core_minnscreatef( n,  x,  diffstep, out  state, 0x0);
    }
    
    public static void minnscreatef(int n, double[] x, double diffstep, out minnsstate state, alglib.xparams _xparams)
    {
        _core_minnscreatef( n,  x,  diffstep, out  state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void minnscreatef(double[] x, double diffstep, out minnsstate state)
    {
        int n;
    
        n = ap.len(x);
        _core_minnscreatef( n,  x,  diffstep, out  state, 0x0);
    
        
    }
    
    public static void minnscreatef(double[] x, double diffstep, out minnsstate state, alglib.xparams _xparams)
    {
        int n;
    
        n = ap.len(x);
        _core_minnscreatef( n,  x,  diffstep, out  state, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_minnssetbc(minnsstate state, double[] bndl, double[] bndu, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_bndl = new x_vector();
        x_vector _d_bndu = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_bndl = bndl, _fp_bndu = bndu){
                x_vector_attach_to_array(ref _d_bndl, _fp_bndl, ap.len(bndl));
                x_vector_attach_to_array(ref _d_bndu, _fp_bndu, ap.len(bndu));
                _error_code = _i_xv2_minnssetbc(&_s_errormsg, &_d_state, &_d_bndl, &_d_bndu, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minnssetbc");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_bndl);
            x_vector_clear(ref _d_bndu);
        }
        // This function returns no value.
    }
    
    public static void minnssetbc(minnsstate state, double[] bndl, double[] bndu)
    {
        _core_minnssetbc( state,  bndl,  bndu, 0x0);
    }
    
    public static void minnssetbc(minnsstate state, double[] bndl, double[] bndu, alglib.xparams _xparams)
    {
        _core_minnssetbc( state,  bndl,  bndu, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minnssetlc(minnsstate state, double[,] c, int[] ct, int k, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_matrix _d_c = new x_matrix();
        x_vector _d_ct = new x_vector();
        x_int _d_k = new x_int(k);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_c = c){
                x_matrix_attach_to_array(ref _d_c, _fp_c, ap.rows(c), ap.cols(c));
                x_vector_from_array(ref _d_ct, ct, X_CREATE);
                _error_code = _i_xv2_minnssetlc(&_s_errormsg, &_d_state, &_d_c, &_d_ct, &_d_k, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minnssetlc");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_c);
            x_vector_clear(ref _d_ct);
        }
        // This function returns no value.
    }
    
    public static void minnssetlc(minnsstate state, double[,] c, int[] ct, int k)
    {
        _core_minnssetlc( state,  c,  ct,  k, 0x0);
    }
    
    public static void minnssetlc(minnsstate state, double[,] c, int[] ct, int k, alglib.xparams _xparams)
    {
        _core_minnssetlc( state,  c,  ct,  k, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void minnssetlc(minnsstate state, double[,] c, int[] ct)
    {
        int k;
        if( (ap.rows(c)!=ap.len(ct)))
            throw new alglibexception("Error while calling 'minnssetlc': looks like one of arguments has wrong size");
        k = ap.rows(c);
        _core_minnssetlc( state,  c,  ct,  k, 0x0);
    
        
    }
    
    public static void minnssetlc(minnsstate state, double[,] c, int[] ct, alglib.xparams _xparams)
    {
        int k;
        if( (ap.rows(c)!=ap.len(ct)))
            throw new alglibexception("Error while calling 'minnssetlc': looks like one of arguments has wrong size");
        k = ap.rows(c);
        _core_minnssetlc( state,  c,  ct,  k, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_minnssetnlc(minnsstate state, int nlec, int nlic, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_int _d_nlec = new x_int(nlec);
        x_int _d_nlic = new x_int(nlic);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_minnssetnlc(&_s_errormsg, &_d_state, &_d_nlec, &_d_nlic, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minnssetnlc");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void minnssetnlc(minnsstate state, int nlec, int nlic)
    {
        _core_minnssetnlc( state,  nlec,  nlic, 0x0);
    }
    
    public static void minnssetnlc(minnsstate state, int nlec, int nlic, alglib.xparams _xparams)
    {
        _core_minnssetnlc( state,  nlec,  nlic, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minnssetcond(minnsstate state, double epsx, int maxits, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_epsx = epsx;
        x_int _d_maxits = new x_int(maxits);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_minnssetcond(&_s_errormsg, &_d_state, &_d_epsx, &_d_maxits, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minnssetcond");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void minnssetcond(minnsstate state, double epsx, int maxits)
    {
        _core_minnssetcond( state,  epsx,  maxits, 0x0);
    }
    
    public static void minnssetcond(minnsstate state, double epsx, int maxits, alglib.xparams _xparams)
    {
        _core_minnssetcond( state,  epsx,  maxits, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minnssetscale(minnsstate state, double[] s, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_s = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_s = s){
                x_vector_attach_to_array(ref _d_s, _fp_s, ap.len(s));
                _error_code = _i_xv2_minnssetscale(&_s_errormsg, &_d_state, &_d_s, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minnssetscale");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_s);
        }
        // This function returns no value.
    }
    
    public static void minnssetscale(minnsstate state, double[] s)
    {
        _core_minnssetscale( state,  s, 0x0);
    }
    
    public static void minnssetscale(minnsstate state, double[] s, alglib.xparams _xparams)
    {
        _core_minnssetscale( state,  s, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minnssetalgoags(minnsstate state, double radius, double penalty, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_radius = radius;
        double _d_penalty = penalty;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_minnssetalgoags(&_s_errormsg, &_d_state, &_d_radius, &_d_penalty, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minnssetalgoags");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void minnssetalgoags(minnsstate state, double radius, double penalty)
    {
        _core_minnssetalgoags( state,  radius,  penalty, 0x0);
    }
    
    public static void minnssetalgoags(minnsstate state, double radius, double penalty, alglib.xparams _xparams)
    {
        _core_minnssetalgoags( state,  radius,  penalty, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minnssetxrep(minnsstate state, bool needxrep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        byte _d_needxrep = (byte)(needxrep ? 1 : 0);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_minnssetxrep(&_s_errormsg, &_d_state, &_d_needxrep, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minnssetxrep");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void minnssetxrep(minnsstate state, bool needxrep)
    {
        _core_minnssetxrep( state,  needxrep, 0x0);
    }
    
    public static void minnssetxrep(minnsstate state, bool needxrep, alglib.xparams _xparams)
    {
        _core_minnssetxrep( state,  needxrep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minnsrequesttermination(minnsstate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_minnsrequesttermination(&_s_errormsg, &_d_state, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minnsrequesttermination");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void minnsrequesttermination(minnsstate state)
    {
        _core_minnsrequesttermination( state, 0x0);
    }
    
    public static void minnsrequesttermination(minnsstate state, alglib.xparams _xparams)
    {
        _core_minnsrequesttermination( state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe bool _core_minnsiteration(minnsstate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        bool result;
        byte _d_result = (byte)0;
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_minnsiteration(&_s_errormsg, &_d_result, &_d_state, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minnsiteration");
            result = _d_result!=0;
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static bool minnsiteration(minnsstate state)
    {
        return _core_minnsiteration( state, 0x0);
    }
    
    public static bool minnsiteration(minnsstate state, alglib.xparams _xparams)
    {
        return _core_minnsiteration( state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static unsafe void minnsoptimize(minnsstate state, ndimensional_fvec  fvec, ndimensional_rep rep, object obj)
    {
        minnsoptimize(state, fvec, rep, obj, null);
    }
    
    public static unsafe void minnsoptimize(minnsstate state, ndimensional_fvec  fvec, ndimensional_rep rep, object obj, alglib.xparams _xparams)
    {
        byte *_s_errormsg = null;
        int _error_code = 0;
        byte _b_result = (byte)0;
        byte _xc_xupdated = 0;
        void *_state = state.ptr;
        IntPtr _pre_ptr;
        x_vector _xc_arg = new x_vector();
        double[] _cs_arg = null;
        x_vector _xc_fi = new x_vector();
        double[] _cs_fi = null;
        byte _xc_needfi= 0;
    
        //
        // Check correctness of delegates
        //
        if( fvec==null )
            throw new alglibexception("ALGLIB: error in 'minnsoptimize()' (fvec is null)");
    
        //
        // Attach x-structures to internal arrays
        //
        x_vector_create_empty(ref _xc_arg, DT_REAL);
        x_vector_create_empty(ref _xc_fi, DT_REAL);
        _i_x_minnsstate_get_x(_state, &_xc_arg);
        _i_x_minnsstate_get_fi(_state, &_xc_fi);
        _cs_arg = new double[_xc_arg.cnt];
        _cs_fi = new double[_xc_fi.cnt];
    
        //
        // Main loop
        //
        for(;;)
        {
            //
            // Call iteration function.
            // Terminate iterations if it returned false.
            //
            _error_code = _i_xv2_minnsiteration(&_s_errormsg, &_b_result, &_state, _xparams==null ? 0x0 : _xparams.flags);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minnsiteration");
            ap.assert(_state==state.ptr, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _b_result==0 )
                break;
            
            //
            // Reverse communication interface:
            // * fetch flags
            // * make delegate calls
            //
            _i_x_minnsstate_get_xupdated(_state, &_xc_xupdated);
            _i_x_minnsstate_get_needfi(_state, &_xc_needfi);
            x_vector_to_array(ref _xc_arg, ref _cs_arg);
            if( _xc_needfi!=0 )
            {
                fvec(_cs_arg, _cs_fi, obj);
                x_vector_from_array(ref _xc_fi, _cs_fi, X_REWRITE);
                continue;
            }
            if( _xc_xupdated!=0 )
            {
                if( rep!=null )
                {
                    double _local_f;
                    _i_x_minnsstate_get_f(_state, &_local_f);
                    rep(_cs_arg, _local_f, obj);
                }
                continue;
            }
            throw new alglibexception("ALGLIB: error in 'minnsoptimize' (some derivatives were not provided?)");
        }
        
        //
        // Integrity post-check:
        // * make sure that no reverse communication array was reallocated during optimization
        //
        _pre_ptr = _xc_arg.xptr.ptr;
        _i_x_minnsstate_get_x(_state, &_xc_arg);
        alglib.ap.assert(_xc_arg.xptr.ptr==_pre_ptr, "ALGLIB: integrity check failed in minnsoptimize()");
        _pre_ptr = _xc_fi.xptr.ptr;
        _i_x_minnsstate_get_fi(_state, &_xc_fi);
        alglib.ap.assert(_xc_fi.xptr.ptr==_pre_ptr, "ALGLIB: integrity check failed in minnsoptimize()");
    }
    
    public static unsafe void minnsoptimize(minnsstate state, ndimensional_jac  jac, ndimensional_rep rep, object obj)
    {
        minnsoptimize(state, jac, rep, obj, null);
    }
    
    public static unsafe void minnsoptimize(minnsstate state, ndimensional_jac  jac, ndimensional_rep rep, object obj, alglib.xparams _xparams)
    {
        byte *_s_errormsg = null;
        int _error_code = 0;
        byte _b_result = (byte)0;
        byte _xc_xupdated = 0;
        void *_state = state.ptr;
        IntPtr _pre_ptr;
        x_vector _xc_arg = new x_vector();
        double[] _cs_arg = null;
        x_vector _xc_fi = new x_vector();
        double[] _cs_fi = null;
        x_matrix _xc_j = new x_matrix();
        double[,] _cs_j = null;
        byte _xc_needfij= 0;
    
        //
        // Check correctness of delegates
        //
        if( jac==null )
            throw new alglibexception("ALGLIB: error in 'minnsoptimize()' (jac is null)");
    
        //
        // Attach x-structures to internal arrays
        //
        x_vector_create_empty(ref _xc_arg, DT_REAL);
        x_vector_create_empty(ref _xc_fi, DT_REAL);
        x_matrix_create_empty(ref _xc_j, DT_REAL);
        _i_x_minnsstate_get_x(_state, &_xc_arg);
        _i_x_minnsstate_get_fi(_state, &_xc_fi);
        _i_x_minnsstate_get_j(_state, &_xc_j);
        _cs_arg = new double[_xc_arg.cnt];
        _cs_fi = new double[_xc_fi.cnt];
        _cs_j = new double[_xc_j.rows,_xc_j.cols];
    
        //
        // Main loop
        //
        for(;;)
        {
            //
            // Call iteration function.
            // Terminate iterations if it returned false.
            //
            _error_code = _i_xv2_minnsiteration(&_s_errormsg, &_b_result, &_state, _xparams==null ? 0x0 : _xparams.flags);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minnsiteration");
            ap.assert(_state==state.ptr, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _b_result==0 )
                break;
            
            //
            // Reverse communication interface:
            // * fetch flags
            // * make delegate calls
            //
            _i_x_minnsstate_get_xupdated(_state, &_xc_xupdated);
            _i_x_minnsstate_get_needfij(_state, &_xc_needfij);
            x_vector_to_array(ref _xc_arg, ref _cs_arg);
            if( _xc_needfij!=0 )
            {
                jac(_cs_arg, _cs_fi, _cs_j, obj);
                x_vector_from_array(ref _xc_fi, _cs_fi, X_REWRITE);
                x_matrix_from_array(ref _xc_j,  _cs_j,  X_REWRITE);
                continue;
            }
            if( _xc_xupdated!=0 )
            {
                if( rep!=null )
                {
                    double _local_f;
                    _i_x_minnsstate_get_f(_state, &_local_f);
                    rep(_cs_arg, _local_f, obj);
                }
                continue;
            }
            throw new alglibexception("ALGLIB: error in 'minnsoptimize' (some derivatives were not provided?)");
        }
        
        //
        // Integrity post-check:
        // * make sure that no reverse communication array was reallocated during optimization
        //
        _pre_ptr = _xc_arg.xptr.ptr;
        _i_x_minnsstate_get_x(_state, &_xc_arg);
        alglib.ap.assert(_xc_arg.xptr.ptr==_pre_ptr, "ALGLIB: integrity check failed in minnsoptimize()");
        _pre_ptr = _xc_fi.xptr.ptr;
        _i_x_minnsstate_get_fi(_state, &_xc_fi);
        alglib.ap.assert(_xc_fi.xptr.ptr==_pre_ptr, "ALGLIB: integrity check failed in minnsoptimize()");
        _pre_ptr = _xc_j.xptr.ptr;
        _i_x_minnsstate_get_j(_state, &_xc_j);
        alglib.ap.assert(_xc_j.xptr.ptr==_pre_ptr, "ALGLIB: integrity check failed in minnsoptimize()");
    }
    
    private static unsafe void _core_minnsresults(minnsstate state, out double[] x, out minnsreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_x = new x_vector();
        x_minnsreport _d_rep = new x_minnsreport();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_x, DT_REAL);
            x = null;
            x_minnsreport_init(ref _d_rep);
            _error_code = _i_xv2_minnsresults(&_s_errormsg, &_d_state, &_d_x, &_d_rep, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minnsresults");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
            rep = null;
            x_minnsreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_minnsreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void minnsresults(minnsstate state, out double[] x, out minnsreport rep)
    {
        _core_minnsresults( state, out  x, out  rep, 0x0);
    }
    
    public static void minnsresults(minnsstate state, out double[] x, out minnsreport rep, alglib.xparams _xparams)
    {
        _core_minnsresults( state, out  x, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minnsresultsbuf(minnsstate state, ref double[] x, minnsreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_x = new x_vector();
        x_minnsreport _d_rep = new x_minnsreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_minnsreport_init_from(ref _d_rep, rep);
                _error_code = _i_xv2_minnsresultsbuf(&_s_errormsg, &_d_state, &_d_x, &_d_rep, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minnsresultsbuf");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
            x_minnsreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_minnsreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void minnsresultsbuf(minnsstate state, ref double[] x, minnsreport rep)
    {
        _core_minnsresultsbuf( state, ref  x,  rep, 0x0);
    }
    
    public static void minnsresultsbuf(minnsstate state, ref double[] x, minnsreport rep, alglib.xparams _xparams)
    {
        _core_minnsresultsbuf( state, ref  x,  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minnsrestartfrom(minnsstate state, double[] x, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_x = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_xv2_minnsrestartfrom(&_s_errormsg, &_d_state, &_d_x, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minnsrestartfrom");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_x);
        }
        // This function returns no value.
    }
    
    public static void minnsrestartfrom(minnsstate state, double[] x)
    {
        _core_minnsrestartfrom( state,  x, 0x0);
    }
    
    public static void minnsrestartfrom(minnsstate state, double[] x, alglib.xparams _xparams)
    {
        _core_minnsrestartfrom( state,  x, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage mincomp
    //
    

    public unsafe class minasastate : alglibobject
    {
        private void *_ptr;
        public minasastate(void *x)
        {
            _ptr = x;
        }
        ~minasastate()
        {
            _deallocate();
        }
        public void* ptr { get { return _ptr; } }
        public override alglib.alglibobject make_copy()
        {
            if( _ptr==null )
                return new minasastate(null);
            return new minasastate(_i_x_obj_copy_minasastate(_ptr));
        }
        public override void _deallocate()
        {
            if( _ptr!=null )
                _i_x_obj_free_minasastate(_ptr);
            _ptr = null;
            System.GC.SuppressFinalize(this);
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_minasastate(void *x);
    private static _d_x_obj_copy_minasastate _i_x_obj_copy_minasastate = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_obj_free_minasastate(void *x);
    private static _d_x_obj_free_minasastate _i_x_obj_free_minasastate = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_minasastate_get_needfg(void *x, byte *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_minasastate_set_needfg(void *x, byte *dst);
    private static _d_x_minasastate_get_needfg _i_x_minasastate_get_needfg = null;
    private static _d_x_minasastate_set_needfg _i_x_minasastate_set_needfg = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_minasastate_get_xupdated(void *x, byte *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_minasastate_set_xupdated(void *x, byte *dst);
    private static _d_x_minasastate_get_xupdated _i_x_minasastate_get_xupdated = null;
    private static _d_x_minasastate_set_xupdated _i_x_minasastate_set_xupdated = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_minasastate_get_f(void *x, double *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_minasastate_set_f(void *x, double *dst);
    private static _d_x_minasastate_get_f _i_x_minasastate_get_f = null;
    private static _d_x_minasastate_set_f _i_x_minasastate_set_f = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_minasastate_get_g(void *x, x_vector *dst);
    private static _d_x_minasastate_get_g _i_x_minasastate_get_g = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_minasastate_get_x(void *x, x_vector *dst);
    private static _d_x_minasastate_get_x _i_x_minasastate_get_x = null;

    [StructLayout(LayoutKind.Sequential, Pack=8)]
    private struct x_minasareport
    {
        public x_int iterationscount;
        public x_int nfev;
        public x_int terminationtype;
        public x_int activeconstraints;
    }

    public class minasareport : alglibobject
    {
        public int iterationscount;
        public int nfev;
        public int terminationtype;
        public int activeconstraints;
        public override alglib.alglibobject make_copy()
        {
            minasareport dst = new minasareport();
            dst.iterationscount = iterationscount;
            dst.nfev = nfev;
            dst.terminationtype = terminationtype;
            dst.activeconstraints = activeconstraints;
            return dst;
        }
    }

    // This function initializes X-structure (its previous content is ignored)
    private static void x_minasareport_init(ref x_minasareport x)
    {
        x.iterationscount.longval = 0;
        x.nfev.longval = 0;
        x.terminationtype.longval = 0;
        x.activeconstraints.longval = 0;
    }

    // This function finalizes fields of X-structure (however, memory occupied by structure itself is not freed)
    // After destruction structure becomes unusable and should be re-initialized if you want to use it
    private static void x_minasareport_clear(ref x_minasareport x)
    {
    }

    // This function initializes X-structure by appropriate C# instance
    // (previous content of X structure is ignored)
    private static void x_minasareport_init_from(ref x_minasareport x, minasareport v)
    {
        x.iterationscount.longval = v.iterationscount;
        x.nfev.longval = v.nfev;
        x.terminationtype.longval = v.terminationtype;
        x.activeconstraints.longval = v.activeconstraints;
    }

    // This function initializes C# structure by appropriate X instance
    // (previous content of C# structure is ignored).
    // This function may accept null v, in this case v is automatically allocated with new().
    private static void x_minasareport_to_record(ref x_minasareport x, ref minasareport v)
    {
        if( v==null )
            v = new minasareport();
        v.iterationscount = x.iterationscount.intval; // long is silently truncated to int
        v.nfev = x.nfev.intval; // long is silently truncated to int
        v.terminationtype = x.terminationtype.intval; // long is silently truncated to int
        v.activeconstraints = x.activeconstraints.intval; // long is silently truncated to int
    }
    
    private static unsafe void _core_minlbfgssetdefaultpreconditioner(minlbfgsstate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_minlbfgssetdefaultpreconditioner(&_s_errormsg, &_d_state, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minlbfgssetdefaultpreconditioner");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void minlbfgssetdefaultpreconditioner(minlbfgsstate state)
    {
        _core_minlbfgssetdefaultpreconditioner( state, 0x0);
    }
    
    public static void minlbfgssetdefaultpreconditioner(minlbfgsstate state, alglib.xparams _xparams)
    {
        _core_minlbfgssetdefaultpreconditioner( state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minlbfgssetcholeskypreconditioner(minlbfgsstate state, double[,] p, bool isupper, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_matrix _d_p = new x_matrix();
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_p = p){
                x_matrix_attach_to_array(ref _d_p, _fp_p, ap.rows(p), ap.cols(p));
                _error_code = _i_xv2_minlbfgssetcholeskypreconditioner(&_s_errormsg, &_d_state, &_d_p, &_d_isupper, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minlbfgssetcholeskypreconditioner");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_p);
        }
        // This function returns no value.
    }
    
    public static void minlbfgssetcholeskypreconditioner(minlbfgsstate state, double[,] p, bool isupper)
    {
        _core_minlbfgssetcholeskypreconditioner( state,  p,  isupper, 0x0);
    }
    
    public static void minlbfgssetcholeskypreconditioner(minlbfgsstate state, double[,] p, bool isupper, alglib.xparams _xparams)
    {
        _core_minlbfgssetcholeskypreconditioner( state,  p,  isupper, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minbleicsetbarrierwidth(minbleicstate state, double mu, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_mu = mu;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_minbleicsetbarrierwidth(&_s_errormsg, &_d_state, &_d_mu, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minbleicsetbarrierwidth");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void minbleicsetbarrierwidth(minbleicstate state, double mu)
    {
        _core_minbleicsetbarrierwidth( state,  mu, 0x0);
    }
    
    public static void minbleicsetbarrierwidth(minbleicstate state, double mu, alglib.xparams _xparams)
    {
        _core_minbleicsetbarrierwidth( state,  mu, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minbleicsetbarrierdecay(minbleicstate state, double mudecay, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_mudecay = mudecay;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_minbleicsetbarrierdecay(&_s_errormsg, &_d_state, &_d_mudecay, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minbleicsetbarrierdecay");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void minbleicsetbarrierdecay(minbleicstate state, double mudecay)
    {
        _core_minbleicsetbarrierdecay( state,  mudecay, 0x0);
    }
    
    public static void minbleicsetbarrierdecay(minbleicstate state, double mudecay, alglib.xparams _xparams)
    {
        _core_minbleicsetbarrierdecay( state,  mudecay, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minasacreate(int n, double[] x, double[] bndl, double[] bndu, out minasastate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        x_vector _d_x = new x_vector();
        x_vector _d_bndl = new x_vector();
        x_vector _d_bndu = new x_vector();
        void *_d_state = null;
        state = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_bndl = bndl, _fp_bndu = bndu){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_bndl, _fp_bndl, ap.len(bndl));
                x_vector_attach_to_array(ref _d_bndu, _fp_bndu, ap.len(bndu));
                _error_code = _i_xv2_minasacreate(&_s_errormsg, &_d_n, &_d_x, &_d_bndl, &_d_bndu, &_d_state, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minasacreate");
            state = new minasastate(_d_state);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_bndl);
            x_vector_clear(ref _d_bndu);
            if( _d_state!=null && state==null)
                _i_x_obj_free_minasastate(_d_state); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void minasacreate(int n, double[] x, double[] bndl, double[] bndu, out minasastate state)
    {
        _core_minasacreate( n,  x,  bndl,  bndu, out  state, 0x0);
    }
    
    public static void minasacreate(int n, double[] x, double[] bndl, double[] bndu, out minasastate state, alglib.xparams _xparams)
    {
        _core_minasacreate( n,  x,  bndl,  bndu, out  state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void minasacreate(double[] x, double[] bndl, double[] bndu, out minasastate state)
    {
        int n;
        if( (ap.len(x)!=ap.len(bndl)) || (ap.len(x)!=ap.len(bndu)))
            throw new alglibexception("Error while calling 'minasacreate': looks like one of arguments has wrong size");
        n = ap.len(x);
        _core_minasacreate( n,  x,  bndl,  bndu, out  state, 0x0);
    
        
    }
    
    public static void minasacreate(double[] x, double[] bndl, double[] bndu, out minasastate state, alglib.xparams _xparams)
    {
        int n;
        if( (ap.len(x)!=ap.len(bndl)) || (ap.len(x)!=ap.len(bndu)))
            throw new alglibexception("Error while calling 'minasacreate': looks like one of arguments has wrong size");
        n = ap.len(x);
        _core_minasacreate( n,  x,  bndl,  bndu, out  state, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_minasasetcond(minasastate state, double epsg, double epsf, double epsx, int maxits, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_epsg = epsg;
        double _d_epsf = epsf;
        double _d_epsx = epsx;
        x_int _d_maxits = new x_int(maxits);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_minasasetcond(&_s_errormsg, &_d_state, &_d_epsg, &_d_epsf, &_d_epsx, &_d_maxits, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minasasetcond");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void minasasetcond(minasastate state, double epsg, double epsf, double epsx, int maxits)
    {
        _core_minasasetcond( state,  epsg,  epsf,  epsx,  maxits, 0x0);
    }
    
    public static void minasasetcond(minasastate state, double epsg, double epsf, double epsx, int maxits, alglib.xparams _xparams)
    {
        _core_minasasetcond( state,  epsg,  epsf,  epsx,  maxits, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minasasetxrep(minasastate state, bool needxrep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        byte _d_needxrep = (byte)(needxrep ? 1 : 0);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_minasasetxrep(&_s_errormsg, &_d_state, &_d_needxrep, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minasasetxrep");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void minasasetxrep(minasastate state, bool needxrep)
    {
        _core_minasasetxrep( state,  needxrep, 0x0);
    }
    
    public static void minasasetxrep(minasastate state, bool needxrep, alglib.xparams _xparams)
    {
        _core_minasasetxrep( state,  needxrep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minasasetalgorithm(minasastate state, int algotype, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_int _d_algotype = new x_int(algotype);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_minasasetalgorithm(&_s_errormsg, &_d_state, &_d_algotype, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minasasetalgorithm");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void minasasetalgorithm(minasastate state, int algotype)
    {
        _core_minasasetalgorithm( state,  algotype, 0x0);
    }
    
    public static void minasasetalgorithm(minasastate state, int algotype, alglib.xparams _xparams)
    {
        _core_minasasetalgorithm( state,  algotype, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minasasetstpmax(minasastate state, double stpmax, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_stpmax = stpmax;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_minasasetstpmax(&_s_errormsg, &_d_state, &_d_stpmax, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minasasetstpmax");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void minasasetstpmax(minasastate state, double stpmax)
    {
        _core_minasasetstpmax( state,  stpmax, 0x0);
    }
    
    public static void minasasetstpmax(minasastate state, double stpmax, alglib.xparams _xparams)
    {
        _core_minasasetstpmax( state,  stpmax, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe bool _core_minasaiteration(minasastate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        bool result;
        byte _d_result = (byte)0;
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_minasaiteration(&_s_errormsg, &_d_result, &_d_state, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minasaiteration");
            result = _d_result!=0;
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static bool minasaiteration(minasastate state)
    {
        return _core_minasaiteration( state, 0x0);
    }
    
    public static bool minasaiteration(minasastate state, alglib.xparams _xparams)
    {
        return _core_minasaiteration( state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static unsafe void minasaoptimize(minasastate state, ndimensional_grad grad, ndimensional_rep rep, object obj)
    {
        minasaoptimize(state, grad, rep, obj, null);
    }
    
    public static unsafe void minasaoptimize(minasastate state, ndimensional_grad grad, ndimensional_rep rep, object obj, alglib.xparams _xparams)
    {
        byte *_s_errormsg = null;
        int _error_code = 0;
        byte _b_result = (byte)0;
        byte _xc_xupdated = 0;
        void *_state = state.ptr;
        IntPtr _pre_ptr;
        x_vector _xc_arg = new x_vector();
        double[] _cs_arg = null;
        double _cs_f = 0;
        x_vector _xc_g = new x_vector();
        double[] _cs_g = null;
        byte _xc_needfg= 0;
    
        //
        // Check correctness of delegates
        //
        if( grad==null )
            throw new alglibexception("ALGLIB: error in 'minasaoptimize()' (grad is null)");
    
        //
        // Attach x-structures to internal arrays
        //
        x_vector_create_empty(ref _xc_arg, DT_REAL);
        x_vector_create_empty(ref _xc_g, DT_REAL);
        _i_x_minasastate_get_x(_state, &_xc_arg);
        _i_x_minasastate_get_g(_state, &_xc_g);
        _cs_arg = new double[_xc_arg.cnt];
        _cs_g = new double[_xc_g.cnt];
    
        //
        // Main loop
        //
        for(;;)
        {
            //
            // Call iteration function.
            // Terminate iterations if it returned false.
            //
            _error_code = _i_xv2_minasaiteration(&_s_errormsg, &_b_result, &_state, _xparams==null ? 0x0 : _xparams.flags);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minasaiteration");
            ap.assert(_state==state.ptr, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _b_result==0 )
                break;
            
            //
            // Reverse communication interface:
            // * fetch flags
            // * make delegate calls
            //
            _i_x_minasastate_get_xupdated(_state, &_xc_xupdated);
            _i_x_minasastate_get_needfg(_state, &_xc_needfg);
            x_vector_to_array(ref _xc_arg, ref _cs_arg);
            if( _xc_needfg!=0 )
            {
                grad(_cs_arg, ref _cs_f, _cs_g, obj);
                _i_x_minasastate_set_f(_state, &_cs_f);
                x_vector_from_array(ref _xc_g, _cs_g, X_REWRITE);
                continue;
            }
            if( _xc_xupdated!=0 )
            {
                if( rep!=null )
                {
                    double _local_f;
                    _i_x_minasastate_get_f(_state, &_local_f);
                    rep(_cs_arg, _local_f, obj);
                }
                continue;
            }
            throw new alglibexception("ALGLIB: error in 'minasaoptimize' (some derivatives were not provided?)");
        }
        
        //
        // Integrity post-check:
        // * make sure that no reverse communication array was reallocated during optimization
        //
        _pre_ptr = _xc_arg.xptr.ptr;
        _i_x_minasastate_get_x(_state, &_xc_arg);
        alglib.ap.assert(_xc_arg.xptr.ptr==_pre_ptr, "ALGLIB: integrity check failed in minasaoptimize()");
        _pre_ptr = _xc_g.xptr.ptr;
        _i_x_minasastate_get_g(_state, &_xc_g);
        alglib.ap.assert(_xc_g.xptr.ptr==_pre_ptr, "ALGLIB: integrity check failed in minasaoptimize()");
    }
    
    private static unsafe void _core_minasaresults(minasastate state, out double[] x, out minasareport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_x = new x_vector();
        x_minasareport _d_rep = new x_minasareport();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_x, DT_REAL);
            x = null;
            x_minasareport_init(ref _d_rep);
            _error_code = _i_xv2_minasaresults(&_s_errormsg, &_d_state, &_d_x, &_d_rep, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minasaresults");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
            rep = null;
            x_minasareport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_minasareport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void minasaresults(minasastate state, out double[] x, out minasareport rep)
    {
        _core_minasaresults( state, out  x, out  rep, 0x0);
    }
    
    public static void minasaresults(minasastate state, out double[] x, out minasareport rep, alglib.xparams _xparams)
    {
        _core_minasaresults( state, out  x, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minasaresultsbuf(minasastate state, ref double[] x, minasareport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_x = new x_vector();
        x_minasareport _d_rep = new x_minasareport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_minasareport_init_from(ref _d_rep, rep);
                _error_code = _i_xv2_minasaresultsbuf(&_s_errormsg, &_d_state, &_d_x, &_d_rep, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minasaresultsbuf");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
            x_minasareport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_minasareport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void minasaresultsbuf(minasastate state, ref double[] x, minasareport rep)
    {
        _core_minasaresultsbuf( state, ref  x,  rep, 0x0);
    }
    
    public static void minasaresultsbuf(minasastate state, ref double[] x, minasareport rep, alglib.xparams _xparams)
    {
        _core_minasaresultsbuf( state, ref  x,  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minasarestartfrom(minasastate state, double[] x, double[] bndl, double[] bndu, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_x = new x_vector();
        x_vector _d_bndl = new x_vector();
        x_vector _d_bndu = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_bndl = bndl, _fp_bndu = bndu){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_bndl, _fp_bndl, ap.len(bndl));
                x_vector_attach_to_array(ref _d_bndu, _fp_bndu, ap.len(bndu));
                _error_code = _i_xv2_minasarestartfrom(&_s_errormsg, &_d_state, &_d_x, &_d_bndl, &_d_bndu, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minasarestartfrom");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_bndl);
            x_vector_clear(ref _d_bndu);
        }
        // This function returns no value.
    }
    
    public static void minasarestartfrom(minasastate state, double[] x, double[] bndl, double[] bndu)
    {
        _core_minasarestartfrom( state,  x,  bndl,  bndu, 0x0);
    }
    
    public static void minasarestartfrom(minasastate state, double[] x, double[] bndl, double[] bndu, alglib.xparams _xparams)
    {
        _core_minasarestartfrom( state,  x,  bndl,  bndu, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage minbc
    //
    

    public unsafe class minbcstate : alglibobject
    {
        private void *_ptr;
        public minbcstate(void *x)
        {
            _ptr = x;
        }
        ~minbcstate()
        {
            _deallocate();
        }
        public void* ptr { get { return _ptr; } }
        public override alglib.alglibobject make_copy()
        {
            if( _ptr==null )
                return new minbcstate(null);
            return new minbcstate(_i_x_obj_copy_minbcstate(_ptr));
        }
        public override void _deallocate()
        {
            if( _ptr!=null )
                _i_x_obj_free_minbcstate(_ptr);
            _ptr = null;
            System.GC.SuppressFinalize(this);
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_minbcstate(void *x);
    private static _d_x_obj_copy_minbcstate _i_x_obj_copy_minbcstate = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_obj_free_minbcstate(void *x);
    private static _d_x_obj_free_minbcstate _i_x_obj_free_minbcstate = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_minbcstate_get_needf(void *x, byte *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_minbcstate_set_needf(void *x, byte *dst);
    private static _d_x_minbcstate_get_needf _i_x_minbcstate_get_needf = null;
    private static _d_x_minbcstate_set_needf _i_x_minbcstate_set_needf = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_minbcstate_get_needfg(void *x, byte *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_minbcstate_set_needfg(void *x, byte *dst);
    private static _d_x_minbcstate_get_needfg _i_x_minbcstate_get_needfg = null;
    private static _d_x_minbcstate_set_needfg _i_x_minbcstate_set_needfg = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_minbcstate_get_xupdated(void *x, byte *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_minbcstate_set_xupdated(void *x, byte *dst);
    private static _d_x_minbcstate_get_xupdated _i_x_minbcstate_get_xupdated = null;
    private static _d_x_minbcstate_set_xupdated _i_x_minbcstate_set_xupdated = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_minbcstate_get_f(void *x, double *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_minbcstate_set_f(void *x, double *dst);
    private static _d_x_minbcstate_get_f _i_x_minbcstate_get_f = null;
    private static _d_x_minbcstate_set_f _i_x_minbcstate_set_f = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_minbcstate_get_g(void *x, x_vector *dst);
    private static _d_x_minbcstate_get_g _i_x_minbcstate_get_g = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_minbcstate_get_x(void *x, x_vector *dst);
    private static _d_x_minbcstate_get_x _i_x_minbcstate_get_x = null;

    [StructLayout(LayoutKind.Sequential, Pack=8)]
    private struct x_minbcreport
    {
        public x_int iterationscount;
        public x_int nfev;
        public x_int varidx;
        public x_int terminationtype;
    }

    public class minbcreport : alglibobject
    {
        public int iterationscount;
        public int nfev;
        public int varidx;
        public int terminationtype;
        public override alglib.alglibobject make_copy()
        {
            minbcreport dst = new minbcreport();
            dst.iterationscount = iterationscount;
            dst.nfev = nfev;
            dst.varidx = varidx;
            dst.terminationtype = terminationtype;
            return dst;
        }
    }

    // This function initializes X-structure (its previous content is ignored)
    private static void x_minbcreport_init(ref x_minbcreport x)
    {
        x.iterationscount.longval = 0;
        x.nfev.longval = 0;
        x.varidx.longval = 0;
        x.terminationtype.longval = 0;
    }

    // This function finalizes fields of X-structure (however, memory occupied by structure itself is not freed)
    // After destruction structure becomes unusable and should be re-initialized if you want to use it
    private static void x_minbcreport_clear(ref x_minbcreport x)
    {
    }

    // This function initializes X-structure by appropriate C# instance
    // (previous content of X structure is ignored)
    private static void x_minbcreport_init_from(ref x_minbcreport x, minbcreport v)
    {
        x.iterationscount.longval = v.iterationscount;
        x.nfev.longval = v.nfev;
        x.varidx.longval = v.varidx;
        x.terminationtype.longval = v.terminationtype;
    }

    // This function initializes C# structure by appropriate X instance
    // (previous content of C# structure is ignored).
    // This function may accept null v, in this case v is automatically allocated with new().
    private static void x_minbcreport_to_record(ref x_minbcreport x, ref minbcreport v)
    {
        if( v==null )
            v = new minbcreport();
        v.iterationscount = x.iterationscount.intval; // long is silently truncated to int
        v.nfev = x.nfev.intval; // long is silently truncated to int
        v.varidx = x.varidx.intval; // long is silently truncated to int
        v.terminationtype = x.terminationtype.intval; // long is silently truncated to int
    }
    
    private static unsafe void _core_minbccreate(int n, double[] x, out minbcstate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        x_vector _d_x = new x_vector();
        void *_d_state = null;
        state = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_xv2_minbccreate(&_s_errormsg, &_d_n, &_d_x, &_d_state, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minbccreate");
            state = new minbcstate(_d_state);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            if( _d_state!=null && state==null)
                _i_x_obj_free_minbcstate(_d_state); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void minbccreate(int n, double[] x, out minbcstate state)
    {
        _core_minbccreate( n,  x, out  state, 0x0);
    }
    
    public static void minbccreate(int n, double[] x, out minbcstate state, alglib.xparams _xparams)
    {
        _core_minbccreate( n,  x, out  state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void minbccreate(double[] x, out minbcstate state)
    {
        int n;
    
        n = ap.len(x);
        _core_minbccreate( n,  x, out  state, 0x0);
    
        
    }
    
    public static void minbccreate(double[] x, out minbcstate state, alglib.xparams _xparams)
    {
        int n;
    
        n = ap.len(x);
        _core_minbccreate( n,  x, out  state, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_minbccreatef(int n, double[] x, double diffstep, out minbcstate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        x_vector _d_x = new x_vector();
        double _d_diffstep = diffstep;
        void *_d_state = null;
        state = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_xv2_minbccreatef(&_s_errormsg, &_d_n, &_d_x, &_d_diffstep, &_d_state, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minbccreatef");
            state = new minbcstate(_d_state);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            if( _d_state!=null && state==null)
                _i_x_obj_free_minbcstate(_d_state); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void minbccreatef(int n, double[] x, double diffstep, out minbcstate state)
    {
        _core_minbccreatef( n,  x,  diffstep, out  state, 0x0);
    }
    
    public static void minbccreatef(int n, double[] x, double diffstep, out minbcstate state, alglib.xparams _xparams)
    {
        _core_minbccreatef( n,  x,  diffstep, out  state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void minbccreatef(double[] x, double diffstep, out minbcstate state)
    {
        int n;
    
        n = ap.len(x);
        _core_minbccreatef( n,  x,  diffstep, out  state, 0x0);
    
        
    }
    
    public static void minbccreatef(double[] x, double diffstep, out minbcstate state, alglib.xparams _xparams)
    {
        int n;
    
        n = ap.len(x);
        _core_minbccreatef( n,  x,  diffstep, out  state, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_minbcsetbc(minbcstate state, double[] bndl, double[] bndu, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_bndl = new x_vector();
        x_vector _d_bndu = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_bndl = bndl, _fp_bndu = bndu){
                x_vector_attach_to_array(ref _d_bndl, _fp_bndl, ap.len(bndl));
                x_vector_attach_to_array(ref _d_bndu, _fp_bndu, ap.len(bndu));
                _error_code = _i_xv2_minbcsetbc(&_s_errormsg, &_d_state, &_d_bndl, &_d_bndu, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minbcsetbc");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_bndl);
            x_vector_clear(ref _d_bndu);
        }
        // This function returns no value.
    }
    
    public static void minbcsetbc(minbcstate state, double[] bndl, double[] bndu)
    {
        _core_minbcsetbc( state,  bndl,  bndu, 0x0);
    }
    
    public static void minbcsetbc(minbcstate state, double[] bndl, double[] bndu, alglib.xparams _xparams)
    {
        _core_minbcsetbc( state,  bndl,  bndu, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minbcsetcond(minbcstate state, double epsg, double epsf, double epsx, int maxits, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_epsg = epsg;
        double _d_epsf = epsf;
        double _d_epsx = epsx;
        x_int _d_maxits = new x_int(maxits);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_minbcsetcond(&_s_errormsg, &_d_state, &_d_epsg, &_d_epsf, &_d_epsx, &_d_maxits, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minbcsetcond");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void minbcsetcond(minbcstate state, double epsg, double epsf, double epsx, int maxits)
    {
        _core_minbcsetcond( state,  epsg,  epsf,  epsx,  maxits, 0x0);
    }
    
    public static void minbcsetcond(minbcstate state, double epsg, double epsf, double epsx, int maxits, alglib.xparams _xparams)
    {
        _core_minbcsetcond( state,  epsg,  epsf,  epsx,  maxits, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minbcsetscale(minbcstate state, double[] s, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_s = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_s = s){
                x_vector_attach_to_array(ref _d_s, _fp_s, ap.len(s));
                _error_code = _i_xv2_minbcsetscale(&_s_errormsg, &_d_state, &_d_s, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minbcsetscale");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_s);
        }
        // This function returns no value.
    }
    
    public static void minbcsetscale(minbcstate state, double[] s)
    {
        _core_minbcsetscale( state,  s, 0x0);
    }
    
    public static void minbcsetscale(minbcstate state, double[] s, alglib.xparams _xparams)
    {
        _core_minbcsetscale( state,  s, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minbcsetprecdefault(minbcstate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_minbcsetprecdefault(&_s_errormsg, &_d_state, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minbcsetprecdefault");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void minbcsetprecdefault(minbcstate state)
    {
        _core_minbcsetprecdefault( state, 0x0);
    }
    
    public static void minbcsetprecdefault(minbcstate state, alglib.xparams _xparams)
    {
        _core_minbcsetprecdefault( state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minbcsetprecdiag(minbcstate state, double[] d, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_d = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_d = d){
                x_vector_attach_to_array(ref _d_d, _fp_d, ap.len(d));
                _error_code = _i_xv2_minbcsetprecdiag(&_s_errormsg, &_d_state, &_d_d, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minbcsetprecdiag");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_d);
        }
        // This function returns no value.
    }
    
    public static void minbcsetprecdiag(minbcstate state, double[] d)
    {
        _core_minbcsetprecdiag( state,  d, 0x0);
    }
    
    public static void minbcsetprecdiag(minbcstate state, double[] d, alglib.xparams _xparams)
    {
        _core_minbcsetprecdiag( state,  d, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minbcsetprecscale(minbcstate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_minbcsetprecscale(&_s_errormsg, &_d_state, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minbcsetprecscale");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void minbcsetprecscale(minbcstate state)
    {
        _core_minbcsetprecscale( state, 0x0);
    }
    
    public static void minbcsetprecscale(minbcstate state, alglib.xparams _xparams)
    {
        _core_minbcsetprecscale( state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minbcsetxrep(minbcstate state, bool needxrep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        byte _d_needxrep = (byte)(needxrep ? 1 : 0);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_minbcsetxrep(&_s_errormsg, &_d_state, &_d_needxrep, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minbcsetxrep");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void minbcsetxrep(minbcstate state, bool needxrep)
    {
        _core_minbcsetxrep( state,  needxrep, 0x0);
    }
    
    public static void minbcsetxrep(minbcstate state, bool needxrep, alglib.xparams _xparams)
    {
        _core_minbcsetxrep( state,  needxrep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minbcsetstpmax(minbcstate state, double stpmax, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_stpmax = stpmax;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_minbcsetstpmax(&_s_errormsg, &_d_state, &_d_stpmax, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minbcsetstpmax");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void minbcsetstpmax(minbcstate state, double stpmax)
    {
        _core_minbcsetstpmax( state,  stpmax, 0x0);
    }
    
    public static void minbcsetstpmax(minbcstate state, double stpmax, alglib.xparams _xparams)
    {
        _core_minbcsetstpmax( state,  stpmax, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe bool _core_minbciteration(minbcstate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        bool result;
        byte _d_result = (byte)0;
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_minbciteration(&_s_errormsg, &_d_result, &_d_state, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minbciteration");
            result = _d_result!=0;
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static bool minbciteration(minbcstate state)
    {
        return _core_minbciteration( state, 0x0);
    }
    
    public static bool minbciteration(minbcstate state, alglib.xparams _xparams)
    {
        return _core_minbciteration( state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static unsafe void minbcoptimize(minbcstate state, ndimensional_func func, ndimensional_rep rep, object obj)
    {
        minbcoptimize(state, func, rep, obj, null);
    }
    
    public static unsafe void minbcoptimize(minbcstate state, ndimensional_func func, ndimensional_rep rep, object obj, alglib.xparams _xparams)
    {
        byte *_s_errormsg = null;
        int _error_code = 0;
        byte _b_result = (byte)0;
        byte _xc_xupdated = 0;
        void *_state = state.ptr;
        IntPtr _pre_ptr;
        x_vector _xc_arg = new x_vector();
        double[] _cs_arg = null;
        double _cs_f = 0;
        byte _xc_needf= 0;
    
        //
        // Check correctness of delegates
        //
        if( func==null )
            throw new alglibexception("ALGLIB: error in 'minbcoptimize()' (func is null)");
    
        //
        // Attach x-structures to internal arrays
        //
        x_vector_create_empty(ref _xc_arg, DT_REAL);
        _i_x_minbcstate_get_x(_state, &_xc_arg);
        _cs_arg = new double[_xc_arg.cnt];
    
        //
        // Main loop
        //
        for(;;)
        {
            //
            // Call iteration function.
            // Terminate iterations if it returned false.
            //
            _error_code = _i_xv2_minbciteration(&_s_errormsg, &_b_result, &_state, _xparams==null ? 0x0 : _xparams.flags);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minbciteration");
            ap.assert(_state==state.ptr, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _b_result==0 )
                break;
            
            //
            // Reverse communication interface:
            // * fetch flags
            // * make delegate calls
            //
            _i_x_minbcstate_get_xupdated(_state, &_xc_xupdated);
            _i_x_minbcstate_get_needf(_state, &_xc_needf);
            x_vector_to_array(ref _xc_arg, ref _cs_arg);
            if( _xc_needf!=0 )
            {
                func(_cs_arg, ref _cs_f, obj);
                _i_x_minbcstate_set_f(_state, &_cs_f);
                continue;
            }
            if( _xc_xupdated!=0 )
            {
                if( rep!=null )
                {
                    double _local_f;
                    _i_x_minbcstate_get_f(_state, &_local_f);
                    rep(_cs_arg, _local_f, obj);
                }
                continue;
            }
            throw new alglibexception("ALGLIB: error in 'minbcoptimize' (some derivatives were not provided?)");
        }
        
        //
        // Integrity post-check:
        // * make sure that no reverse communication array was reallocated during optimization
        //
        _pre_ptr = _xc_arg.xptr.ptr;
        _i_x_minbcstate_get_x(_state, &_xc_arg);
        alglib.ap.assert(_xc_arg.xptr.ptr==_pre_ptr, "ALGLIB: integrity check failed in minbcoptimize()");
    }
    
    public static unsafe void minbcoptimize(minbcstate state, ndimensional_grad grad, ndimensional_rep rep, object obj)
    {
        minbcoptimize(state, grad, rep, obj, null);
    }
    
    public static unsafe void minbcoptimize(minbcstate state, ndimensional_grad grad, ndimensional_rep rep, object obj, alglib.xparams _xparams)
    {
        byte *_s_errormsg = null;
        int _error_code = 0;
        byte _b_result = (byte)0;
        byte _xc_xupdated = 0;
        void *_state = state.ptr;
        IntPtr _pre_ptr;
        x_vector _xc_arg = new x_vector();
        double[] _cs_arg = null;
        double _cs_f = 0;
        x_vector _xc_g = new x_vector();
        double[] _cs_g = null;
        byte _xc_needfg= 0;
    
        //
        // Check correctness of delegates
        //
        if( grad==null )
            throw new alglibexception("ALGLIB: error in 'minbcoptimize()' (grad is null)");
    
        //
        // Attach x-structures to internal arrays
        //
        x_vector_create_empty(ref _xc_arg, DT_REAL);
        x_vector_create_empty(ref _xc_g, DT_REAL);
        _i_x_minbcstate_get_x(_state, &_xc_arg);
        _i_x_minbcstate_get_g(_state, &_xc_g);
        _cs_arg = new double[_xc_arg.cnt];
        _cs_g = new double[_xc_g.cnt];
    
        //
        // Main loop
        //
        for(;;)
        {
            //
            // Call iteration function.
            // Terminate iterations if it returned false.
            //
            _error_code = _i_xv2_minbciteration(&_s_errormsg, &_b_result, &_state, _xparams==null ? 0x0 : _xparams.flags);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minbciteration");
            ap.assert(_state==state.ptr, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _b_result==0 )
                break;
            
            //
            // Reverse communication interface:
            // * fetch flags
            // * make delegate calls
            //
            _i_x_minbcstate_get_xupdated(_state, &_xc_xupdated);
            _i_x_minbcstate_get_needfg(_state, &_xc_needfg);
            x_vector_to_array(ref _xc_arg, ref _cs_arg);
            if( _xc_needfg!=0 )
            {
                grad(_cs_arg, ref _cs_f, _cs_g, obj);
                _i_x_minbcstate_set_f(_state, &_cs_f);
                x_vector_from_array(ref _xc_g, _cs_g, X_REWRITE);
                continue;
            }
            if( _xc_xupdated!=0 )
            {
                if( rep!=null )
                {
                    double _local_f;
                    _i_x_minbcstate_get_f(_state, &_local_f);
                    rep(_cs_arg, _local_f, obj);
                }
                continue;
            }
            throw new alglibexception("ALGLIB: error in 'minbcoptimize' (some derivatives were not provided?)");
        }
        
        //
        // Integrity post-check:
        // * make sure that no reverse communication array was reallocated during optimization
        //
        _pre_ptr = _xc_arg.xptr.ptr;
        _i_x_minbcstate_get_x(_state, &_xc_arg);
        alglib.ap.assert(_xc_arg.xptr.ptr==_pre_ptr, "ALGLIB: integrity check failed in minbcoptimize()");
        _pre_ptr = _xc_g.xptr.ptr;
        _i_x_minbcstate_get_g(_state, &_xc_g);
        alglib.ap.assert(_xc_g.xptr.ptr==_pre_ptr, "ALGLIB: integrity check failed in minbcoptimize()");
    }
    
    private static unsafe void _core_minbcoptguardgradient(minbcstate state, double teststep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_teststep = teststep;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_minbcoptguardgradient(&_s_errormsg, &_d_state, &_d_teststep, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minbcoptguardgradient");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void minbcoptguardgradient(minbcstate state, double teststep)
    {
        _core_minbcoptguardgradient( state,  teststep, 0x0);
    }
    
    public static void minbcoptguardgradient(minbcstate state, double teststep, alglib.xparams _xparams)
    {
        _core_minbcoptguardgradient( state,  teststep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minbcoptguardsmoothness(minbcstate state, int level, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_int _d_level = new x_int(level);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_minbcoptguardsmoothness(&_s_errormsg, &_d_state, &_d_level, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minbcoptguardsmoothness");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void minbcoptguardsmoothness(minbcstate state, int level)
    {
        _core_minbcoptguardsmoothness( state,  level, 0x0);
    }
    
    public static void minbcoptguardsmoothness(minbcstate state, int level, alglib.xparams _xparams)
    {
        _core_minbcoptguardsmoothness( state,  level, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void minbcoptguardsmoothness(minbcstate state)
    {
        int level;
    
        level = 1;
        _core_minbcoptguardsmoothness( state,  level, 0x0);
    
        
    }
    
    public static void minbcoptguardsmoothness(minbcstate state, alglib.xparams _xparams)
    {
        int level;
    
        level = 1;
        _core_minbcoptguardsmoothness( state,  level, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_minbcoptguardresults(minbcstate state, out optguardreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_optguardreport _d_rep = new x_optguardreport();
        
        // Pack, call, unpack
        try
        {
            x_optguardreport_init(ref _d_rep);
            _error_code = _i_xv2_minbcoptguardresults(&_s_errormsg, &_d_state, &_d_rep, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minbcoptguardresults");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            rep = null;
            x_optguardreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_optguardreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void minbcoptguardresults(minbcstate state, out optguardreport rep)
    {
        _core_minbcoptguardresults( state, out  rep, 0x0);
    }
    
    public static void minbcoptguardresults(minbcstate state, out optguardreport rep, alglib.xparams _xparams)
    {
        _core_minbcoptguardresults( state, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minbcoptguardnonc1test0results(minbcstate state, out optguardnonc1test0report strrep, out optguardnonc1test0report lngrep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_optguardnonc1test0report _d_strrep = new x_optguardnonc1test0report();
        x_optguardnonc1test0report _d_lngrep = new x_optguardnonc1test0report();
        
        // Pack, call, unpack
        try
        {
            x_optguardnonc1test0report_init(ref _d_strrep);
            x_optguardnonc1test0report_init(ref _d_lngrep);
            _error_code = _i_xv2_minbcoptguardnonc1test0results(&_s_errormsg, &_d_state, &_d_strrep, &_d_lngrep, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minbcoptguardnonc1test0results");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            strrep = null;
            x_optguardnonc1test0report_to_record(ref _d_strrep, ref strrep);
            lngrep = null;
            x_optguardnonc1test0report_to_record(ref _d_lngrep, ref lngrep);
        }
        finally
        {
            x_optguardnonc1test0report_clear(ref _d_strrep);
            x_optguardnonc1test0report_clear(ref _d_lngrep);
        }
        // This function returns no value.
    }
    
    public static void minbcoptguardnonc1test0results(minbcstate state, out optguardnonc1test0report strrep, out optguardnonc1test0report lngrep)
    {
        _core_minbcoptguardnonc1test0results( state, out  strrep, out  lngrep, 0x0);
    }
    
    public static void minbcoptguardnonc1test0results(minbcstate state, out optguardnonc1test0report strrep, out optguardnonc1test0report lngrep, alglib.xparams _xparams)
    {
        _core_minbcoptguardnonc1test0results( state, out  strrep, out  lngrep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minbcoptguardnonc1test1results(minbcstate state, out optguardnonc1test1report strrep, out optguardnonc1test1report lngrep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_optguardnonc1test1report _d_strrep = new x_optguardnonc1test1report();
        x_optguardnonc1test1report _d_lngrep = new x_optguardnonc1test1report();
        
        // Pack, call, unpack
        try
        {
            x_optguardnonc1test1report_init(ref _d_strrep);
            x_optguardnonc1test1report_init(ref _d_lngrep);
            _error_code = _i_xv2_minbcoptguardnonc1test1results(&_s_errormsg, &_d_state, &_d_strrep, &_d_lngrep, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minbcoptguardnonc1test1results");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            strrep = null;
            x_optguardnonc1test1report_to_record(ref _d_strrep, ref strrep);
            lngrep = null;
            x_optguardnonc1test1report_to_record(ref _d_lngrep, ref lngrep);
        }
        finally
        {
            x_optguardnonc1test1report_clear(ref _d_strrep);
            x_optguardnonc1test1report_clear(ref _d_lngrep);
        }
        // This function returns no value.
    }
    
    public static void minbcoptguardnonc1test1results(minbcstate state, out optguardnonc1test1report strrep, out optguardnonc1test1report lngrep)
    {
        _core_minbcoptguardnonc1test1results( state, out  strrep, out  lngrep, 0x0);
    }
    
    public static void minbcoptguardnonc1test1results(minbcstate state, out optguardnonc1test1report strrep, out optguardnonc1test1report lngrep, alglib.xparams _xparams)
    {
        _core_minbcoptguardnonc1test1results( state, out  strrep, out  lngrep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minbcresults(minbcstate state, out double[] x, out minbcreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_x = new x_vector();
        x_minbcreport _d_rep = new x_minbcreport();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_x, DT_REAL);
            x = null;
            x_minbcreport_init(ref _d_rep);
            _error_code = _i_xv2_minbcresults(&_s_errormsg, &_d_state, &_d_x, &_d_rep, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minbcresults");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
            rep = null;
            x_minbcreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_minbcreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void minbcresults(minbcstate state, out double[] x, out minbcreport rep)
    {
        _core_minbcresults( state, out  x, out  rep, 0x0);
    }
    
    public static void minbcresults(minbcstate state, out double[] x, out minbcreport rep, alglib.xparams _xparams)
    {
        _core_minbcresults( state, out  x, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minbcresultsbuf(minbcstate state, ref double[] x, minbcreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_x = new x_vector();
        x_minbcreport _d_rep = new x_minbcreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_minbcreport_init_from(ref _d_rep, rep);
                _error_code = _i_xv2_minbcresultsbuf(&_s_errormsg, &_d_state, &_d_x, &_d_rep, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minbcresultsbuf");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
            x_minbcreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_minbcreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void minbcresultsbuf(minbcstate state, ref double[] x, minbcreport rep)
    {
        _core_minbcresultsbuf( state, ref  x,  rep, 0x0);
    }
    
    public static void minbcresultsbuf(minbcstate state, ref double[] x, minbcreport rep, alglib.xparams _xparams)
    {
        _core_minbcresultsbuf( state, ref  x,  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minbcrestartfrom(minbcstate state, double[] x, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_x = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_xv2_minbcrestartfrom(&_s_errormsg, &_d_state, &_d_x, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minbcrestartfrom");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_x);
        }
        // This function returns no value.
    }
    
    public static void minbcrestartfrom(minbcstate state, double[] x)
    {
        _core_minbcrestartfrom( state,  x, 0x0);
    }
    
    public static void minbcrestartfrom(minbcstate state, double[] x, alglib.xparams _xparams)
    {
        _core_minbcrestartfrom( state,  x, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_minbcrequesttermination(minbcstate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_minbcrequesttermination(&_s_errormsg, &_d_state, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "minbcrequesttermination");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void minbcrequesttermination(minbcstate state)
    {
        _core_minbcrequesttermination( state, 0x0);
    }
    
    public static void minbcrequesttermination(minbcstate state, alglib.xparams _xparams)
    {
        _core_minbcrequesttermination( state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage opts
    //
    

    public unsafe class lptestproblem : alglibobject
    {
        private void *_ptr;
        public lptestproblem(void *x)
        {
            _ptr = x;
        }
        ~lptestproblem()
        {
            _deallocate();
        }
        public void* ptr { get { return _ptr; } }
        public override alglib.alglibobject make_copy()
        {
            if( _ptr==null )
                return new lptestproblem(null);
            return new lptestproblem(_i_x_obj_copy_lptestproblem(_ptr));
        }
        public override void _deallocate()
        {
            if( _ptr!=null )
                _i_x_obj_free_lptestproblem(_ptr);
            _ptr = null;
            System.GC.SuppressFinalize(this);
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_lptestproblem(void *x);
    private static _d_x_obj_copy_lptestproblem _i_x_obj_copy_lptestproblem = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_obj_free_lptestproblem(void *x);
    private static _d_x_obj_free_lptestproblem _i_x_obj_free_lptestproblem = null;
    public static unsafe void lptestproblemserialize(lptestproblem obj, out string s_out)
    {
        byte *_s_errormsg = null;
        byte *_out = null;
        void *_x = obj.ptr;
        try
        {
            int _error_code = _i_x_lptestproblemserialize(&_s_errormsg, &_x, &_out);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "lptestproblemserialize");
            s_out = Marshal.PtrToStringAnsi((IntPtr)_out);
        }
        finally
        {
            x_free((IntPtr)_out);
        }
    }
    
    public static unsafe void lptestproblemunserialize(string s_in, out lptestproblem obj)
    {
        byte *_s_errormsg = null;
        byte[] _ain = System.Text.Encoding.UTF8.GetBytes(s_in);
        fixed(byte *_pin = _ain )
        {
            byte *_in = _pin;
            void *_x = null;
            obj = null;
            try
            {
                int _error_code = _i_x_lptestproblemunserialize(&_s_errormsg, &_in, &_x);
                if( _error_code!=X_OK )
                    handle_exception(_error_code, _s_errormsg, "lptestproblemunserialize");
                obj = new lptestproblem(_x);
            }
            finally
            {
                // on exception clean up X objects which were not attached to C# objects
                if( _x!=null && obj==null)
                    _i_x_obj_free_lptestproblem(_x);
            }
        }
    }
    public static unsafe void lptestproblemserialize(lptestproblem obj, System.IO.Stream s_out)
    {
        byte *_s_errormsg = null;
        void *_x = obj.ptr;
        alglib.native_stream_adapter a = new alglib.native_stream_adapter();
        a.sstart_stream(s_out);
        int _error_code = _i_x_lptestproblemserialize_stream(&_s_errormsg, &_x, a.writer_callback, IntPtr.Zero);
        if( _error_code!=X_OK )
            handle_exception(_error_code, _s_errormsg, "lptestproblemserialize");
    }
    
    public static unsafe void lptestproblemunserialize(System.IO.Stream s_in, out lptestproblem obj)
    {
        byte *_s_errormsg = null;
        void *_x = null;
        obj = null;
        alglib.native_stream_adapter a = new alglib.native_stream_adapter();
        a.ustart_stream(s_in);
        try
        {
            int _error_code = _i_x_lptestproblemunserialize_stream(&_s_errormsg, a.reader_callback, IntPtr.Zero, &_x);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "lptestproblemunserialize");
            obj = new lptestproblem(_x);
        }
        finally
        {
            // on exception clean up X objects which were not attached to C# objects
            if( _x!=null && obj==null)
                _i_x_obj_free_lptestproblem(_x);
        }
    }
    
    private static unsafe void _core_lptestproblemcreate(int n, bool hasknowntarget, double targetf, out lptestproblem p, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        byte _d_hasknowntarget = (byte)(hasknowntarget ? 1 : 0);
        double _d_targetf = targetf;
        void *_d_p = null;
        p = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_lptestproblemcreate(&_s_errormsg, &_d_n, &_d_hasknowntarget, &_d_targetf, &_d_p, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "lptestproblemcreate");
            p = new lptestproblem(_d_p);
        }
        finally
        {
            if( _d_p!=null && p==null)
                _i_x_obj_free_lptestproblem(_d_p); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void lptestproblemcreate(int n, bool hasknowntarget, double targetf, out lptestproblem p)
    {
        _core_lptestproblemcreate( n,  hasknowntarget,  targetf, out  p, 0x0);
    }
    
    public static void lptestproblemcreate(int n, bool hasknowntarget, double targetf, out lptestproblem p, alglib.xparams _xparams)
    {
        _core_lptestproblemcreate( n,  hasknowntarget,  targetf, out  p, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe bool _core_lptestproblemhasknowntarget(lptestproblem p, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        bool result;
        byte _d_result = (byte)0;
        void *_d_p = p.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_lptestproblemhasknowntarget(&_s_errormsg, &_d_result, &_d_p, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "lptestproblemhasknowntarget");
            result = _d_result!=0;
            ap.assert(p.ptr==_d_p, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static bool lptestproblemhasknowntarget(lptestproblem p)
    {
        return _core_lptestproblemhasknowntarget( p, 0x0);
    }
    
    public static bool lptestproblemhasknowntarget(lptestproblem p, alglib.xparams _xparams)
    {
        return _core_lptestproblemhasknowntarget( p, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_lptestproblemgettargetf(lptestproblem p, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_p = p.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_lptestproblemgettargetf(&_s_errormsg, &_d_result, &_d_p, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "lptestproblemgettargetf");
            result = _d_result;
            ap.assert(p.ptr==_d_p, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double lptestproblemgettargetf(lptestproblem p)
    {
        return _core_lptestproblemgettargetf( p, 0x0);
    }
    
    public static double lptestproblemgettargetf(lptestproblem p, alglib.xparams _xparams)
    {
        return _core_lptestproblemgettargetf( p, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe int _core_lptestproblemgetn(lptestproblem p, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        int result;
        x_int _d_result = new x_int();
        void *_d_p = p.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_lptestproblemgetn(&_s_errormsg, &_d_result, &_d_p, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "lptestproblemgetn");
            result = _d_result.intval;
            ap.assert(p.ptr==_d_p, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static int lptestproblemgetn(lptestproblem p)
    {
        return _core_lptestproblemgetn( p, 0x0);
    }
    
    public static int lptestproblemgetn(lptestproblem p, alglib.xparams _xparams)
    {
        return _core_lptestproblemgetn( p, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe int _core_lptestproblemgetm(lptestproblem p, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        int result;
        x_int _d_result = new x_int();
        void *_d_p = p.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_lptestproblemgetm(&_s_errormsg, &_d_result, &_d_p, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "lptestproblemgetm");
            result = _d_result.intval;
            ap.assert(p.ptr==_d_p, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static int lptestproblemgetm(lptestproblem p)
    {
        return _core_lptestproblemgetm( p, 0x0);
    }
    
    public static int lptestproblemgetm(lptestproblem p, alglib.xparams _xparams)
    {
        return _core_lptestproblemgetm( p, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_lptestproblemsetscale(lptestproblem p, double[] s, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_p = p.ptr;
        x_vector _d_s = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_s = s){
                x_vector_attach_to_array(ref _d_s, _fp_s, ap.len(s));
                _error_code = _i_xv2_lptestproblemsetscale(&_s_errormsg, &_d_p, &_d_s, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "lptestproblemsetscale");
            ap.assert(p.ptr==_d_p, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_s);
        }
        // This function returns no value.
    }
    
    public static void lptestproblemsetscale(lptestproblem p, double[] s)
    {
        _core_lptestproblemsetscale( p,  s, 0x0);
    }
    
    public static void lptestproblemsetscale(lptestproblem p, double[] s, alglib.xparams _xparams)
    {
        _core_lptestproblemsetscale( p,  s, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_lptestproblemsetcost(lptestproblem p, double[] c, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_p = p.ptr;
        x_vector _d_c = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_c = c){
                x_vector_attach_to_array(ref _d_c, _fp_c, ap.len(c));
                _error_code = _i_xv2_lptestproblemsetcost(&_s_errormsg, &_d_p, &_d_c, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "lptestproblemsetcost");
            ap.assert(p.ptr==_d_p, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_c);
        }
        // This function returns no value.
    }
    
    public static void lptestproblemsetcost(lptestproblem p, double[] c)
    {
        _core_lptestproblemsetcost( p,  c, 0x0);
    }
    
    public static void lptestproblemsetcost(lptestproblem p, double[] c, alglib.xparams _xparams)
    {
        _core_lptestproblemsetcost( p,  c, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_lptestproblemsetbc(lptestproblem p, double[] bndl, double[] bndu, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_p = p.ptr;
        x_vector _d_bndl = new x_vector();
        x_vector _d_bndu = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_bndl = bndl, _fp_bndu = bndu){
                x_vector_attach_to_array(ref _d_bndl, _fp_bndl, ap.len(bndl));
                x_vector_attach_to_array(ref _d_bndu, _fp_bndu, ap.len(bndu));
                _error_code = _i_xv2_lptestproblemsetbc(&_s_errormsg, &_d_p, &_d_bndl, &_d_bndu, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "lptestproblemsetbc");
            ap.assert(p.ptr==_d_p, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_bndl);
            x_vector_clear(ref _d_bndu);
        }
        // This function returns no value.
    }
    
    public static void lptestproblemsetbc(lptestproblem p, double[] bndl, double[] bndu)
    {
        _core_lptestproblemsetbc( p,  bndl,  bndu, 0x0);
    }
    
    public static void lptestproblemsetbc(lptestproblem p, double[] bndl, double[] bndu, alglib.xparams _xparams)
    {
        _core_lptestproblemsetbc( p,  bndl,  bndu, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_lptestproblemsetlc2(lptestproblem p, sparsematrix a, double[] al, double[] au, int m, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_p = p.ptr;
        void *_d_a = a.ptr;
        x_vector _d_al = new x_vector();
        x_vector _d_au = new x_vector();
        x_int _d_m = new x_int(m);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_al = al, _fp_au = au){
                x_vector_attach_to_array(ref _d_al, _fp_al, ap.len(al));
                x_vector_attach_to_array(ref _d_au, _fp_au, ap.len(au));
                _error_code = _i_xv2_lptestproblemsetlc2(&_s_errormsg, &_d_p, &_d_a, &_d_al, &_d_au, &_d_m, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "lptestproblemsetlc2");
            ap.assert(p.ptr==_d_p, "ALGLIB: internal error (reference changed for non-out X-object)");
            ap.assert(a.ptr==_d_a, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_al);
            x_vector_clear(ref _d_au);
        }
        // This function returns no value.
    }
    
    public static void lptestproblemsetlc2(lptestproblem p, sparsematrix a, double[] al, double[] au, int m)
    {
        _core_lptestproblemsetlc2( p,  a,  al,  au,  m, 0x0);
    }
    
    public static void lptestproblemsetlc2(lptestproblem p, sparsematrix a, double[] al, double[] au, int m, alglib.xparams _xparams)
    {
        _core_lptestproblemsetlc2( p,  a,  al,  au,  m, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_xdbgminlpcreatefromtestproblem(lptestproblem p, out minlpstate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_p = p.ptr;
        void *_d_state = null;
        state = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_xdbgminlpcreatefromtestproblem(&_s_errormsg, &_d_p, &_d_state, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "xdbgminlpcreatefromtestproblem");
            ap.assert(p.ptr==_d_p, "ALGLIB: internal error (reference changed for non-out X-object)");
            state = new minlpstate(_d_state);
        }
        finally
        {
            if( _d_state!=null && state==null)
                _i_x_obj_free_minlpstate(_d_state); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void xdbgminlpcreatefromtestproblem(lptestproblem p, out minlpstate state)
    {
        _core_xdbgminlpcreatefromtestproblem( p, out  state, 0x0);
    }
    
    public static void xdbgminlpcreatefromtestproblem(lptestproblem p, out minlpstate state, alglib.xparams _xparams)
    {
        _core_xdbgminlpcreatefromtestproblem( p, out  state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage xdebug
    //
    

    [StructLayout(LayoutKind.Sequential, Pack=8)]
    private struct x_xdebugrecord1
    {
        public x_int i;
        public alglib.complex c;
        public x_vector a;
    }

    public class xdebugrecord1 : alglibobject
    {
        public int i;
        public alglib.complex c;
        public double[] a;
        public override alglib.alglibobject make_copy()
        {
            xdebugrecord1 dst = new xdebugrecord1();
            dst.i = i;
            dst.c = c;
            dst.a = (double[])a.Clone();        return dst;
        }
    }

    // This function initializes X-structure (its previous content is ignored)
    private static void x_xdebugrecord1_init(ref x_xdebugrecord1 x)
    {
        x.i.longval = 0;
        x.c.x = 0;
        x.c.y = 0;
        x_vector_create_empty(ref x.a, DT_REAL);
    }

    // This function finalizes fields of X-structure (however, memory occupied by structure itself is not freed)
    // After destruction structure becomes unusable and should be re-initialized if you want to use it
    private static void x_xdebugrecord1_clear(ref x_xdebugrecord1 x)
    {
        x_vector_clear(ref x.a);
    }

    // This function initializes X-structure by appropriate C# instance
    // (previous content of X structure is ignored)
    private static void x_xdebugrecord1_init_from(ref x_xdebugrecord1 x, xdebugrecord1 v)
    {
        x.i.longval = v.i;
        x.c.x = v.c.x;
        x.c.y = v.c.y;
        x_vector_from_array(ref x.a, v.a, X_CREATE);
    }

    // This function initializes C# structure by appropriate X instance
    // (previous content of C# structure is ignored).
    // This function may accept null v, in this case v is automatically allocated with new().
    private static void x_xdebugrecord1_to_record(ref x_xdebugrecord1 x, ref xdebugrecord1 v)
    {
        if( v==null )
            v = new xdebugrecord1();
        v.i = x.i.intval; // long is silently truncated to int
        v.c.x = x.c.x;
        v.c.y = x.c.y;
        x_vector_to_array(ref x.a, ref v.a);
    }
    
    private static unsafe void _core_xdebuginitrecord1(out xdebugrecord1 rec1, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_xdebugrecord1 _d_rec1 = new x_xdebugrecord1();
        
        // Pack, call, unpack
        try
        {
            x_xdebugrecord1_init(ref _d_rec1);
            _error_code = _i_xv2_xdebuginitrecord1(&_s_errormsg, &_d_rec1, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "xdebuginitrecord1");
            rec1 = null;
            x_xdebugrecord1_to_record(ref _d_rec1, ref rec1);
        }
        finally
        {
            x_xdebugrecord1_clear(ref _d_rec1);
        }
        // This function returns no value.
    }
    
    public static void xdebuginitrecord1(out xdebugrecord1 rec1)
    {
        _core_xdebuginitrecord1(out  rec1, 0x0);
    }
    
    public static void xdebuginitrecord1(out xdebugrecord1 rec1, alglib.xparams _xparams)
    {
        _core_xdebuginitrecord1(out  rec1, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe int _core_xdebugb1count(bool[] a, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        int result;
        x_int _d_result = new x_int();
        x_vector _d_a = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(bool* _fp_a = a){
                x_vector_attach_to_array(ref _d_a, _fp_a, ap.len(a));
                _error_code = _i_xv2_xdebugb1count(&_s_errormsg, &_d_result, &_d_a, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "xdebugb1count");
            result = _d_result.intval;
        }
        finally
        {
            x_vector_clear(ref _d_a);
        }
        return result;
    }
    
    public static int xdebugb1count(bool[] a)
    {
        return _core_xdebugb1count( a, 0x0);
    }
    
    public static int xdebugb1count(bool[] a, alglib.xparams _xparams)
    {
        return _core_xdebugb1count( a, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_xdebugb1not(ref bool[] a, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_a = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(bool* _fp_a = a){
                x_vector_attach_to_array(ref _d_a, _fp_a, ap.len(a));
                _error_code = _i_xv2_xdebugb1not(&_s_errormsg, &_d_a, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "xdebugb1not");
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_a, ref a);
            if( a == null )
                a = new bool[0];
        }
        finally
        {
            x_vector_clear(ref _d_a);
        }
        // This function returns no value.
    }
    
    public static void xdebugb1not(ref bool[] a)
    {
        _core_xdebugb1not(ref  a, 0x0);
    }
    
    public static void xdebugb1not(ref bool[] a, alglib.xparams _xparams)
    {
        _core_xdebugb1not(ref  a, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_xdebugb1appendcopy(ref bool[] a, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_a = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(bool* _fp_a = a){
                x_vector_attach_to_array(ref _d_a, _fp_a, ap.len(a));
                _error_code = _i_xv2_xdebugb1appendcopy(&_s_errormsg, &_d_a, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "xdebugb1appendcopy");
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_a, ref a);
            if( a == null )
                a = new bool[0];
        }
        finally
        {
            x_vector_clear(ref _d_a);
        }
        // This function returns no value.
    }
    
    public static void xdebugb1appendcopy(ref bool[] a)
    {
        _core_xdebugb1appendcopy(ref  a, 0x0);
    }
    
    public static void xdebugb1appendcopy(ref bool[] a, alglib.xparams _xparams)
    {
        _core_xdebugb1appendcopy(ref  a, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_xdebugb1outeven(int n, out bool[] a, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        x_vector _d_a = new x_vector();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_a, DT_BOOL);
            a = null;
            _error_code = _i_xv2_xdebugb1outeven(&_s_errormsg, &_d_n, &_d_a, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "xdebugb1outeven");
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_a, ref a);
            if( a == null )
                a = new bool[0];
        }
        finally
        {
            x_vector_clear(ref _d_a);
        }
        // This function returns no value.
    }
    
    public static void xdebugb1outeven(int n, out bool[] a)
    {
        _core_xdebugb1outeven( n, out  a, 0x0);
    }
    
    public static void xdebugb1outeven(int n, out bool[] a, alglib.xparams _xparams)
    {
        _core_xdebugb1outeven( n, out  a, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe int _core_xdebugi1sum(int[] a, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        int result;
        x_int _d_result = new x_int();
        x_vector _d_a = new x_vector();
        
        // Pack, call, unpack
        try
        {
            x_vector_from_array(ref _d_a, a, X_CREATE);
            _error_code = _i_xv2_xdebugi1sum(&_s_errormsg, &_d_result, &_d_a, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "xdebugi1sum");
            result = _d_result.intval;
        }
        finally
        {
            x_vector_clear(ref _d_a);
        }
        return result;
    }
    
    public static int xdebugi1sum(int[] a)
    {
        return _core_xdebugi1sum( a, 0x0);
    }
    
    public static int xdebugi1sum(int[] a, alglib.xparams _xparams)
    {
        return _core_xdebugi1sum( a, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_xdebugi1neg(ref int[] a, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_a = new x_vector();
        
        // Pack, call, unpack
        try
        {
            x_vector_from_array(ref _d_a, a, X_CREATE);
            _error_code = _i_xv2_xdebugi1neg(&_s_errormsg, &_d_a, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "xdebugi1neg");
            x_vector_to_array(ref _d_a, ref a);
        }
        finally
        {
            x_vector_clear(ref _d_a);
        }
        // This function returns no value.
    }
    
    public static void xdebugi1neg(ref int[] a)
    {
        _core_xdebugi1neg(ref  a, 0x0);
    }
    
    public static void xdebugi1neg(ref int[] a, alglib.xparams _xparams)
    {
        _core_xdebugi1neg(ref  a, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_xdebugi1appendcopy(ref int[] a, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_a = new x_vector();
        
        // Pack, call, unpack
        try
        {
            x_vector_from_array(ref _d_a, a, X_CREATE);
            _error_code = _i_xv2_xdebugi1appendcopy(&_s_errormsg, &_d_a, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "xdebugi1appendcopy");
            x_vector_to_array(ref _d_a, ref a);
        }
        finally
        {
            x_vector_clear(ref _d_a);
        }
        // This function returns no value.
    }
    
    public static void xdebugi1appendcopy(ref int[] a)
    {
        _core_xdebugi1appendcopy(ref  a, 0x0);
    }
    
    public static void xdebugi1appendcopy(ref int[] a, alglib.xparams _xparams)
    {
        _core_xdebugi1appendcopy(ref  a, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_xdebugi1outeven(int n, out int[] a, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        x_vector _d_a = new x_vector();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_a, DT_INT);
            a = null;
            _error_code = _i_xv2_xdebugi1outeven(&_s_errormsg, &_d_n, &_d_a, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "xdebugi1outeven");
            x_vector_to_array(ref _d_a, ref a);
        }
        finally
        {
            x_vector_clear(ref _d_a);
        }
        // This function returns no value.
    }
    
    public static void xdebugi1outeven(int n, out int[] a)
    {
        _core_xdebugi1outeven( n, out  a, 0x0);
    }
    
    public static void xdebugi1outeven(int n, out int[] a, alglib.xparams _xparams)
    {
        _core_xdebugi1outeven( n, out  a, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_xdebugr1sum(double[] a, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_vector _d_a = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_vector_attach_to_array(ref _d_a, _fp_a, ap.len(a));
                _error_code = _i_xv2_xdebugr1sum(&_s_errormsg, &_d_result, &_d_a, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "xdebugr1sum");
            result = _d_result;
        }
        finally
        {
            x_vector_clear(ref _d_a);
        }
        return result;
    }
    
    public static double xdebugr1sum(double[] a)
    {
        return _core_xdebugr1sum( a, 0x0);
    }
    
    public static double xdebugr1sum(double[] a, alglib.xparams _xparams)
    {
        return _core_xdebugr1sum( a, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_xdebugr1neg(ref double[] a, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_a = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_vector_attach_to_array(ref _d_a, _fp_a, ap.len(a));
                _error_code = _i_xv2_xdebugr1neg(&_s_errormsg, &_d_a, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "xdebugr1neg");
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_a, ref a);
            if( a == null )
                a = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_a);
        }
        // This function returns no value.
    }
    
    public static void xdebugr1neg(ref double[] a)
    {
        _core_xdebugr1neg(ref  a, 0x0);
    }
    
    public static void xdebugr1neg(ref double[] a, alglib.xparams _xparams)
    {
        _core_xdebugr1neg(ref  a, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_xdebugr1appendcopy(ref double[] a, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_a = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_vector_attach_to_array(ref _d_a, _fp_a, ap.len(a));
                _error_code = _i_xv2_xdebugr1appendcopy(&_s_errormsg, &_d_a, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "xdebugr1appendcopy");
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_a, ref a);
            if( a == null )
                a = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_a);
        }
        // This function returns no value.
    }
    
    public static void xdebugr1appendcopy(ref double[] a)
    {
        _core_xdebugr1appendcopy(ref  a, 0x0);
    }
    
    public static void xdebugr1appendcopy(ref double[] a, alglib.xparams _xparams)
    {
        _core_xdebugr1appendcopy(ref  a, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_xdebugr1outeven(int n, out double[] a, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        x_vector _d_a = new x_vector();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_a, DT_REAL);
            a = null;
            _error_code = _i_xv2_xdebugr1outeven(&_s_errormsg, &_d_n, &_d_a, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "xdebugr1outeven");
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_a, ref a);
            if( a == null )
                a = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_a);
        }
        // This function returns no value.
    }
    
    public static void xdebugr1outeven(int n, out double[] a)
    {
        _core_xdebugr1outeven( n, out  a, 0x0);
    }
    
    public static void xdebugr1outeven(int n, out double[] a, alglib.xparams _xparams)
    {
        _core_xdebugr1outeven( n, out  a, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe complex _core_xdebugc1sum(complex[] a, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        alglib.complex result;
        alglib.complex _d_result;
        x_vector _d_a = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a){
                _d_result.x = 0;
                _d_result.y = 0;
                x_vector_attach_to_array(ref _d_a, _fp_a, ap.len(a));
                _error_code = _i_xv2_xdebugc1sum(&_s_errormsg, &_d_result, &_d_a, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "xdebugc1sum");
            result.x = _d_result.x;
            result.y = _d_result.y;
        }
        finally
        {
            x_vector_clear(ref _d_a);
        }
        return result;
    }
    
    public static alglib.complex xdebugc1sum(complex[] a)
    {
        return _core_xdebugc1sum( a, 0x0);
    }
    
    public static alglib.complex xdebugc1sum(complex[] a, alglib.xparams _xparams)
    {
        return _core_xdebugc1sum( a, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_xdebugc1neg(ref complex[] a, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_a = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a){
                x_vector_attach_to_array(ref _d_a, _fp_a, ap.len(a));
                _error_code = _i_xv2_xdebugc1neg(&_s_errormsg, &_d_a, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "xdebugc1neg");
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_a, ref a);
            if( a == null )
                a = new alglib.complex[0];
        }
        finally
        {
            x_vector_clear(ref _d_a);
        }
        // This function returns no value.
    }
    
    public static void xdebugc1neg(ref complex[] a)
    {
        _core_xdebugc1neg(ref  a, 0x0);
    }
    
    public static void xdebugc1neg(ref complex[] a, alglib.xparams _xparams)
    {
        _core_xdebugc1neg(ref  a, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_xdebugc1appendcopy(ref complex[] a, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_a = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a){
                x_vector_attach_to_array(ref _d_a, _fp_a, ap.len(a));
                _error_code = _i_xv2_xdebugc1appendcopy(&_s_errormsg, &_d_a, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "xdebugc1appendcopy");
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_a, ref a);
            if( a == null )
                a = new alglib.complex[0];
        }
        finally
        {
            x_vector_clear(ref _d_a);
        }
        // This function returns no value.
    }
    
    public static void xdebugc1appendcopy(ref complex[] a)
    {
        _core_xdebugc1appendcopy(ref  a, 0x0);
    }
    
    public static void xdebugc1appendcopy(ref complex[] a, alglib.xparams _xparams)
    {
        _core_xdebugc1appendcopy(ref  a, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_xdebugc1outeven(int n, out complex[] a, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        x_vector _d_a = new x_vector();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_a, DT_COMPLEX);
            a = null;
            _error_code = _i_xv2_xdebugc1outeven(&_s_errormsg, &_d_n, &_d_a, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "xdebugc1outeven");
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_a, ref a);
            if( a == null )
                a = new alglib.complex[0];
        }
        finally
        {
            x_vector_clear(ref _d_a);
        }
        // This function returns no value.
    }
    
    public static void xdebugc1outeven(int n, out complex[] a)
    {
        _core_xdebugc1outeven( n, out  a, 0x0);
    }
    
    public static void xdebugc1outeven(int n, out complex[] a, alglib.xparams _xparams)
    {
        _core_xdebugc1outeven( n, out  a, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe int _core_xdebugb2count(bool[,] a, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        int result;
        x_int _d_result = new x_int();
        x_matrix _d_a = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(bool* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                _error_code = _i_xv2_xdebugb2count(&_s_errormsg, &_d_result, &_d_a, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "xdebugb2count");
            result = _d_result.intval;
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        return result;
    }
    
    public static int xdebugb2count(bool[,] a)
    {
        return _core_xdebugb2count( a, 0x0);
    }
    
    public static int xdebugb2count(bool[,] a, alglib.xparams _xparams)
    {
        return _core_xdebugb2count( a, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_xdebugb2not(ref bool[,] a, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(bool* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                _error_code = _i_xv2_xdebugb2not(&_s_errormsg, &_d_a, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "xdebugb2not");
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new bool[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        // This function returns no value.
    }
    
    public static void xdebugb2not(ref bool[,] a)
    {
        _core_xdebugb2not(ref  a, 0x0);
    }
    
    public static void xdebugb2not(ref bool[,] a, alglib.xparams _xparams)
    {
        _core_xdebugb2not(ref  a, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_xdebugb2transpose(ref bool[,] a, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(bool* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                _error_code = _i_xv2_xdebugb2transpose(&_s_errormsg, &_d_a, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "xdebugb2transpose");
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new bool[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        // This function returns no value.
    }
    
    public static void xdebugb2transpose(ref bool[,] a)
    {
        _core_xdebugb2transpose(ref  a, 0x0);
    }
    
    public static void xdebugb2transpose(ref bool[,] a, alglib.xparams _xparams)
    {
        _core_xdebugb2transpose(ref  a, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_xdebugb2outsin(int m, int n, out bool[,] a, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_matrix _d_a = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            x_matrix_create_empty(ref _d_a, DT_BOOL);
            a = null;
            _error_code = _i_xv2_xdebugb2outsin(&_s_errormsg, &_d_m, &_d_n, &_d_a, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "xdebugb2outsin");
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new bool[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        // This function returns no value.
    }
    
    public static void xdebugb2outsin(int m, int n, out bool[,] a)
    {
        _core_xdebugb2outsin( m,  n, out  a, 0x0);
    }
    
    public static void xdebugb2outsin(int m, int n, out bool[,] a, alglib.xparams _xparams)
    {
        _core_xdebugb2outsin( m,  n, out  a, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe int _core_xdebugi2sum(int[,] a, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        int result;
        x_int _d_result = new x_int();
        x_matrix _d_a = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            x_matrix_from_array(ref _d_a, a, X_CREATE);
            _error_code = _i_xv2_xdebugi2sum(&_s_errormsg, &_d_result, &_d_a, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "xdebugi2sum");
            result = _d_result.intval;
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        return result;
    }
    
    public static int xdebugi2sum(int[,] a)
    {
        return _core_xdebugi2sum( a, 0x0);
    }
    
    public static int xdebugi2sum(int[,] a, alglib.xparams _xparams)
    {
        return _core_xdebugi2sum( a, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_xdebugi2neg(ref int[,] a, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            x_matrix_from_array(ref _d_a, a, X_CREATE);
            _error_code = _i_xv2_xdebugi2neg(&_s_errormsg, &_d_a, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "xdebugi2neg");
            x_matrix_to_array(ref _d_a, ref a);
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        // This function returns no value.
    }
    
    public static void xdebugi2neg(ref int[,] a)
    {
        _core_xdebugi2neg(ref  a, 0x0);
    }
    
    public static void xdebugi2neg(ref int[,] a, alglib.xparams _xparams)
    {
        _core_xdebugi2neg(ref  a, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_xdebugi2transpose(ref int[,] a, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            x_matrix_from_array(ref _d_a, a, X_CREATE);
            _error_code = _i_xv2_xdebugi2transpose(&_s_errormsg, &_d_a, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "xdebugi2transpose");
            x_matrix_to_array(ref _d_a, ref a);
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        // This function returns no value.
    }
    
    public static void xdebugi2transpose(ref int[,] a)
    {
        _core_xdebugi2transpose(ref  a, 0x0);
    }
    
    public static void xdebugi2transpose(ref int[,] a, alglib.xparams _xparams)
    {
        _core_xdebugi2transpose(ref  a, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_xdebugi2outsin(int m, int n, out int[,] a, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_matrix _d_a = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            x_matrix_create_empty(ref _d_a, DT_INT);
            a = null;
            _error_code = _i_xv2_xdebugi2outsin(&_s_errormsg, &_d_m, &_d_n, &_d_a, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "xdebugi2outsin");
            x_matrix_to_array(ref _d_a, ref a);
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        // This function returns no value.
    }
    
    public static void xdebugi2outsin(int m, int n, out int[,] a)
    {
        _core_xdebugi2outsin( m,  n, out  a, 0x0);
    }
    
    public static void xdebugi2outsin(int m, int n, out int[,] a, alglib.xparams _xparams)
    {
        _core_xdebugi2outsin( m,  n, out  a, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_xdebugr2sum(double[,] a, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_matrix _d_a = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                _error_code = _i_xv2_xdebugr2sum(&_s_errormsg, &_d_result, &_d_a, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "xdebugr2sum");
            result = _d_result;
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        return result;
    }
    
    public static double xdebugr2sum(double[,] a)
    {
        return _core_xdebugr2sum( a, 0x0);
    }
    
    public static double xdebugr2sum(double[,] a, alglib.xparams _xparams)
    {
        return _core_xdebugr2sum( a, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_xdebugr2neg(ref double[,] a, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                _error_code = _i_xv2_xdebugr2neg(&_s_errormsg, &_d_a, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "xdebugr2neg");
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        // This function returns no value.
    }
    
    public static void xdebugr2neg(ref double[,] a)
    {
        _core_xdebugr2neg(ref  a, 0x0);
    }
    
    public static void xdebugr2neg(ref double[,] a, alglib.xparams _xparams)
    {
        _core_xdebugr2neg(ref  a, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_xdebugr2transpose(ref double[,] a, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                _error_code = _i_xv2_xdebugr2transpose(&_s_errormsg, &_d_a, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "xdebugr2transpose");
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        // This function returns no value.
    }
    
    public static void xdebugr2transpose(ref double[,] a)
    {
        _core_xdebugr2transpose(ref  a, 0x0);
    }
    
    public static void xdebugr2transpose(ref double[,] a, alglib.xparams _xparams)
    {
        _core_xdebugr2transpose(ref  a, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_xdebugr2outsin(int m, int n, out double[,] a, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_matrix _d_a = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            x_matrix_create_empty(ref _d_a, DT_REAL);
            a = null;
            _error_code = _i_xv2_xdebugr2outsin(&_s_errormsg, &_d_m, &_d_n, &_d_a, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "xdebugr2outsin");
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        // This function returns no value.
    }
    
    public static void xdebugr2outsin(int m, int n, out double[,] a)
    {
        _core_xdebugr2outsin( m,  n, out  a, 0x0);
    }
    
    public static void xdebugr2outsin(int m, int n, out double[,] a, alglib.xparams _xparams)
    {
        _core_xdebugr2outsin( m,  n, out  a, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe complex _core_xdebugc2sum(complex[,] a, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        alglib.complex result;
        alglib.complex _d_result;
        x_matrix _d_a = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a){
                _d_result.x = 0;
                _d_result.y = 0;
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                _error_code = _i_xv2_xdebugc2sum(&_s_errormsg, &_d_result, &_d_a, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "xdebugc2sum");
            result.x = _d_result.x;
            result.y = _d_result.y;
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        return result;
    }
    
    public static alglib.complex xdebugc2sum(complex[,] a)
    {
        return _core_xdebugc2sum( a, 0x0);
    }
    
    public static alglib.complex xdebugc2sum(complex[,] a, alglib.xparams _xparams)
    {
        return _core_xdebugc2sum( a, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_xdebugc2neg(ref complex[,] a, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                _error_code = _i_xv2_xdebugc2neg(&_s_errormsg, &_d_a, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "xdebugc2neg");
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new alglib.complex[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        // This function returns no value.
    }
    
    public static void xdebugc2neg(ref complex[,] a)
    {
        _core_xdebugc2neg(ref  a, 0x0);
    }
    
    public static void xdebugc2neg(ref complex[,] a, alglib.xparams _xparams)
    {
        _core_xdebugc2neg(ref  a, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_xdebugc2transpose(ref complex[,] a, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                _error_code = _i_xv2_xdebugc2transpose(&_s_errormsg, &_d_a, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "xdebugc2transpose");
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new alglib.complex[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        // This function returns no value.
    }
    
    public static void xdebugc2transpose(ref complex[,] a)
    {
        _core_xdebugc2transpose(ref  a, 0x0);
    }
    
    public static void xdebugc2transpose(ref complex[,] a, alglib.xparams _xparams)
    {
        _core_xdebugc2transpose(ref  a, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_xdebugc2outsincos(int m, int n, out complex[,] a, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_matrix _d_a = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            x_matrix_create_empty(ref _d_a, DT_COMPLEX);
            a = null;
            _error_code = _i_xv2_xdebugc2outsincos(&_s_errormsg, &_d_m, &_d_n, &_d_a, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "xdebugc2outsincos");
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new alglib.complex[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        // This function returns no value.
    }
    
    public static void xdebugc2outsincos(int m, int n, out complex[,] a)
    {
        _core_xdebugc2outsincos( m,  n, out  a, 0x0);
    }
    
    public static void xdebugc2outsincos(int m, int n, out complex[,] a, alglib.xparams _xparams)
    {
        _core_xdebugc2outsincos( m,  n, out  a, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_xdebugmaskedbiasedproductsum(int m, int n, double[,] a, double[,] b, bool[,] c, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_matrix _d_a = new x_matrix();
        x_matrix _d_b = new x_matrix();
        x_matrix _d_c = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a, _fp_b = b){fixed(bool* _fp_c = c){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matrix_attach_to_array(ref _d_b, _fp_b, ap.rows(b), ap.cols(b));
                x_matrix_attach_to_array(ref _d_c, _fp_c, ap.rows(c), ap.cols(c));
                _error_code = _i_xv2_xdebugmaskedbiasedproductsum(&_s_errormsg, &_d_result, &_d_m, &_d_n, &_d_a, &_d_b, &_d_c, _xparams);
            }}
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "xdebugmaskedbiasedproductsum");
            result = _d_result;
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matrix_clear(ref _d_b);
            x_matrix_clear(ref _d_c);
        }
        return result;
    }
    
    public static double xdebugmaskedbiasedproductsum(int m, int n, double[,] a, double[,] b, bool[,] c)
    {
        return _core_xdebugmaskedbiasedproductsum( m,  n,  a,  b,  c, 0x0);
    }
    
    public static double xdebugmaskedbiasedproductsum(int m, int n, double[,] a, double[,] b, bool[,] c, alglib.xparams _xparams)
    {
        return _core_xdebugmaskedbiasedproductsum( m,  n,  a,  b,  c, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage nearestneighbor
    //
    

    public unsafe class kdtreerequestbuffer : alglibobject
    {
        private void *_ptr;
        public kdtreerequestbuffer(void *x)
        {
            _ptr = x;
        }
        ~kdtreerequestbuffer()
        {
            _deallocate();
        }
        public void* ptr { get { return _ptr; } }
        public override alglib.alglibobject make_copy()
        {
            if( _ptr==null )
                return new kdtreerequestbuffer(null);
            return new kdtreerequestbuffer(_i_x_obj_copy_kdtreerequestbuffer(_ptr));
        }
        public override void _deallocate()
        {
            if( _ptr!=null )
                _i_x_obj_free_kdtreerequestbuffer(_ptr);
            _ptr = null;
            System.GC.SuppressFinalize(this);
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_kdtreerequestbuffer(void *x);
    private static _d_x_obj_copy_kdtreerequestbuffer _i_x_obj_copy_kdtreerequestbuffer = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_obj_free_kdtreerequestbuffer(void *x);
    private static _d_x_obj_free_kdtreerequestbuffer _i_x_obj_free_kdtreerequestbuffer = null;

    public unsafe class kdtree : alglibobject
    {
        private void *_ptr;
        public kdtree(void *x)
        {
            _ptr = x;
        }
        ~kdtree()
        {
            _deallocate();
        }
        public void* ptr { get { return _ptr; } }
        public override alglib.alglibobject make_copy()
        {
            if( _ptr==null )
                return new kdtree(null);
            return new kdtree(_i_x_obj_copy_kdtree(_ptr));
        }
        public override void _deallocate()
        {
            if( _ptr!=null )
                _i_x_obj_free_kdtree(_ptr);
            _ptr = null;
            System.GC.SuppressFinalize(this);
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_kdtree(void *x);
    private static _d_x_obj_copy_kdtree _i_x_obj_copy_kdtree = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_obj_free_kdtree(void *x);
    private static _d_x_obj_free_kdtree _i_x_obj_free_kdtree = null;
    public static unsafe void kdtreeserialize(kdtree obj, out string s_out)
    {
        byte *_s_errormsg = null;
        byte *_out = null;
        void *_x = obj.ptr;
        try
        {
            int _error_code = _i_x_kdtreeserialize(&_s_errormsg, &_x, &_out);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "kdtreeserialize");
            s_out = Marshal.PtrToStringAnsi((IntPtr)_out);
        }
        finally
        {
            x_free((IntPtr)_out);
        }
    }
    
    public static unsafe void kdtreeunserialize(string s_in, out kdtree obj)
    {
        byte *_s_errormsg = null;
        byte[] _ain = System.Text.Encoding.UTF8.GetBytes(s_in);
        fixed(byte *_pin = _ain )
        {
            byte *_in = _pin;
            void *_x = null;
            obj = null;
            try
            {
                int _error_code = _i_x_kdtreeunserialize(&_s_errormsg, &_in, &_x);
                if( _error_code!=X_OK )
                    handle_exception(_error_code, _s_errormsg, "kdtreeunserialize");
                obj = new kdtree(_x);
            }
            finally
            {
                // on exception clean up X objects which were not attached to C# objects
                if( _x!=null && obj==null)
                    _i_x_obj_free_kdtree(_x);
            }
        }
    }
    public static unsafe void kdtreeserialize(kdtree obj, System.IO.Stream s_out)
    {
        byte *_s_errormsg = null;
        void *_x = obj.ptr;
        alglib.native_stream_adapter a = new alglib.native_stream_adapter();
        a.sstart_stream(s_out);
        int _error_code = _i_x_kdtreeserialize_stream(&_s_errormsg, &_x, a.writer_callback, IntPtr.Zero);
        if( _error_code!=X_OK )
            handle_exception(_error_code, _s_errormsg, "kdtreeserialize");
    }
    
    public static unsafe void kdtreeunserialize(System.IO.Stream s_in, out kdtree obj)
    {
        byte *_s_errormsg = null;
        void *_x = null;
        obj = null;
        alglib.native_stream_adapter a = new alglib.native_stream_adapter();
        a.ustart_stream(s_in);
        try
        {
            int _error_code = _i_x_kdtreeunserialize_stream(&_s_errormsg, a.reader_callback, IntPtr.Zero, &_x);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "kdtreeunserialize");
            obj = new kdtree(_x);
        }
        finally
        {
            // on exception clean up X objects which were not attached to C# objects
            if( _x!=null && obj==null)
                _i_x_obj_free_kdtree(_x);
        }
    }
    
    private static unsafe void _core_kdtreebuild(double[,] xy, int n, int nx, int ny, int normtype, out kdtree kdt, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_xy = new x_matrix();
        x_int _d_n = new x_int(n);
        x_int _d_nx = new x_int(nx);
        x_int _d_ny = new x_int(ny);
        x_int _d_normtype = new x_int(normtype);
        void *_d_kdt = null;
        kdt = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_xv2_kdtreebuild(&_s_errormsg, &_d_xy, &_d_n, &_d_nx, &_d_ny, &_d_normtype, &_d_kdt, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "kdtreebuild");
            kdt = new kdtree(_d_kdt);
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
            if( _d_kdt!=null && kdt==null)
                _i_x_obj_free_kdtree(_d_kdt); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void kdtreebuild(double[,] xy, int n, int nx, int ny, int normtype, out kdtree kdt)
    {
        _core_kdtreebuild( xy,  n,  nx,  ny,  normtype, out  kdt, 0x0);
    }
    
    public static void kdtreebuild(double[,] xy, int n, int nx, int ny, int normtype, out kdtree kdt, alglib.xparams _xparams)
    {
        _core_kdtreebuild( xy,  n,  nx,  ny,  normtype, out  kdt, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void kdtreebuild(double[,] xy, int nx, int ny, int normtype, out kdtree kdt)
    {
        int n;
    
        n = ap.rows(xy);
        _core_kdtreebuild( xy,  n,  nx,  ny,  normtype, out  kdt, 0x0);
    
        
    }
    
    public static void kdtreebuild(double[,] xy, int nx, int ny, int normtype, out kdtree kdt, alglib.xparams _xparams)
    {
        int n;
    
        n = ap.rows(xy);
        _core_kdtreebuild( xy,  n,  nx,  ny,  normtype, out  kdt, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_kdtreebuildtagged(double[,] xy, int[] tags, int n, int nx, int ny, int normtype, out kdtree kdt, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_xy = new x_matrix();
        x_vector _d_tags = new x_vector();
        x_int _d_n = new x_int(n);
        x_int _d_nx = new x_int(nx);
        x_int _d_ny = new x_int(ny);
        x_int _d_normtype = new x_int(normtype);
        void *_d_kdt = null;
        kdt = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                x_vector_from_array(ref _d_tags, tags, X_CREATE);
                _error_code = _i_xv2_kdtreebuildtagged(&_s_errormsg, &_d_xy, &_d_tags, &_d_n, &_d_nx, &_d_ny, &_d_normtype, &_d_kdt, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "kdtreebuildtagged");
            kdt = new kdtree(_d_kdt);
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
            x_vector_clear(ref _d_tags);
            if( _d_kdt!=null && kdt==null)
                _i_x_obj_free_kdtree(_d_kdt); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void kdtreebuildtagged(double[,] xy, int[] tags, int n, int nx, int ny, int normtype, out kdtree kdt)
    {
        _core_kdtreebuildtagged( xy,  tags,  n,  nx,  ny,  normtype, out  kdt, 0x0);
    }
    
    public static void kdtreebuildtagged(double[,] xy, int[] tags, int n, int nx, int ny, int normtype, out kdtree kdt, alglib.xparams _xparams)
    {
        _core_kdtreebuildtagged( xy,  tags,  n,  nx,  ny,  normtype, out  kdt, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void kdtreebuildtagged(double[,] xy, int[] tags, int nx, int ny, int normtype, out kdtree kdt)
    {
        int n;
        if( (ap.rows(xy)!=ap.len(tags)))
            throw new alglibexception("Error while calling 'kdtreebuildtagged': looks like one of arguments has wrong size");
        n = ap.rows(xy);
        _core_kdtreebuildtagged( xy,  tags,  n,  nx,  ny,  normtype, out  kdt, 0x0);
    
        
    }
    
    public static void kdtreebuildtagged(double[,] xy, int[] tags, int nx, int ny, int normtype, out kdtree kdt, alglib.xparams _xparams)
    {
        int n;
        if( (ap.rows(xy)!=ap.len(tags)))
            throw new alglibexception("Error while calling 'kdtreebuildtagged': looks like one of arguments has wrong size");
        n = ap.rows(xy);
        _core_kdtreebuildtagged( xy,  tags,  n,  nx,  ny,  normtype, out  kdt, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_kdtreecreaterequestbuffer(kdtree kdt, out kdtreerequestbuffer buf, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_kdt = kdt.ptr;
        void *_d_buf = null;
        buf = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_kdtreecreaterequestbuffer(&_s_errormsg, &_d_kdt, &_d_buf, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "kdtreecreaterequestbuffer");
            ap.assert(kdt.ptr==_d_kdt, "ALGLIB: internal error (reference changed for non-out X-object)");
            buf = new kdtreerequestbuffer(_d_buf);
        }
        finally
        {
            if( _d_buf!=null && buf==null)
                _i_x_obj_free_kdtreerequestbuffer(_d_buf); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void kdtreecreaterequestbuffer(kdtree kdt, out kdtreerequestbuffer buf)
    {
        _core_kdtreecreaterequestbuffer( kdt, out  buf, 0x0);
    }
    
    public static void kdtreecreaterequestbuffer(kdtree kdt, out kdtreerequestbuffer buf, alglib.xparams _xparams)
    {
        _core_kdtreecreaterequestbuffer( kdt, out  buf, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe int _core_kdtreequeryknn(kdtree kdt, double[] x, int k, bool selfmatch, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        int result;
        x_int _d_result = new x_int();
        void *_d_kdt = kdt.ptr;
        x_vector _d_x = new x_vector();
        x_int _d_k = new x_int(k);
        byte _d_selfmatch = (byte)(selfmatch ? 1 : 0);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_xv2_kdtreequeryknn(&_s_errormsg, &_d_result, &_d_kdt, &_d_x, &_d_k, &_d_selfmatch, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "kdtreequeryknn");
            result = _d_result.intval;
            ap.assert(kdt.ptr==_d_kdt, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_x);
        }
        return result;
    }
    
    public static int kdtreequeryknn(kdtree kdt, double[] x, int k, bool selfmatch)
    {
        return _core_kdtreequeryknn( kdt,  x,  k,  selfmatch, 0x0);
    }
    
    public static int kdtreequeryknn(kdtree kdt, double[] x, int k, bool selfmatch, alglib.xparams _xparams)
    {
        return _core_kdtreequeryknn( kdt,  x,  k,  selfmatch, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static int kdtreequeryknn(kdtree kdt, double[] x, int k)
    {
        bool selfmatch;
    
        selfmatch = true;
        int result = _core_kdtreequeryknn( kdt,  x,  k,  selfmatch, 0x0);
    
        return result;
    }
    
    public static int kdtreequeryknn(kdtree kdt, double[] x, int k, alglib.xparams _xparams)
    {
        bool selfmatch;
    
        selfmatch = true;
        int result = _core_kdtreequeryknn( kdt,  x,  k,  selfmatch, _xparams==null ? 0x0 : _xparams.flags);
    
        return result;
    }
    
    private static unsafe int _core_kdtreetsqueryknn(kdtree kdt, kdtreerequestbuffer buf, double[] x, int k, bool selfmatch, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        int result;
        x_int _d_result = new x_int();
        void *_d_kdt = kdt.ptr;
        void *_d_buf = buf.ptr;
        x_vector _d_x = new x_vector();
        x_int _d_k = new x_int(k);
        byte _d_selfmatch = (byte)(selfmatch ? 1 : 0);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_xv2_kdtreetsqueryknn(&_s_errormsg, &_d_result, &_d_kdt, &_d_buf, &_d_x, &_d_k, &_d_selfmatch, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "kdtreetsqueryknn");
            result = _d_result.intval;
            ap.assert(kdt.ptr==_d_kdt, "ALGLIB: internal error (reference changed for non-out X-object)");
            ap.assert(buf.ptr==_d_buf, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_x);
        }
        return result;
    }
    
    public static int kdtreetsqueryknn(kdtree kdt, kdtreerequestbuffer buf, double[] x, int k, bool selfmatch)
    {
        return _core_kdtreetsqueryknn( kdt,  buf,  x,  k,  selfmatch, 0x0);
    }
    
    public static int kdtreetsqueryknn(kdtree kdt, kdtreerequestbuffer buf, double[] x, int k, bool selfmatch, alglib.xparams _xparams)
    {
        return _core_kdtreetsqueryknn( kdt,  buf,  x,  k,  selfmatch, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static int kdtreetsqueryknn(kdtree kdt, kdtreerequestbuffer buf, double[] x, int k)
    {
        bool selfmatch;
    
        selfmatch = true;
        int result = _core_kdtreetsqueryknn( kdt,  buf,  x,  k,  selfmatch, 0x0);
    
        return result;
    }
    
    public static int kdtreetsqueryknn(kdtree kdt, kdtreerequestbuffer buf, double[] x, int k, alglib.xparams _xparams)
    {
        bool selfmatch;
    
        selfmatch = true;
        int result = _core_kdtreetsqueryknn( kdt,  buf,  x,  k,  selfmatch, _xparams==null ? 0x0 : _xparams.flags);
    
        return result;
    }
    
    private static unsafe int _core_kdtreequeryrnn(kdtree kdt, double[] x, double r, bool selfmatch, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        int result;
        x_int _d_result = new x_int();
        void *_d_kdt = kdt.ptr;
        x_vector _d_x = new x_vector();
        double _d_r = r;
        byte _d_selfmatch = (byte)(selfmatch ? 1 : 0);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_xv2_kdtreequeryrnn(&_s_errormsg, &_d_result, &_d_kdt, &_d_x, &_d_r, &_d_selfmatch, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "kdtreequeryrnn");
            result = _d_result.intval;
            ap.assert(kdt.ptr==_d_kdt, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_x);
        }
        return result;
    }
    
    public static int kdtreequeryrnn(kdtree kdt, double[] x, double r, bool selfmatch)
    {
        return _core_kdtreequeryrnn( kdt,  x,  r,  selfmatch, 0x0);
    }
    
    public static int kdtreequeryrnn(kdtree kdt, double[] x, double r, bool selfmatch, alglib.xparams _xparams)
    {
        return _core_kdtreequeryrnn( kdt,  x,  r,  selfmatch, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static int kdtreequeryrnn(kdtree kdt, double[] x, double r)
    {
        bool selfmatch;
    
        selfmatch = true;
        int result = _core_kdtreequeryrnn( kdt,  x,  r,  selfmatch, 0x0);
    
        return result;
    }
    
    public static int kdtreequeryrnn(kdtree kdt, double[] x, double r, alglib.xparams _xparams)
    {
        bool selfmatch;
    
        selfmatch = true;
        int result = _core_kdtreequeryrnn( kdt,  x,  r,  selfmatch, _xparams==null ? 0x0 : _xparams.flags);
    
        return result;
    }
    
    private static unsafe int _core_kdtreequeryrnnu(kdtree kdt, double[] x, double r, bool selfmatch, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        int result;
        x_int _d_result = new x_int();
        void *_d_kdt = kdt.ptr;
        x_vector _d_x = new x_vector();
        double _d_r = r;
        byte _d_selfmatch = (byte)(selfmatch ? 1 : 0);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_xv2_kdtreequeryrnnu(&_s_errormsg, &_d_result, &_d_kdt, &_d_x, &_d_r, &_d_selfmatch, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "kdtreequeryrnnu");
            result = _d_result.intval;
            ap.assert(kdt.ptr==_d_kdt, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_x);
        }
        return result;
    }
    
    public static int kdtreequeryrnnu(kdtree kdt, double[] x, double r, bool selfmatch)
    {
        return _core_kdtreequeryrnnu( kdt,  x,  r,  selfmatch, 0x0);
    }
    
    public static int kdtreequeryrnnu(kdtree kdt, double[] x, double r, bool selfmatch, alglib.xparams _xparams)
    {
        return _core_kdtreequeryrnnu( kdt,  x,  r,  selfmatch, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static int kdtreequeryrnnu(kdtree kdt, double[] x, double r)
    {
        bool selfmatch;
    
        selfmatch = true;
        int result = _core_kdtreequeryrnnu( kdt,  x,  r,  selfmatch, 0x0);
    
        return result;
    }
    
    public static int kdtreequeryrnnu(kdtree kdt, double[] x, double r, alglib.xparams _xparams)
    {
        bool selfmatch;
    
        selfmatch = true;
        int result = _core_kdtreequeryrnnu( kdt,  x,  r,  selfmatch, _xparams==null ? 0x0 : _xparams.flags);
    
        return result;
    }
    
    private static unsafe int _core_kdtreetsqueryrnn(kdtree kdt, kdtreerequestbuffer buf, double[] x, double r, bool selfmatch, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        int result;
        x_int _d_result = new x_int();
        void *_d_kdt = kdt.ptr;
        void *_d_buf = buf.ptr;
        x_vector _d_x = new x_vector();
        double _d_r = r;
        byte _d_selfmatch = (byte)(selfmatch ? 1 : 0);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_xv2_kdtreetsqueryrnn(&_s_errormsg, &_d_result, &_d_kdt, &_d_buf, &_d_x, &_d_r, &_d_selfmatch, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "kdtreetsqueryrnn");
            result = _d_result.intval;
            ap.assert(kdt.ptr==_d_kdt, "ALGLIB: internal error (reference changed for non-out X-object)");
            ap.assert(buf.ptr==_d_buf, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_x);
        }
        return result;
    }
    
    public static int kdtreetsqueryrnn(kdtree kdt, kdtreerequestbuffer buf, double[] x, double r, bool selfmatch)
    {
        return _core_kdtreetsqueryrnn( kdt,  buf,  x,  r,  selfmatch, 0x0);
    }
    
    public static int kdtreetsqueryrnn(kdtree kdt, kdtreerequestbuffer buf, double[] x, double r, bool selfmatch, alglib.xparams _xparams)
    {
        return _core_kdtreetsqueryrnn( kdt,  buf,  x,  r,  selfmatch, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static int kdtreetsqueryrnn(kdtree kdt, kdtreerequestbuffer buf, double[] x, double r)
    {
        bool selfmatch;
    
        selfmatch = true;
        int result = _core_kdtreetsqueryrnn( kdt,  buf,  x,  r,  selfmatch, 0x0);
    
        return result;
    }
    
    public static int kdtreetsqueryrnn(kdtree kdt, kdtreerequestbuffer buf, double[] x, double r, alglib.xparams _xparams)
    {
        bool selfmatch;
    
        selfmatch = true;
        int result = _core_kdtreetsqueryrnn( kdt,  buf,  x,  r,  selfmatch, _xparams==null ? 0x0 : _xparams.flags);
    
        return result;
    }
    
    private static unsafe int _core_kdtreetsqueryrnnu(kdtree kdt, kdtreerequestbuffer buf, double[] x, double r, bool selfmatch, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        int result;
        x_int _d_result = new x_int();
        void *_d_kdt = kdt.ptr;
        void *_d_buf = buf.ptr;
        x_vector _d_x = new x_vector();
        double _d_r = r;
        byte _d_selfmatch = (byte)(selfmatch ? 1 : 0);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_xv2_kdtreetsqueryrnnu(&_s_errormsg, &_d_result, &_d_kdt, &_d_buf, &_d_x, &_d_r, &_d_selfmatch, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "kdtreetsqueryrnnu");
            result = _d_result.intval;
            ap.assert(kdt.ptr==_d_kdt, "ALGLIB: internal error (reference changed for non-out X-object)");
            ap.assert(buf.ptr==_d_buf, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_x);
        }
        return result;
    }
    
    public static int kdtreetsqueryrnnu(kdtree kdt, kdtreerequestbuffer buf, double[] x, double r, bool selfmatch)
    {
        return _core_kdtreetsqueryrnnu( kdt,  buf,  x,  r,  selfmatch, 0x0);
    }
    
    public static int kdtreetsqueryrnnu(kdtree kdt, kdtreerequestbuffer buf, double[] x, double r, bool selfmatch, alglib.xparams _xparams)
    {
        return _core_kdtreetsqueryrnnu( kdt,  buf,  x,  r,  selfmatch, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static int kdtreetsqueryrnnu(kdtree kdt, kdtreerequestbuffer buf, double[] x, double r)
    {
        bool selfmatch;
    
        selfmatch = true;
        int result = _core_kdtreetsqueryrnnu( kdt,  buf,  x,  r,  selfmatch, 0x0);
    
        return result;
    }
    
    public static int kdtreetsqueryrnnu(kdtree kdt, kdtreerequestbuffer buf, double[] x, double r, alglib.xparams _xparams)
    {
        bool selfmatch;
    
        selfmatch = true;
        int result = _core_kdtreetsqueryrnnu( kdt,  buf,  x,  r,  selfmatch, _xparams==null ? 0x0 : _xparams.flags);
    
        return result;
    }
    
    private static unsafe int _core_kdtreequeryaknn(kdtree kdt, double[] x, int k, bool selfmatch, double eps, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        int result;
        x_int _d_result = new x_int();
        void *_d_kdt = kdt.ptr;
        x_vector _d_x = new x_vector();
        x_int _d_k = new x_int(k);
        byte _d_selfmatch = (byte)(selfmatch ? 1 : 0);
        double _d_eps = eps;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_xv2_kdtreequeryaknn(&_s_errormsg, &_d_result, &_d_kdt, &_d_x, &_d_k, &_d_selfmatch, &_d_eps, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "kdtreequeryaknn");
            result = _d_result.intval;
            ap.assert(kdt.ptr==_d_kdt, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_x);
        }
        return result;
    }
    
    public static int kdtreequeryaknn(kdtree kdt, double[] x, int k, bool selfmatch, double eps)
    {
        return _core_kdtreequeryaknn( kdt,  x,  k,  selfmatch,  eps, 0x0);
    }
    
    public static int kdtreequeryaknn(kdtree kdt, double[] x, int k, bool selfmatch, double eps, alglib.xparams _xparams)
    {
        return _core_kdtreequeryaknn( kdt,  x,  k,  selfmatch,  eps, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static int kdtreequeryaknn(kdtree kdt, double[] x, int k, double eps)
    {
        bool selfmatch;
    
        selfmatch = true;
        int result = _core_kdtreequeryaknn( kdt,  x,  k,  selfmatch,  eps, 0x0);
    
        return result;
    }
    
    public static int kdtreequeryaknn(kdtree kdt, double[] x, int k, double eps, alglib.xparams _xparams)
    {
        bool selfmatch;
    
        selfmatch = true;
        int result = _core_kdtreequeryaknn( kdt,  x,  k,  selfmatch,  eps, _xparams==null ? 0x0 : _xparams.flags);
    
        return result;
    }
    
    private static unsafe int _core_kdtreetsqueryaknn(kdtree kdt, kdtreerequestbuffer buf, double[] x, int k, bool selfmatch, double eps, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        int result;
        x_int _d_result = new x_int();
        void *_d_kdt = kdt.ptr;
        void *_d_buf = buf.ptr;
        x_vector _d_x = new x_vector();
        x_int _d_k = new x_int(k);
        byte _d_selfmatch = (byte)(selfmatch ? 1 : 0);
        double _d_eps = eps;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_xv2_kdtreetsqueryaknn(&_s_errormsg, &_d_result, &_d_kdt, &_d_buf, &_d_x, &_d_k, &_d_selfmatch, &_d_eps, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "kdtreetsqueryaknn");
            result = _d_result.intval;
            ap.assert(kdt.ptr==_d_kdt, "ALGLIB: internal error (reference changed for non-out X-object)");
            ap.assert(buf.ptr==_d_buf, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_x);
        }
        return result;
    }
    
    public static int kdtreetsqueryaknn(kdtree kdt, kdtreerequestbuffer buf, double[] x, int k, bool selfmatch, double eps)
    {
        return _core_kdtreetsqueryaknn( kdt,  buf,  x,  k,  selfmatch,  eps, 0x0);
    }
    
    public static int kdtreetsqueryaknn(kdtree kdt, kdtreerequestbuffer buf, double[] x, int k, bool selfmatch, double eps, alglib.xparams _xparams)
    {
        return _core_kdtreetsqueryaknn( kdt,  buf,  x,  k,  selfmatch,  eps, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static int kdtreetsqueryaknn(kdtree kdt, kdtreerequestbuffer buf, double[] x, int k, double eps)
    {
        bool selfmatch;
    
        selfmatch = true;
        int result = _core_kdtreetsqueryaknn( kdt,  buf,  x,  k,  selfmatch,  eps, 0x0);
    
        return result;
    }
    
    public static int kdtreetsqueryaknn(kdtree kdt, kdtreerequestbuffer buf, double[] x, int k, double eps, alglib.xparams _xparams)
    {
        bool selfmatch;
    
        selfmatch = true;
        int result = _core_kdtreetsqueryaknn( kdt,  buf,  x,  k,  selfmatch,  eps, _xparams==null ? 0x0 : _xparams.flags);
    
        return result;
    }
    
    private static unsafe int _core_kdtreequerybox(kdtree kdt, double[] boxmin, double[] boxmax, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        int result;
        x_int _d_result = new x_int();
        void *_d_kdt = kdt.ptr;
        x_vector _d_boxmin = new x_vector();
        x_vector _d_boxmax = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_boxmin = boxmin, _fp_boxmax = boxmax){
                x_vector_attach_to_array(ref _d_boxmin, _fp_boxmin, ap.len(boxmin));
                x_vector_attach_to_array(ref _d_boxmax, _fp_boxmax, ap.len(boxmax));
                _error_code = _i_xv2_kdtreequerybox(&_s_errormsg, &_d_result, &_d_kdt, &_d_boxmin, &_d_boxmax, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "kdtreequerybox");
            result = _d_result.intval;
            ap.assert(kdt.ptr==_d_kdt, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_boxmin);
            x_vector_clear(ref _d_boxmax);
        }
        return result;
    }
    
    public static int kdtreequerybox(kdtree kdt, double[] boxmin, double[] boxmax)
    {
        return _core_kdtreequerybox( kdt,  boxmin,  boxmax, 0x0);
    }
    
    public static int kdtreequerybox(kdtree kdt, double[] boxmin, double[] boxmax, alglib.xparams _xparams)
    {
        return _core_kdtreequerybox( kdt,  boxmin,  boxmax, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe int _core_kdtreetsquerybox(kdtree kdt, kdtreerequestbuffer buf, double[] boxmin, double[] boxmax, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        int result;
        x_int _d_result = new x_int();
        void *_d_kdt = kdt.ptr;
        void *_d_buf = buf.ptr;
        x_vector _d_boxmin = new x_vector();
        x_vector _d_boxmax = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_boxmin = boxmin, _fp_boxmax = boxmax){
                x_vector_attach_to_array(ref _d_boxmin, _fp_boxmin, ap.len(boxmin));
                x_vector_attach_to_array(ref _d_boxmax, _fp_boxmax, ap.len(boxmax));
                _error_code = _i_xv2_kdtreetsquerybox(&_s_errormsg, &_d_result, &_d_kdt, &_d_buf, &_d_boxmin, &_d_boxmax, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "kdtreetsquerybox");
            result = _d_result.intval;
            ap.assert(kdt.ptr==_d_kdt, "ALGLIB: internal error (reference changed for non-out X-object)");
            ap.assert(buf.ptr==_d_buf, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_boxmin);
            x_vector_clear(ref _d_boxmax);
        }
        return result;
    }
    
    public static int kdtreetsquerybox(kdtree kdt, kdtreerequestbuffer buf, double[] boxmin, double[] boxmax)
    {
        return _core_kdtreetsquerybox( kdt,  buf,  boxmin,  boxmax, 0x0);
    }
    
    public static int kdtreetsquerybox(kdtree kdt, kdtreerequestbuffer buf, double[] boxmin, double[] boxmax, alglib.xparams _xparams)
    {
        return _core_kdtreetsquerybox( kdt,  buf,  boxmin,  boxmax, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_kdtreequeryresultsx(kdtree kdt, ref double[,] x, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_kdt = kdt.ptr;
        x_matrix _d_x = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_matrix_attach_to_array(ref _d_x, _fp_x, ap.rows(x), ap.cols(x));
                _error_code = _i_xv2_kdtreequeryresultsx(&_s_errormsg, &_d_kdt, &_d_x, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "kdtreequeryresultsx");
            ap.assert(kdt.ptr==_d_kdt, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_x);
        }
        // This function returns no value.
    }
    
    public static void kdtreequeryresultsx(kdtree kdt, ref double[,] x)
    {
        _core_kdtreequeryresultsx( kdt, ref  x, 0x0);
    }
    
    public static void kdtreequeryresultsx(kdtree kdt, ref double[,] x, alglib.xparams _xparams)
    {
        _core_kdtreequeryresultsx( kdt, ref  x, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_kdtreequeryresultsxy(kdtree kdt, ref double[,] xy, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_kdt = kdt.ptr;
        x_matrix _d_xy = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_xv2_kdtreequeryresultsxy(&_s_errormsg, &_d_kdt, &_d_xy, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "kdtreequeryresultsxy");
            ap.assert(kdt.ptr==_d_kdt, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_xy.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_xy, ref xy);
            if( xy == null )
                xy = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
        }
        // This function returns no value.
    }
    
    public static void kdtreequeryresultsxy(kdtree kdt, ref double[,] xy)
    {
        _core_kdtreequeryresultsxy( kdt, ref  xy, 0x0);
    }
    
    public static void kdtreequeryresultsxy(kdtree kdt, ref double[,] xy, alglib.xparams _xparams)
    {
        _core_kdtreequeryresultsxy( kdt, ref  xy, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_kdtreequeryresultstags(kdtree kdt, ref int[] tags, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_kdt = kdt.ptr;
        x_vector _d_tags = new x_vector();
        
        // Pack, call, unpack
        try
        {
            x_vector_from_array(ref _d_tags, tags, X_CREATE);
            _error_code = _i_xv2_kdtreequeryresultstags(&_s_errormsg, &_d_kdt, &_d_tags, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "kdtreequeryresultstags");
            ap.assert(kdt.ptr==_d_kdt, "ALGLIB: internal error (reference changed for non-out X-object)");
            x_vector_to_array(ref _d_tags, ref tags);
        }
        finally
        {
            x_vector_clear(ref _d_tags);
        }
        // This function returns no value.
    }
    
    public static void kdtreequeryresultstags(kdtree kdt, ref int[] tags)
    {
        _core_kdtreequeryresultstags( kdt, ref  tags, 0x0);
    }
    
    public static void kdtreequeryresultstags(kdtree kdt, ref int[] tags, alglib.xparams _xparams)
    {
        _core_kdtreequeryresultstags( kdt, ref  tags, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_kdtreequeryresultsdistances(kdtree kdt, ref double[] r, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_kdt = kdt.ptr;
        x_vector _d_r = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_r = r){
                x_vector_attach_to_array(ref _d_r, _fp_r, ap.len(r));
                _error_code = _i_xv2_kdtreequeryresultsdistances(&_s_errormsg, &_d_kdt, &_d_r, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "kdtreequeryresultsdistances");
            ap.assert(kdt.ptr==_d_kdt, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_r.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_r, ref r);
            if( r == null )
                r = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_r);
        }
        // This function returns no value.
    }
    
    public static void kdtreequeryresultsdistances(kdtree kdt, ref double[] r)
    {
        _core_kdtreequeryresultsdistances( kdt, ref  r, 0x0);
    }
    
    public static void kdtreequeryresultsdistances(kdtree kdt, ref double[] r, alglib.xparams _xparams)
    {
        _core_kdtreequeryresultsdistances( kdt, ref  r, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_kdtreetsqueryresultsx(kdtree kdt, kdtreerequestbuffer buf, ref double[,] x, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_kdt = kdt.ptr;
        void *_d_buf = buf.ptr;
        x_matrix _d_x = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_matrix_attach_to_array(ref _d_x, _fp_x, ap.rows(x), ap.cols(x));
                _error_code = _i_xv2_kdtreetsqueryresultsx(&_s_errormsg, &_d_kdt, &_d_buf, &_d_x, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "kdtreetsqueryresultsx");
            ap.assert(kdt.ptr==_d_kdt, "ALGLIB: internal error (reference changed for non-out X-object)");
            ap.assert(buf.ptr==_d_buf, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_x);
        }
        // This function returns no value.
    }
    
    public static void kdtreetsqueryresultsx(kdtree kdt, kdtreerequestbuffer buf, ref double[,] x)
    {
        _core_kdtreetsqueryresultsx( kdt,  buf, ref  x, 0x0);
    }
    
    public static void kdtreetsqueryresultsx(kdtree kdt, kdtreerequestbuffer buf, ref double[,] x, alglib.xparams _xparams)
    {
        _core_kdtreetsqueryresultsx( kdt,  buf, ref  x, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_kdtreetsqueryresultsxy(kdtree kdt, kdtreerequestbuffer buf, ref double[,] xy, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_kdt = kdt.ptr;
        void *_d_buf = buf.ptr;
        x_matrix _d_xy = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_xv2_kdtreetsqueryresultsxy(&_s_errormsg, &_d_kdt, &_d_buf, &_d_xy, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "kdtreetsqueryresultsxy");
            ap.assert(kdt.ptr==_d_kdt, "ALGLIB: internal error (reference changed for non-out X-object)");
            ap.assert(buf.ptr==_d_buf, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_xy.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_xy, ref xy);
            if( xy == null )
                xy = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
        }
        // This function returns no value.
    }
    
    public static void kdtreetsqueryresultsxy(kdtree kdt, kdtreerequestbuffer buf, ref double[,] xy)
    {
        _core_kdtreetsqueryresultsxy( kdt,  buf, ref  xy, 0x0);
    }
    
    public static void kdtreetsqueryresultsxy(kdtree kdt, kdtreerequestbuffer buf, ref double[,] xy, alglib.xparams _xparams)
    {
        _core_kdtreetsqueryresultsxy( kdt,  buf, ref  xy, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_kdtreetsqueryresultstags(kdtree kdt, kdtreerequestbuffer buf, ref int[] tags, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_kdt = kdt.ptr;
        void *_d_buf = buf.ptr;
        x_vector _d_tags = new x_vector();
        
        // Pack, call, unpack
        try
        {
            x_vector_from_array(ref _d_tags, tags, X_CREATE);
            _error_code = _i_xv2_kdtreetsqueryresultstags(&_s_errormsg, &_d_kdt, &_d_buf, &_d_tags, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "kdtreetsqueryresultstags");
            ap.assert(kdt.ptr==_d_kdt, "ALGLIB: internal error (reference changed for non-out X-object)");
            ap.assert(buf.ptr==_d_buf, "ALGLIB: internal error (reference changed for non-out X-object)");
            x_vector_to_array(ref _d_tags, ref tags);
        }
        finally
        {
            x_vector_clear(ref _d_tags);
        }
        // This function returns no value.
    }
    
    public static void kdtreetsqueryresultstags(kdtree kdt, kdtreerequestbuffer buf, ref int[] tags)
    {
        _core_kdtreetsqueryresultstags( kdt,  buf, ref  tags, 0x0);
    }
    
    public static void kdtreetsqueryresultstags(kdtree kdt, kdtreerequestbuffer buf, ref int[] tags, alglib.xparams _xparams)
    {
        _core_kdtreetsqueryresultstags( kdt,  buf, ref  tags, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_kdtreetsqueryresultsdistances(kdtree kdt, kdtreerequestbuffer buf, ref double[] r, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_kdt = kdt.ptr;
        void *_d_buf = buf.ptr;
        x_vector _d_r = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_r = r){
                x_vector_attach_to_array(ref _d_r, _fp_r, ap.len(r));
                _error_code = _i_xv2_kdtreetsqueryresultsdistances(&_s_errormsg, &_d_kdt, &_d_buf, &_d_r, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "kdtreetsqueryresultsdistances");
            ap.assert(kdt.ptr==_d_kdt, "ALGLIB: internal error (reference changed for non-out X-object)");
            ap.assert(buf.ptr==_d_buf, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_r.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_r, ref r);
            if( r == null )
                r = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_r);
        }
        // This function returns no value.
    }
    
    public static void kdtreetsqueryresultsdistances(kdtree kdt, kdtreerequestbuffer buf, ref double[] r)
    {
        _core_kdtreetsqueryresultsdistances( kdt,  buf, ref  r, 0x0);
    }
    
    public static void kdtreetsqueryresultsdistances(kdtree kdt, kdtreerequestbuffer buf, ref double[] r, alglib.xparams _xparams)
    {
        _core_kdtreetsqueryresultsdistances( kdt,  buf, ref  r, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_kdtreequeryresultsxi(kdtree kdt, out double[,] x, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_kdt = kdt.ptr;
        x_matrix _d_x = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            x_matrix_create_empty(ref _d_x, DT_REAL);
            x = null;
            _error_code = _i_xv2_kdtreequeryresultsxi(&_s_errormsg, &_d_kdt, &_d_x, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "kdtreequeryresultsxi");
            ap.assert(kdt.ptr==_d_kdt, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_x);
        }
        // This function returns no value.
    }
    
    public static void kdtreequeryresultsxi(kdtree kdt, out double[,] x)
    {
        _core_kdtreequeryresultsxi( kdt, out  x, 0x0);
    }
    
    public static void kdtreequeryresultsxi(kdtree kdt, out double[,] x, alglib.xparams _xparams)
    {
        _core_kdtreequeryresultsxi( kdt, out  x, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_kdtreequeryresultsxyi(kdtree kdt, out double[,] xy, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_kdt = kdt.ptr;
        x_matrix _d_xy = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            x_matrix_create_empty(ref _d_xy, DT_REAL);
            xy = null;
            _error_code = _i_xv2_kdtreequeryresultsxyi(&_s_errormsg, &_d_kdt, &_d_xy, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "kdtreequeryresultsxyi");
            ap.assert(kdt.ptr==_d_kdt, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_xy.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_xy, ref xy);
            if( xy == null )
                xy = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
        }
        // This function returns no value.
    }
    
    public static void kdtreequeryresultsxyi(kdtree kdt, out double[,] xy)
    {
        _core_kdtreequeryresultsxyi( kdt, out  xy, 0x0);
    }
    
    public static void kdtreequeryresultsxyi(kdtree kdt, out double[,] xy, alglib.xparams _xparams)
    {
        _core_kdtreequeryresultsxyi( kdt, out  xy, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_kdtreequeryresultstagsi(kdtree kdt, out int[] tags, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_kdt = kdt.ptr;
        x_vector _d_tags = new x_vector();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_tags, DT_INT);
            tags = null;
            _error_code = _i_xv2_kdtreequeryresultstagsi(&_s_errormsg, &_d_kdt, &_d_tags, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "kdtreequeryresultstagsi");
            ap.assert(kdt.ptr==_d_kdt, "ALGLIB: internal error (reference changed for non-out X-object)");
            x_vector_to_array(ref _d_tags, ref tags);
        }
        finally
        {
            x_vector_clear(ref _d_tags);
        }
        // This function returns no value.
    }
    
    public static void kdtreequeryresultstagsi(kdtree kdt, out int[] tags)
    {
        _core_kdtreequeryresultstagsi( kdt, out  tags, 0x0);
    }
    
    public static void kdtreequeryresultstagsi(kdtree kdt, out int[] tags, alglib.xparams _xparams)
    {
        _core_kdtreequeryresultstagsi( kdt, out  tags, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_kdtreequeryresultsdistancesi(kdtree kdt, out double[] r, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_kdt = kdt.ptr;
        x_vector _d_r = new x_vector();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_r, DT_REAL);
            r = null;
            _error_code = _i_xv2_kdtreequeryresultsdistancesi(&_s_errormsg, &_d_kdt, &_d_r, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "kdtreequeryresultsdistancesi");
            ap.assert(kdt.ptr==_d_kdt, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_r.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_r, ref r);
            if( r == null )
                r = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_r);
        }
        // This function returns no value.
    }
    
    public static void kdtreequeryresultsdistancesi(kdtree kdt, out double[] r)
    {
        _core_kdtreequeryresultsdistancesi( kdt, out  r, 0x0);
    }
    
    public static void kdtreequeryresultsdistancesi(kdtree kdt, out double[] r, alglib.xparams _xparams)
    {
        _core_kdtreequeryresultsdistancesi( kdt, out  r, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage odesolver
    //
    

    public unsafe class odesolverstate : alglibobject
    {
        private void *_ptr;
        public odesolverstate(void *x)
        {
            _ptr = x;
        }
        ~odesolverstate()
        {
            _deallocate();
        }
        public void* ptr { get { return _ptr; } }
        public override alglib.alglibobject make_copy()
        {
            if( _ptr==null )
                return new odesolverstate(null);
            return new odesolverstate(_i_x_obj_copy_odesolverstate(_ptr));
        }
        public override void _deallocate()
        {
            if( _ptr!=null )
                _i_x_obj_free_odesolverstate(_ptr);
            _ptr = null;
            System.GC.SuppressFinalize(this);
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_odesolverstate(void *x);
    private static _d_x_obj_copy_odesolverstate _i_x_obj_copy_odesolverstate = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_obj_free_odesolverstate(void *x);
    private static _d_x_obj_free_odesolverstate _i_x_obj_free_odesolverstate = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_odesolverstate_get_needdy(void *x, byte *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_odesolverstate_set_needdy(void *x, byte *dst);
    private static _d_x_odesolverstate_get_needdy _i_x_odesolverstate_get_needdy = null;
    private static _d_x_odesolverstate_set_needdy _i_x_odesolverstate_set_needdy = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_odesolverstate_get_y(void *x, x_vector *dst);
    private static _d_x_odesolverstate_get_y _i_x_odesolverstate_get_y = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_odesolverstate_get_dy(void *x, x_vector *dst);
    private static _d_x_odesolverstate_get_dy _i_x_odesolverstate_get_dy = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_odesolverstate_get_x(void *x, double *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_odesolverstate_set_x(void *x, double *dst);
    private static _d_x_odesolverstate_get_x _i_x_odesolverstate_get_x = null;
    private static _d_x_odesolverstate_set_x _i_x_odesolverstate_set_x = null;

    [StructLayout(LayoutKind.Sequential, Pack=8)]
    private struct x_odesolverreport
    {
        public x_int nfev;
        public x_int terminationtype;
    }

    public class odesolverreport : alglibobject
    {
        public int nfev;
        public int terminationtype;
        public override alglib.alglibobject make_copy()
        {
            odesolverreport dst = new odesolverreport();
            dst.nfev = nfev;
            dst.terminationtype = terminationtype;
            return dst;
        }
    }

    // This function initializes X-structure (its previous content is ignored)
    private static void x_odesolverreport_init(ref x_odesolverreport x)
    {
        x.nfev.longval = 0;
        x.terminationtype.longval = 0;
    }

    // This function finalizes fields of X-structure (however, memory occupied by structure itself is not freed)
    // After destruction structure becomes unusable and should be re-initialized if you want to use it
    private static void x_odesolverreport_clear(ref x_odesolverreport x)
    {
    }

    // This function initializes X-structure by appropriate C# instance
    // (previous content of X structure is ignored)
    private static void x_odesolverreport_init_from(ref x_odesolverreport x, odesolverreport v)
    {
        x.nfev.longval = v.nfev;
        x.terminationtype.longval = v.terminationtype;
    }

    // This function initializes C# structure by appropriate X instance
    // (previous content of C# structure is ignored).
    // This function may accept null v, in this case v is automatically allocated with new().
    private static void x_odesolverreport_to_record(ref x_odesolverreport x, ref odesolverreport v)
    {
        if( v==null )
            v = new odesolverreport();
        v.nfev = x.nfev.intval; // long is silently truncated to int
        v.terminationtype = x.terminationtype.intval; // long is silently truncated to int
    }
    
    private static unsafe void _core_odesolverrkck(double[] y, int n, double[] x, int m, double eps, double h, out odesolverstate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_y = new x_vector();
        x_int _d_n = new x_int(n);
        x_vector _d_x = new x_vector();
        x_int _d_m = new x_int(m);
        double _d_eps = eps;
        double _d_h = h;
        void *_d_state = null;
        state = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_y = y, _fp_x = x){
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_xv2_odesolverrkck(&_s_errormsg, &_d_y, &_d_n, &_d_x, &_d_m, &_d_eps, &_d_h, &_d_state, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "odesolverrkck");
            state = new odesolverstate(_d_state);
        }
        finally
        {
            x_vector_clear(ref _d_y);
            x_vector_clear(ref _d_x);
            if( _d_state!=null && state==null)
                _i_x_obj_free_odesolverstate(_d_state); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void odesolverrkck(double[] y, int n, double[] x, int m, double eps, double h, out odesolverstate state)
    {
        _core_odesolverrkck( y,  n,  x,  m,  eps,  h, out  state, 0x0);
    }
    
    public static void odesolverrkck(double[] y, int n, double[] x, int m, double eps, double h, out odesolverstate state, alglib.xparams _xparams)
    {
        _core_odesolverrkck( y,  n,  x,  m,  eps,  h, out  state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void odesolverrkck(double[] y, double[] x, double eps, double h, out odesolverstate state)
    {
        int n;
        int m;
    
        n = ap.len(y);
        m = ap.len(x);
        _core_odesolverrkck( y,  n,  x,  m,  eps,  h, out  state, 0x0);
    
        
    }
    
    public static void odesolverrkck(double[] y, double[] x, double eps, double h, out odesolverstate state, alglib.xparams _xparams)
    {
        int n;
        int m;
    
        n = ap.len(y);
        m = ap.len(x);
        _core_odesolverrkck( y,  n,  x,  m,  eps,  h, out  state, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe bool _core_odesolveriteration(odesolverstate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        bool result;
        byte _d_result = (byte)0;
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_odesolveriteration(&_s_errormsg, &_d_result, &_d_state, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "odesolveriteration");
            result = _d_result!=0;
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static bool odesolveriteration(odesolverstate state)
    {
        return _core_odesolveriteration( state, 0x0);
    }
    
    public static bool odesolveriteration(odesolverstate state, alglib.xparams _xparams)
    {
        return _core_odesolveriteration( state, _xparams==null ? 0x0 : _xparams.flags);
    }
    public static unsafe void odesolversolve(odesolverstate state, ndimensional_ode_rp diff, object obj)
    {
        odesolversolve(state, diff, obj, null);
    }
    
    public static unsafe void odesolversolve(odesolverstate state, ndimensional_ode_rp diff, object obj, alglib.xparams _xparams)
    {
        byte *_s_errormsg = null;
        int _error_code = 0;
        byte _b_result = (byte)0;
        void *_state = state.ptr;
        double _xc_x = 0;
        x_vector _xc_y  = new x_vector();
        x_vector _xc_dy = new x_vector();
        double[] _cs_y  = null;
        double[] _cs_dy = null;
        byte _xc_needdy = 0;
    
        //
        // Check correctness of delegates
        //
        if( diff==null )
            throw new alglibexception("ALGLIB: error in 'odesolversolve()' (diff is null)");
    
        //
        // Attach x-structures to internal arrays allocated by solver
        //
        x_vector_create_empty(ref _xc_y,  DT_REAL);
        x_vector_create_empty(ref _xc_dy, DT_REAL);
        _i_x_odesolverstate_get_y(_state,  &_xc_y);
        _i_x_odesolverstate_get_dy(_state, &_xc_dy);
        _cs_y  = new double[_xc_y.cnt];
        _cs_dy = new double[_xc_dy.cnt];
    
        //
        // Main loop
        //
        for(;;)
        {
            //
            // Call iteration function.
            // Terminate iterations if it returned false.
            //
            _error_code = _i_xv2_odesolveriteration(&_s_errormsg, &_b_result, &_state, _xparams==null ? 0x0 : _xparams.flags);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "odesolveriteration");
            ap.assert(_state==state.ptr, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _b_result==0 )
                break;
    
            //
            // Reverse communication interface:
            // * fetch flags
            // * make delegate calls
            //
            _i_x_odesolverstate_get_needdy(_state, &_xc_needdy);
            if( _xc_needdy!=0 )
            {
                _i_x_odesolverstate_get_x(_state, &_xc_x);
                x_vector_to_array(ref _xc_y, ref _cs_y);
                diff(_cs_y, _xc_x, _cs_dy, obj);
                x_vector_from_array(ref _xc_dy, _cs_dy, X_REWRITE);
                continue;
            }
            throw new alglibexception("ALGLIB: error in 'odesolversolve' (some derivatives were not provided?)");
        }
    }
    
    private static unsafe void _core_odesolverresults(odesolverstate state, out int m, out double[] xtbl, out double[,] ytbl, out odesolverreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_int _d_m = new x_int();
        x_vector _d_xtbl = new x_vector();
        x_matrix _d_ytbl = new x_matrix();
        x_odesolverreport _d_rep = new x_odesolverreport();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_xtbl, DT_REAL);
            xtbl = null;
            x_matrix_create_empty(ref _d_ytbl, DT_REAL);
            ytbl = null;
            x_odesolverreport_init(ref _d_rep);
            _error_code = _i_xv2_odesolverresults(&_s_errormsg, &_d_state, &_d_m, &_d_xtbl, &_d_ytbl, &_d_rep, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "odesolverresults");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            m = _d_m.intval;
            if( _d_xtbl.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_xtbl, ref xtbl);
            if( xtbl == null )
                xtbl = new double[0];
            if( _d_ytbl.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_ytbl, ref ytbl);
            if( ytbl == null )
                ytbl = new double[0,0];
            rep = null;
            x_odesolverreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_xtbl);
            x_matrix_clear(ref _d_ytbl);
            x_odesolverreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void odesolverresults(odesolverstate state, out int m, out double[] xtbl, out double[,] ytbl, out odesolverreport rep)
    {
        _core_odesolverresults( state, out  m, out  xtbl, out  ytbl, out  rep, 0x0);
    }
    
    public static void odesolverresults(odesolverstate state, out int m, out double[] xtbl, out double[,] ytbl, out odesolverreport rep, alglib.xparams _xparams)
    {
        _core_odesolverresults( state, out  m, out  xtbl, out  ytbl, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage inverseupdate
    //
    
    
    private static unsafe void _core_rmatrixinvupdatesimple(ref double[,] inva, int n, int updrow, int updcolumn, double updval, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_inva = new x_matrix();
        x_int _d_n = new x_int(n);
        x_int _d_updrow = new x_int(updrow);
        x_int _d_updcolumn = new x_int(updcolumn);
        double _d_updval = updval;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_inva = inva){
                x_matrix_attach_to_array(ref _d_inva, _fp_inva, ap.rows(inva), ap.cols(inva));
                _error_code = _i_xv2_rmatrixinvupdatesimple(&_s_errormsg, &_d_inva, &_d_n, &_d_updrow, &_d_updcolumn, &_d_updval, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rmatrixinvupdatesimple");
            if( _d_inva.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_inva, ref inva);
            if( inva == null )
                inva = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_inva);
        }
        // This function returns no value.
    }
    
    public static void rmatrixinvupdatesimple(ref double[,] inva, int n, int updrow, int updcolumn, double updval)
    {
        _core_rmatrixinvupdatesimple(ref  inva,  n,  updrow,  updcolumn,  updval, 0x0);
    }
    
    public static void rmatrixinvupdatesimple(ref double[,] inva, int n, int updrow, int updcolumn, double updval, alglib.xparams _xparams)
    {
        _core_rmatrixinvupdatesimple(ref  inva,  n,  updrow,  updcolumn,  updval, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_rmatrixinvupdaterow(ref double[,] inva, int n, int updrow, double[] v, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_inva = new x_matrix();
        x_int _d_n = new x_int(n);
        x_int _d_updrow = new x_int(updrow);
        x_vector _d_v = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_inva = inva, _fp_v = v){
                x_matrix_attach_to_array(ref _d_inva, _fp_inva, ap.rows(inva), ap.cols(inva));
                x_vector_attach_to_array(ref _d_v, _fp_v, ap.len(v));
                _error_code = _i_xv2_rmatrixinvupdaterow(&_s_errormsg, &_d_inva, &_d_n, &_d_updrow, &_d_v, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rmatrixinvupdaterow");
            if( _d_inva.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_inva, ref inva);
            if( inva == null )
                inva = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_inva);
            x_vector_clear(ref _d_v);
        }
        // This function returns no value.
    }
    
    public static void rmatrixinvupdaterow(ref double[,] inva, int n, int updrow, double[] v)
    {
        _core_rmatrixinvupdaterow(ref  inva,  n,  updrow,  v, 0x0);
    }
    
    public static void rmatrixinvupdaterow(ref double[,] inva, int n, int updrow, double[] v, alglib.xparams _xparams)
    {
        _core_rmatrixinvupdaterow(ref  inva,  n,  updrow,  v, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_rmatrixinvupdatecolumn(ref double[,] inva, int n, int updcolumn, double[] u, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_inva = new x_matrix();
        x_int _d_n = new x_int(n);
        x_int _d_updcolumn = new x_int(updcolumn);
        x_vector _d_u = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_inva = inva, _fp_u = u){
                x_matrix_attach_to_array(ref _d_inva, _fp_inva, ap.rows(inva), ap.cols(inva));
                x_vector_attach_to_array(ref _d_u, _fp_u, ap.len(u));
                _error_code = _i_xv2_rmatrixinvupdatecolumn(&_s_errormsg, &_d_inva, &_d_n, &_d_updcolumn, &_d_u, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rmatrixinvupdatecolumn");
            if( _d_inva.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_inva, ref inva);
            if( inva == null )
                inva = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_inva);
            x_vector_clear(ref _d_u);
        }
        // This function returns no value.
    }
    
    public static void rmatrixinvupdatecolumn(ref double[,] inva, int n, int updcolumn, double[] u)
    {
        _core_rmatrixinvupdatecolumn(ref  inva,  n,  updcolumn,  u, 0x0);
    }
    
    public static void rmatrixinvupdatecolumn(ref double[,] inva, int n, int updcolumn, double[] u, alglib.xparams _xparams)
    {
        _core_rmatrixinvupdatecolumn(ref  inva,  n,  updcolumn,  u, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_rmatrixinvupdateuv(ref double[,] inva, int n, double[] u, double[] v, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_inva = new x_matrix();
        x_int _d_n = new x_int(n);
        x_vector _d_u = new x_vector();
        x_vector _d_v = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_inva = inva, _fp_u = u, _fp_v = v){
                x_matrix_attach_to_array(ref _d_inva, _fp_inva, ap.rows(inva), ap.cols(inva));
                x_vector_attach_to_array(ref _d_u, _fp_u, ap.len(u));
                x_vector_attach_to_array(ref _d_v, _fp_v, ap.len(v));
                _error_code = _i_xv2_rmatrixinvupdateuv(&_s_errormsg, &_d_inva, &_d_n, &_d_u, &_d_v, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rmatrixinvupdateuv");
            if( _d_inva.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_inva, ref inva);
            if( inva == null )
                inva = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_inva);
            x_vector_clear(ref _d_u);
            x_vector_clear(ref _d_v);
        }
        // This function returns no value.
    }
    
    public static void rmatrixinvupdateuv(ref double[,] inva, int n, double[] u, double[] v)
    {
        _core_rmatrixinvupdateuv(ref  inva,  n,  u,  v, 0x0);
    }
    
    public static void rmatrixinvupdateuv(ref double[,] inva, int n, double[] u, double[] v, alglib.xparams _xparams)
    {
        _core_rmatrixinvupdateuv(ref  inva,  n,  u,  v, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage schur
    //
    
    
    private static unsafe bool _core_rmatrixschur(ref double[,] a, int n, out double[,] s, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        bool result;
        byte _d_result = (byte)0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        x_matrix _d_s = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matrix_create_empty(ref _d_s, DT_REAL);
                s = null;
                _error_code = _i_xv2_rmatrixschur(&_s_errormsg, &_d_result, &_d_a, &_d_n, &_d_s, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rmatrixschur");
            result = _d_result!=0;
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new double[0,0];
            if( _d_s.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_s, ref s);
            if( s == null )
                s = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matrix_clear(ref _d_s);
        }
        return result;
    }
    
    public static bool rmatrixschur(ref double[,] a, int n, out double[,] s)
    {
        return _core_rmatrixschur(ref  a,  n, out  s, 0x0);
    }
    
    public static bool rmatrixschur(ref double[,] a, int n, out double[,] s, alglib.xparams _xparams)
    {
        return _core_rmatrixschur(ref  a,  n, out  s, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage spdgevd
    //
    
    
    private static unsafe bool _core_smatrixgevd(double[,] a, int n, bool isuppera, double[,] b, bool isupperb, int zneeded, int problemtype, out double[] d, out double[,] z, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        bool result;
        byte _d_result = (byte)0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isuppera = (byte)(isuppera ? 1 : 0);
        x_matrix _d_b = new x_matrix();
        byte _d_isupperb = (byte)(isupperb ? 1 : 0);
        x_int _d_zneeded = new x_int(zneeded);
        x_int _d_problemtype = new x_int(problemtype);
        x_vector _d_d = new x_vector();
        x_matrix _d_z = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a, _fp_b = b){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matrix_attach_to_array(ref _d_b, _fp_b, ap.rows(b), ap.cols(b));
                x_vector_create_empty(ref _d_d, DT_REAL);
                d = null;
                x_matrix_create_empty(ref _d_z, DT_REAL);
                z = null;
                _error_code = _i_xv2_smatrixgevd(&_s_errormsg, &_d_result, &_d_a, &_d_n, &_d_isuppera, &_d_b, &_d_isupperb, &_d_zneeded, &_d_problemtype, &_d_d, &_d_z, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "smatrixgevd");
            result = _d_result!=0;
            if( _d_d.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_d, ref d);
            if( d == null )
                d = new double[0];
            if( _d_z.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_z, ref z);
            if( z == null )
                z = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matrix_clear(ref _d_b);
            x_vector_clear(ref _d_d);
            x_matrix_clear(ref _d_z);
        }
        return result;
    }
    
    public static bool smatrixgevd(double[,] a, int n, bool isuppera, double[,] b, bool isupperb, int zneeded, int problemtype, out double[] d, out double[,] z)
    {
        return _core_smatrixgevd( a,  n,  isuppera,  b,  isupperb,  zneeded,  problemtype, out  d, out  z, 0x0);
    }
    
    public static bool smatrixgevd(double[,] a, int n, bool isuppera, double[,] b, bool isupperb, int zneeded, int problemtype, out double[] d, out double[,] z, alglib.xparams _xparams)
    {
        return _core_smatrixgevd( a,  n,  isuppera,  b,  isupperb,  zneeded,  problemtype, out  d, out  z, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe bool _core_smatrixgevdreduce(ref double[,] a, int n, bool isuppera, double[,] b, bool isupperb, int problemtype, out double[,] r, out bool isupperr, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        bool result;
        byte _d_result = (byte)0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isuppera = (byte)(isuppera ? 1 : 0);
        x_matrix _d_b = new x_matrix();
        byte _d_isupperb = (byte)(isupperb ? 1 : 0);
        x_int _d_problemtype = new x_int(problemtype);
        x_matrix _d_r = new x_matrix();
        byte _d_isupperr = (byte)0;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a, _fp_b = b){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matrix_attach_to_array(ref _d_b, _fp_b, ap.rows(b), ap.cols(b));
                x_matrix_create_empty(ref _d_r, DT_REAL);
                r = null;
                _error_code = _i_xv2_smatrixgevdreduce(&_s_errormsg, &_d_result, &_d_a, &_d_n, &_d_isuppera, &_d_b, &_d_isupperb, &_d_problemtype, &_d_r, &_d_isupperr, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "smatrixgevdreduce");
            result = _d_result!=0;
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new double[0,0];
            if( _d_r.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_r, ref r);
            if( r == null )
                r = new double[0,0];
            isupperr = _d_isupperr!=0;
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matrix_clear(ref _d_b);
            x_matrix_clear(ref _d_r);
        }
        return result;
    }
    
    public static bool smatrixgevdreduce(ref double[,] a, int n, bool isuppera, double[,] b, bool isupperb, int problemtype, out double[,] r, out bool isupperr)
    {
        return _core_smatrixgevdreduce(ref  a,  n,  isuppera,  b,  isupperb,  problemtype, out  r, out  isupperr, 0x0);
    }
    
    public static bool smatrixgevdreduce(ref double[,] a, int n, bool isuppera, double[,] b, bool isupperb, int problemtype, out double[,] r, out bool isupperr, alglib.xparams _xparams)
    {
        return _core_smatrixgevdreduce(ref  a,  n,  isuppera,  b,  isupperb,  problemtype, out  r, out  isupperr, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage matdet
    //
    
    
    private static unsafe double _core_rmatrixludet(double[,] a, int[] pivots, int n, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_matrix _d_a = new x_matrix();
        x_vector _d_pivots = new x_vector();
        x_int _d_n = new x_int(n);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_from_array(ref _d_pivots, pivots, X_CREATE);
                _error_code = _i_xv2_rmatrixludet(&_s_errormsg, &_d_result, &_d_a, &_d_pivots, &_d_n, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rmatrixludet");
            result = _d_result;
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_pivots);
        }
        return result;
    }
    
    public static double rmatrixludet(double[,] a, int[] pivots, int n)
    {
        return _core_rmatrixludet( a,  pivots,  n, 0x0);
    }
    
    public static double rmatrixludet(double[,] a, int[] pivots, int n, alglib.xparams _xparams)
    {
        return _core_rmatrixludet( a,  pivots,  n, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static double rmatrixludet(double[,] a, int[] pivots)
    {
        int n;
        if( (ap.rows(a)!=ap.cols(a)) || (ap.rows(a)!=ap.len(pivots)))
            throw new alglibexception("Error while calling 'rmatrixludet': looks like one of arguments has wrong size");
        n = ap.rows(a);
        double result = _core_rmatrixludet( a,  pivots,  n, 0x0);
    
        return result;
    }
    
    public static double rmatrixludet(double[,] a, int[] pivots, alglib.xparams _xparams)
    {
        int n;
        if( (ap.rows(a)!=ap.cols(a)) || (ap.rows(a)!=ap.len(pivots)))
            throw new alglibexception("Error while calling 'rmatrixludet': looks like one of arguments has wrong size");
        n = ap.rows(a);
        double result = _core_rmatrixludet( a,  pivots,  n, _xparams==null ? 0x0 : _xparams.flags);
    
        return result;
    }
    
    private static unsafe double _core_rmatrixdet(double[,] a, int n, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                _error_code = _i_xv2_rmatrixdet(&_s_errormsg, &_d_result, &_d_a, &_d_n, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rmatrixdet");
            result = _d_result;
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        return result;
    }
    
    public static double rmatrixdet(double[,] a, int n)
    {
        return _core_rmatrixdet( a,  n, 0x0);
    }
    
    public static double rmatrixdet(double[,] a, int n, alglib.xparams _xparams)
    {
        return _core_rmatrixdet( a,  n, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static double rmatrixdet(double[,] a)
    {
        int n;
        if( (ap.rows(a)!=ap.cols(a)))
            throw new alglibexception("Error while calling 'rmatrixdet': looks like one of arguments has wrong size");
        n = ap.rows(a);
        double result = _core_rmatrixdet( a,  n, 0x0);
    
        return result;
    }
    
    public static double rmatrixdet(double[,] a, alglib.xparams _xparams)
    {
        int n;
        if( (ap.rows(a)!=ap.cols(a)))
            throw new alglibexception("Error while calling 'rmatrixdet': looks like one of arguments has wrong size");
        n = ap.rows(a);
        double result = _core_rmatrixdet( a,  n, _xparams==null ? 0x0 : _xparams.flags);
    
        return result;
    }
    
    private static unsafe complex _core_cmatrixludet(complex[,] a, int[] pivots, int n, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        alglib.complex result;
        alglib.complex _d_result;
        x_matrix _d_a = new x_matrix();
        x_vector _d_pivots = new x_vector();
        x_int _d_n = new x_int(n);
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a){
                _d_result.x = 0;
                _d_result.y = 0;
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_from_array(ref _d_pivots, pivots, X_CREATE);
                _error_code = _i_xv2_cmatrixludet(&_s_errormsg, &_d_result, &_d_a, &_d_pivots, &_d_n, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "cmatrixludet");
            result.x = _d_result.x;
            result.y = _d_result.y;
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_pivots);
        }
        return result;
    }
    
    public static alglib.complex cmatrixludet(complex[,] a, int[] pivots, int n)
    {
        return _core_cmatrixludet( a,  pivots,  n, 0x0);
    }
    
    public static alglib.complex cmatrixludet(complex[,] a, int[] pivots, int n, alglib.xparams _xparams)
    {
        return _core_cmatrixludet( a,  pivots,  n, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static alglib.complex cmatrixludet(complex[,] a, int[] pivots)
    {
        int n;
        if( (ap.rows(a)!=ap.cols(a)) || (ap.rows(a)!=ap.len(pivots)))
            throw new alglibexception("Error while calling 'cmatrixludet': looks like one of arguments has wrong size");
        n = ap.rows(a);
        alglib.complex result = _core_cmatrixludet( a,  pivots,  n, 0x0);
    
        return result;
    }
    
    public static alglib.complex cmatrixludet(complex[,] a, int[] pivots, alglib.xparams _xparams)
    {
        int n;
        if( (ap.rows(a)!=ap.cols(a)) || (ap.rows(a)!=ap.len(pivots)))
            throw new alglibexception("Error while calling 'cmatrixludet': looks like one of arguments has wrong size");
        n = ap.rows(a);
        alglib.complex result = _core_cmatrixludet( a,  pivots,  n, _xparams==null ? 0x0 : _xparams.flags);
    
        return result;
    }
    
    private static unsafe complex _core_cmatrixdet(complex[,] a, int n, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        alglib.complex result;
        alglib.complex _d_result;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a){
                _d_result.x = 0;
                _d_result.y = 0;
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                _error_code = _i_xv2_cmatrixdet(&_s_errormsg, &_d_result, &_d_a, &_d_n, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "cmatrixdet");
            result.x = _d_result.x;
            result.y = _d_result.y;
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        return result;
    }
    
    public static alglib.complex cmatrixdet(complex[,] a, int n)
    {
        return _core_cmatrixdet( a,  n, 0x0);
    }
    
    public static alglib.complex cmatrixdet(complex[,] a, int n, alglib.xparams _xparams)
    {
        return _core_cmatrixdet( a,  n, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static alglib.complex cmatrixdet(complex[,] a)
    {
        int n;
        if( (ap.rows(a)!=ap.cols(a)))
            throw new alglibexception("Error while calling 'cmatrixdet': looks like one of arguments has wrong size");
        n = ap.rows(a);
        alglib.complex result = _core_cmatrixdet( a,  n, 0x0);
    
        return result;
    }
    
    public static alglib.complex cmatrixdet(complex[,] a, alglib.xparams _xparams)
    {
        int n;
        if( (ap.rows(a)!=ap.cols(a)))
            throw new alglibexception("Error while calling 'cmatrixdet': looks like one of arguments has wrong size");
        n = ap.rows(a);
        alglib.complex result = _core_cmatrixdet( a,  n, _xparams==null ? 0x0 : _xparams.flags);
    
        return result;
    }
    
    private static unsafe double _core_spdmatrixcholeskydet(double[,] a, int n, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                _error_code = _i_xv2_spdmatrixcholeskydet(&_s_errormsg, &_d_result, &_d_a, &_d_n, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spdmatrixcholeskydet");
            result = _d_result;
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        return result;
    }
    
    public static double spdmatrixcholeskydet(double[,] a, int n)
    {
        return _core_spdmatrixcholeskydet( a,  n, 0x0);
    }
    
    public static double spdmatrixcholeskydet(double[,] a, int n, alglib.xparams _xparams)
    {
        return _core_spdmatrixcholeskydet( a,  n, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static double spdmatrixcholeskydet(double[,] a)
    {
        int n;
        if( (ap.rows(a)!=ap.cols(a)))
            throw new alglibexception("Error while calling 'spdmatrixcholeskydet': looks like one of arguments has wrong size");
        n = ap.rows(a);
        double result = _core_spdmatrixcholeskydet( a,  n, 0x0);
    
        return result;
    }
    
    public static double spdmatrixcholeskydet(double[,] a, alglib.xparams _xparams)
    {
        int n;
        if( (ap.rows(a)!=ap.cols(a)))
            throw new alglibexception("Error while calling 'spdmatrixcholeskydet': looks like one of arguments has wrong size");
        n = ap.rows(a);
        double result = _core_spdmatrixcholeskydet( a,  n, _xparams==null ? 0x0 : _xparams.flags);
    
        return result;
    }
    
    private static unsafe double _core_spdmatrixdet(double[,] a, int n, bool isupper, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                _error_code = _i_xv2_spdmatrixdet(&_s_errormsg, &_d_result, &_d_a, &_d_n, &_d_isupper, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spdmatrixdet");
            result = _d_result;
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        return result;
    }
    
    public static double spdmatrixdet(double[,] a, int n, bool isupper)
    {
        return _core_spdmatrixdet( a,  n,  isupper, 0x0);
    }
    
    public static double spdmatrixdet(double[,] a, int n, bool isupper, alglib.xparams _xparams)
    {
        return _core_spdmatrixdet( a,  n,  isupper, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static double spdmatrixdet(double[,] a)
    {
        int n;
        bool isupper;
        if( !alglib.ap.issymmetric(a) )
            throw new alglibexception("'a' parameter is not symmetric matrix");
        if( (ap.rows(a)!=ap.cols(a)))
            throw new alglibexception("Error while calling 'spdmatrixdet': looks like one of arguments has wrong size");
        n = ap.rows(a);
        isupper = false;
        double result = _core_spdmatrixdet( a,  n,  isupper, 0x0);
    
        return result;
    }
    
    public static double spdmatrixdet(double[,] a, alglib.xparams _xparams)
    {
        int n;
        bool isupper;
        if( !alglib.ap.issymmetric(a) )
            throw new alglibexception("'a' parameter is not symmetric matrix");
        if( (ap.rows(a)!=ap.cols(a)))
            throw new alglibexception("Error while calling 'spdmatrixdet': looks like one of arguments has wrong size");
        n = ap.rows(a);
        isupper = false;
        double result = _core_spdmatrixdet( a,  n,  isupper, _xparams==null ? 0x0 : _xparams.flags);
    
        return result;
    }
    
    
    //
    // Subpackage gammafunc
    //
    
    
    private static unsafe double _core_gammafunction(double x, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        double _d_x = x;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_gammafunction(&_s_errormsg, &_d_result, &_d_x, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "gammafunction");
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double gammafunction(double x)
    {
        return _core_gammafunction( x, 0x0);
    }
    
    public static double gammafunction(double x, alglib.xparams _xparams)
    {
        return _core_gammafunction( x, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_lngamma(double x, out double sgngam, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        double _d_x = x;
        double _d_sgngam = 0;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_lngamma(&_s_errormsg, &_d_result, &_d_x, &_d_sgngam, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "lngamma");
            result = _d_result;
            sgngam = _d_sgngam;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double lngamma(double x, out double sgngam)
    {
        return _core_lngamma( x, out  sgngam, 0x0);
    }
    
    public static double lngamma(double x, out double sgngam, alglib.xparams _xparams)
    {
        return _core_lngamma( x, out  sgngam, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage gq
    //
    
    
    private static unsafe void _core_gqgeneraterec(double[] alpha, double[] beta, double mu0, int n, out int info, out double[] x, out double[] w, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_alpha = new x_vector();
        x_vector _d_beta = new x_vector();
        double _d_mu0 = mu0;
        x_int _d_n = new x_int(n);
        x_int _d_info = new x_int();
        x_vector _d_x = new x_vector();
        x_vector _d_w = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_alpha = alpha, _fp_beta = beta){
                x_vector_attach_to_array(ref _d_alpha, _fp_alpha, ap.len(alpha));
                x_vector_attach_to_array(ref _d_beta, _fp_beta, ap.len(beta));
                x_vector_create_empty(ref _d_x, DT_REAL);
                x = null;
                x_vector_create_empty(ref _d_w, DT_REAL);
                w = null;
                _error_code = _i_xv2_gqgeneraterec(&_s_errormsg, &_d_alpha, &_d_beta, &_d_mu0, &_d_n, &_d_info, &_d_x, &_d_w, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "gqgeneraterec");
            info = _d_info.intval;
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
            if( _d_w.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_w, ref w);
            if( w == null )
                w = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_alpha);
            x_vector_clear(ref _d_beta);
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_w);
        }
        // This function returns no value.
    }
    
    public static void gqgeneraterec(double[] alpha, double[] beta, double mu0, int n, out int info, out double[] x, out double[] w)
    {
        _core_gqgeneraterec( alpha,  beta,  mu0,  n, out  info, out  x, out  w, 0x0);
    }
    
    public static void gqgeneraterec(double[] alpha, double[] beta, double mu0, int n, out int info, out double[] x, out double[] w, alglib.xparams _xparams)
    {
        _core_gqgeneraterec( alpha,  beta,  mu0,  n, out  info, out  x, out  w, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_gqgenerategausslobattorec(double[] alpha, double[] beta, double mu0, double a, double b, int n, out int info, out double[] x, out double[] w, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_alpha = new x_vector();
        x_vector _d_beta = new x_vector();
        double _d_mu0 = mu0;
        double _d_a = a;
        double _d_b = b;
        x_int _d_n = new x_int(n);
        x_int _d_info = new x_int();
        x_vector _d_x = new x_vector();
        x_vector _d_w = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_alpha = alpha, _fp_beta = beta){
                x_vector_attach_to_array(ref _d_alpha, _fp_alpha, ap.len(alpha));
                x_vector_attach_to_array(ref _d_beta, _fp_beta, ap.len(beta));
                x_vector_create_empty(ref _d_x, DT_REAL);
                x = null;
                x_vector_create_empty(ref _d_w, DT_REAL);
                w = null;
                _error_code = _i_xv2_gqgenerategausslobattorec(&_s_errormsg, &_d_alpha, &_d_beta, &_d_mu0, &_d_a, &_d_b, &_d_n, &_d_info, &_d_x, &_d_w, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "gqgenerategausslobattorec");
            info = _d_info.intval;
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
            if( _d_w.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_w, ref w);
            if( w == null )
                w = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_alpha);
            x_vector_clear(ref _d_beta);
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_w);
        }
        // This function returns no value.
    }
    
    public static void gqgenerategausslobattorec(double[] alpha, double[] beta, double mu0, double a, double b, int n, out int info, out double[] x, out double[] w)
    {
        _core_gqgenerategausslobattorec( alpha,  beta,  mu0,  a,  b,  n, out  info, out  x, out  w, 0x0);
    }
    
    public static void gqgenerategausslobattorec(double[] alpha, double[] beta, double mu0, double a, double b, int n, out int info, out double[] x, out double[] w, alglib.xparams _xparams)
    {
        _core_gqgenerategausslobattorec( alpha,  beta,  mu0,  a,  b,  n, out  info, out  x, out  w, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_gqgenerategaussradaurec(double[] alpha, double[] beta, double mu0, double a, int n, out int info, out double[] x, out double[] w, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_alpha = new x_vector();
        x_vector _d_beta = new x_vector();
        double _d_mu0 = mu0;
        double _d_a = a;
        x_int _d_n = new x_int(n);
        x_int _d_info = new x_int();
        x_vector _d_x = new x_vector();
        x_vector _d_w = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_alpha = alpha, _fp_beta = beta){
                x_vector_attach_to_array(ref _d_alpha, _fp_alpha, ap.len(alpha));
                x_vector_attach_to_array(ref _d_beta, _fp_beta, ap.len(beta));
                x_vector_create_empty(ref _d_x, DT_REAL);
                x = null;
                x_vector_create_empty(ref _d_w, DT_REAL);
                w = null;
                _error_code = _i_xv2_gqgenerategaussradaurec(&_s_errormsg, &_d_alpha, &_d_beta, &_d_mu0, &_d_a, &_d_n, &_d_info, &_d_x, &_d_w, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "gqgenerategaussradaurec");
            info = _d_info.intval;
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
            if( _d_w.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_w, ref w);
            if( w == null )
                w = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_alpha);
            x_vector_clear(ref _d_beta);
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_w);
        }
        // This function returns no value.
    }
    
    public static void gqgenerategaussradaurec(double[] alpha, double[] beta, double mu0, double a, int n, out int info, out double[] x, out double[] w)
    {
        _core_gqgenerategaussradaurec( alpha,  beta,  mu0,  a,  n, out  info, out  x, out  w, 0x0);
    }
    
    public static void gqgenerategaussradaurec(double[] alpha, double[] beta, double mu0, double a, int n, out int info, out double[] x, out double[] w, alglib.xparams _xparams)
    {
        _core_gqgenerategaussradaurec( alpha,  beta,  mu0,  a,  n, out  info, out  x, out  w, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_gqgenerategausslegendre(int n, out int info, out double[] x, out double[] w, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        x_int _d_info = new x_int();
        x_vector _d_x = new x_vector();
        x_vector _d_w = new x_vector();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_x, DT_REAL);
            x = null;
            x_vector_create_empty(ref _d_w, DT_REAL);
            w = null;
            _error_code = _i_xv2_gqgenerategausslegendre(&_s_errormsg, &_d_n, &_d_info, &_d_x, &_d_w, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "gqgenerategausslegendre");
            info = _d_info.intval;
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
            if( _d_w.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_w, ref w);
            if( w == null )
                w = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_w);
        }
        // This function returns no value.
    }
    
    public static void gqgenerategausslegendre(int n, out int info, out double[] x, out double[] w)
    {
        _core_gqgenerategausslegendre( n, out  info, out  x, out  w, 0x0);
    }
    
    public static void gqgenerategausslegendre(int n, out int info, out double[] x, out double[] w, alglib.xparams _xparams)
    {
        _core_gqgenerategausslegendre( n, out  info, out  x, out  w, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_gqgenerategaussjacobi(int n, double alpha, double beta, out int info, out double[] x, out double[] w, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        double _d_alpha = alpha;
        double _d_beta = beta;
        x_int _d_info = new x_int();
        x_vector _d_x = new x_vector();
        x_vector _d_w = new x_vector();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_x, DT_REAL);
            x = null;
            x_vector_create_empty(ref _d_w, DT_REAL);
            w = null;
            _error_code = _i_xv2_gqgenerategaussjacobi(&_s_errormsg, &_d_n, &_d_alpha, &_d_beta, &_d_info, &_d_x, &_d_w, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "gqgenerategaussjacobi");
            info = _d_info.intval;
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
            if( _d_w.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_w, ref w);
            if( w == null )
                w = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_w);
        }
        // This function returns no value.
    }
    
    public static void gqgenerategaussjacobi(int n, double alpha, double beta, out int info, out double[] x, out double[] w)
    {
        _core_gqgenerategaussjacobi( n,  alpha,  beta, out  info, out  x, out  w, 0x0);
    }
    
    public static void gqgenerategaussjacobi(int n, double alpha, double beta, out int info, out double[] x, out double[] w, alglib.xparams _xparams)
    {
        _core_gqgenerategaussjacobi( n,  alpha,  beta, out  info, out  x, out  w, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_gqgenerategausslaguerre(int n, double alpha, out int info, out double[] x, out double[] w, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        double _d_alpha = alpha;
        x_int _d_info = new x_int();
        x_vector _d_x = new x_vector();
        x_vector _d_w = new x_vector();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_x, DT_REAL);
            x = null;
            x_vector_create_empty(ref _d_w, DT_REAL);
            w = null;
            _error_code = _i_xv2_gqgenerategausslaguerre(&_s_errormsg, &_d_n, &_d_alpha, &_d_info, &_d_x, &_d_w, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "gqgenerategausslaguerre");
            info = _d_info.intval;
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
            if( _d_w.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_w, ref w);
            if( w == null )
                w = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_w);
        }
        // This function returns no value.
    }
    
    public static void gqgenerategausslaguerre(int n, double alpha, out int info, out double[] x, out double[] w)
    {
        _core_gqgenerategausslaguerre( n,  alpha, out  info, out  x, out  w, 0x0);
    }
    
    public static void gqgenerategausslaguerre(int n, double alpha, out int info, out double[] x, out double[] w, alglib.xparams _xparams)
    {
        _core_gqgenerategausslaguerre( n,  alpha, out  info, out  x, out  w, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_gqgenerategausshermite(int n, out int info, out double[] x, out double[] w, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        x_int _d_info = new x_int();
        x_vector _d_x = new x_vector();
        x_vector _d_w = new x_vector();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_x, DT_REAL);
            x = null;
            x_vector_create_empty(ref _d_w, DT_REAL);
            w = null;
            _error_code = _i_xv2_gqgenerategausshermite(&_s_errormsg, &_d_n, &_d_info, &_d_x, &_d_w, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "gqgenerategausshermite");
            info = _d_info.intval;
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
            if( _d_w.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_w, ref w);
            if( w == null )
                w = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_w);
        }
        // This function returns no value.
    }
    
    public static void gqgenerategausshermite(int n, out int info, out double[] x, out double[] w)
    {
        _core_gqgenerategausshermite( n, out  info, out  x, out  w, 0x0);
    }
    
    public static void gqgenerategausshermite(int n, out int info, out double[] x, out double[] w, alglib.xparams _xparams)
    {
        _core_gqgenerategausshermite( n, out  info, out  x, out  w, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage gkq
    //
    
    
    private static unsafe void _core_gkqgeneraterec(double[] alpha, double[] beta, double mu0, int n, out int info, out double[] x, out double[] wkronrod, out double[] wgauss, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_alpha = new x_vector();
        x_vector _d_beta = new x_vector();
        double _d_mu0 = mu0;
        x_int _d_n = new x_int(n);
        x_int _d_info = new x_int();
        x_vector _d_x = new x_vector();
        x_vector _d_wkronrod = new x_vector();
        x_vector _d_wgauss = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_alpha = alpha, _fp_beta = beta){
                x_vector_attach_to_array(ref _d_alpha, _fp_alpha, ap.len(alpha));
                x_vector_attach_to_array(ref _d_beta, _fp_beta, ap.len(beta));
                x_vector_create_empty(ref _d_x, DT_REAL);
                x = null;
                x_vector_create_empty(ref _d_wkronrod, DT_REAL);
                wkronrod = null;
                x_vector_create_empty(ref _d_wgauss, DT_REAL);
                wgauss = null;
                _error_code = _i_xv2_gkqgeneraterec(&_s_errormsg, &_d_alpha, &_d_beta, &_d_mu0, &_d_n, &_d_info, &_d_x, &_d_wkronrod, &_d_wgauss, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "gkqgeneraterec");
            info = _d_info.intval;
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
            if( _d_wkronrod.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_wkronrod, ref wkronrod);
            if( wkronrod == null )
                wkronrod = new double[0];
            if( _d_wgauss.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_wgauss, ref wgauss);
            if( wgauss == null )
                wgauss = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_alpha);
            x_vector_clear(ref _d_beta);
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_wkronrod);
            x_vector_clear(ref _d_wgauss);
        }
        // This function returns no value.
    }
    
    public static void gkqgeneraterec(double[] alpha, double[] beta, double mu0, int n, out int info, out double[] x, out double[] wkronrod, out double[] wgauss)
    {
        _core_gkqgeneraterec( alpha,  beta,  mu0,  n, out  info, out  x, out  wkronrod, out  wgauss, 0x0);
    }
    
    public static void gkqgeneraterec(double[] alpha, double[] beta, double mu0, int n, out int info, out double[] x, out double[] wkronrod, out double[] wgauss, alglib.xparams _xparams)
    {
        _core_gkqgeneraterec( alpha,  beta,  mu0,  n, out  info, out  x, out  wkronrod, out  wgauss, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_gkqgenerategausslegendre(int n, out int info, out double[] x, out double[] wkronrod, out double[] wgauss, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        x_int _d_info = new x_int();
        x_vector _d_x = new x_vector();
        x_vector _d_wkronrod = new x_vector();
        x_vector _d_wgauss = new x_vector();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_x, DT_REAL);
            x = null;
            x_vector_create_empty(ref _d_wkronrod, DT_REAL);
            wkronrod = null;
            x_vector_create_empty(ref _d_wgauss, DT_REAL);
            wgauss = null;
            _error_code = _i_xv2_gkqgenerategausslegendre(&_s_errormsg, &_d_n, &_d_info, &_d_x, &_d_wkronrod, &_d_wgauss, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "gkqgenerategausslegendre");
            info = _d_info.intval;
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
            if( _d_wkronrod.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_wkronrod, ref wkronrod);
            if( wkronrod == null )
                wkronrod = new double[0];
            if( _d_wgauss.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_wgauss, ref wgauss);
            if( wgauss == null )
                wgauss = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_wkronrod);
            x_vector_clear(ref _d_wgauss);
        }
        // This function returns no value.
    }
    
    public static void gkqgenerategausslegendre(int n, out int info, out double[] x, out double[] wkronrod, out double[] wgauss)
    {
        _core_gkqgenerategausslegendre( n, out  info, out  x, out  wkronrod, out  wgauss, 0x0);
    }
    
    public static void gkqgenerategausslegendre(int n, out int info, out double[] x, out double[] wkronrod, out double[] wgauss, alglib.xparams _xparams)
    {
        _core_gkqgenerategausslegendre( n, out  info, out  x, out  wkronrod, out  wgauss, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_gkqgenerategaussjacobi(int n, double alpha, double beta, out int info, out double[] x, out double[] wkronrod, out double[] wgauss, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        double _d_alpha = alpha;
        double _d_beta = beta;
        x_int _d_info = new x_int();
        x_vector _d_x = new x_vector();
        x_vector _d_wkronrod = new x_vector();
        x_vector _d_wgauss = new x_vector();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_x, DT_REAL);
            x = null;
            x_vector_create_empty(ref _d_wkronrod, DT_REAL);
            wkronrod = null;
            x_vector_create_empty(ref _d_wgauss, DT_REAL);
            wgauss = null;
            _error_code = _i_xv2_gkqgenerategaussjacobi(&_s_errormsg, &_d_n, &_d_alpha, &_d_beta, &_d_info, &_d_x, &_d_wkronrod, &_d_wgauss, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "gkqgenerategaussjacobi");
            info = _d_info.intval;
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
            if( _d_wkronrod.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_wkronrod, ref wkronrod);
            if( wkronrod == null )
                wkronrod = new double[0];
            if( _d_wgauss.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_wgauss, ref wgauss);
            if( wgauss == null )
                wgauss = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_wkronrod);
            x_vector_clear(ref _d_wgauss);
        }
        // This function returns no value.
    }
    
    public static void gkqgenerategaussjacobi(int n, double alpha, double beta, out int info, out double[] x, out double[] wkronrod, out double[] wgauss)
    {
        _core_gkqgenerategaussjacobi( n,  alpha,  beta, out  info, out  x, out  wkronrod, out  wgauss, 0x0);
    }
    
    public static void gkqgenerategaussjacobi(int n, double alpha, double beta, out int info, out double[] x, out double[] wkronrod, out double[] wgauss, alglib.xparams _xparams)
    {
        _core_gkqgenerategaussjacobi( n,  alpha,  beta, out  info, out  x, out  wkronrod, out  wgauss, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_gkqlegendrecalc(int n, out int info, out double[] x, out double[] wkronrod, out double[] wgauss, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        x_int _d_info = new x_int();
        x_vector _d_x = new x_vector();
        x_vector _d_wkronrod = new x_vector();
        x_vector _d_wgauss = new x_vector();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_x, DT_REAL);
            x = null;
            x_vector_create_empty(ref _d_wkronrod, DT_REAL);
            wkronrod = null;
            x_vector_create_empty(ref _d_wgauss, DT_REAL);
            wgauss = null;
            _error_code = _i_xv2_gkqlegendrecalc(&_s_errormsg, &_d_n, &_d_info, &_d_x, &_d_wkronrod, &_d_wgauss, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "gkqlegendrecalc");
            info = _d_info.intval;
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
            if( _d_wkronrod.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_wkronrod, ref wkronrod);
            if( wkronrod == null )
                wkronrod = new double[0];
            if( _d_wgauss.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_wgauss, ref wgauss);
            if( wgauss == null )
                wgauss = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_wkronrod);
            x_vector_clear(ref _d_wgauss);
        }
        // This function returns no value.
    }
    
    public static void gkqlegendrecalc(int n, out int info, out double[] x, out double[] wkronrod, out double[] wgauss)
    {
        _core_gkqlegendrecalc( n, out  info, out  x, out  wkronrod, out  wgauss, 0x0);
    }
    
    public static void gkqlegendrecalc(int n, out int info, out double[] x, out double[] wkronrod, out double[] wgauss, alglib.xparams _xparams)
    {
        _core_gkqlegendrecalc( n, out  info, out  x, out  wkronrod, out  wgauss, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_gkqlegendretbl(int n, out double[] x, out double[] wkronrod, out double[] wgauss, out double eps, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        x_vector _d_x = new x_vector();
        x_vector _d_wkronrod = new x_vector();
        x_vector _d_wgauss = new x_vector();
        double _d_eps = 0;
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_x, DT_REAL);
            x = null;
            x_vector_create_empty(ref _d_wkronrod, DT_REAL);
            wkronrod = null;
            x_vector_create_empty(ref _d_wgauss, DT_REAL);
            wgauss = null;
            _error_code = _i_xv2_gkqlegendretbl(&_s_errormsg, &_d_n, &_d_x, &_d_wkronrod, &_d_wgauss, &_d_eps, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "gkqlegendretbl");
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
            if( _d_wkronrod.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_wkronrod, ref wkronrod);
            if( wkronrod == null )
                wkronrod = new double[0];
            if( _d_wgauss.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_wgauss, ref wgauss);
            if( wgauss == null )
                wgauss = new double[0];
            eps = _d_eps;
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_wkronrod);
            x_vector_clear(ref _d_wgauss);
        }
        // This function returns no value.
    }
    
    public static void gkqlegendretbl(int n, out double[] x, out double[] wkronrod, out double[] wgauss, out double eps)
    {
        _core_gkqlegendretbl( n, out  x, out  wkronrod, out  wgauss, out  eps, 0x0);
    }
    
    public static void gkqlegendretbl(int n, out double[] x, out double[] wkronrod, out double[] wgauss, out double eps, alglib.xparams _xparams)
    {
        _core_gkqlegendretbl( n, out  x, out  wkronrod, out  wgauss, out  eps, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage autogk
    //
    

    [StructLayout(LayoutKind.Sequential, Pack=8)]
    private struct x_autogkreport
    {
        public x_int terminationtype;
        public x_int nfev;
        public x_int nintervals;
    }

    public class autogkreport : alglibobject
    {
        public int terminationtype;
        public int nfev;
        public int nintervals;
        public override alglib.alglibobject make_copy()
        {
            autogkreport dst = new autogkreport();
            dst.terminationtype = terminationtype;
            dst.nfev = nfev;
            dst.nintervals = nintervals;
            return dst;
        }
    }

    // This function initializes X-structure (its previous content is ignored)
    private static void x_autogkreport_init(ref x_autogkreport x)
    {
        x.terminationtype.longval = 0;
        x.nfev.longval = 0;
        x.nintervals.longval = 0;
    }

    // This function finalizes fields of X-structure (however, memory occupied by structure itself is not freed)
    // After destruction structure becomes unusable and should be re-initialized if you want to use it
    private static void x_autogkreport_clear(ref x_autogkreport x)
    {
    }

    // This function initializes X-structure by appropriate C# instance
    // (previous content of X structure is ignored)
    private static void x_autogkreport_init_from(ref x_autogkreport x, autogkreport v)
    {
        x.terminationtype.longval = v.terminationtype;
        x.nfev.longval = v.nfev;
        x.nintervals.longval = v.nintervals;
    }

    // This function initializes C# structure by appropriate X instance
    // (previous content of C# structure is ignored).
    // This function may accept null v, in this case v is automatically allocated with new().
    private static void x_autogkreport_to_record(ref x_autogkreport x, ref autogkreport v)
    {
        if( v==null )
            v = new autogkreport();
        v.terminationtype = x.terminationtype.intval; // long is silently truncated to int
        v.nfev = x.nfev.intval; // long is silently truncated to int
        v.nintervals = x.nintervals.intval; // long is silently truncated to int
    }

    public unsafe class autogkstate : alglibobject
    {
        private void *_ptr;
        public autogkstate(void *x)
        {
            _ptr = x;
        }
        ~autogkstate()
        {
            _deallocate();
        }
        public void* ptr { get { return _ptr; } }
        public override alglib.alglibobject make_copy()
        {
            if( _ptr==null )
                return new autogkstate(null);
            return new autogkstate(_i_x_obj_copy_autogkstate(_ptr));
        }
        public override void _deallocate()
        {
            if( _ptr!=null )
                _i_x_obj_free_autogkstate(_ptr);
            _ptr = null;
            System.GC.SuppressFinalize(this);
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_autogkstate(void *x);
    private static _d_x_obj_copy_autogkstate _i_x_obj_copy_autogkstate = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_obj_free_autogkstate(void *x);
    private static _d_x_obj_free_autogkstate _i_x_obj_free_autogkstate = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_autogkstate_get_needf(void *x, byte *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_autogkstate_set_needf(void *x, byte *dst);
    private static _d_x_autogkstate_get_needf _i_x_autogkstate_get_needf = null;
    private static _d_x_autogkstate_set_needf _i_x_autogkstate_set_needf = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_autogkstate_get_x(void *x, double *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_autogkstate_set_x(void *x, double *dst);
    private static _d_x_autogkstate_get_x _i_x_autogkstate_get_x = null;
    private static _d_x_autogkstate_set_x _i_x_autogkstate_set_x = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_autogkstate_get_xminusa(void *x, double *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_autogkstate_set_xminusa(void *x, double *dst);
    private static _d_x_autogkstate_get_xminusa _i_x_autogkstate_get_xminusa = null;
    private static _d_x_autogkstate_set_xminusa _i_x_autogkstate_set_xminusa = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_autogkstate_get_bminusx(void *x, double *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_autogkstate_set_bminusx(void *x, double *dst);
    private static _d_x_autogkstate_get_bminusx _i_x_autogkstate_get_bminusx = null;
    private static _d_x_autogkstate_set_bminusx _i_x_autogkstate_set_bminusx = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_autogkstate_get_f(void *x, double *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_autogkstate_set_f(void *x, double *dst);
    private static _d_x_autogkstate_get_f _i_x_autogkstate_get_f = null;
    private static _d_x_autogkstate_set_f _i_x_autogkstate_set_f = null;
    
    private static unsafe void _core_autogksmooth(double a, double b, out autogkstate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double _d_a = a;
        double _d_b = b;
        void *_d_state = null;
        state = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_autogksmooth(&_s_errormsg, &_d_a, &_d_b, &_d_state, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "autogksmooth");
            state = new autogkstate(_d_state);
        }
        finally
        {
            if( _d_state!=null && state==null)
                _i_x_obj_free_autogkstate(_d_state); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void autogksmooth(double a, double b, out autogkstate state)
    {
        _core_autogksmooth( a,  b, out  state, 0x0);
    }
    
    public static void autogksmooth(double a, double b, out autogkstate state, alglib.xparams _xparams)
    {
        _core_autogksmooth( a,  b, out  state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_autogksmoothw(double a, double b, double xwidth, out autogkstate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double _d_a = a;
        double _d_b = b;
        double _d_xwidth = xwidth;
        void *_d_state = null;
        state = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_autogksmoothw(&_s_errormsg, &_d_a, &_d_b, &_d_xwidth, &_d_state, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "autogksmoothw");
            state = new autogkstate(_d_state);
        }
        finally
        {
            if( _d_state!=null && state==null)
                _i_x_obj_free_autogkstate(_d_state); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void autogksmoothw(double a, double b, double xwidth, out autogkstate state)
    {
        _core_autogksmoothw( a,  b,  xwidth, out  state, 0x0);
    }
    
    public static void autogksmoothw(double a, double b, double xwidth, out autogkstate state, alglib.xparams _xparams)
    {
        _core_autogksmoothw( a,  b,  xwidth, out  state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_autogksingular(double a, double b, double alpha, double beta, out autogkstate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double _d_a = a;
        double _d_b = b;
        double _d_alpha = alpha;
        double _d_beta = beta;
        void *_d_state = null;
        state = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_autogksingular(&_s_errormsg, &_d_a, &_d_b, &_d_alpha, &_d_beta, &_d_state, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "autogksingular");
            state = new autogkstate(_d_state);
        }
        finally
        {
            if( _d_state!=null && state==null)
                _i_x_obj_free_autogkstate(_d_state); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void autogksingular(double a, double b, double alpha, double beta, out autogkstate state)
    {
        _core_autogksingular( a,  b,  alpha,  beta, out  state, 0x0);
    }
    
    public static void autogksingular(double a, double b, double alpha, double beta, out autogkstate state, alglib.xparams _xparams)
    {
        _core_autogksingular( a,  b,  alpha,  beta, out  state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe bool _core_autogkiteration(autogkstate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        bool result;
        byte _d_result = (byte)0;
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_autogkiteration(&_s_errormsg, &_d_result, &_d_state, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "autogkiteration");
            result = _d_result!=0;
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static bool autogkiteration(autogkstate state)
    {
        return _core_autogkiteration( state, 0x0);
    }
    
    public static bool autogkiteration(autogkstate state, alglib.xparams _xparams)
    {
        return _core_autogkiteration( state, _xparams==null ? 0x0 : _xparams.flags);
    }
    public static unsafe void autogkintegrate(autogkstate state, integrator1_func func, object obj)
    {
        autogkintegrate(state, func, obj, null);
    }
    
    public static unsafe void autogkintegrate(autogkstate state, integrator1_func func, object obj, alglib.xparams _xparams)
    {
        byte *_s_errormsg = null;
        int _error_code = 0;
        byte _b_result = (byte)0;
        void *_state = state.ptr;
        double _xc_x = 0;
        double _xc_xminusa = 0;
        double _xc_bminusx = 0;
        double _xc_f = 0;
        byte   _xc_needf = 0;
    
        //
        // Check correctness of delegates
        //
        if( func==null )
            throw new alglibexception("ALGLIB: error in 'autogkintegrate()' (func is null)");
    
        //
        // Main loop
        //
        for(;;)
        {
            //
            // Call iteration function.
            // Terminate iterations if it returned false.
            //
            _error_code = _i_xv2_autogkiteration(&_s_errormsg, &_b_result, &_state, _xparams==null ? 0x0 : _xparams.flags);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "autogkiteration");
            ap.assert(_state==state.ptr, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _b_result==0 )
                break;
    
            //
            // Reverse communication interface:
            // * fetch flags
            // * make delegate calls
            //
            _i_x_autogkstate_get_needf(_state, &_xc_needf);
            if( _xc_needf!=0 )
            {
                _i_x_autogkstate_get_x(_state, &_xc_x);
                _i_x_autogkstate_get_xminusa(_state, &_xc_xminusa);
                _i_x_autogkstate_get_bminusx(_state, &_xc_bminusx);
                func(_xc_x, _xc_xminusa, _xc_bminusx, ref _xc_f, obj);
                _i_x_autogkstate_set_f(_state, &_xc_f);
                continue;
            }
            throw new alglibexception("ALGLIB: error in 'autogkintegrate' (some derivatives were not provided?)");
        }
    }
    
    private static unsafe void _core_autogkresults(autogkstate state, out double v, out autogkreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_v = 0;
        x_autogkreport _d_rep = new x_autogkreport();
        
        // Pack, call, unpack
        try
        {
            x_autogkreport_init(ref _d_rep);
            _error_code = _i_xv2_autogkresults(&_s_errormsg, &_d_state, &_d_v, &_d_rep, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "autogkresults");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            v = _d_v;
            rep = null;
            x_autogkreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_autogkreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void autogkresults(autogkstate state, out double v, out autogkreport rep)
    {
        _core_autogkresults( state, out  v, out  rep, 0x0);
    }
    
    public static void autogkresults(autogkstate state, out double v, out autogkreport rep, alglib.xparams _xparams)
    {
        _core_autogkresults( state, out  v, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage normaldistr
    //
    
    
    private static unsafe double _core_errorfunction(double x, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        double _d_x = x;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_errorfunction(&_s_errormsg, &_d_result, &_d_x, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "errorfunction");
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double errorfunction(double x)
    {
        return _core_errorfunction( x, 0x0);
    }
    
    public static double errorfunction(double x, alglib.xparams _xparams)
    {
        return _core_errorfunction( x, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_errorfunctionc(double x, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        double _d_x = x;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_errorfunctionc(&_s_errormsg, &_d_result, &_d_x, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "errorfunctionc");
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double errorfunctionc(double x)
    {
        return _core_errorfunctionc( x, 0x0);
    }
    
    public static double errorfunctionc(double x, alglib.xparams _xparams)
    {
        return _core_errorfunctionc( x, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_normaldistribution(double x, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        double _d_x = x;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_normaldistribution(&_s_errormsg, &_d_result, &_d_x, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "normaldistribution");
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double normaldistribution(double x)
    {
        return _core_normaldistribution( x, 0x0);
    }
    
    public static double normaldistribution(double x, alglib.xparams _xparams)
    {
        return _core_normaldistribution( x, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_normalpdf(double x, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        double _d_x = x;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_normalpdf(&_s_errormsg, &_d_result, &_d_x, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "normalpdf");
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double normalpdf(double x)
    {
        return _core_normalpdf( x, 0x0);
    }
    
    public static double normalpdf(double x, alglib.xparams _xparams)
    {
        return _core_normalpdf( x, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_normalcdf(double x, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        double _d_x = x;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_normalcdf(&_s_errormsg, &_d_result, &_d_x, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "normalcdf");
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double normalcdf(double x)
    {
        return _core_normalcdf( x, 0x0);
    }
    
    public static double normalcdf(double x, alglib.xparams _xparams)
    {
        return _core_normalcdf( x, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_inverf(double e, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        double _d_e = e;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_inverf(&_s_errormsg, &_d_result, &_d_e, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "inverf");
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double inverf(double e)
    {
        return _core_inverf( e, 0x0);
    }
    
    public static double inverf(double e, alglib.xparams _xparams)
    {
        return _core_inverf( e, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_invnormaldistribution(double y0, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        double _d_y0 = y0;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_invnormaldistribution(&_s_errormsg, &_d_result, &_d_y0, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "invnormaldistribution");
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double invnormaldistribution(double y0)
    {
        return _core_invnormaldistribution( y0, 0x0);
    }
    
    public static double invnormaldistribution(double y0, alglib.xparams _xparams)
    {
        return _core_invnormaldistribution( y0, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_invnormalcdf(double y0, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        double _d_y0 = y0;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_invnormalcdf(&_s_errormsg, &_d_result, &_d_y0, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "invnormalcdf");
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double invnormalcdf(double y0)
    {
        return _core_invnormalcdf( y0, 0x0);
    }
    
    public static double invnormalcdf(double y0, alglib.xparams _xparams)
    {
        return _core_invnormalcdf( y0, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_bivariatenormalpdf(double x, double y, double rho, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        double _d_x = x;
        double _d_y = y;
        double _d_rho = rho;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_bivariatenormalpdf(&_s_errormsg, &_d_result, &_d_x, &_d_y, &_d_rho, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "bivariatenormalpdf");
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double bivariatenormalpdf(double x, double y, double rho)
    {
        return _core_bivariatenormalpdf( x,  y,  rho, 0x0);
    }
    
    public static double bivariatenormalpdf(double x, double y, double rho, alglib.xparams _xparams)
    {
        return _core_bivariatenormalpdf( x,  y,  rho, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_bivariatenormalcdf(double x, double y, double rho, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        double _d_x = x;
        double _d_y = y;
        double _d_rho = rho;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_bivariatenormalcdf(&_s_errormsg, &_d_result, &_d_x, &_d_y, &_d_rho, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "bivariatenormalcdf");
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double bivariatenormalcdf(double x, double y, double rho)
    {
        return _core_bivariatenormalcdf( x,  y,  rho, 0x0);
    }
    
    public static double bivariatenormalcdf(double x, double y, double rho, alglib.xparams _xparams)
    {
        return _core_bivariatenormalcdf( x,  y,  rho, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage ibetaf
    //
    
    
    private static unsafe double _core_incompletebeta(double a, double b, double x, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        double _d_a = a;
        double _d_b = b;
        double _d_x = x;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_incompletebeta(&_s_errormsg, &_d_result, &_d_a, &_d_b, &_d_x, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "incompletebeta");
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double incompletebeta(double a, double b, double x)
    {
        return _core_incompletebeta( a,  b,  x, 0x0);
    }
    
    public static double incompletebeta(double a, double b, double x, alglib.xparams _xparams)
    {
        return _core_incompletebeta( a,  b,  x, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_invincompletebeta(double a, double b, double y, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        double _d_a = a;
        double _d_b = b;
        double _d_y = y;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_invincompletebeta(&_s_errormsg, &_d_result, &_d_a, &_d_b, &_d_y, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "invincompletebeta");
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double invincompletebeta(double a, double b, double y)
    {
        return _core_invincompletebeta( a,  b,  y, 0x0);
    }
    
    public static double invincompletebeta(double a, double b, double y, alglib.xparams _xparams)
    {
        return _core_invincompletebeta( a,  b,  y, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage studenttdistr
    //
    
    
    private static unsafe double _core_studenttdistribution(int k, double t, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_int _d_k = new x_int(k);
        double _d_t = t;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_studenttdistribution(&_s_errormsg, &_d_result, &_d_k, &_d_t, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "studenttdistribution");
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double studenttdistribution(int k, double t)
    {
        return _core_studenttdistribution( k,  t, 0x0);
    }
    
    public static double studenttdistribution(int k, double t, alglib.xparams _xparams)
    {
        return _core_studenttdistribution( k,  t, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_invstudenttdistribution(int k, double p, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_int _d_k = new x_int(k);
        double _d_p = p;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_invstudenttdistribution(&_s_errormsg, &_d_result, &_d_k, &_d_p, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "invstudenttdistribution");
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double invstudenttdistribution(int k, double p)
    {
        return _core_invstudenttdistribution( k,  p, 0x0);
    }
    
    public static double invstudenttdistribution(int k, double p, alglib.xparams _xparams)
    {
        return _core_invstudenttdistribution( k,  p, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage basestat
    //
    
    
    private static unsafe void _core_samplemoments(double[] x, int n, out double mean, out double variance, out double skewness, out double kurtosis, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_int _d_n = new x_int(n);
        double _d_mean = 0;
        double _d_variance = 0;
        double _d_skewness = 0;
        double _d_kurtosis = 0;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_xv2_samplemoments(&_s_errormsg, &_d_x, &_d_n, &_d_mean, &_d_variance, &_d_skewness, &_d_kurtosis, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "samplemoments");
            mean = _d_mean;
            variance = _d_variance;
            skewness = _d_skewness;
            kurtosis = _d_kurtosis;
        }
        finally
        {
            x_vector_clear(ref _d_x);
        }
        // This function returns no value.
    }
    
    public static void samplemoments(double[] x, int n, out double mean, out double variance, out double skewness, out double kurtosis)
    {
        _core_samplemoments( x,  n, out  mean, out  variance, out  skewness, out  kurtosis, 0x0);
    }
    
    public static void samplemoments(double[] x, int n, out double mean, out double variance, out double skewness, out double kurtosis, alglib.xparams _xparams)
    {
        _core_samplemoments( x,  n, out  mean, out  variance, out  skewness, out  kurtosis, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void samplemoments(double[] x, out double mean, out double variance, out double skewness, out double kurtosis)
    {
        int n;
    
        n = ap.len(x);
        _core_samplemoments( x,  n, out  mean, out  variance, out  skewness, out  kurtosis, 0x0);
    
        
    }
    
    public static void samplemoments(double[] x, out double mean, out double variance, out double skewness, out double kurtosis, alglib.xparams _xparams)
    {
        int n;
    
        n = ap.len(x);
        _core_samplemoments( x,  n, out  mean, out  variance, out  skewness, out  kurtosis, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe double _core_samplemean(double[] x, int n, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_vector _d_x = new x_vector();
        x_int _d_n = new x_int(n);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_xv2_samplemean(&_s_errormsg, &_d_result, &_d_x, &_d_n, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "samplemean");
            result = _d_result;
        }
        finally
        {
            x_vector_clear(ref _d_x);
        }
        return result;
    }
    
    public static double samplemean(double[] x, int n)
    {
        return _core_samplemean( x,  n, 0x0);
    }
    
    public static double samplemean(double[] x, int n, alglib.xparams _xparams)
    {
        return _core_samplemean( x,  n, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static double samplemean(double[] x)
    {
        int n;
    
        n = ap.len(x);
        double result = _core_samplemean( x,  n, 0x0);
    
        return result;
    }
    
    public static double samplemean(double[] x, alglib.xparams _xparams)
    {
        int n;
    
        n = ap.len(x);
        double result = _core_samplemean( x,  n, _xparams==null ? 0x0 : _xparams.flags);
    
        return result;
    }
    
    private static unsafe double _core_samplevariance(double[] x, int n, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_vector _d_x = new x_vector();
        x_int _d_n = new x_int(n);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_xv2_samplevariance(&_s_errormsg, &_d_result, &_d_x, &_d_n, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "samplevariance");
            result = _d_result;
        }
        finally
        {
            x_vector_clear(ref _d_x);
        }
        return result;
    }
    
    public static double samplevariance(double[] x, int n)
    {
        return _core_samplevariance( x,  n, 0x0);
    }
    
    public static double samplevariance(double[] x, int n, alglib.xparams _xparams)
    {
        return _core_samplevariance( x,  n, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static double samplevariance(double[] x)
    {
        int n;
    
        n = ap.len(x);
        double result = _core_samplevariance( x,  n, 0x0);
    
        return result;
    }
    
    public static double samplevariance(double[] x, alglib.xparams _xparams)
    {
        int n;
    
        n = ap.len(x);
        double result = _core_samplevariance( x,  n, _xparams==null ? 0x0 : _xparams.flags);
    
        return result;
    }
    
    private static unsafe double _core_sampleskewness(double[] x, int n, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_vector _d_x = new x_vector();
        x_int _d_n = new x_int(n);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_xv2_sampleskewness(&_s_errormsg, &_d_result, &_d_x, &_d_n, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sampleskewness");
            result = _d_result;
        }
        finally
        {
            x_vector_clear(ref _d_x);
        }
        return result;
    }
    
    public static double sampleskewness(double[] x, int n)
    {
        return _core_sampleskewness( x,  n, 0x0);
    }
    
    public static double sampleskewness(double[] x, int n, alglib.xparams _xparams)
    {
        return _core_sampleskewness( x,  n, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static double sampleskewness(double[] x)
    {
        int n;
    
        n = ap.len(x);
        double result = _core_sampleskewness( x,  n, 0x0);
    
        return result;
    }
    
    public static double sampleskewness(double[] x, alglib.xparams _xparams)
    {
        int n;
    
        n = ap.len(x);
        double result = _core_sampleskewness( x,  n, _xparams==null ? 0x0 : _xparams.flags);
    
        return result;
    }
    
    private static unsafe double _core_samplekurtosis(double[] x, int n, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_vector _d_x = new x_vector();
        x_int _d_n = new x_int(n);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_xv2_samplekurtosis(&_s_errormsg, &_d_result, &_d_x, &_d_n, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "samplekurtosis");
            result = _d_result;
        }
        finally
        {
            x_vector_clear(ref _d_x);
        }
        return result;
    }
    
    public static double samplekurtosis(double[] x, int n)
    {
        return _core_samplekurtosis( x,  n, 0x0);
    }
    
    public static double samplekurtosis(double[] x, int n, alglib.xparams _xparams)
    {
        return _core_samplekurtosis( x,  n, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static double samplekurtosis(double[] x)
    {
        int n;
    
        n = ap.len(x);
        double result = _core_samplekurtosis( x,  n, 0x0);
    
        return result;
    }
    
    public static double samplekurtosis(double[] x, alglib.xparams _xparams)
    {
        int n;
    
        n = ap.len(x);
        double result = _core_samplekurtosis( x,  n, _xparams==null ? 0x0 : _xparams.flags);
    
        return result;
    }
    
    private static unsafe void _core_sampleadev(double[] x, int n, out double adev, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_int _d_n = new x_int(n);
        double _d_adev = 0;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_xv2_sampleadev(&_s_errormsg, &_d_x, &_d_n, &_d_adev, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sampleadev");
            adev = _d_adev;
        }
        finally
        {
            x_vector_clear(ref _d_x);
        }
        // This function returns no value.
    }
    
    public static void sampleadev(double[] x, int n, out double adev)
    {
        _core_sampleadev( x,  n, out  adev, 0x0);
    }
    
    public static void sampleadev(double[] x, int n, out double adev, alglib.xparams _xparams)
    {
        _core_sampleadev( x,  n, out  adev, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void sampleadev(double[] x, out double adev)
    {
        int n;
    
        n = ap.len(x);
        _core_sampleadev( x,  n, out  adev, 0x0);
    
        
    }
    
    public static void sampleadev(double[] x, out double adev, alglib.xparams _xparams)
    {
        int n;
    
        n = ap.len(x);
        _core_sampleadev( x,  n, out  adev, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_samplemedian(double[] x, int n, out double median, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_int _d_n = new x_int(n);
        double _d_median = 0;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_xv2_samplemedian(&_s_errormsg, &_d_x, &_d_n, &_d_median, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "samplemedian");
            median = _d_median;
        }
        finally
        {
            x_vector_clear(ref _d_x);
        }
        // This function returns no value.
    }
    
    public static void samplemedian(double[] x, int n, out double median)
    {
        _core_samplemedian( x,  n, out  median, 0x0);
    }
    
    public static void samplemedian(double[] x, int n, out double median, alglib.xparams _xparams)
    {
        _core_samplemedian( x,  n, out  median, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void samplemedian(double[] x, out double median)
    {
        int n;
    
        n = ap.len(x);
        _core_samplemedian( x,  n, out  median, 0x0);
    
        
    }
    
    public static void samplemedian(double[] x, out double median, alglib.xparams _xparams)
    {
        int n;
    
        n = ap.len(x);
        _core_samplemedian( x,  n, out  median, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_samplepercentile(double[] x, int n, double p, out double v, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_int _d_n = new x_int(n);
        double _d_p = p;
        double _d_v = 0;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_xv2_samplepercentile(&_s_errormsg, &_d_x, &_d_n, &_d_p, &_d_v, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "samplepercentile");
            v = _d_v;
        }
        finally
        {
            x_vector_clear(ref _d_x);
        }
        // This function returns no value.
    }
    
    public static void samplepercentile(double[] x, int n, double p, out double v)
    {
        _core_samplepercentile( x,  n,  p, out  v, 0x0);
    }
    
    public static void samplepercentile(double[] x, int n, double p, out double v, alglib.xparams _xparams)
    {
        _core_samplepercentile( x,  n,  p, out  v, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void samplepercentile(double[] x, double p, out double v)
    {
        int n;
    
        n = ap.len(x);
        _core_samplepercentile( x,  n,  p, out  v, 0x0);
    
        
    }
    
    public static void samplepercentile(double[] x, double p, out double v, alglib.xparams _xparams)
    {
        int n;
    
        n = ap.len(x);
        _core_samplepercentile( x,  n,  p, out  v, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe double _core_cov2(double[] x, double[] y, int n, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_int _d_n = new x_int(n);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                _error_code = _i_xv2_cov2(&_s_errormsg, &_d_result, &_d_x, &_d_y, &_d_n, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "cov2");
            result = _d_result;
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
        }
        return result;
    }
    
    public static double cov2(double[] x, double[] y, int n)
    {
        return _core_cov2( x,  y,  n, 0x0);
    }
    
    public static double cov2(double[] x, double[] y, int n, alglib.xparams _xparams)
    {
        return _core_cov2( x,  y,  n, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static double cov2(double[] x, double[] y)
    {
        int n;
        if( (ap.len(x)!=ap.len(y)))
            throw new alglibexception("Error while calling 'cov2': looks like one of arguments has wrong size");
        n = ap.len(x);
        double result = _core_cov2( x,  y,  n, 0x0);
    
        return result;
    }
    
    public static double cov2(double[] x, double[] y, alglib.xparams _xparams)
    {
        int n;
        if( (ap.len(x)!=ap.len(y)))
            throw new alglibexception("Error while calling 'cov2': looks like one of arguments has wrong size");
        n = ap.len(x);
        double result = _core_cov2( x,  y,  n, _xparams==null ? 0x0 : _xparams.flags);
    
        return result;
    }
    
    private static unsafe double _core_pearsoncorr2(double[] x, double[] y, int n, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_int _d_n = new x_int(n);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                _error_code = _i_xv2_pearsoncorr2(&_s_errormsg, &_d_result, &_d_x, &_d_y, &_d_n, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "pearsoncorr2");
            result = _d_result;
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
        }
        return result;
    }
    
    public static double pearsoncorr2(double[] x, double[] y, int n)
    {
        return _core_pearsoncorr2( x,  y,  n, 0x0);
    }
    
    public static double pearsoncorr2(double[] x, double[] y, int n, alglib.xparams _xparams)
    {
        return _core_pearsoncorr2( x,  y,  n, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static double pearsoncorr2(double[] x, double[] y)
    {
        int n;
        if( (ap.len(x)!=ap.len(y)))
            throw new alglibexception("Error while calling 'pearsoncorr2': looks like one of arguments has wrong size");
        n = ap.len(x);
        double result = _core_pearsoncorr2( x,  y,  n, 0x0);
    
        return result;
    }
    
    public static double pearsoncorr2(double[] x, double[] y, alglib.xparams _xparams)
    {
        int n;
        if( (ap.len(x)!=ap.len(y)))
            throw new alglibexception("Error while calling 'pearsoncorr2': looks like one of arguments has wrong size");
        n = ap.len(x);
        double result = _core_pearsoncorr2( x,  y,  n, _xparams==null ? 0x0 : _xparams.flags);
    
        return result;
    }
    
    private static unsafe double _core_spearmancorr2(double[] x, double[] y, int n, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_int _d_n = new x_int(n);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                _error_code = _i_xv2_spearmancorr2(&_s_errormsg, &_d_result, &_d_x, &_d_y, &_d_n, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spearmancorr2");
            result = _d_result;
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
        }
        return result;
    }
    
    public static double spearmancorr2(double[] x, double[] y, int n)
    {
        return _core_spearmancorr2( x,  y,  n, 0x0);
    }
    
    public static double spearmancorr2(double[] x, double[] y, int n, alglib.xparams _xparams)
    {
        return _core_spearmancorr2( x,  y,  n, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static double spearmancorr2(double[] x, double[] y)
    {
        int n;
        if( (ap.len(x)!=ap.len(y)))
            throw new alglibexception("Error while calling 'spearmancorr2': looks like one of arguments has wrong size");
        n = ap.len(x);
        double result = _core_spearmancorr2( x,  y,  n, 0x0);
    
        return result;
    }
    
    public static double spearmancorr2(double[] x, double[] y, alglib.xparams _xparams)
    {
        int n;
        if( (ap.len(x)!=ap.len(y)))
            throw new alglibexception("Error while calling 'spearmancorr2': looks like one of arguments has wrong size");
        n = ap.len(x);
        double result = _core_spearmancorr2( x,  y,  n, _xparams==null ? 0x0 : _xparams.flags);
    
        return result;
    }
    
    private static unsafe void _core_covm(double[,] x, int n, int m, out double[,] c, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_x = new x_matrix();
        x_int _d_n = new x_int(n);
        x_int _d_m = new x_int(m);
        x_matrix _d_c = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_matrix_attach_to_array(ref _d_x, _fp_x, ap.rows(x), ap.cols(x));
                x_matrix_create_empty(ref _d_c, DT_REAL);
                c = null;
                _error_code = _i_xv2_covm(&_s_errormsg, &_d_x, &_d_n, &_d_m, &_d_c, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "covm");
            if( _d_c.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_c, ref c);
            if( c == null )
                c = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_x);
            x_matrix_clear(ref _d_c);
        }
        // This function returns no value.
    }
    
    public static void covm(double[,] x, int n, int m, out double[,] c)
    {
        _core_covm( x,  n,  m, out  c, 0x0);
    }
    
    public static void covm(double[,] x, int n, int m, out double[,] c, alglib.xparams _xparams)
    {
        _core_covm( x,  n,  m, out  c, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void covm(double[,] x, out double[,] c)
    {
        int n;
        int m;
    
        n = ap.rows(x);
        m = ap.cols(x);
        _core_covm( x,  n,  m, out  c, 0x0);
    
        
    }
    
    public static void covm(double[,] x, out double[,] c, alglib.xparams _xparams)
    {
        int n;
        int m;
    
        n = ap.rows(x);
        m = ap.cols(x);
        _core_covm( x,  n,  m, out  c, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_pearsoncorrm(double[,] x, int n, int m, out double[,] c, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_x = new x_matrix();
        x_int _d_n = new x_int(n);
        x_int _d_m = new x_int(m);
        x_matrix _d_c = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_matrix_attach_to_array(ref _d_x, _fp_x, ap.rows(x), ap.cols(x));
                x_matrix_create_empty(ref _d_c, DT_REAL);
                c = null;
                _error_code = _i_xv2_pearsoncorrm(&_s_errormsg, &_d_x, &_d_n, &_d_m, &_d_c, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "pearsoncorrm");
            if( _d_c.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_c, ref c);
            if( c == null )
                c = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_x);
            x_matrix_clear(ref _d_c);
        }
        // This function returns no value.
    }
    
    public static void pearsoncorrm(double[,] x, int n, int m, out double[,] c)
    {
        _core_pearsoncorrm( x,  n,  m, out  c, 0x0);
    }
    
    public static void pearsoncorrm(double[,] x, int n, int m, out double[,] c, alglib.xparams _xparams)
    {
        _core_pearsoncorrm( x,  n,  m, out  c, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void pearsoncorrm(double[,] x, out double[,] c)
    {
        int n;
        int m;
    
        n = ap.rows(x);
        m = ap.cols(x);
        _core_pearsoncorrm( x,  n,  m, out  c, 0x0);
    
        
    }
    
    public static void pearsoncorrm(double[,] x, out double[,] c, alglib.xparams _xparams)
    {
        int n;
        int m;
    
        n = ap.rows(x);
        m = ap.cols(x);
        _core_pearsoncorrm( x,  n,  m, out  c, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_spearmancorrm(double[,] x, int n, int m, out double[,] c, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_x = new x_matrix();
        x_int _d_n = new x_int(n);
        x_int _d_m = new x_int(m);
        x_matrix _d_c = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_matrix_attach_to_array(ref _d_x, _fp_x, ap.rows(x), ap.cols(x));
                x_matrix_create_empty(ref _d_c, DT_REAL);
                c = null;
                _error_code = _i_xv2_spearmancorrm(&_s_errormsg, &_d_x, &_d_n, &_d_m, &_d_c, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spearmancorrm");
            if( _d_c.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_c, ref c);
            if( c == null )
                c = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_x);
            x_matrix_clear(ref _d_c);
        }
        // This function returns no value.
    }
    
    public static void spearmancorrm(double[,] x, int n, int m, out double[,] c)
    {
        _core_spearmancorrm( x,  n,  m, out  c, 0x0);
    }
    
    public static void spearmancorrm(double[,] x, int n, int m, out double[,] c, alglib.xparams _xparams)
    {
        _core_spearmancorrm( x,  n,  m, out  c, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void spearmancorrm(double[,] x, out double[,] c)
    {
        int n;
        int m;
    
        n = ap.rows(x);
        m = ap.cols(x);
        _core_spearmancorrm( x,  n,  m, out  c, 0x0);
    
        
    }
    
    public static void spearmancorrm(double[,] x, out double[,] c, alglib.xparams _xparams)
    {
        int n;
        int m;
    
        n = ap.rows(x);
        m = ap.cols(x);
        _core_spearmancorrm( x,  n,  m, out  c, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_covm2(double[,] x, double[,] y, int n, int m1, int m2, out double[,] c, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_x = new x_matrix();
        x_matrix _d_y = new x_matrix();
        x_int _d_n = new x_int(n);
        x_int _d_m1 = new x_int(m1);
        x_int _d_m2 = new x_int(m2);
        x_matrix _d_c = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_matrix_attach_to_array(ref _d_x, _fp_x, ap.rows(x), ap.cols(x));
                x_matrix_attach_to_array(ref _d_y, _fp_y, ap.rows(y), ap.cols(y));
                x_matrix_create_empty(ref _d_c, DT_REAL);
                c = null;
                _error_code = _i_xv2_covm2(&_s_errormsg, &_d_x, &_d_y, &_d_n, &_d_m1, &_d_m2, &_d_c, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "covm2");
            if( _d_c.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_c, ref c);
            if( c == null )
                c = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_x);
            x_matrix_clear(ref _d_y);
            x_matrix_clear(ref _d_c);
        }
        // This function returns no value.
    }
    
    public static void covm2(double[,] x, double[,] y, int n, int m1, int m2, out double[,] c)
    {
        _core_covm2( x,  y,  n,  m1,  m2, out  c, 0x0);
    }
    
    public static void covm2(double[,] x, double[,] y, int n, int m1, int m2, out double[,] c, alglib.xparams _xparams)
    {
        _core_covm2( x,  y,  n,  m1,  m2, out  c, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void covm2(double[,] x, double[,] y, out double[,] c)
    {
        int n;
        int m1;
        int m2;
        if( (ap.rows(x)!=ap.rows(y)))
            throw new alglibexception("Error while calling 'covm2': looks like one of arguments has wrong size");
        n = ap.rows(x);
        m1 = ap.cols(x);
        m2 = ap.cols(y);
        _core_covm2( x,  y,  n,  m1,  m2, out  c, 0x0);
    
        
    }
    
    public static void covm2(double[,] x, double[,] y, out double[,] c, alglib.xparams _xparams)
    {
        int n;
        int m1;
        int m2;
        if( (ap.rows(x)!=ap.rows(y)))
            throw new alglibexception("Error while calling 'covm2': looks like one of arguments has wrong size");
        n = ap.rows(x);
        m1 = ap.cols(x);
        m2 = ap.cols(y);
        _core_covm2( x,  y,  n,  m1,  m2, out  c, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_pearsoncorrm2(double[,] x, double[,] y, int n, int m1, int m2, out double[,] c, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_x = new x_matrix();
        x_matrix _d_y = new x_matrix();
        x_int _d_n = new x_int(n);
        x_int _d_m1 = new x_int(m1);
        x_int _d_m2 = new x_int(m2);
        x_matrix _d_c = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_matrix_attach_to_array(ref _d_x, _fp_x, ap.rows(x), ap.cols(x));
                x_matrix_attach_to_array(ref _d_y, _fp_y, ap.rows(y), ap.cols(y));
                x_matrix_create_empty(ref _d_c, DT_REAL);
                c = null;
                _error_code = _i_xv2_pearsoncorrm2(&_s_errormsg, &_d_x, &_d_y, &_d_n, &_d_m1, &_d_m2, &_d_c, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "pearsoncorrm2");
            if( _d_c.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_c, ref c);
            if( c == null )
                c = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_x);
            x_matrix_clear(ref _d_y);
            x_matrix_clear(ref _d_c);
        }
        // This function returns no value.
    }
    
    public static void pearsoncorrm2(double[,] x, double[,] y, int n, int m1, int m2, out double[,] c)
    {
        _core_pearsoncorrm2( x,  y,  n,  m1,  m2, out  c, 0x0);
    }
    
    public static void pearsoncorrm2(double[,] x, double[,] y, int n, int m1, int m2, out double[,] c, alglib.xparams _xparams)
    {
        _core_pearsoncorrm2( x,  y,  n,  m1,  m2, out  c, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void pearsoncorrm2(double[,] x, double[,] y, out double[,] c)
    {
        int n;
        int m1;
        int m2;
        if( (ap.rows(x)!=ap.rows(y)))
            throw new alglibexception("Error while calling 'pearsoncorrm2': looks like one of arguments has wrong size");
        n = ap.rows(x);
        m1 = ap.cols(x);
        m2 = ap.cols(y);
        _core_pearsoncorrm2( x,  y,  n,  m1,  m2, out  c, 0x0);
    
        
    }
    
    public static void pearsoncorrm2(double[,] x, double[,] y, out double[,] c, alglib.xparams _xparams)
    {
        int n;
        int m1;
        int m2;
        if( (ap.rows(x)!=ap.rows(y)))
            throw new alglibexception("Error while calling 'pearsoncorrm2': looks like one of arguments has wrong size");
        n = ap.rows(x);
        m1 = ap.cols(x);
        m2 = ap.cols(y);
        _core_pearsoncorrm2( x,  y,  n,  m1,  m2, out  c, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_spearmancorrm2(double[,] x, double[,] y, int n, int m1, int m2, out double[,] c, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_x = new x_matrix();
        x_matrix _d_y = new x_matrix();
        x_int _d_n = new x_int(n);
        x_int _d_m1 = new x_int(m1);
        x_int _d_m2 = new x_int(m2);
        x_matrix _d_c = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_matrix_attach_to_array(ref _d_x, _fp_x, ap.rows(x), ap.cols(x));
                x_matrix_attach_to_array(ref _d_y, _fp_y, ap.rows(y), ap.cols(y));
                x_matrix_create_empty(ref _d_c, DT_REAL);
                c = null;
                _error_code = _i_xv2_spearmancorrm2(&_s_errormsg, &_d_x, &_d_y, &_d_n, &_d_m1, &_d_m2, &_d_c, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spearmancorrm2");
            if( _d_c.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_c, ref c);
            if( c == null )
                c = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_x);
            x_matrix_clear(ref _d_y);
            x_matrix_clear(ref _d_c);
        }
        // This function returns no value.
    }
    
    public static void spearmancorrm2(double[,] x, double[,] y, int n, int m1, int m2, out double[,] c)
    {
        _core_spearmancorrm2( x,  y,  n,  m1,  m2, out  c, 0x0);
    }
    
    public static void spearmancorrm2(double[,] x, double[,] y, int n, int m1, int m2, out double[,] c, alglib.xparams _xparams)
    {
        _core_spearmancorrm2( x,  y,  n,  m1,  m2, out  c, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void spearmancorrm2(double[,] x, double[,] y, out double[,] c)
    {
        int n;
        int m1;
        int m2;
        if( (ap.rows(x)!=ap.rows(y)))
            throw new alglibexception("Error while calling 'spearmancorrm2': looks like one of arguments has wrong size");
        n = ap.rows(x);
        m1 = ap.cols(x);
        m2 = ap.cols(y);
        _core_spearmancorrm2( x,  y,  n,  m1,  m2, out  c, 0x0);
    
        
    }
    
    public static void spearmancorrm2(double[,] x, double[,] y, out double[,] c, alglib.xparams _xparams)
    {
        int n;
        int m1;
        int m2;
        if( (ap.rows(x)!=ap.rows(y)))
            throw new alglibexception("Error while calling 'spearmancorrm2': looks like one of arguments has wrong size");
        n = ap.rows(x);
        m1 = ap.cols(x);
        m2 = ap.cols(y);
        _core_spearmancorrm2( x,  y,  n,  m1,  m2, out  c, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_rankdata(ref double[,] xy, int npoints, int nfeatures, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        x_int _d_nfeatures = new x_int(nfeatures);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_xv2_rankdata(&_s_errormsg, &_d_xy, &_d_npoints, &_d_nfeatures, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rankdata");
            if( _d_xy.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_xy, ref xy);
            if( xy == null )
                xy = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
        }
        // This function returns no value.
    }
    
    public static void rankdata(ref double[,] xy, int npoints, int nfeatures)
    {
        _core_rankdata(ref  xy,  npoints,  nfeatures, 0x0);
    }
    
    public static void rankdata(ref double[,] xy, int npoints, int nfeatures, alglib.xparams _xparams)
    {
        _core_rankdata(ref  xy,  npoints,  nfeatures, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void rankdata(ref double[,] xy)
    {
        int npoints;
        int nfeatures;
    
        npoints = ap.rows(xy);
        nfeatures = ap.cols(xy);
        _core_rankdata(ref  xy,  npoints,  nfeatures, 0x0);
    
        
    }
    
    public static void rankdata(ref double[,] xy, alglib.xparams _xparams)
    {
        int npoints;
        int nfeatures;
    
        npoints = ap.rows(xy);
        nfeatures = ap.cols(xy);
        _core_rankdata(ref  xy,  npoints,  nfeatures, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_rankdatacentered(ref double[,] xy, int npoints, int nfeatures, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        x_int _d_nfeatures = new x_int(nfeatures);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_xv2_rankdatacentered(&_s_errormsg, &_d_xy, &_d_npoints, &_d_nfeatures, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rankdatacentered");
            if( _d_xy.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_xy, ref xy);
            if( xy == null )
                xy = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
        }
        // This function returns no value.
    }
    
    public static void rankdatacentered(ref double[,] xy, int npoints, int nfeatures)
    {
        _core_rankdatacentered(ref  xy,  npoints,  nfeatures, 0x0);
    }
    
    public static void rankdatacentered(ref double[,] xy, int npoints, int nfeatures, alglib.xparams _xparams)
    {
        _core_rankdatacentered(ref  xy,  npoints,  nfeatures, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void rankdatacentered(ref double[,] xy)
    {
        int npoints;
        int nfeatures;
    
        npoints = ap.rows(xy);
        nfeatures = ap.cols(xy);
        _core_rankdatacentered(ref  xy,  npoints,  nfeatures, 0x0);
    
        
    }
    
    public static void rankdatacentered(ref double[,] xy, alglib.xparams _xparams)
    {
        int npoints;
        int nfeatures;
    
        npoints = ap.rows(xy);
        nfeatures = ap.cols(xy);
        _core_rankdatacentered(ref  xy,  npoints,  nfeatures, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe double _core_pearsoncorrelation(double[] x, double[] y, int n, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_int _d_n = new x_int(n);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                _error_code = _i_xv2_pearsoncorrelation(&_s_errormsg, &_d_result, &_d_x, &_d_y, &_d_n, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "pearsoncorrelation");
            result = _d_result;
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
        }
        return result;
    }
    
    public static double pearsoncorrelation(double[] x, double[] y, int n)
    {
        return _core_pearsoncorrelation( x,  y,  n, 0x0);
    }
    
    public static double pearsoncorrelation(double[] x, double[] y, int n, alglib.xparams _xparams)
    {
        return _core_pearsoncorrelation( x,  y,  n, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_spearmanrankcorrelation(double[] x, double[] y, int n, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_int _d_n = new x_int(n);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                _error_code = _i_xv2_spearmanrankcorrelation(&_s_errormsg, &_d_result, &_d_x, &_d_y, &_d_n, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spearmanrankcorrelation");
            result = _d_result;
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
        }
        return result;
    }
    
    public static double spearmanrankcorrelation(double[] x, double[] y, int n)
    {
        return _core_spearmanrankcorrelation( x,  y,  n, 0x0);
    }
    
    public static double spearmanrankcorrelation(double[] x, double[] y, int n, alglib.xparams _xparams)
    {
        return _core_spearmanrankcorrelation( x,  y,  n, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage correlationtests
    //
    
    
    private static unsafe void _core_pearsoncorrelationsignificance(double r, int n, out double bothtails, out double lefttail, out double righttail, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double _d_r = r;
        x_int _d_n = new x_int(n);
        double _d_bothtails = 0;
        double _d_lefttail = 0;
        double _d_righttail = 0;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_pearsoncorrelationsignificance(&_s_errormsg, &_d_r, &_d_n, &_d_bothtails, &_d_lefttail, &_d_righttail, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "pearsoncorrelationsignificance");
            bothtails = _d_bothtails;
            lefttail = _d_lefttail;
            righttail = _d_righttail;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void pearsoncorrelationsignificance(double r, int n, out double bothtails, out double lefttail, out double righttail)
    {
        _core_pearsoncorrelationsignificance( r,  n, out  bothtails, out  lefttail, out  righttail, 0x0);
    }
    
    public static void pearsoncorrelationsignificance(double r, int n, out double bothtails, out double lefttail, out double righttail, alglib.xparams _xparams)
    {
        _core_pearsoncorrelationsignificance( r,  n, out  bothtails, out  lefttail, out  righttail, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_spearmanrankcorrelationsignificance(double r, int n, out double bothtails, out double lefttail, out double righttail, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double _d_r = r;
        x_int _d_n = new x_int(n);
        double _d_bothtails = 0;
        double _d_lefttail = 0;
        double _d_righttail = 0;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_spearmanrankcorrelationsignificance(&_s_errormsg, &_d_r, &_d_n, &_d_bothtails, &_d_lefttail, &_d_righttail, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spearmanrankcorrelationsignificance");
            bothtails = _d_bothtails;
            lefttail = _d_lefttail;
            righttail = _d_righttail;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void spearmanrankcorrelationsignificance(double r, int n, out double bothtails, out double lefttail, out double righttail)
    {
        _core_spearmanrankcorrelationsignificance( r,  n, out  bothtails, out  lefttail, out  righttail, 0x0);
    }
    
    public static void spearmanrankcorrelationsignificance(double r, int n, out double bothtails, out double lefttail, out double righttail, alglib.xparams _xparams)
    {
        _core_spearmanrankcorrelationsignificance( r,  n, out  bothtails, out  lefttail, out  righttail, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage jarquebera
    //
    
    
    private static unsafe void _core_jarqueberatest(double[] x, int n, out double p, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_int _d_n = new x_int(n);
        double _d_p = 0;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_xv2_jarqueberatest(&_s_errormsg, &_d_x, &_d_n, &_d_p, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "jarqueberatest");
            p = _d_p;
        }
        finally
        {
            x_vector_clear(ref _d_x);
        }
        // This function returns no value.
    }
    
    public static void jarqueberatest(double[] x, int n, out double p)
    {
        _core_jarqueberatest( x,  n, out  p, 0x0);
    }
    
    public static void jarqueberatest(double[] x, int n, out double p, alglib.xparams _xparams)
    {
        _core_jarqueberatest( x,  n, out  p, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage fdistr
    //
    
    
    private static unsafe double _core_fdistribution(int a, int b, double x, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_int _d_a = new x_int(a);
        x_int _d_b = new x_int(b);
        double _d_x = x;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_fdistribution(&_s_errormsg, &_d_result, &_d_a, &_d_b, &_d_x, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "fdistribution");
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double fdistribution(int a, int b, double x)
    {
        return _core_fdistribution( a,  b,  x, 0x0);
    }
    
    public static double fdistribution(int a, int b, double x, alglib.xparams _xparams)
    {
        return _core_fdistribution( a,  b,  x, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_fcdistribution(int a, int b, double x, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_int _d_a = new x_int(a);
        x_int _d_b = new x_int(b);
        double _d_x = x;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_fcdistribution(&_s_errormsg, &_d_result, &_d_a, &_d_b, &_d_x, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "fcdistribution");
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double fcdistribution(int a, int b, double x)
    {
        return _core_fcdistribution( a,  b,  x, 0x0);
    }
    
    public static double fcdistribution(int a, int b, double x, alglib.xparams _xparams)
    {
        return _core_fcdistribution( a,  b,  x, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_invfdistribution(int a, int b, double y, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_int _d_a = new x_int(a);
        x_int _d_b = new x_int(b);
        double _d_y = y;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_invfdistribution(&_s_errormsg, &_d_result, &_d_a, &_d_b, &_d_y, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "invfdistribution");
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double invfdistribution(int a, int b, double y)
    {
        return _core_invfdistribution( a,  b,  y, 0x0);
    }
    
    public static double invfdistribution(int a, int b, double y, alglib.xparams _xparams)
    {
        return _core_invfdistribution( a,  b,  y, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage igammaf
    //
    
    
    private static unsafe double _core_incompletegamma(double a, double x, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        double _d_a = a;
        double _d_x = x;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_incompletegamma(&_s_errormsg, &_d_result, &_d_a, &_d_x, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "incompletegamma");
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double incompletegamma(double a, double x)
    {
        return _core_incompletegamma( a,  x, 0x0);
    }
    
    public static double incompletegamma(double a, double x, alglib.xparams _xparams)
    {
        return _core_incompletegamma( a,  x, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_incompletegammac(double a, double x, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        double _d_a = a;
        double _d_x = x;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_incompletegammac(&_s_errormsg, &_d_result, &_d_a, &_d_x, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "incompletegammac");
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double incompletegammac(double a, double x)
    {
        return _core_incompletegammac( a,  x, 0x0);
    }
    
    public static double incompletegammac(double a, double x, alglib.xparams _xparams)
    {
        return _core_incompletegammac( a,  x, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_invincompletegammac(double a, double y0, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        double _d_a = a;
        double _d_y0 = y0;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_invincompletegammac(&_s_errormsg, &_d_result, &_d_a, &_d_y0, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "invincompletegammac");
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double invincompletegammac(double a, double y0)
    {
        return _core_invincompletegammac( a,  y0, 0x0);
    }
    
    public static double invincompletegammac(double a, double y0, alglib.xparams _xparams)
    {
        return _core_invincompletegammac( a,  y0, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage chisquaredistr
    //
    
    
    private static unsafe double _core_chisquaredistribution(double v, double x, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        double _d_v = v;
        double _d_x = x;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_chisquaredistribution(&_s_errormsg, &_d_result, &_d_v, &_d_x, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "chisquaredistribution");
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double chisquaredistribution(double v, double x)
    {
        return _core_chisquaredistribution( v,  x, 0x0);
    }
    
    public static double chisquaredistribution(double v, double x, alglib.xparams _xparams)
    {
        return _core_chisquaredistribution( v,  x, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_chisquarecdistribution(double v, double x, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        double _d_v = v;
        double _d_x = x;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_chisquarecdistribution(&_s_errormsg, &_d_result, &_d_v, &_d_x, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "chisquarecdistribution");
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double chisquarecdistribution(double v, double x)
    {
        return _core_chisquarecdistribution( v,  x, 0x0);
    }
    
    public static double chisquarecdistribution(double v, double x, alglib.xparams _xparams)
    {
        return _core_chisquarecdistribution( v,  x, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_invchisquaredistribution(double v, double y, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        double _d_v = v;
        double _d_y = y;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_invchisquaredistribution(&_s_errormsg, &_d_result, &_d_v, &_d_y, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "invchisquaredistribution");
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double invchisquaredistribution(double v, double y)
    {
        return _core_invchisquaredistribution( v,  y, 0x0);
    }
    
    public static double invchisquaredistribution(double v, double y, alglib.xparams _xparams)
    {
        return _core_invchisquaredistribution( v,  y, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage variancetests
    //
    
    
    private static unsafe void _core_ftest(double[] x, int n, double[] y, int m, out double bothtails, out double lefttail, out double righttail, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_int _d_n = new x_int(n);
        x_vector _d_y = new x_vector();
        x_int _d_m = new x_int(m);
        double _d_bothtails = 0;
        double _d_lefttail = 0;
        double _d_righttail = 0;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                _error_code = _i_xv2_ftest(&_s_errormsg, &_d_x, &_d_n, &_d_y, &_d_m, &_d_bothtails, &_d_lefttail, &_d_righttail, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "ftest");
            bothtails = _d_bothtails;
            lefttail = _d_lefttail;
            righttail = _d_righttail;
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
        }
        // This function returns no value.
    }
    
    public static void ftest(double[] x, int n, double[] y, int m, out double bothtails, out double lefttail, out double righttail)
    {
        _core_ftest( x,  n,  y,  m, out  bothtails, out  lefttail, out  righttail, 0x0);
    }
    
    public static void ftest(double[] x, int n, double[] y, int m, out double bothtails, out double lefttail, out double righttail, alglib.xparams _xparams)
    {
        _core_ftest( x,  n,  y,  m, out  bothtails, out  lefttail, out  righttail, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_onesamplevariancetest(double[] x, int n, double variance, out double bothtails, out double lefttail, out double righttail, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_int _d_n = new x_int(n);
        double _d_variance = variance;
        double _d_bothtails = 0;
        double _d_lefttail = 0;
        double _d_righttail = 0;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_xv2_onesamplevariancetest(&_s_errormsg, &_d_x, &_d_n, &_d_variance, &_d_bothtails, &_d_lefttail, &_d_righttail, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "onesamplevariancetest");
            bothtails = _d_bothtails;
            lefttail = _d_lefttail;
            righttail = _d_righttail;
        }
        finally
        {
            x_vector_clear(ref _d_x);
        }
        // This function returns no value.
    }
    
    public static void onesamplevariancetest(double[] x, int n, double variance, out double bothtails, out double lefttail, out double righttail)
    {
        _core_onesamplevariancetest( x,  n,  variance, out  bothtails, out  lefttail, out  righttail, 0x0);
    }
    
    public static void onesamplevariancetest(double[] x, int n, double variance, out double bothtails, out double lefttail, out double righttail, alglib.xparams _xparams)
    {
        _core_onesamplevariancetest( x,  n,  variance, out  bothtails, out  lefttail, out  righttail, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage wsr
    //
    
    
    private static unsafe void _core_wilcoxonsignedranktest(double[] x, int n, double e, out double bothtails, out double lefttail, out double righttail, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_int _d_n = new x_int(n);
        double _d_e = e;
        double _d_bothtails = 0;
        double _d_lefttail = 0;
        double _d_righttail = 0;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_xv2_wilcoxonsignedranktest(&_s_errormsg, &_d_x, &_d_n, &_d_e, &_d_bothtails, &_d_lefttail, &_d_righttail, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "wilcoxonsignedranktest");
            bothtails = _d_bothtails;
            lefttail = _d_lefttail;
            righttail = _d_righttail;
        }
        finally
        {
            x_vector_clear(ref _d_x);
        }
        // This function returns no value.
    }
    
    public static void wilcoxonsignedranktest(double[] x, int n, double e, out double bothtails, out double lefttail, out double righttail)
    {
        _core_wilcoxonsignedranktest( x,  n,  e, out  bothtails, out  lefttail, out  righttail, 0x0);
    }
    
    public static void wilcoxonsignedranktest(double[] x, int n, double e, out double bothtails, out double lefttail, out double righttail, alglib.xparams _xparams)
    {
        _core_wilcoxonsignedranktest( x,  n,  e, out  bothtails, out  lefttail, out  righttail, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage mannwhitneyu
    //
    
    
    private static unsafe void _core_mannwhitneyutest(double[] x, int n, double[] y, int m, out double bothtails, out double lefttail, out double righttail, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_int _d_n = new x_int(n);
        x_vector _d_y = new x_vector();
        x_int _d_m = new x_int(m);
        double _d_bothtails = 0;
        double _d_lefttail = 0;
        double _d_righttail = 0;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                _error_code = _i_xv2_mannwhitneyutest(&_s_errormsg, &_d_x, &_d_n, &_d_y, &_d_m, &_d_bothtails, &_d_lefttail, &_d_righttail, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mannwhitneyutest");
            bothtails = _d_bothtails;
            lefttail = _d_lefttail;
            righttail = _d_righttail;
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
        }
        // This function returns no value.
    }
    
    public static void mannwhitneyutest(double[] x, int n, double[] y, int m, out double bothtails, out double lefttail, out double righttail)
    {
        _core_mannwhitneyutest( x,  n,  y,  m, out  bothtails, out  lefttail, out  righttail, 0x0);
    }
    
    public static void mannwhitneyutest(double[] x, int n, double[] y, int m, out double bothtails, out double lefttail, out double righttail, alglib.xparams _xparams)
    {
        _core_mannwhitneyutest( x,  n,  y,  m, out  bothtails, out  lefttail, out  righttail, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage binomialdistr
    //
    
    
    private static unsafe double _core_binomialdistribution(int k, int n, double p, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_int _d_k = new x_int(k);
        x_int _d_n = new x_int(n);
        double _d_p = p;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_binomialdistribution(&_s_errormsg, &_d_result, &_d_k, &_d_n, &_d_p, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "binomialdistribution");
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double binomialdistribution(int k, int n, double p)
    {
        return _core_binomialdistribution( k,  n,  p, 0x0);
    }
    
    public static double binomialdistribution(int k, int n, double p, alglib.xparams _xparams)
    {
        return _core_binomialdistribution( k,  n,  p, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_binomialcdistribution(int k, int n, double p, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_int _d_k = new x_int(k);
        x_int _d_n = new x_int(n);
        double _d_p = p;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_binomialcdistribution(&_s_errormsg, &_d_result, &_d_k, &_d_n, &_d_p, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "binomialcdistribution");
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double binomialcdistribution(int k, int n, double p)
    {
        return _core_binomialcdistribution( k,  n,  p, 0x0);
    }
    
    public static double binomialcdistribution(int k, int n, double p, alglib.xparams _xparams)
    {
        return _core_binomialcdistribution( k,  n,  p, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_invbinomialdistribution(int k, int n, double y, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_int _d_k = new x_int(k);
        x_int _d_n = new x_int(n);
        double _d_y = y;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_invbinomialdistribution(&_s_errormsg, &_d_result, &_d_k, &_d_n, &_d_y, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "invbinomialdistribution");
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double invbinomialdistribution(int k, int n, double y)
    {
        return _core_invbinomialdistribution( k,  n,  y, 0x0);
    }
    
    public static double invbinomialdistribution(int k, int n, double y, alglib.xparams _xparams)
    {
        return _core_invbinomialdistribution( k,  n,  y, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage stest
    //
    
    
    private static unsafe void _core_onesamplesigntest(double[] x, int n, double median, out double bothtails, out double lefttail, out double righttail, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_int _d_n = new x_int(n);
        double _d_median = median;
        double _d_bothtails = 0;
        double _d_lefttail = 0;
        double _d_righttail = 0;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_xv2_onesamplesigntest(&_s_errormsg, &_d_x, &_d_n, &_d_median, &_d_bothtails, &_d_lefttail, &_d_righttail, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "onesamplesigntest");
            bothtails = _d_bothtails;
            lefttail = _d_lefttail;
            righttail = _d_righttail;
        }
        finally
        {
            x_vector_clear(ref _d_x);
        }
        // This function returns no value.
    }
    
    public static void onesamplesigntest(double[] x, int n, double median, out double bothtails, out double lefttail, out double righttail)
    {
        _core_onesamplesigntest( x,  n,  median, out  bothtails, out  lefttail, out  righttail, 0x0);
    }
    
    public static void onesamplesigntest(double[] x, int n, double median, out double bothtails, out double lefttail, out double righttail, alglib.xparams _xparams)
    {
        _core_onesamplesigntest( x,  n,  median, out  bothtails, out  lefttail, out  righttail, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage studentttests
    //
    
    
    private static unsafe void _core_studentttest1(double[] x, int n, double mean, out double bothtails, out double lefttail, out double righttail, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_int _d_n = new x_int(n);
        double _d_mean = mean;
        double _d_bothtails = 0;
        double _d_lefttail = 0;
        double _d_righttail = 0;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_xv2_studentttest1(&_s_errormsg, &_d_x, &_d_n, &_d_mean, &_d_bothtails, &_d_lefttail, &_d_righttail, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "studentttest1");
            bothtails = _d_bothtails;
            lefttail = _d_lefttail;
            righttail = _d_righttail;
        }
        finally
        {
            x_vector_clear(ref _d_x);
        }
        // This function returns no value.
    }
    
    public static void studentttest1(double[] x, int n, double mean, out double bothtails, out double lefttail, out double righttail)
    {
        _core_studentttest1( x,  n,  mean, out  bothtails, out  lefttail, out  righttail, 0x0);
    }
    
    public static void studentttest1(double[] x, int n, double mean, out double bothtails, out double lefttail, out double righttail, alglib.xparams _xparams)
    {
        _core_studentttest1( x,  n,  mean, out  bothtails, out  lefttail, out  righttail, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_studentttest2(double[] x, int n, double[] y, int m, out double bothtails, out double lefttail, out double righttail, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_int _d_n = new x_int(n);
        x_vector _d_y = new x_vector();
        x_int _d_m = new x_int(m);
        double _d_bothtails = 0;
        double _d_lefttail = 0;
        double _d_righttail = 0;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                _error_code = _i_xv2_studentttest2(&_s_errormsg, &_d_x, &_d_n, &_d_y, &_d_m, &_d_bothtails, &_d_lefttail, &_d_righttail, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "studentttest2");
            bothtails = _d_bothtails;
            lefttail = _d_lefttail;
            righttail = _d_righttail;
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
        }
        // This function returns no value.
    }
    
    public static void studentttest2(double[] x, int n, double[] y, int m, out double bothtails, out double lefttail, out double righttail)
    {
        _core_studentttest2( x,  n,  y,  m, out  bothtails, out  lefttail, out  righttail, 0x0);
    }
    
    public static void studentttest2(double[] x, int n, double[] y, int m, out double bothtails, out double lefttail, out double righttail, alglib.xparams _xparams)
    {
        _core_studentttest2( x,  n,  y,  m, out  bothtails, out  lefttail, out  righttail, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_unequalvariancettest(double[] x, int n, double[] y, int m, out double bothtails, out double lefttail, out double righttail, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_int _d_n = new x_int(n);
        x_vector _d_y = new x_vector();
        x_int _d_m = new x_int(m);
        double _d_bothtails = 0;
        double _d_lefttail = 0;
        double _d_righttail = 0;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                _error_code = _i_xv2_unequalvariancettest(&_s_errormsg, &_d_x, &_d_n, &_d_y, &_d_m, &_d_bothtails, &_d_lefttail, &_d_righttail, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "unequalvariancettest");
            bothtails = _d_bothtails;
            lefttail = _d_lefttail;
            righttail = _d_righttail;
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
        }
        // This function returns no value.
    }
    
    public static void unequalvariancettest(double[] x, int n, double[] y, int m, out double bothtails, out double lefttail, out double righttail)
    {
        _core_unequalvariancettest( x,  n,  y,  m, out  bothtails, out  lefttail, out  righttail, 0x0);
    }
    
    public static void unequalvariancettest(double[] x, int n, double[] y, int m, out double bothtails, out double lefttail, out double righttail, alglib.xparams _xparams)
    {
        _core_unequalvariancettest( x,  n,  y,  m, out  bothtails, out  lefttail, out  righttail, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage ratint
    //
    

    public unsafe class barycentricinterpolant : alglibobject
    {
        private void *_ptr;
        public barycentricinterpolant(void *x)
        {
            _ptr = x;
        }
        ~barycentricinterpolant()
        {
            _deallocate();
        }
        public void* ptr { get { return _ptr; } }
        public override alglib.alglibobject make_copy()
        {
            if( _ptr==null )
                return new barycentricinterpolant(null);
            return new barycentricinterpolant(_i_x_obj_copy_barycentricinterpolant(_ptr));
        }
        public override void _deallocate()
        {
            if( _ptr!=null )
                _i_x_obj_free_barycentricinterpolant(_ptr);
            _ptr = null;
            System.GC.SuppressFinalize(this);
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_barycentricinterpolant(void *x);
    private static _d_x_obj_copy_barycentricinterpolant _i_x_obj_copy_barycentricinterpolant = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_obj_free_barycentricinterpolant(void *x);
    private static _d_x_obj_free_barycentricinterpolant _i_x_obj_free_barycentricinterpolant = null;
    
    private static unsafe double _core_barycentriccalc(barycentricinterpolant b, double t, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_b = b.ptr;
        double _d_t = t;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_barycentriccalc(&_s_errormsg, &_d_result, &_d_b, &_d_t, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "barycentriccalc");
            result = _d_result;
            ap.assert(b.ptr==_d_b, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double barycentriccalc(barycentricinterpolant b, double t)
    {
        return _core_barycentriccalc( b,  t, 0x0);
    }
    
    public static double barycentriccalc(barycentricinterpolant b, double t, alglib.xparams _xparams)
    {
        return _core_barycentriccalc( b,  t, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_barycentricdiff1(barycentricinterpolant b, double t, out double f, out double df, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_b = b.ptr;
        double _d_t = t;
        double _d_f = 0;
        double _d_df = 0;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_barycentricdiff1(&_s_errormsg, &_d_b, &_d_t, &_d_f, &_d_df, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "barycentricdiff1");
            ap.assert(b.ptr==_d_b, "ALGLIB: internal error (reference changed for non-out X-object)");
            f = _d_f;
            df = _d_df;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void barycentricdiff1(barycentricinterpolant b, double t, out double f, out double df)
    {
        _core_barycentricdiff1( b,  t, out  f, out  df, 0x0);
    }
    
    public static void barycentricdiff1(barycentricinterpolant b, double t, out double f, out double df, alglib.xparams _xparams)
    {
        _core_barycentricdiff1( b,  t, out  f, out  df, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_barycentricdiff2(barycentricinterpolant b, double t, out double f, out double df, out double d2f, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_b = b.ptr;
        double _d_t = t;
        double _d_f = 0;
        double _d_df = 0;
        double _d_d2f = 0;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_barycentricdiff2(&_s_errormsg, &_d_b, &_d_t, &_d_f, &_d_df, &_d_d2f, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "barycentricdiff2");
            ap.assert(b.ptr==_d_b, "ALGLIB: internal error (reference changed for non-out X-object)");
            f = _d_f;
            df = _d_df;
            d2f = _d_d2f;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void barycentricdiff2(barycentricinterpolant b, double t, out double f, out double df, out double d2f)
    {
        _core_barycentricdiff2( b,  t, out  f, out  df, out  d2f, 0x0);
    }
    
    public static void barycentricdiff2(barycentricinterpolant b, double t, out double f, out double df, out double d2f, alglib.xparams _xparams)
    {
        _core_barycentricdiff2( b,  t, out  f, out  df, out  d2f, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_barycentriclintransx(barycentricinterpolant b, double ca, double cb, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_b = b.ptr;
        double _d_ca = ca;
        double _d_cb = cb;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_barycentriclintransx(&_s_errormsg, &_d_b, &_d_ca, &_d_cb, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "barycentriclintransx");
            ap.assert(b.ptr==_d_b, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void barycentriclintransx(barycentricinterpolant b, double ca, double cb)
    {
        _core_barycentriclintransx( b,  ca,  cb, 0x0);
    }
    
    public static void barycentriclintransx(barycentricinterpolant b, double ca, double cb, alglib.xparams _xparams)
    {
        _core_barycentriclintransx( b,  ca,  cb, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_barycentriclintransy(barycentricinterpolant b, double ca, double cb, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_b = b.ptr;
        double _d_ca = ca;
        double _d_cb = cb;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_barycentriclintransy(&_s_errormsg, &_d_b, &_d_ca, &_d_cb, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "barycentriclintransy");
            ap.assert(b.ptr==_d_b, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void barycentriclintransy(barycentricinterpolant b, double ca, double cb)
    {
        _core_barycentriclintransy( b,  ca,  cb, 0x0);
    }
    
    public static void barycentriclintransy(barycentricinterpolant b, double ca, double cb, alglib.xparams _xparams)
    {
        _core_barycentriclintransy( b,  ca,  cb, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_barycentricunpack(barycentricinterpolant b, out int n, out double[] x, out double[] y, out double[] w, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_b = b.ptr;
        x_int _d_n = new x_int();
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_vector _d_w = new x_vector();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_x, DT_REAL);
            x = null;
            x_vector_create_empty(ref _d_y, DT_REAL);
            y = null;
            x_vector_create_empty(ref _d_w, DT_REAL);
            w = null;
            _error_code = _i_xv2_barycentricunpack(&_s_errormsg, &_d_b, &_d_n, &_d_x, &_d_y, &_d_w, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "barycentricunpack");
            ap.assert(b.ptr==_d_b, "ALGLIB: internal error (reference changed for non-out X-object)");
            n = _d_n.intval;
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
            if( _d_y.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_y, ref y);
            if( y == null )
                y = new double[0];
            if( _d_w.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_w, ref w);
            if( w == null )
                w = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            x_vector_clear(ref _d_w);
        }
        // This function returns no value.
    }
    
    public static void barycentricunpack(barycentricinterpolant b, out int n, out double[] x, out double[] y, out double[] w)
    {
        _core_barycentricunpack( b, out  n, out  x, out  y, out  w, 0x0);
    }
    
    public static void barycentricunpack(barycentricinterpolant b, out int n, out double[] x, out double[] y, out double[] w, alglib.xparams _xparams)
    {
        _core_barycentricunpack( b, out  n, out  x, out  y, out  w, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_barycentricbuildxyw(double[] x, double[] y, double[] w, int n, out barycentricinterpolant b, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_vector _d_w = new x_vector();
        x_int _d_n = new x_int(n);
        void *_d_b = null;
        b = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y, _fp_w = w){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_vector_attach_to_array(ref _d_w, _fp_w, ap.len(w));
                _error_code = _i_xv2_barycentricbuildxyw(&_s_errormsg, &_d_x, &_d_y, &_d_w, &_d_n, &_d_b, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "barycentricbuildxyw");
            b = new barycentricinterpolant(_d_b);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            x_vector_clear(ref _d_w);
            if( _d_b!=null && b==null)
                _i_x_obj_free_barycentricinterpolant(_d_b); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void barycentricbuildxyw(double[] x, double[] y, double[] w, int n, out barycentricinterpolant b)
    {
        _core_barycentricbuildxyw( x,  y,  w,  n, out  b, 0x0);
    }
    
    public static void barycentricbuildxyw(double[] x, double[] y, double[] w, int n, out barycentricinterpolant b, alglib.xparams _xparams)
    {
        _core_barycentricbuildxyw( x,  y,  w,  n, out  b, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_barycentricbuildfloaterhormann(double[] x, double[] y, int n, int d, out barycentricinterpolant b, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_int _d_n = new x_int(n);
        x_int _d_d = new x_int(d);
        void *_d_b = null;
        b = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                _error_code = _i_xv2_barycentricbuildfloaterhormann(&_s_errormsg, &_d_x, &_d_y, &_d_n, &_d_d, &_d_b, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "barycentricbuildfloaterhormann");
            b = new barycentricinterpolant(_d_b);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            if( _d_b!=null && b==null)
                _i_x_obj_free_barycentricinterpolant(_d_b); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void barycentricbuildfloaterhormann(double[] x, double[] y, int n, int d, out barycentricinterpolant b)
    {
        _core_barycentricbuildfloaterhormann( x,  y,  n,  d, out  b, 0x0);
    }
    
    public static void barycentricbuildfloaterhormann(double[] x, double[] y, int n, int d, out barycentricinterpolant b, alglib.xparams _xparams)
    {
        _core_barycentricbuildfloaterhormann( x,  y,  n,  d, out  b, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage idw
    //
    

    public unsafe class idwcalcbuffer : alglibobject
    {
        private void *_ptr;
        public idwcalcbuffer(void *x)
        {
            _ptr = x;
        }
        ~idwcalcbuffer()
        {
            _deallocate();
        }
        public void* ptr { get { return _ptr; } }
        public override alglib.alglibobject make_copy()
        {
            if( _ptr==null )
                return new idwcalcbuffer(null);
            return new idwcalcbuffer(_i_x_obj_copy_idwcalcbuffer(_ptr));
        }
        public override void _deallocate()
        {
            if( _ptr!=null )
                _i_x_obj_free_idwcalcbuffer(_ptr);
            _ptr = null;
            System.GC.SuppressFinalize(this);
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_idwcalcbuffer(void *x);
    private static _d_x_obj_copy_idwcalcbuffer _i_x_obj_copy_idwcalcbuffer = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_obj_free_idwcalcbuffer(void *x);
    private static _d_x_obj_free_idwcalcbuffer _i_x_obj_free_idwcalcbuffer = null;

    public unsafe class idwmodel : alglibobject
    {
        private void *_ptr;
        public idwmodel(void *x)
        {
            _ptr = x;
        }
        ~idwmodel()
        {
            _deallocate();
        }
        public void* ptr { get { return _ptr; } }
        public override alglib.alglibobject make_copy()
        {
            if( _ptr==null )
                return new idwmodel(null);
            return new idwmodel(_i_x_obj_copy_idwmodel(_ptr));
        }
        public override void _deallocate()
        {
            if( _ptr!=null )
                _i_x_obj_free_idwmodel(_ptr);
            _ptr = null;
            System.GC.SuppressFinalize(this);
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_idwmodel(void *x);
    private static _d_x_obj_copy_idwmodel _i_x_obj_copy_idwmodel = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_obj_free_idwmodel(void *x);
    private static _d_x_obj_free_idwmodel _i_x_obj_free_idwmodel = null;

    public unsafe class idwbuilder : alglibobject
    {
        private void *_ptr;
        public idwbuilder(void *x)
        {
            _ptr = x;
        }
        ~idwbuilder()
        {
            _deallocate();
        }
        public void* ptr { get { return _ptr; } }
        public override alglib.alglibobject make_copy()
        {
            if( _ptr==null )
                return new idwbuilder(null);
            return new idwbuilder(_i_x_obj_copy_idwbuilder(_ptr));
        }
        public override void _deallocate()
        {
            if( _ptr!=null )
                _i_x_obj_free_idwbuilder(_ptr);
            _ptr = null;
            System.GC.SuppressFinalize(this);
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_idwbuilder(void *x);
    private static _d_x_obj_copy_idwbuilder _i_x_obj_copy_idwbuilder = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_obj_free_idwbuilder(void *x);
    private static _d_x_obj_free_idwbuilder _i_x_obj_free_idwbuilder = null;

    [StructLayout(LayoutKind.Sequential, Pack=8)]
    private struct x_idwreport
    {
        public double rmserror;
        public double avgerror;
        public double maxerror;
        public double r2;
    }

    public class idwreport : alglibobject
    {
        public double rmserror;
        public double avgerror;
        public double maxerror;
        public double r2;
        public override alglib.alglibobject make_copy()
        {
            idwreport dst = new idwreport();
            dst.rmserror = rmserror;
            dst.avgerror = avgerror;
            dst.maxerror = maxerror;
            dst.r2 = r2;
            return dst;
        }
    }

    // This function initializes X-structure (its previous content is ignored)
    private static void x_idwreport_init(ref x_idwreport x)
    {
        x.rmserror = 0;
        x.avgerror = 0;
        x.maxerror = 0;
        x.r2 = 0;
    }

    // This function finalizes fields of X-structure (however, memory occupied by structure itself is not freed)
    // After destruction structure becomes unusable and should be re-initialized if you want to use it
    private static void x_idwreport_clear(ref x_idwreport x)
    {
    }

    // This function initializes X-structure by appropriate C# instance
    // (previous content of X structure is ignored)
    private static void x_idwreport_init_from(ref x_idwreport x, idwreport v)
    {
        x.rmserror = v.rmserror;
        x.avgerror = v.avgerror;
        x.maxerror = v.maxerror;
        x.r2 = v.r2;
    }

    // This function initializes C# structure by appropriate X instance
    // (previous content of C# structure is ignored).
    // This function may accept null v, in this case v is automatically allocated with new().
    private static void x_idwreport_to_record(ref x_idwreport x, ref idwreport v)
    {
        if( v==null )
            v = new idwreport();
        v.rmserror = x.rmserror;
        v.avgerror = x.avgerror;
        v.maxerror = x.maxerror;
        v.r2 = x.r2;
    }
    public static unsafe void idwserialize(idwmodel obj, out string s_out)
    {
        byte *_s_errormsg = null;
        byte *_out = null;
        void *_x = obj.ptr;
        try
        {
            int _error_code = _i_x_idwserialize(&_s_errormsg, &_x, &_out);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "idwserialize");
            s_out = Marshal.PtrToStringAnsi((IntPtr)_out);
        }
        finally
        {
            x_free((IntPtr)_out);
        }
    }
    
    public static unsafe void idwunserialize(string s_in, out idwmodel obj)
    {
        byte *_s_errormsg = null;
        byte[] _ain = System.Text.Encoding.UTF8.GetBytes(s_in);
        fixed(byte *_pin = _ain )
        {
            byte *_in = _pin;
            void *_x = null;
            obj = null;
            try
            {
                int _error_code = _i_x_idwunserialize(&_s_errormsg, &_in, &_x);
                if( _error_code!=X_OK )
                    handle_exception(_error_code, _s_errormsg, "idwunserialize");
                obj = new idwmodel(_x);
            }
            finally
            {
                // on exception clean up X objects which were not attached to C# objects
                if( _x!=null && obj==null)
                    _i_x_obj_free_idwmodel(_x);
            }
        }
    }
    public static unsafe void idwserialize(idwmodel obj, System.IO.Stream s_out)
    {
        byte *_s_errormsg = null;
        void *_x = obj.ptr;
        alglib.native_stream_adapter a = new alglib.native_stream_adapter();
        a.sstart_stream(s_out);
        int _error_code = _i_x_idwserialize_stream(&_s_errormsg, &_x, a.writer_callback, IntPtr.Zero);
        if( _error_code!=X_OK )
            handle_exception(_error_code, _s_errormsg, "idwserialize");
    }
    
    public static unsafe void idwunserialize(System.IO.Stream s_in, out idwmodel obj)
    {
        byte *_s_errormsg = null;
        void *_x = null;
        obj = null;
        alglib.native_stream_adapter a = new alglib.native_stream_adapter();
        a.ustart_stream(s_in);
        try
        {
            int _error_code = _i_x_idwunserialize_stream(&_s_errormsg, a.reader_callback, IntPtr.Zero, &_x);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "idwunserialize");
            obj = new idwmodel(_x);
        }
        finally
        {
            // on exception clean up X objects which were not attached to C# objects
            if( _x!=null && obj==null)
                _i_x_obj_free_idwmodel(_x);
        }
    }
    
    private static unsafe void _core_idwcreatecalcbuffer(idwmodel s, out idwcalcbuffer buf, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        void *_d_buf = null;
        buf = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_idwcreatecalcbuffer(&_s_errormsg, &_d_s, &_d_buf, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "idwcreatecalcbuffer");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            buf = new idwcalcbuffer(_d_buf);
        }
        finally
        {
            if( _d_buf!=null && buf==null)
                _i_x_obj_free_idwcalcbuffer(_d_buf); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void idwcreatecalcbuffer(idwmodel s, out idwcalcbuffer buf)
    {
        _core_idwcreatecalcbuffer( s, out  buf, 0x0);
    }
    
    public static void idwcreatecalcbuffer(idwmodel s, out idwcalcbuffer buf, alglib.xparams _xparams)
    {
        _core_idwcreatecalcbuffer( s, out  buf, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_idwbuildercreate(int nx, int ny, out idwbuilder state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_nx = new x_int(nx);
        x_int _d_ny = new x_int(ny);
        void *_d_state = null;
        state = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_idwbuildercreate(&_s_errormsg, &_d_nx, &_d_ny, &_d_state, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "idwbuildercreate");
            state = new idwbuilder(_d_state);
        }
        finally
        {
            if( _d_state!=null && state==null)
                _i_x_obj_free_idwbuilder(_d_state); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void idwbuildercreate(int nx, int ny, out idwbuilder state)
    {
        _core_idwbuildercreate( nx,  ny, out  state, 0x0);
    }
    
    public static void idwbuildercreate(int nx, int ny, out idwbuilder state, alglib.xparams _xparams)
    {
        _core_idwbuildercreate( nx,  ny, out  state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_idwbuildersetnlayers(idwbuilder state, int nlayers, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_int _d_nlayers = new x_int(nlayers);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_idwbuildersetnlayers(&_s_errormsg, &_d_state, &_d_nlayers, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "idwbuildersetnlayers");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void idwbuildersetnlayers(idwbuilder state, int nlayers)
    {
        _core_idwbuildersetnlayers( state,  nlayers, 0x0);
    }
    
    public static void idwbuildersetnlayers(idwbuilder state, int nlayers, alglib.xparams _xparams)
    {
        _core_idwbuildersetnlayers( state,  nlayers, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_idwbuildersetpoints(idwbuilder state, double[,] xy, int n, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_n = new x_int(n);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_xv2_idwbuildersetpoints(&_s_errormsg, &_d_state, &_d_xy, &_d_n, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "idwbuildersetpoints");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
        }
        // This function returns no value.
    }
    
    public static void idwbuildersetpoints(idwbuilder state, double[,] xy, int n)
    {
        _core_idwbuildersetpoints( state,  xy,  n, 0x0);
    }
    
    public static void idwbuildersetpoints(idwbuilder state, double[,] xy, int n, alglib.xparams _xparams)
    {
        _core_idwbuildersetpoints( state,  xy,  n, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void idwbuildersetpoints(idwbuilder state, double[,] xy)
    {
        int n;
    
        n = ap.rows(xy);
        _core_idwbuildersetpoints( state,  xy,  n, 0x0);
    
        
    }
    
    public static void idwbuildersetpoints(idwbuilder state, double[,] xy, alglib.xparams _xparams)
    {
        int n;
    
        n = ap.rows(xy);
        _core_idwbuildersetpoints( state,  xy,  n, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_idwbuildersetalgomstab(idwbuilder state, double srad, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_srad = srad;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_idwbuildersetalgomstab(&_s_errormsg, &_d_state, &_d_srad, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "idwbuildersetalgomstab");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void idwbuildersetalgomstab(idwbuilder state, double srad)
    {
        _core_idwbuildersetalgomstab( state,  srad, 0x0);
    }
    
    public static void idwbuildersetalgomstab(idwbuilder state, double srad, alglib.xparams _xparams)
    {
        _core_idwbuildersetalgomstab( state,  srad, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_idwbuildersetalgotextbookshepard(idwbuilder state, double p, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_p = p;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_idwbuildersetalgotextbookshepard(&_s_errormsg, &_d_state, &_d_p, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "idwbuildersetalgotextbookshepard");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void idwbuildersetalgotextbookshepard(idwbuilder state, double p)
    {
        _core_idwbuildersetalgotextbookshepard( state,  p, 0x0);
    }
    
    public static void idwbuildersetalgotextbookshepard(idwbuilder state, double p, alglib.xparams _xparams)
    {
        _core_idwbuildersetalgotextbookshepard( state,  p, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_idwbuildersetalgotextbookmodshepard(idwbuilder state, double r, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_r = r;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_idwbuildersetalgotextbookmodshepard(&_s_errormsg, &_d_state, &_d_r, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "idwbuildersetalgotextbookmodshepard");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void idwbuildersetalgotextbookmodshepard(idwbuilder state, double r)
    {
        _core_idwbuildersetalgotextbookmodshepard( state,  r, 0x0);
    }
    
    public static void idwbuildersetalgotextbookmodshepard(idwbuilder state, double r, alglib.xparams _xparams)
    {
        _core_idwbuildersetalgotextbookmodshepard( state,  r, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_idwbuildersetuserterm(idwbuilder state, double v, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_v = v;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_idwbuildersetuserterm(&_s_errormsg, &_d_state, &_d_v, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "idwbuildersetuserterm");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void idwbuildersetuserterm(idwbuilder state, double v)
    {
        _core_idwbuildersetuserterm( state,  v, 0x0);
    }
    
    public static void idwbuildersetuserterm(idwbuilder state, double v, alglib.xparams _xparams)
    {
        _core_idwbuildersetuserterm( state,  v, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_idwbuildersetconstterm(idwbuilder state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_idwbuildersetconstterm(&_s_errormsg, &_d_state, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "idwbuildersetconstterm");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void idwbuildersetconstterm(idwbuilder state)
    {
        _core_idwbuildersetconstterm( state, 0x0);
    }
    
    public static void idwbuildersetconstterm(idwbuilder state, alglib.xparams _xparams)
    {
        _core_idwbuildersetconstterm( state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_idwbuildersetzeroterm(idwbuilder state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_idwbuildersetzeroterm(&_s_errormsg, &_d_state, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "idwbuildersetzeroterm");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void idwbuildersetzeroterm(idwbuilder state)
    {
        _core_idwbuildersetzeroterm( state, 0x0);
    }
    
    public static void idwbuildersetzeroterm(idwbuilder state, alglib.xparams _xparams)
    {
        _core_idwbuildersetzeroterm( state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_idwcalc1(idwmodel s, double x0, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_s = s.ptr;
        double _d_x0 = x0;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_idwcalc1(&_s_errormsg, &_d_result, &_d_s, &_d_x0, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "idwcalc1");
            result = _d_result;
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double idwcalc1(idwmodel s, double x0)
    {
        return _core_idwcalc1( s,  x0, 0x0);
    }
    
    public static double idwcalc1(idwmodel s, double x0, alglib.xparams _xparams)
    {
        return _core_idwcalc1( s,  x0, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_idwcalc2(idwmodel s, double x0, double x1, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_s = s.ptr;
        double _d_x0 = x0;
        double _d_x1 = x1;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_idwcalc2(&_s_errormsg, &_d_result, &_d_s, &_d_x0, &_d_x1, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "idwcalc2");
            result = _d_result;
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double idwcalc2(idwmodel s, double x0, double x1)
    {
        return _core_idwcalc2( s,  x0,  x1, 0x0);
    }
    
    public static double idwcalc2(idwmodel s, double x0, double x1, alglib.xparams _xparams)
    {
        return _core_idwcalc2( s,  x0,  x1, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_idwcalc3(idwmodel s, double x0, double x1, double x2, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_s = s.ptr;
        double _d_x0 = x0;
        double _d_x1 = x1;
        double _d_x2 = x2;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_idwcalc3(&_s_errormsg, &_d_result, &_d_s, &_d_x0, &_d_x1, &_d_x2, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "idwcalc3");
            result = _d_result;
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double idwcalc3(idwmodel s, double x0, double x1, double x2)
    {
        return _core_idwcalc3( s,  x0,  x1,  x2, 0x0);
    }
    
    public static double idwcalc3(idwmodel s, double x0, double x1, double x2, alglib.xparams _xparams)
    {
        return _core_idwcalc3( s,  x0,  x1,  x2, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_idwcalc(idwmodel s, double[] x, out double[] y, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_create_empty(ref _d_y, DT_REAL);
                y = null;
                _error_code = _i_xv2_idwcalc(&_s_errormsg, &_d_s, &_d_x, &_d_y, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "idwcalc");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_y.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_y, ref y);
            if( y == null )
                y = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
        }
        // This function returns no value.
    }
    
    public static void idwcalc(idwmodel s, double[] x, out double[] y)
    {
        _core_idwcalc( s,  x, out  y, 0x0);
    }
    
    public static void idwcalc(idwmodel s, double[] x, out double[] y, alglib.xparams _xparams)
    {
        _core_idwcalc( s,  x, out  y, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_idwcalcbuf(idwmodel s, double[] x, ref double[] y, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                _error_code = _i_xv2_idwcalcbuf(&_s_errormsg, &_d_s, &_d_x, &_d_y, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "idwcalcbuf");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_y.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_y, ref y);
            if( y == null )
                y = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
        }
        // This function returns no value.
    }
    
    public static void idwcalcbuf(idwmodel s, double[] x, ref double[] y)
    {
        _core_idwcalcbuf( s,  x, ref  y, 0x0);
    }
    
    public static void idwcalcbuf(idwmodel s, double[] x, ref double[] y, alglib.xparams _xparams)
    {
        _core_idwcalcbuf( s,  x, ref  y, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_idwtscalcbuf(idwmodel s, idwcalcbuffer buf, double[] x, ref double[] y, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        void *_d_buf = buf.ptr;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                _error_code = _i_xv2_idwtscalcbuf(&_s_errormsg, &_d_s, &_d_buf, &_d_x, &_d_y, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "idwtscalcbuf");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            ap.assert(buf.ptr==_d_buf, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_y.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_y, ref y);
            if( y == null )
                y = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
        }
        // This function returns no value.
    }
    
    public static void idwtscalcbuf(idwmodel s, idwcalcbuffer buf, double[] x, ref double[] y)
    {
        _core_idwtscalcbuf( s,  buf,  x, ref  y, 0x0);
    }
    
    public static void idwtscalcbuf(idwmodel s, idwcalcbuffer buf, double[] x, ref double[] y, alglib.xparams _xparams)
    {
        _core_idwtscalcbuf( s,  buf,  x, ref  y, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_idwfit(idwbuilder state, out idwmodel model, out idwreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        void *_d_model = null;
        model = null;
        x_idwreport _d_rep = new x_idwreport();
        
        // Pack, call, unpack
        try
        {
            x_idwreport_init(ref _d_rep);
            _error_code = _i_xv2_idwfit(&_s_errormsg, &_d_state, &_d_model, &_d_rep, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "idwfit");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            model = new idwmodel(_d_model);
            rep = null;
            x_idwreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            if( _d_model!=null && model==null)
                _i_x_obj_free_idwmodel(_d_model); // on exception clean up X objects which were not attached to C# objects
            x_idwreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void idwfit(idwbuilder state, out idwmodel model, out idwreport rep)
    {
        _core_idwfit( state, out  model, out  rep, 0x0);
    }
    
    public static void idwfit(idwbuilder state, out idwmodel model, out idwreport rep, alglib.xparams _xparams)
    {
        _core_idwfit( state, out  model, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage intfitserv
    //
    
    
    
    //
    // Subpackage polint
    //
    
    
    private static unsafe void _core_polynomialbar2cheb(barycentricinterpolant p, double a, double b, out double[] t, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_p = p.ptr;
        double _d_a = a;
        double _d_b = b;
        x_vector _d_t = new x_vector();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_t, DT_REAL);
            t = null;
            _error_code = _i_xv2_polynomialbar2cheb(&_s_errormsg, &_d_p, &_d_a, &_d_b, &_d_t, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "polynomialbar2cheb");
            ap.assert(p.ptr==_d_p, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_t.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_t, ref t);
            if( t == null )
                t = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_t);
        }
        // This function returns no value.
    }
    
    public static void polynomialbar2cheb(barycentricinterpolant p, double a, double b, out double[] t)
    {
        _core_polynomialbar2cheb( p,  a,  b, out  t, 0x0);
    }
    
    public static void polynomialbar2cheb(barycentricinterpolant p, double a, double b, out double[] t, alglib.xparams _xparams)
    {
        _core_polynomialbar2cheb( p,  a,  b, out  t, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_polynomialcheb2bar(double[] t, int n, double a, double b, out barycentricinterpolant p, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_t = new x_vector();
        x_int _d_n = new x_int(n);
        double _d_a = a;
        double _d_b = b;
        void *_d_p = null;
        p = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_t = t){
                x_vector_attach_to_array(ref _d_t, _fp_t, ap.len(t));
                _error_code = _i_xv2_polynomialcheb2bar(&_s_errormsg, &_d_t, &_d_n, &_d_a, &_d_b, &_d_p, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "polynomialcheb2bar");
            p = new barycentricinterpolant(_d_p);
        }
        finally
        {
            x_vector_clear(ref _d_t);
            if( _d_p!=null && p==null)
                _i_x_obj_free_barycentricinterpolant(_d_p); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void polynomialcheb2bar(double[] t, int n, double a, double b, out barycentricinterpolant p)
    {
        _core_polynomialcheb2bar( t,  n,  a,  b, out  p, 0x0);
    }
    
    public static void polynomialcheb2bar(double[] t, int n, double a, double b, out barycentricinterpolant p, alglib.xparams _xparams)
    {
        _core_polynomialcheb2bar( t,  n,  a,  b, out  p, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void polynomialcheb2bar(double[] t, double a, double b, out barycentricinterpolant p)
    {
        int n;
    
        n = ap.len(t);
        _core_polynomialcheb2bar( t,  n,  a,  b, out  p, 0x0);
    
        
    }
    
    public static void polynomialcheb2bar(double[] t, double a, double b, out barycentricinterpolant p, alglib.xparams _xparams)
    {
        int n;
    
        n = ap.len(t);
        _core_polynomialcheb2bar( t,  n,  a,  b, out  p, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_polynomialbar2pow(barycentricinterpolant p, double c, double s, out double[] a, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_p = p.ptr;
        double _d_c = c;
        double _d_s = s;
        x_vector _d_a = new x_vector();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_a, DT_REAL);
            a = null;
            _error_code = _i_xv2_polynomialbar2pow(&_s_errormsg, &_d_p, &_d_c, &_d_s, &_d_a, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "polynomialbar2pow");
            ap.assert(p.ptr==_d_p, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_a, ref a);
            if( a == null )
                a = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_a);
        }
        // This function returns no value.
    }
    
    public static void polynomialbar2pow(barycentricinterpolant p, double c, double s, out double[] a)
    {
        _core_polynomialbar2pow( p,  c,  s, out  a, 0x0);
    }
    
    public static void polynomialbar2pow(barycentricinterpolant p, double c, double s, out double[] a, alglib.xparams _xparams)
    {
        _core_polynomialbar2pow( p,  c,  s, out  a, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void polynomialbar2pow(barycentricinterpolant p, out double[] a)
    {
        double c;
        double s;
    
        c = 0;
        s = 1;
        _core_polynomialbar2pow( p,  c,  s, out  a, 0x0);
    
        
    }
    
    public static void polynomialbar2pow(barycentricinterpolant p, out double[] a, alglib.xparams _xparams)
    {
        double c;
        double s;
    
        c = 0;
        s = 1;
        _core_polynomialbar2pow( p,  c,  s, out  a, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_polynomialpow2bar(double[] a, int n, double c, double s, out barycentricinterpolant p, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_a = new x_vector();
        x_int _d_n = new x_int(n);
        double _d_c = c;
        double _d_s = s;
        void *_d_p = null;
        p = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_vector_attach_to_array(ref _d_a, _fp_a, ap.len(a));
                _error_code = _i_xv2_polynomialpow2bar(&_s_errormsg, &_d_a, &_d_n, &_d_c, &_d_s, &_d_p, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "polynomialpow2bar");
            p = new barycentricinterpolant(_d_p);
        }
        finally
        {
            x_vector_clear(ref _d_a);
            if( _d_p!=null && p==null)
                _i_x_obj_free_barycentricinterpolant(_d_p); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void polynomialpow2bar(double[] a, int n, double c, double s, out barycentricinterpolant p)
    {
        _core_polynomialpow2bar( a,  n,  c,  s, out  p, 0x0);
    }
    
    public static void polynomialpow2bar(double[] a, int n, double c, double s, out barycentricinterpolant p, alglib.xparams _xparams)
    {
        _core_polynomialpow2bar( a,  n,  c,  s, out  p, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void polynomialpow2bar(double[] a, out barycentricinterpolant p)
    {
        int n;
        double c;
        double s;
    
        n = ap.len(a);
        c = 0;
        s = 1;
        _core_polynomialpow2bar( a,  n,  c,  s, out  p, 0x0);
    
        
    }
    
    public static void polynomialpow2bar(double[] a, out barycentricinterpolant p, alglib.xparams _xparams)
    {
        int n;
        double c;
        double s;
    
        n = ap.len(a);
        c = 0;
        s = 1;
        _core_polynomialpow2bar( a,  n,  c,  s, out  p, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_polynomialbuild(double[] x, double[] y, int n, out barycentricinterpolant p, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_int _d_n = new x_int(n);
        void *_d_p = null;
        p = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                _error_code = _i_xv2_polynomialbuild(&_s_errormsg, &_d_x, &_d_y, &_d_n, &_d_p, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "polynomialbuild");
            p = new barycentricinterpolant(_d_p);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            if( _d_p!=null && p==null)
                _i_x_obj_free_barycentricinterpolant(_d_p); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void polynomialbuild(double[] x, double[] y, int n, out barycentricinterpolant p)
    {
        _core_polynomialbuild( x,  y,  n, out  p, 0x0);
    }
    
    public static void polynomialbuild(double[] x, double[] y, int n, out barycentricinterpolant p, alglib.xparams _xparams)
    {
        _core_polynomialbuild( x,  y,  n, out  p, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void polynomialbuild(double[] x, double[] y, out barycentricinterpolant p)
    {
        int n;
        if( (ap.len(x)!=ap.len(y)))
            throw new alglibexception("Error while calling 'polynomialbuild': looks like one of arguments has wrong size");
        n = ap.len(x);
        _core_polynomialbuild( x,  y,  n, out  p, 0x0);
    
        
    }
    
    public static void polynomialbuild(double[] x, double[] y, out barycentricinterpolant p, alglib.xparams _xparams)
    {
        int n;
        if( (ap.len(x)!=ap.len(y)))
            throw new alglibexception("Error while calling 'polynomialbuild': looks like one of arguments has wrong size");
        n = ap.len(x);
        _core_polynomialbuild( x,  y,  n, out  p, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_polynomialbuildeqdist(double a, double b, double[] y, int n, out barycentricinterpolant p, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double _d_a = a;
        double _d_b = b;
        x_vector _d_y = new x_vector();
        x_int _d_n = new x_int(n);
        void *_d_p = null;
        p = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_y = y){
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                _error_code = _i_xv2_polynomialbuildeqdist(&_s_errormsg, &_d_a, &_d_b, &_d_y, &_d_n, &_d_p, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "polynomialbuildeqdist");
            p = new barycentricinterpolant(_d_p);
        }
        finally
        {
            x_vector_clear(ref _d_y);
            if( _d_p!=null && p==null)
                _i_x_obj_free_barycentricinterpolant(_d_p); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void polynomialbuildeqdist(double a, double b, double[] y, int n, out barycentricinterpolant p)
    {
        _core_polynomialbuildeqdist( a,  b,  y,  n, out  p, 0x0);
    }
    
    public static void polynomialbuildeqdist(double a, double b, double[] y, int n, out barycentricinterpolant p, alglib.xparams _xparams)
    {
        _core_polynomialbuildeqdist( a,  b,  y,  n, out  p, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void polynomialbuildeqdist(double a, double b, double[] y, out barycentricinterpolant p)
    {
        int n;
    
        n = ap.len(y);
        _core_polynomialbuildeqdist( a,  b,  y,  n, out  p, 0x0);
    
        
    }
    
    public static void polynomialbuildeqdist(double a, double b, double[] y, out barycentricinterpolant p, alglib.xparams _xparams)
    {
        int n;
    
        n = ap.len(y);
        _core_polynomialbuildeqdist( a,  b,  y,  n, out  p, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_polynomialbuildcheb1(double a, double b, double[] y, int n, out barycentricinterpolant p, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double _d_a = a;
        double _d_b = b;
        x_vector _d_y = new x_vector();
        x_int _d_n = new x_int(n);
        void *_d_p = null;
        p = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_y = y){
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                _error_code = _i_xv2_polynomialbuildcheb1(&_s_errormsg, &_d_a, &_d_b, &_d_y, &_d_n, &_d_p, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "polynomialbuildcheb1");
            p = new barycentricinterpolant(_d_p);
        }
        finally
        {
            x_vector_clear(ref _d_y);
            if( _d_p!=null && p==null)
                _i_x_obj_free_barycentricinterpolant(_d_p); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void polynomialbuildcheb1(double a, double b, double[] y, int n, out barycentricinterpolant p)
    {
        _core_polynomialbuildcheb1( a,  b,  y,  n, out  p, 0x0);
    }
    
    public static void polynomialbuildcheb1(double a, double b, double[] y, int n, out barycentricinterpolant p, alglib.xparams _xparams)
    {
        _core_polynomialbuildcheb1( a,  b,  y,  n, out  p, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void polynomialbuildcheb1(double a, double b, double[] y, out barycentricinterpolant p)
    {
        int n;
    
        n = ap.len(y);
        _core_polynomialbuildcheb1( a,  b,  y,  n, out  p, 0x0);
    
        
    }
    
    public static void polynomialbuildcheb1(double a, double b, double[] y, out barycentricinterpolant p, alglib.xparams _xparams)
    {
        int n;
    
        n = ap.len(y);
        _core_polynomialbuildcheb1( a,  b,  y,  n, out  p, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_polynomialbuildcheb2(double a, double b, double[] y, int n, out barycentricinterpolant p, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double _d_a = a;
        double _d_b = b;
        x_vector _d_y = new x_vector();
        x_int _d_n = new x_int(n);
        void *_d_p = null;
        p = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_y = y){
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                _error_code = _i_xv2_polynomialbuildcheb2(&_s_errormsg, &_d_a, &_d_b, &_d_y, &_d_n, &_d_p, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "polynomialbuildcheb2");
            p = new barycentricinterpolant(_d_p);
        }
        finally
        {
            x_vector_clear(ref _d_y);
            if( _d_p!=null && p==null)
                _i_x_obj_free_barycentricinterpolant(_d_p); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void polynomialbuildcheb2(double a, double b, double[] y, int n, out barycentricinterpolant p)
    {
        _core_polynomialbuildcheb2( a,  b,  y,  n, out  p, 0x0);
    }
    
    public static void polynomialbuildcheb2(double a, double b, double[] y, int n, out barycentricinterpolant p, alglib.xparams _xparams)
    {
        _core_polynomialbuildcheb2( a,  b,  y,  n, out  p, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void polynomialbuildcheb2(double a, double b, double[] y, out barycentricinterpolant p)
    {
        int n;
    
        n = ap.len(y);
        _core_polynomialbuildcheb2( a,  b,  y,  n, out  p, 0x0);
    
        
    }
    
    public static void polynomialbuildcheb2(double a, double b, double[] y, out barycentricinterpolant p, alglib.xparams _xparams)
    {
        int n;
    
        n = ap.len(y);
        _core_polynomialbuildcheb2( a,  b,  y,  n, out  p, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe double _core_polynomialcalceqdist(double a, double b, double[] f, int n, double t, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        double _d_a = a;
        double _d_b = b;
        x_vector _d_f = new x_vector();
        x_int _d_n = new x_int(n);
        double _d_t = t;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_f = f){
                x_vector_attach_to_array(ref _d_f, _fp_f, ap.len(f));
                _error_code = _i_xv2_polynomialcalceqdist(&_s_errormsg, &_d_result, &_d_a, &_d_b, &_d_f, &_d_n, &_d_t, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "polynomialcalceqdist");
            result = _d_result;
        }
        finally
        {
            x_vector_clear(ref _d_f);
        }
        return result;
    }
    
    public static double polynomialcalceqdist(double a, double b, double[] f, int n, double t)
    {
        return _core_polynomialcalceqdist( a,  b,  f,  n,  t, 0x0);
    }
    
    public static double polynomialcalceqdist(double a, double b, double[] f, int n, double t, alglib.xparams _xparams)
    {
        return _core_polynomialcalceqdist( a,  b,  f,  n,  t, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static double polynomialcalceqdist(double a, double b, double[] f, double t)
    {
        int n;
    
        n = ap.len(f);
        double result = _core_polynomialcalceqdist( a,  b,  f,  n,  t, 0x0);
    
        return result;
    }
    
    public static double polynomialcalceqdist(double a, double b, double[] f, double t, alglib.xparams _xparams)
    {
        int n;
    
        n = ap.len(f);
        double result = _core_polynomialcalceqdist( a,  b,  f,  n,  t, _xparams==null ? 0x0 : _xparams.flags);
    
        return result;
    }
    
    private static unsafe double _core_polynomialcalccheb1(double a, double b, double[] f, int n, double t, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        double _d_a = a;
        double _d_b = b;
        x_vector _d_f = new x_vector();
        x_int _d_n = new x_int(n);
        double _d_t = t;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_f = f){
                x_vector_attach_to_array(ref _d_f, _fp_f, ap.len(f));
                _error_code = _i_xv2_polynomialcalccheb1(&_s_errormsg, &_d_result, &_d_a, &_d_b, &_d_f, &_d_n, &_d_t, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "polynomialcalccheb1");
            result = _d_result;
        }
        finally
        {
            x_vector_clear(ref _d_f);
        }
        return result;
    }
    
    public static double polynomialcalccheb1(double a, double b, double[] f, int n, double t)
    {
        return _core_polynomialcalccheb1( a,  b,  f,  n,  t, 0x0);
    }
    
    public static double polynomialcalccheb1(double a, double b, double[] f, int n, double t, alglib.xparams _xparams)
    {
        return _core_polynomialcalccheb1( a,  b,  f,  n,  t, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static double polynomialcalccheb1(double a, double b, double[] f, double t)
    {
        int n;
    
        n = ap.len(f);
        double result = _core_polynomialcalccheb1( a,  b,  f,  n,  t, 0x0);
    
        return result;
    }
    
    public static double polynomialcalccheb1(double a, double b, double[] f, double t, alglib.xparams _xparams)
    {
        int n;
    
        n = ap.len(f);
        double result = _core_polynomialcalccheb1( a,  b,  f,  n,  t, _xparams==null ? 0x0 : _xparams.flags);
    
        return result;
    }
    
    private static unsafe double _core_polynomialcalccheb2(double a, double b, double[] f, int n, double t, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        double _d_a = a;
        double _d_b = b;
        x_vector _d_f = new x_vector();
        x_int _d_n = new x_int(n);
        double _d_t = t;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_f = f){
                x_vector_attach_to_array(ref _d_f, _fp_f, ap.len(f));
                _error_code = _i_xv2_polynomialcalccheb2(&_s_errormsg, &_d_result, &_d_a, &_d_b, &_d_f, &_d_n, &_d_t, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "polynomialcalccheb2");
            result = _d_result;
        }
        finally
        {
            x_vector_clear(ref _d_f);
        }
        return result;
    }
    
    public static double polynomialcalccheb2(double a, double b, double[] f, int n, double t)
    {
        return _core_polynomialcalccheb2( a,  b,  f,  n,  t, 0x0);
    }
    
    public static double polynomialcalccheb2(double a, double b, double[] f, int n, double t, alglib.xparams _xparams)
    {
        return _core_polynomialcalccheb2( a,  b,  f,  n,  t, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static double polynomialcalccheb2(double a, double b, double[] f, double t)
    {
        int n;
    
        n = ap.len(f);
        double result = _core_polynomialcalccheb2( a,  b,  f,  n,  t, 0x0);
    
        return result;
    }
    
    public static double polynomialcalccheb2(double a, double b, double[] f, double t, alglib.xparams _xparams)
    {
        int n;
    
        n = ap.len(f);
        double result = _core_polynomialcalccheb2( a,  b,  f,  n,  t, _xparams==null ? 0x0 : _xparams.flags);
    
        return result;
    }
    
    
    //
    // Subpackage spline1d
    //
    

    public unsafe class spline1dinterpolant : alglibobject
    {
        private void *_ptr;
        public spline1dinterpolant(void *x)
        {
            _ptr = x;
        }
        ~spline1dinterpolant()
        {
            _deallocate();
        }
        public void* ptr { get { return _ptr; } }
        public override alglib.alglibobject make_copy()
        {
            if( _ptr==null )
                return new spline1dinterpolant(null);
            return new spline1dinterpolant(_i_x_obj_copy_spline1dinterpolant(_ptr));
        }
        public override void _deallocate()
        {
            if( _ptr!=null )
                _i_x_obj_free_spline1dinterpolant(_ptr);
            _ptr = null;
            System.GC.SuppressFinalize(this);
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_spline1dinterpolant(void *x);
    private static _d_x_obj_copy_spline1dinterpolant _i_x_obj_copy_spline1dinterpolant = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_obj_free_spline1dinterpolant(void *x);
    private static _d_x_obj_free_spline1dinterpolant _i_x_obj_free_spline1dinterpolant = null;

    [StructLayout(LayoutKind.Sequential, Pack=8)]
    private struct x_spline1dfitreport
    {
        public double taskrcond;
        public double rmserror;
        public double avgerror;
        public double avgrelerror;
        public double maxerror;
    }

    public class spline1dfitreport : alglibobject
    {
        public double taskrcond;
        public double rmserror;
        public double avgerror;
        public double avgrelerror;
        public double maxerror;
        public override alglib.alglibobject make_copy()
        {
            spline1dfitreport dst = new spline1dfitreport();
            dst.taskrcond = taskrcond;
            dst.rmserror = rmserror;
            dst.avgerror = avgerror;
            dst.avgrelerror = avgrelerror;
            dst.maxerror = maxerror;
            return dst;
        }
    }

    // This function initializes X-structure (its previous content is ignored)
    private static void x_spline1dfitreport_init(ref x_spline1dfitreport x)
    {
        x.taskrcond = 0;
        x.rmserror = 0;
        x.avgerror = 0;
        x.avgrelerror = 0;
        x.maxerror = 0;
    }

    // This function finalizes fields of X-structure (however, memory occupied by structure itself is not freed)
    // After destruction structure becomes unusable and should be re-initialized if you want to use it
    private static void x_spline1dfitreport_clear(ref x_spline1dfitreport x)
    {
    }

    // This function initializes X-structure by appropriate C# instance
    // (previous content of X structure is ignored)
    private static void x_spline1dfitreport_init_from(ref x_spline1dfitreport x, spline1dfitreport v)
    {
        x.taskrcond = v.taskrcond;
        x.rmserror = v.rmserror;
        x.avgerror = v.avgerror;
        x.avgrelerror = v.avgrelerror;
        x.maxerror = v.maxerror;
    }

    // This function initializes C# structure by appropriate X instance
    // (previous content of C# structure is ignored).
    // This function may accept null v, in this case v is automatically allocated with new().
    private static void x_spline1dfitreport_to_record(ref x_spline1dfitreport x, ref spline1dfitreport v)
    {
        if( v==null )
            v = new spline1dfitreport();
        v.taskrcond = x.taskrcond;
        v.rmserror = x.rmserror;
        v.avgerror = x.avgerror;
        v.avgrelerror = x.avgrelerror;
        v.maxerror = x.maxerror;
    }
    
    private static unsafe void _core_spline1dbuildlinear(double[] x, double[] y, int n, out spline1dinterpolant c, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_int _d_n = new x_int(n);
        void *_d_c = null;
        c = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                _error_code = _i_xv2_spline1dbuildlinear(&_s_errormsg, &_d_x, &_d_y, &_d_n, &_d_c, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spline1dbuildlinear");
            c = new spline1dinterpolant(_d_c);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            if( _d_c!=null && c==null)
                _i_x_obj_free_spline1dinterpolant(_d_c); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void spline1dbuildlinear(double[] x, double[] y, int n, out spline1dinterpolant c)
    {
        _core_spline1dbuildlinear( x,  y,  n, out  c, 0x0);
    }
    
    public static void spline1dbuildlinear(double[] x, double[] y, int n, out spline1dinterpolant c, alglib.xparams _xparams)
    {
        _core_spline1dbuildlinear( x,  y,  n, out  c, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void spline1dbuildlinear(double[] x, double[] y, out spline1dinterpolant c)
    {
        int n;
        if( (ap.len(x)!=ap.len(y)))
            throw new alglibexception("Error while calling 'spline1dbuildlinear': looks like one of arguments has wrong size");
        n = ap.len(x);
        _core_spline1dbuildlinear( x,  y,  n, out  c, 0x0);
    
        
    }
    
    public static void spline1dbuildlinear(double[] x, double[] y, out spline1dinterpolant c, alglib.xparams _xparams)
    {
        int n;
        if( (ap.len(x)!=ap.len(y)))
            throw new alglibexception("Error while calling 'spline1dbuildlinear': looks like one of arguments has wrong size");
        n = ap.len(x);
        _core_spline1dbuildlinear( x,  y,  n, out  c, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_spline1dbuildcubic(double[] x, double[] y, int n, int boundltype, double boundl, int boundrtype, double boundr, out spline1dinterpolant c, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_int _d_n = new x_int(n);
        x_int _d_boundltype = new x_int(boundltype);
        double _d_boundl = boundl;
        x_int _d_boundrtype = new x_int(boundrtype);
        double _d_boundr = boundr;
        void *_d_c = null;
        c = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                _error_code = _i_xv2_spline1dbuildcubic(&_s_errormsg, &_d_x, &_d_y, &_d_n, &_d_boundltype, &_d_boundl, &_d_boundrtype, &_d_boundr, &_d_c, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spline1dbuildcubic");
            c = new spline1dinterpolant(_d_c);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            if( _d_c!=null && c==null)
                _i_x_obj_free_spline1dinterpolant(_d_c); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void spline1dbuildcubic(double[] x, double[] y, int n, int boundltype, double boundl, int boundrtype, double boundr, out spline1dinterpolant c)
    {
        _core_spline1dbuildcubic( x,  y,  n,  boundltype,  boundl,  boundrtype,  boundr, out  c, 0x0);
    }
    
    public static void spline1dbuildcubic(double[] x, double[] y, int n, int boundltype, double boundl, int boundrtype, double boundr, out spline1dinterpolant c, alglib.xparams _xparams)
    {
        _core_spline1dbuildcubic( x,  y,  n,  boundltype,  boundl,  boundrtype,  boundr, out  c, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void spline1dbuildcubic(double[] x, double[] y, out spline1dinterpolant c)
    {
        int n;
        int boundltype;
        double boundl;
        int boundrtype;
        double boundr;
        if( (ap.len(x)!=ap.len(y)))
            throw new alglibexception("Error while calling 'spline1dbuildcubic': looks like one of arguments has wrong size");
        n = ap.len(x);
        boundltype = 0;
        boundl = 0;
        boundrtype = 0;
        boundr = 0;
        _core_spline1dbuildcubic( x,  y,  n,  boundltype,  boundl,  boundrtype,  boundr, out  c, 0x0);
    
        
    }
    
    public static void spline1dbuildcubic(double[] x, double[] y, out spline1dinterpolant c, alglib.xparams _xparams)
    {
        int n;
        int boundltype;
        double boundl;
        int boundrtype;
        double boundr;
        if( (ap.len(x)!=ap.len(y)))
            throw new alglibexception("Error while calling 'spline1dbuildcubic': looks like one of arguments has wrong size");
        n = ap.len(x);
        boundltype = 0;
        boundl = 0;
        boundrtype = 0;
        boundr = 0;
        _core_spline1dbuildcubic( x,  y,  n,  boundltype,  boundl,  boundrtype,  boundr, out  c, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_spline1dgriddiffcubic(double[] x, double[] y, int n, int boundltype, double boundl, int boundrtype, double boundr, out double[] d, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_int _d_n = new x_int(n);
        x_int _d_boundltype = new x_int(boundltype);
        double _d_boundl = boundl;
        x_int _d_boundrtype = new x_int(boundrtype);
        double _d_boundr = boundr;
        x_vector _d_d = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_vector_create_empty(ref _d_d, DT_REAL);
                d = null;
                _error_code = _i_xv2_spline1dgriddiffcubic(&_s_errormsg, &_d_x, &_d_y, &_d_n, &_d_boundltype, &_d_boundl, &_d_boundrtype, &_d_boundr, &_d_d, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spline1dgriddiffcubic");
            if( _d_d.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_d, ref d);
            if( d == null )
                d = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            x_vector_clear(ref _d_d);
        }
        // This function returns no value.
    }
    
    public static void spline1dgriddiffcubic(double[] x, double[] y, int n, int boundltype, double boundl, int boundrtype, double boundr, out double[] d)
    {
        _core_spline1dgriddiffcubic( x,  y,  n,  boundltype,  boundl,  boundrtype,  boundr, out  d, 0x0);
    }
    
    public static void spline1dgriddiffcubic(double[] x, double[] y, int n, int boundltype, double boundl, int boundrtype, double boundr, out double[] d, alglib.xparams _xparams)
    {
        _core_spline1dgriddiffcubic( x,  y,  n,  boundltype,  boundl,  boundrtype,  boundr, out  d, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void spline1dgriddiffcubic(double[] x, double[] y, out double[] d)
    {
        int n;
        int boundltype;
        double boundl;
        int boundrtype;
        double boundr;
        if( (ap.len(x)!=ap.len(y)))
            throw new alglibexception("Error while calling 'spline1dgriddiffcubic': looks like one of arguments has wrong size");
        n = ap.len(x);
        boundltype = 0;
        boundl = 0;
        boundrtype = 0;
        boundr = 0;
        _core_spline1dgriddiffcubic( x,  y,  n,  boundltype,  boundl,  boundrtype,  boundr, out  d, 0x0);
    
        
    }
    
    public static void spline1dgriddiffcubic(double[] x, double[] y, out double[] d, alglib.xparams _xparams)
    {
        int n;
        int boundltype;
        double boundl;
        int boundrtype;
        double boundr;
        if( (ap.len(x)!=ap.len(y)))
            throw new alglibexception("Error while calling 'spline1dgriddiffcubic': looks like one of arguments has wrong size");
        n = ap.len(x);
        boundltype = 0;
        boundl = 0;
        boundrtype = 0;
        boundr = 0;
        _core_spline1dgriddiffcubic( x,  y,  n,  boundltype,  boundl,  boundrtype,  boundr, out  d, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_spline1dgriddiff2cubic(double[] x, double[] y, int n, int boundltype, double boundl, int boundrtype, double boundr, out double[] d1, out double[] d2, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_int _d_n = new x_int(n);
        x_int _d_boundltype = new x_int(boundltype);
        double _d_boundl = boundl;
        x_int _d_boundrtype = new x_int(boundrtype);
        double _d_boundr = boundr;
        x_vector _d_d1 = new x_vector();
        x_vector _d_d2 = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_vector_create_empty(ref _d_d1, DT_REAL);
                d1 = null;
                x_vector_create_empty(ref _d_d2, DT_REAL);
                d2 = null;
                _error_code = _i_xv2_spline1dgriddiff2cubic(&_s_errormsg, &_d_x, &_d_y, &_d_n, &_d_boundltype, &_d_boundl, &_d_boundrtype, &_d_boundr, &_d_d1, &_d_d2, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spline1dgriddiff2cubic");
            if( _d_d1.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_d1, ref d1);
            if( d1 == null )
                d1 = new double[0];
            if( _d_d2.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_d2, ref d2);
            if( d2 == null )
                d2 = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            x_vector_clear(ref _d_d1);
            x_vector_clear(ref _d_d2);
        }
        // This function returns no value.
    }
    
    public static void spline1dgriddiff2cubic(double[] x, double[] y, int n, int boundltype, double boundl, int boundrtype, double boundr, out double[] d1, out double[] d2)
    {
        _core_spline1dgriddiff2cubic( x,  y,  n,  boundltype,  boundl,  boundrtype,  boundr, out  d1, out  d2, 0x0);
    }
    
    public static void spline1dgriddiff2cubic(double[] x, double[] y, int n, int boundltype, double boundl, int boundrtype, double boundr, out double[] d1, out double[] d2, alglib.xparams _xparams)
    {
        _core_spline1dgriddiff2cubic( x,  y,  n,  boundltype,  boundl,  boundrtype,  boundr, out  d1, out  d2, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void spline1dgriddiff2cubic(double[] x, double[] y, out double[] d1, out double[] d2)
    {
        int n;
        int boundltype;
        double boundl;
        int boundrtype;
        double boundr;
        if( (ap.len(x)!=ap.len(y)))
            throw new alglibexception("Error while calling 'spline1dgriddiff2cubic': looks like one of arguments has wrong size");
        n = ap.len(x);
        boundltype = 0;
        boundl = 0;
        boundrtype = 0;
        boundr = 0;
        _core_spline1dgriddiff2cubic( x,  y,  n,  boundltype,  boundl,  boundrtype,  boundr, out  d1, out  d2, 0x0);
    
        
    }
    
    public static void spline1dgriddiff2cubic(double[] x, double[] y, out double[] d1, out double[] d2, alglib.xparams _xparams)
    {
        int n;
        int boundltype;
        double boundl;
        int boundrtype;
        double boundr;
        if( (ap.len(x)!=ap.len(y)))
            throw new alglibexception("Error while calling 'spline1dgriddiff2cubic': looks like one of arguments has wrong size");
        n = ap.len(x);
        boundltype = 0;
        boundl = 0;
        boundrtype = 0;
        boundr = 0;
        _core_spline1dgriddiff2cubic( x,  y,  n,  boundltype,  boundl,  boundrtype,  boundr, out  d1, out  d2, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_spline1dconvcubic(double[] x, double[] y, int n, int boundltype, double boundl, int boundrtype, double boundr, double[] x2, int n2, out double[] y2, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_int _d_n = new x_int(n);
        x_int _d_boundltype = new x_int(boundltype);
        double _d_boundl = boundl;
        x_int _d_boundrtype = new x_int(boundrtype);
        double _d_boundr = boundr;
        x_vector _d_x2 = new x_vector();
        x_int _d_n2 = new x_int(n2);
        x_vector _d_y2 = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y, _fp_x2 = x2){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_vector_attach_to_array(ref _d_x2, _fp_x2, ap.len(x2));
                x_vector_create_empty(ref _d_y2, DT_REAL);
                y2 = null;
                _error_code = _i_xv2_spline1dconvcubic(&_s_errormsg, &_d_x, &_d_y, &_d_n, &_d_boundltype, &_d_boundl, &_d_boundrtype, &_d_boundr, &_d_x2, &_d_n2, &_d_y2, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spline1dconvcubic");
            if( _d_y2.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_y2, ref y2);
            if( y2 == null )
                y2 = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            x_vector_clear(ref _d_x2);
            x_vector_clear(ref _d_y2);
        }
        // This function returns no value.
    }
    
    public static void spline1dconvcubic(double[] x, double[] y, int n, int boundltype, double boundl, int boundrtype, double boundr, double[] x2, int n2, out double[] y2)
    {
        _core_spline1dconvcubic( x,  y,  n,  boundltype,  boundl,  boundrtype,  boundr,  x2,  n2, out  y2, 0x0);
    }
    
    public static void spline1dconvcubic(double[] x, double[] y, int n, int boundltype, double boundl, int boundrtype, double boundr, double[] x2, int n2, out double[] y2, alglib.xparams _xparams)
    {
        _core_spline1dconvcubic( x,  y,  n,  boundltype,  boundl,  boundrtype,  boundr,  x2,  n2, out  y2, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void spline1dconvcubic(double[] x, double[] y, double[] x2, out double[] y2)
    {
        int n;
        int boundltype;
        double boundl;
        int boundrtype;
        double boundr;
        int n2;
        if( (ap.len(x)!=ap.len(y)))
            throw new alglibexception("Error while calling 'spline1dconvcubic': looks like one of arguments has wrong size");
        n = ap.len(x);
        boundltype = 0;
        boundl = 0;
        boundrtype = 0;
        boundr = 0;
        n2 = ap.len(x2);
        _core_spline1dconvcubic( x,  y,  n,  boundltype,  boundl,  boundrtype,  boundr,  x2,  n2, out  y2, 0x0);
    
        
    }
    
    public static void spline1dconvcubic(double[] x, double[] y, double[] x2, out double[] y2, alglib.xparams _xparams)
    {
        int n;
        int boundltype;
        double boundl;
        int boundrtype;
        double boundr;
        int n2;
        if( (ap.len(x)!=ap.len(y)))
            throw new alglibexception("Error while calling 'spline1dconvcubic': looks like one of arguments has wrong size");
        n = ap.len(x);
        boundltype = 0;
        boundl = 0;
        boundrtype = 0;
        boundr = 0;
        n2 = ap.len(x2);
        _core_spline1dconvcubic( x,  y,  n,  boundltype,  boundl,  boundrtype,  boundr,  x2,  n2, out  y2, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_spline1dconvdiffcubic(double[] x, double[] y, int n, int boundltype, double boundl, int boundrtype, double boundr, double[] x2, int n2, out double[] y2, out double[] d2, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_int _d_n = new x_int(n);
        x_int _d_boundltype = new x_int(boundltype);
        double _d_boundl = boundl;
        x_int _d_boundrtype = new x_int(boundrtype);
        double _d_boundr = boundr;
        x_vector _d_x2 = new x_vector();
        x_int _d_n2 = new x_int(n2);
        x_vector _d_y2 = new x_vector();
        x_vector _d_d2 = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y, _fp_x2 = x2){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_vector_attach_to_array(ref _d_x2, _fp_x2, ap.len(x2));
                x_vector_create_empty(ref _d_y2, DT_REAL);
                y2 = null;
                x_vector_create_empty(ref _d_d2, DT_REAL);
                d2 = null;
                _error_code = _i_xv2_spline1dconvdiffcubic(&_s_errormsg, &_d_x, &_d_y, &_d_n, &_d_boundltype, &_d_boundl, &_d_boundrtype, &_d_boundr, &_d_x2, &_d_n2, &_d_y2, &_d_d2, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spline1dconvdiffcubic");
            if( _d_y2.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_y2, ref y2);
            if( y2 == null )
                y2 = new double[0];
            if( _d_d2.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_d2, ref d2);
            if( d2 == null )
                d2 = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            x_vector_clear(ref _d_x2);
            x_vector_clear(ref _d_y2);
            x_vector_clear(ref _d_d2);
        }
        // This function returns no value.
    }
    
    public static void spline1dconvdiffcubic(double[] x, double[] y, int n, int boundltype, double boundl, int boundrtype, double boundr, double[] x2, int n2, out double[] y2, out double[] d2)
    {
        _core_spline1dconvdiffcubic( x,  y,  n,  boundltype,  boundl,  boundrtype,  boundr,  x2,  n2, out  y2, out  d2, 0x0);
    }
    
    public static void spline1dconvdiffcubic(double[] x, double[] y, int n, int boundltype, double boundl, int boundrtype, double boundr, double[] x2, int n2, out double[] y2, out double[] d2, alglib.xparams _xparams)
    {
        _core_spline1dconvdiffcubic( x,  y,  n,  boundltype,  boundl,  boundrtype,  boundr,  x2,  n2, out  y2, out  d2, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void spline1dconvdiffcubic(double[] x, double[] y, double[] x2, out double[] y2, out double[] d2)
    {
        int n;
        int boundltype;
        double boundl;
        int boundrtype;
        double boundr;
        int n2;
        if( (ap.len(x)!=ap.len(y)))
            throw new alglibexception("Error while calling 'spline1dconvdiffcubic': looks like one of arguments has wrong size");
        n = ap.len(x);
        boundltype = 0;
        boundl = 0;
        boundrtype = 0;
        boundr = 0;
        n2 = ap.len(x2);
        _core_spline1dconvdiffcubic( x,  y,  n,  boundltype,  boundl,  boundrtype,  boundr,  x2,  n2, out  y2, out  d2, 0x0);
    
        
    }
    
    public static void spline1dconvdiffcubic(double[] x, double[] y, double[] x2, out double[] y2, out double[] d2, alglib.xparams _xparams)
    {
        int n;
        int boundltype;
        double boundl;
        int boundrtype;
        double boundr;
        int n2;
        if( (ap.len(x)!=ap.len(y)))
            throw new alglibexception("Error while calling 'spline1dconvdiffcubic': looks like one of arguments has wrong size");
        n = ap.len(x);
        boundltype = 0;
        boundl = 0;
        boundrtype = 0;
        boundr = 0;
        n2 = ap.len(x2);
        _core_spline1dconvdiffcubic( x,  y,  n,  boundltype,  boundl,  boundrtype,  boundr,  x2,  n2, out  y2, out  d2, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_spline1dconvdiff2cubic(double[] x, double[] y, int n, int boundltype, double boundl, int boundrtype, double boundr, double[] x2, int n2, out double[] y2, out double[] d2, out double[] dd2, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_int _d_n = new x_int(n);
        x_int _d_boundltype = new x_int(boundltype);
        double _d_boundl = boundl;
        x_int _d_boundrtype = new x_int(boundrtype);
        double _d_boundr = boundr;
        x_vector _d_x2 = new x_vector();
        x_int _d_n2 = new x_int(n2);
        x_vector _d_y2 = new x_vector();
        x_vector _d_d2 = new x_vector();
        x_vector _d_dd2 = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y, _fp_x2 = x2){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_vector_attach_to_array(ref _d_x2, _fp_x2, ap.len(x2));
                x_vector_create_empty(ref _d_y2, DT_REAL);
                y2 = null;
                x_vector_create_empty(ref _d_d2, DT_REAL);
                d2 = null;
                x_vector_create_empty(ref _d_dd2, DT_REAL);
                dd2 = null;
                _error_code = _i_xv2_spline1dconvdiff2cubic(&_s_errormsg, &_d_x, &_d_y, &_d_n, &_d_boundltype, &_d_boundl, &_d_boundrtype, &_d_boundr, &_d_x2, &_d_n2, &_d_y2, &_d_d2, &_d_dd2, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spline1dconvdiff2cubic");
            if( _d_y2.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_y2, ref y2);
            if( y2 == null )
                y2 = new double[0];
            if( _d_d2.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_d2, ref d2);
            if( d2 == null )
                d2 = new double[0];
            if( _d_dd2.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_dd2, ref dd2);
            if( dd2 == null )
                dd2 = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            x_vector_clear(ref _d_x2);
            x_vector_clear(ref _d_y2);
            x_vector_clear(ref _d_d2);
            x_vector_clear(ref _d_dd2);
        }
        // This function returns no value.
    }
    
    public static void spline1dconvdiff2cubic(double[] x, double[] y, int n, int boundltype, double boundl, int boundrtype, double boundr, double[] x2, int n2, out double[] y2, out double[] d2, out double[] dd2)
    {
        _core_spline1dconvdiff2cubic( x,  y,  n,  boundltype,  boundl,  boundrtype,  boundr,  x2,  n2, out  y2, out  d2, out  dd2, 0x0);
    }
    
    public static void spline1dconvdiff2cubic(double[] x, double[] y, int n, int boundltype, double boundl, int boundrtype, double boundr, double[] x2, int n2, out double[] y2, out double[] d2, out double[] dd2, alglib.xparams _xparams)
    {
        _core_spline1dconvdiff2cubic( x,  y,  n,  boundltype,  boundl,  boundrtype,  boundr,  x2,  n2, out  y2, out  d2, out  dd2, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void spline1dconvdiff2cubic(double[] x, double[] y, double[] x2, out double[] y2, out double[] d2, out double[] dd2)
    {
        int n;
        int boundltype;
        double boundl;
        int boundrtype;
        double boundr;
        int n2;
        if( (ap.len(x)!=ap.len(y)))
            throw new alglibexception("Error while calling 'spline1dconvdiff2cubic': looks like one of arguments has wrong size");
        n = ap.len(x);
        boundltype = 0;
        boundl = 0;
        boundrtype = 0;
        boundr = 0;
        n2 = ap.len(x2);
        _core_spline1dconvdiff2cubic( x,  y,  n,  boundltype,  boundl,  boundrtype,  boundr,  x2,  n2, out  y2, out  d2, out  dd2, 0x0);
    
        
    }
    
    public static void spline1dconvdiff2cubic(double[] x, double[] y, double[] x2, out double[] y2, out double[] d2, out double[] dd2, alglib.xparams _xparams)
    {
        int n;
        int boundltype;
        double boundl;
        int boundrtype;
        double boundr;
        int n2;
        if( (ap.len(x)!=ap.len(y)))
            throw new alglibexception("Error while calling 'spline1dconvdiff2cubic': looks like one of arguments has wrong size");
        n = ap.len(x);
        boundltype = 0;
        boundl = 0;
        boundrtype = 0;
        boundr = 0;
        n2 = ap.len(x2);
        _core_spline1dconvdiff2cubic( x,  y,  n,  boundltype,  boundl,  boundrtype,  boundr,  x2,  n2, out  y2, out  d2, out  dd2, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_spline1dbuildcatmullrom(double[] x, double[] y, int n, int boundtype, double tension, out spline1dinterpolant c, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_int _d_n = new x_int(n);
        x_int _d_boundtype = new x_int(boundtype);
        double _d_tension = tension;
        void *_d_c = null;
        c = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                _error_code = _i_xv2_spline1dbuildcatmullrom(&_s_errormsg, &_d_x, &_d_y, &_d_n, &_d_boundtype, &_d_tension, &_d_c, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spline1dbuildcatmullrom");
            c = new spline1dinterpolant(_d_c);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            if( _d_c!=null && c==null)
                _i_x_obj_free_spline1dinterpolant(_d_c); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void spline1dbuildcatmullrom(double[] x, double[] y, int n, int boundtype, double tension, out spline1dinterpolant c)
    {
        _core_spline1dbuildcatmullrom( x,  y,  n,  boundtype,  tension, out  c, 0x0);
    }
    
    public static void spline1dbuildcatmullrom(double[] x, double[] y, int n, int boundtype, double tension, out spline1dinterpolant c, alglib.xparams _xparams)
    {
        _core_spline1dbuildcatmullrom( x,  y,  n,  boundtype,  tension, out  c, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void spline1dbuildcatmullrom(double[] x, double[] y, out spline1dinterpolant c)
    {
        int n;
        int boundtype;
        double tension;
        if( (ap.len(x)!=ap.len(y)))
            throw new alglibexception("Error while calling 'spline1dbuildcatmullrom': looks like one of arguments has wrong size");
        n = ap.len(x);
        boundtype = 0;
        tension = 0;
        _core_spline1dbuildcatmullrom( x,  y,  n,  boundtype,  tension, out  c, 0x0);
    
        
    }
    
    public static void spline1dbuildcatmullrom(double[] x, double[] y, out spline1dinterpolant c, alglib.xparams _xparams)
    {
        int n;
        int boundtype;
        double tension;
        if( (ap.len(x)!=ap.len(y)))
            throw new alglibexception("Error while calling 'spline1dbuildcatmullrom': looks like one of arguments has wrong size");
        n = ap.len(x);
        boundtype = 0;
        tension = 0;
        _core_spline1dbuildcatmullrom( x,  y,  n,  boundtype,  tension, out  c, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_spline1dbuildhermite(double[] x, double[] y, double[] d, int n, out spline1dinterpolant c, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_vector _d_d = new x_vector();
        x_int _d_n = new x_int(n);
        void *_d_c = null;
        c = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y, _fp_d = d){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_vector_attach_to_array(ref _d_d, _fp_d, ap.len(d));
                _error_code = _i_xv2_spline1dbuildhermite(&_s_errormsg, &_d_x, &_d_y, &_d_d, &_d_n, &_d_c, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spline1dbuildhermite");
            c = new spline1dinterpolant(_d_c);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            x_vector_clear(ref _d_d);
            if( _d_c!=null && c==null)
                _i_x_obj_free_spline1dinterpolant(_d_c); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void spline1dbuildhermite(double[] x, double[] y, double[] d, int n, out spline1dinterpolant c)
    {
        _core_spline1dbuildhermite( x,  y,  d,  n, out  c, 0x0);
    }
    
    public static void spline1dbuildhermite(double[] x, double[] y, double[] d, int n, out spline1dinterpolant c, alglib.xparams _xparams)
    {
        _core_spline1dbuildhermite( x,  y,  d,  n, out  c, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void spline1dbuildhermite(double[] x, double[] y, double[] d, out spline1dinterpolant c)
    {
        int n;
        if( (ap.len(x)!=ap.len(y)) || (ap.len(x)!=ap.len(d)))
            throw new alglibexception("Error while calling 'spline1dbuildhermite': looks like one of arguments has wrong size");
        n = ap.len(x);
        _core_spline1dbuildhermite( x,  y,  d,  n, out  c, 0x0);
    
        
    }
    
    public static void spline1dbuildhermite(double[] x, double[] y, double[] d, out spline1dinterpolant c, alglib.xparams _xparams)
    {
        int n;
        if( (ap.len(x)!=ap.len(y)) || (ap.len(x)!=ap.len(d)))
            throw new alglibexception("Error while calling 'spline1dbuildhermite': looks like one of arguments has wrong size");
        n = ap.len(x);
        _core_spline1dbuildhermite( x,  y,  d,  n, out  c, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_spline1dbuildakima(double[] x, double[] y, int n, out spline1dinterpolant c, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_int _d_n = new x_int(n);
        void *_d_c = null;
        c = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                _error_code = _i_xv2_spline1dbuildakima(&_s_errormsg, &_d_x, &_d_y, &_d_n, &_d_c, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spline1dbuildakima");
            c = new spline1dinterpolant(_d_c);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            if( _d_c!=null && c==null)
                _i_x_obj_free_spline1dinterpolant(_d_c); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void spline1dbuildakima(double[] x, double[] y, int n, out spline1dinterpolant c)
    {
        _core_spline1dbuildakima( x,  y,  n, out  c, 0x0);
    }
    
    public static void spline1dbuildakima(double[] x, double[] y, int n, out spline1dinterpolant c, alglib.xparams _xparams)
    {
        _core_spline1dbuildakima( x,  y,  n, out  c, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void spline1dbuildakima(double[] x, double[] y, out spline1dinterpolant c)
    {
        int n;
        if( (ap.len(x)!=ap.len(y)))
            throw new alglibexception("Error while calling 'spline1dbuildakima': looks like one of arguments has wrong size");
        n = ap.len(x);
        _core_spline1dbuildakima( x,  y,  n, out  c, 0x0);
    
        
    }
    
    public static void spline1dbuildakima(double[] x, double[] y, out spline1dinterpolant c, alglib.xparams _xparams)
    {
        int n;
        if( (ap.len(x)!=ap.len(y)))
            throw new alglibexception("Error while calling 'spline1dbuildakima': looks like one of arguments has wrong size");
        n = ap.len(x);
        _core_spline1dbuildakima( x,  y,  n, out  c, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe double _core_spline1dcalc(spline1dinterpolant c, double x, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_c = c.ptr;
        double _d_x = x;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_spline1dcalc(&_s_errormsg, &_d_result, &_d_c, &_d_x, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spline1dcalc");
            result = _d_result;
            ap.assert(c.ptr==_d_c, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double spline1dcalc(spline1dinterpolant c, double x)
    {
        return _core_spline1dcalc( c,  x, 0x0);
    }
    
    public static double spline1dcalc(spline1dinterpolant c, double x, alglib.xparams _xparams)
    {
        return _core_spline1dcalc( c,  x, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_spline1ddiff(spline1dinterpolant c, double x, out double s, out double ds, out double d2s, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_c = c.ptr;
        double _d_x = x;
        double _d_s = 0;
        double _d_ds = 0;
        double _d_d2s = 0;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_spline1ddiff(&_s_errormsg, &_d_c, &_d_x, &_d_s, &_d_ds, &_d_d2s, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spline1ddiff");
            ap.assert(c.ptr==_d_c, "ALGLIB: internal error (reference changed for non-out X-object)");
            s = _d_s;
            ds = _d_ds;
            d2s = _d_d2s;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void spline1ddiff(spline1dinterpolant c, double x, out double s, out double ds, out double d2s)
    {
        _core_spline1ddiff( c,  x, out  s, out  ds, out  d2s, 0x0);
    }
    
    public static void spline1ddiff(spline1dinterpolant c, double x, out double s, out double ds, out double d2s, alglib.xparams _xparams)
    {
        _core_spline1ddiff( c,  x, out  s, out  ds, out  d2s, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_spline1dunpack(spline1dinterpolant c, out int n, out double[,] tbl, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_c = c.ptr;
        x_int _d_n = new x_int();
        x_matrix _d_tbl = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            x_matrix_create_empty(ref _d_tbl, DT_REAL);
            tbl = null;
            _error_code = _i_xv2_spline1dunpack(&_s_errormsg, &_d_c, &_d_n, &_d_tbl, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spline1dunpack");
            ap.assert(c.ptr==_d_c, "ALGLIB: internal error (reference changed for non-out X-object)");
            n = _d_n.intval;
            if( _d_tbl.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_tbl, ref tbl);
            if( tbl == null )
                tbl = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_tbl);
        }
        // This function returns no value.
    }
    
    public static void spline1dunpack(spline1dinterpolant c, out int n, out double[,] tbl)
    {
        _core_spline1dunpack( c, out  n, out  tbl, 0x0);
    }
    
    public static void spline1dunpack(spline1dinterpolant c, out int n, out double[,] tbl, alglib.xparams _xparams)
    {
        _core_spline1dunpack( c, out  n, out  tbl, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_spline1dlintransx(spline1dinterpolant c, double a, double b, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_c = c.ptr;
        double _d_a = a;
        double _d_b = b;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_spline1dlintransx(&_s_errormsg, &_d_c, &_d_a, &_d_b, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spline1dlintransx");
            ap.assert(c.ptr==_d_c, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void spline1dlintransx(spline1dinterpolant c, double a, double b)
    {
        _core_spline1dlintransx( c,  a,  b, 0x0);
    }
    
    public static void spline1dlintransx(spline1dinterpolant c, double a, double b, alglib.xparams _xparams)
    {
        _core_spline1dlintransx( c,  a,  b, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_spline1dlintransy(spline1dinterpolant c, double a, double b, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_c = c.ptr;
        double _d_a = a;
        double _d_b = b;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_spline1dlintransy(&_s_errormsg, &_d_c, &_d_a, &_d_b, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spline1dlintransy");
            ap.assert(c.ptr==_d_c, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void spline1dlintransy(spline1dinterpolant c, double a, double b)
    {
        _core_spline1dlintransy( c,  a,  b, 0x0);
    }
    
    public static void spline1dlintransy(spline1dinterpolant c, double a, double b, alglib.xparams _xparams)
    {
        _core_spline1dlintransy( c,  a,  b, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_spline1dintegrate(spline1dinterpolant c, double x, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_c = c.ptr;
        double _d_x = x;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_spline1dintegrate(&_s_errormsg, &_d_result, &_d_c, &_d_x, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spline1dintegrate");
            result = _d_result;
            ap.assert(c.ptr==_d_c, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double spline1dintegrate(spline1dinterpolant c, double x)
    {
        return _core_spline1dintegrate( c,  x, 0x0);
    }
    
    public static double spline1dintegrate(spline1dinterpolant c, double x, alglib.xparams _xparams)
    {
        return _core_spline1dintegrate( c,  x, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_spline1dfit(double[] x, double[] y, int n, int m, double lambdans, out spline1dinterpolant s, out spline1dfitreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_int _d_n = new x_int(n);
        x_int _d_m = new x_int(m);
        double _d_lambdans = lambdans;
        void *_d_s = null;
        s = null;
        x_spline1dfitreport _d_rep = new x_spline1dfitreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_spline1dfitreport_init(ref _d_rep);
                _error_code = _i_xv2_spline1dfit(&_s_errormsg, &_d_x, &_d_y, &_d_n, &_d_m, &_d_lambdans, &_d_s, &_d_rep, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spline1dfit");
            s = new spline1dinterpolant(_d_s);
            rep = null;
            x_spline1dfitreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            if( _d_s!=null && s==null)
                _i_x_obj_free_spline1dinterpolant(_d_s); // on exception clean up X objects which were not attached to C# objects
            x_spline1dfitreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void spline1dfit(double[] x, double[] y, int n, int m, double lambdans, out spline1dinterpolant s, out spline1dfitreport rep)
    {
        _core_spline1dfit( x,  y,  n,  m,  lambdans, out  s, out  rep, 0x0);
    }
    
    public static void spline1dfit(double[] x, double[] y, int n, int m, double lambdans, out spline1dinterpolant s, out spline1dfitreport rep, alglib.xparams _xparams)
    {
        _core_spline1dfit( x,  y,  n,  m,  lambdans, out  s, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void spline1dfit(double[] x, double[] y, int m, double lambdans, out spline1dinterpolant s, out spline1dfitreport rep)
    {
        int n;
        if( (ap.len(x)!=ap.len(y)))
            throw new alglibexception("Error while calling 'spline1dfit': looks like one of arguments has wrong size");
        n = ap.len(x);
        _core_spline1dfit( x,  y,  n,  m,  lambdans, out  s, out  rep, 0x0);
    
        
    }
    
    public static void spline1dfit(double[] x, double[] y, int m, double lambdans, out spline1dinterpolant s, out spline1dfitreport rep, alglib.xparams _xparams)
    {
        int n;
        if( (ap.len(x)!=ap.len(y)))
            throw new alglibexception("Error while calling 'spline1dfit': looks like one of arguments has wrong size");
        n = ap.len(x);
        _core_spline1dfit( x,  y,  n,  m,  lambdans, out  s, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_spline1dbuildmonotone(double[] x, double[] y, int n, out spline1dinterpolant c, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_int _d_n = new x_int(n);
        void *_d_c = null;
        c = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                _error_code = _i_xv2_spline1dbuildmonotone(&_s_errormsg, &_d_x, &_d_y, &_d_n, &_d_c, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spline1dbuildmonotone");
            c = new spline1dinterpolant(_d_c);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            if( _d_c!=null && c==null)
                _i_x_obj_free_spline1dinterpolant(_d_c); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void spline1dbuildmonotone(double[] x, double[] y, int n, out spline1dinterpolant c)
    {
        _core_spline1dbuildmonotone( x,  y,  n, out  c, 0x0);
    }
    
    public static void spline1dbuildmonotone(double[] x, double[] y, int n, out spline1dinterpolant c, alglib.xparams _xparams)
    {
        _core_spline1dbuildmonotone( x,  y,  n, out  c, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void spline1dbuildmonotone(double[] x, double[] y, out spline1dinterpolant c)
    {
        int n;
        if( (ap.len(x)!=ap.len(y)))
            throw new alglibexception("Error while calling 'spline1dbuildmonotone': looks like one of arguments has wrong size");
        n = ap.len(x);
        _core_spline1dbuildmonotone( x,  y,  n, out  c, 0x0);
    
        
    }
    
    public static void spline1dbuildmonotone(double[] x, double[] y, out spline1dinterpolant c, alglib.xparams _xparams)
    {
        int n;
        if( (ap.len(x)!=ap.len(y)))
            throw new alglibexception("Error while calling 'spline1dbuildmonotone': looks like one of arguments has wrong size");
        n = ap.len(x);
        _core_spline1dbuildmonotone( x,  y,  n, out  c, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    
    //
    // Subpackage lsfit
    //
    

    [StructLayout(LayoutKind.Sequential, Pack=8)]
    private struct x_polynomialfitreport
    {
        public double taskrcond;
        public double rmserror;
        public double avgerror;
        public double avgrelerror;
        public double maxerror;
    }

    public class polynomialfitreport : alglibobject
    {
        public double taskrcond;
        public double rmserror;
        public double avgerror;
        public double avgrelerror;
        public double maxerror;
        public override alglib.alglibobject make_copy()
        {
            polynomialfitreport dst = new polynomialfitreport();
            dst.taskrcond = taskrcond;
            dst.rmserror = rmserror;
            dst.avgerror = avgerror;
            dst.avgrelerror = avgrelerror;
            dst.maxerror = maxerror;
            return dst;
        }
    }

    // This function initializes X-structure (its previous content is ignored)
    private static void x_polynomialfitreport_init(ref x_polynomialfitreport x)
    {
        x.taskrcond = 0;
        x.rmserror = 0;
        x.avgerror = 0;
        x.avgrelerror = 0;
        x.maxerror = 0;
    }

    // This function finalizes fields of X-structure (however, memory occupied by structure itself is not freed)
    // After destruction structure becomes unusable and should be re-initialized if you want to use it
    private static void x_polynomialfitreport_clear(ref x_polynomialfitreport x)
    {
    }

    // This function initializes X-structure by appropriate C# instance
    // (previous content of X structure is ignored)
    private static void x_polynomialfitreport_init_from(ref x_polynomialfitreport x, polynomialfitreport v)
    {
        x.taskrcond = v.taskrcond;
        x.rmserror = v.rmserror;
        x.avgerror = v.avgerror;
        x.avgrelerror = v.avgrelerror;
        x.maxerror = v.maxerror;
    }

    // This function initializes C# structure by appropriate X instance
    // (previous content of C# structure is ignored).
    // This function may accept null v, in this case v is automatically allocated with new().
    private static void x_polynomialfitreport_to_record(ref x_polynomialfitreport x, ref polynomialfitreport v)
    {
        if( v==null )
            v = new polynomialfitreport();
        v.taskrcond = x.taskrcond;
        v.rmserror = x.rmserror;
        v.avgerror = x.avgerror;
        v.avgrelerror = x.avgrelerror;
        v.maxerror = x.maxerror;
    }

    [StructLayout(LayoutKind.Sequential, Pack=8)]
    private struct x_barycentricfitreport
    {
        public double taskrcond;
        public x_int dbest;
        public double rmserror;
        public double avgerror;
        public double avgrelerror;
        public double maxerror;
    }

    public class barycentricfitreport : alglibobject
    {
        public double taskrcond;
        public int dbest;
        public double rmserror;
        public double avgerror;
        public double avgrelerror;
        public double maxerror;
        public override alglib.alglibobject make_copy()
        {
            barycentricfitreport dst = new barycentricfitreport();
            dst.taskrcond = taskrcond;
            dst.dbest = dbest;
            dst.rmserror = rmserror;
            dst.avgerror = avgerror;
            dst.avgrelerror = avgrelerror;
            dst.maxerror = maxerror;
            return dst;
        }
    }

    // This function initializes X-structure (its previous content is ignored)
    private static void x_barycentricfitreport_init(ref x_barycentricfitreport x)
    {
        x.taskrcond = 0;
        x.dbest.longval = 0;
        x.rmserror = 0;
        x.avgerror = 0;
        x.avgrelerror = 0;
        x.maxerror = 0;
    }

    // This function finalizes fields of X-structure (however, memory occupied by structure itself is not freed)
    // After destruction structure becomes unusable and should be re-initialized if you want to use it
    private static void x_barycentricfitreport_clear(ref x_barycentricfitreport x)
    {
    }

    // This function initializes X-structure by appropriate C# instance
    // (previous content of X structure is ignored)
    private static void x_barycentricfitreport_init_from(ref x_barycentricfitreport x, barycentricfitreport v)
    {
        x.taskrcond = v.taskrcond;
        x.dbest.longval = v.dbest;
        x.rmserror = v.rmserror;
        x.avgerror = v.avgerror;
        x.avgrelerror = v.avgrelerror;
        x.maxerror = v.maxerror;
    }

    // This function initializes C# structure by appropriate X instance
    // (previous content of C# structure is ignored).
    // This function may accept null v, in this case v is automatically allocated with new().
    private static void x_barycentricfitreport_to_record(ref x_barycentricfitreport x, ref barycentricfitreport v)
    {
        if( v==null )
            v = new barycentricfitreport();
        v.taskrcond = x.taskrcond;
        v.dbest = x.dbest.intval; // long is silently truncated to int
        v.rmserror = x.rmserror;
        v.avgerror = x.avgerror;
        v.avgrelerror = x.avgrelerror;
        v.maxerror = x.maxerror;
    }

    [StructLayout(LayoutKind.Sequential, Pack=8)]
    private struct x_lsfitreport
    {
        public double taskrcond;
        public x_int iterationscount;
        public x_int varidx;
        public double rmserror;
        public double avgerror;
        public double avgrelerror;
        public double maxerror;
        public double wrmserror;
        public x_matrix covpar;
        public x_vector errpar;
        public x_vector errcurve;
        public x_vector noise;
        public double r2;
    }

    public class lsfitreport : alglibobject
    {
        public double taskrcond;
        public int iterationscount;
        public int varidx;
        public double rmserror;
        public double avgerror;
        public double avgrelerror;
        public double maxerror;
        public double wrmserror;
        public double[,] covpar;
        public double[] errpar;
        public double[] errcurve;
        public double[] noise;
        public double r2;
        public override alglib.alglibobject make_copy()
        {
            lsfitreport dst = new lsfitreport();
            dst.taskrcond = taskrcond;
            dst.iterationscount = iterationscount;
            dst.varidx = varidx;
            dst.rmserror = rmserror;
            dst.avgerror = avgerror;
            dst.avgrelerror = avgrelerror;
            dst.maxerror = maxerror;
            dst.wrmserror = wrmserror;
            dst.covpar = (double[,])covpar.Clone();        dst.errpar = (double[])errpar.Clone();        dst.errcurve = (double[])errcurve.Clone();        dst.noise = (double[])noise.Clone();        dst.r2 = r2;
            return dst;
        }
    }

    // This function initializes X-structure (its previous content is ignored)
    private static void x_lsfitreport_init(ref x_lsfitreport x)
    {
        x.taskrcond = 0;
        x.iterationscount.longval = 0;
        x.varidx.longval = 0;
        x.rmserror = 0;
        x.avgerror = 0;
        x.avgrelerror = 0;
        x.maxerror = 0;
        x.wrmserror = 0;
        x_matrix_create_empty(ref x.covpar, DT_REAL);
        x_vector_create_empty(ref x.errpar, DT_REAL);
        x_vector_create_empty(ref x.errcurve, DT_REAL);
        x_vector_create_empty(ref x.noise, DT_REAL);
        x.r2 = 0;
    }

    // This function finalizes fields of X-structure (however, memory occupied by structure itself is not freed)
    // After destruction structure becomes unusable and should be re-initialized if you want to use it
    private static void x_lsfitreport_clear(ref x_lsfitreport x)
    {
        x_matrix_clear(ref x.covpar);
        x_vector_clear(ref x.errpar);
        x_vector_clear(ref x.errcurve);
        x_vector_clear(ref x.noise);
    }

    // This function initializes X-structure by appropriate C# instance
    // (previous content of X structure is ignored)
    private static void x_lsfitreport_init_from(ref x_lsfitreport x, lsfitreport v)
    {
        x.taskrcond = v.taskrcond;
        x.iterationscount.longval = v.iterationscount;
        x.varidx.longval = v.varidx;
        x.rmserror = v.rmserror;
        x.avgerror = v.avgerror;
        x.avgrelerror = v.avgrelerror;
        x.maxerror = v.maxerror;
        x.wrmserror = v.wrmserror;
        x_matrix_from_array(ref x.covpar, v.covpar, X_CREATE);
        x_vector_from_array(ref x.errpar, v.errpar, X_CREATE);
        x_vector_from_array(ref x.errcurve, v.errcurve, X_CREATE);
        x_vector_from_array(ref x.noise, v.noise, X_CREATE);
        x.r2 = v.r2;
    }

    // This function initializes C# structure by appropriate X instance
    // (previous content of C# structure is ignored).
    // This function may accept null v, in this case v is automatically allocated with new().
    private static void x_lsfitreport_to_record(ref x_lsfitreport x, ref lsfitreport v)
    {
        if( v==null )
            v = new lsfitreport();
        v.taskrcond = x.taskrcond;
        v.iterationscount = x.iterationscount.intval; // long is silently truncated to int
        v.varidx = x.varidx.intval; // long is silently truncated to int
        v.rmserror = x.rmserror;
        v.avgerror = x.avgerror;
        v.avgrelerror = x.avgrelerror;
        v.maxerror = x.maxerror;
        v.wrmserror = x.wrmserror;
        x_matrix_to_array(ref x.covpar, ref v.covpar);
        x_vector_to_array(ref x.errpar, ref v.errpar);
        x_vector_to_array(ref x.errcurve, ref v.errcurve);
        x_vector_to_array(ref x.noise, ref v.noise);
        v.r2 = x.r2;
    }

    public unsafe class lsfitstate : alglibobject
    {
        private void *_ptr;
        public lsfitstate(void *x)
        {
            _ptr = x;
        }
        ~lsfitstate()
        {
            _deallocate();
        }
        public void* ptr { get { return _ptr; } }
        public override alglib.alglibobject make_copy()
        {
            if( _ptr==null )
                return new lsfitstate(null);
            return new lsfitstate(_i_x_obj_copy_lsfitstate(_ptr));
        }
        public override void _deallocate()
        {
            if( _ptr!=null )
                _i_x_obj_free_lsfitstate(_ptr);
            _ptr = null;
            System.GC.SuppressFinalize(this);
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_lsfitstate(void *x);
    private static _d_x_obj_copy_lsfitstate _i_x_obj_copy_lsfitstate = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_obj_free_lsfitstate(void *x);
    private static _d_x_obj_free_lsfitstate _i_x_obj_free_lsfitstate = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_lsfitstate_get_needf(void *x, byte *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_lsfitstate_set_needf(void *x, byte *dst);
    private static _d_x_lsfitstate_get_needf _i_x_lsfitstate_get_needf = null;
    private static _d_x_lsfitstate_set_needf _i_x_lsfitstate_set_needf = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_lsfitstate_get_needfg(void *x, byte *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_lsfitstate_set_needfg(void *x, byte *dst);
    private static _d_x_lsfitstate_get_needfg _i_x_lsfitstate_get_needfg = null;
    private static _d_x_lsfitstate_set_needfg _i_x_lsfitstate_set_needfg = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_lsfitstate_get_needfgh(void *x, byte *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_lsfitstate_set_needfgh(void *x, byte *dst);
    private static _d_x_lsfitstate_get_needfgh _i_x_lsfitstate_get_needfgh = null;
    private static _d_x_lsfitstate_set_needfgh _i_x_lsfitstate_set_needfgh = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_lsfitstate_get_xupdated(void *x, byte *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_lsfitstate_set_xupdated(void *x, byte *dst);
    private static _d_x_lsfitstate_get_xupdated _i_x_lsfitstate_get_xupdated = null;
    private static _d_x_lsfitstate_set_xupdated _i_x_lsfitstate_set_xupdated = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_lsfitstate_get_c(void *x, x_vector *dst);
    private static _d_x_lsfitstate_get_c _i_x_lsfitstate_get_c = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_lsfitstate_get_f(void *x, double *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_lsfitstate_set_f(void *x, double *dst);
    private static _d_x_lsfitstate_get_f _i_x_lsfitstate_get_f = null;
    private static _d_x_lsfitstate_set_f _i_x_lsfitstate_set_f = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_lsfitstate_get_g(void *x, x_vector *dst);
    private static _d_x_lsfitstate_get_g _i_x_lsfitstate_get_g = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_lsfitstate_get_h(void *x, x_matrix *dst);
    private static _d_x_lsfitstate_get_h _i_x_lsfitstate_get_h = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_lsfitstate_get_x(void *x, x_vector *dst);
    private static _d_x_lsfitstate_get_x _i_x_lsfitstate_get_x = null;
    
    private static unsafe void _core_lstfitpiecewiselinearrdpfixed(double[] x, double[] y, int n, int m, out double[] x2, out double[] y2, out int nsections, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_int _d_n = new x_int(n);
        x_int _d_m = new x_int(m);
        x_vector _d_x2 = new x_vector();
        x_vector _d_y2 = new x_vector();
        x_int _d_nsections = new x_int();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_vector_create_empty(ref _d_x2, DT_REAL);
                x2 = null;
                x_vector_create_empty(ref _d_y2, DT_REAL);
                y2 = null;
                _error_code = _i_xv2_lstfitpiecewiselinearrdpfixed(&_s_errormsg, &_d_x, &_d_y, &_d_n, &_d_m, &_d_x2, &_d_y2, &_d_nsections, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "lstfitpiecewiselinearrdpfixed");
            if( _d_x2.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x2, ref x2);
            if( x2 == null )
                x2 = new double[0];
            if( _d_y2.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_y2, ref y2);
            if( y2 == null )
                y2 = new double[0];
            nsections = _d_nsections.intval;
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            x_vector_clear(ref _d_x2);
            x_vector_clear(ref _d_y2);
        }
        // This function returns no value.
    }
    
    public static void lstfitpiecewiselinearrdpfixed(double[] x, double[] y, int n, int m, out double[] x2, out double[] y2, out int nsections)
    {
        _core_lstfitpiecewiselinearrdpfixed( x,  y,  n,  m, out  x2, out  y2, out  nsections, 0x0);
    }
    
    public static void lstfitpiecewiselinearrdpfixed(double[] x, double[] y, int n, int m, out double[] x2, out double[] y2, out int nsections, alglib.xparams _xparams)
    {
        _core_lstfitpiecewiselinearrdpfixed( x,  y,  n,  m, out  x2, out  y2, out  nsections, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_lstfitpiecewiselinearrdp(double[] x, double[] y, int n, double eps, out double[] x2, out double[] y2, out int nsections, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_int _d_n = new x_int(n);
        double _d_eps = eps;
        x_vector _d_x2 = new x_vector();
        x_vector _d_y2 = new x_vector();
        x_int _d_nsections = new x_int();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_vector_create_empty(ref _d_x2, DT_REAL);
                x2 = null;
                x_vector_create_empty(ref _d_y2, DT_REAL);
                y2 = null;
                _error_code = _i_xv2_lstfitpiecewiselinearrdp(&_s_errormsg, &_d_x, &_d_y, &_d_n, &_d_eps, &_d_x2, &_d_y2, &_d_nsections, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "lstfitpiecewiselinearrdp");
            if( _d_x2.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x2, ref x2);
            if( x2 == null )
                x2 = new double[0];
            if( _d_y2.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_y2, ref y2);
            if( y2 == null )
                y2 = new double[0];
            nsections = _d_nsections.intval;
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            x_vector_clear(ref _d_x2);
            x_vector_clear(ref _d_y2);
        }
        // This function returns no value.
    }
    
    public static void lstfitpiecewiselinearrdp(double[] x, double[] y, int n, double eps, out double[] x2, out double[] y2, out int nsections)
    {
        _core_lstfitpiecewiselinearrdp( x,  y,  n,  eps, out  x2, out  y2, out  nsections, 0x0);
    }
    
    public static void lstfitpiecewiselinearrdp(double[] x, double[] y, int n, double eps, out double[] x2, out double[] y2, out int nsections, alglib.xparams _xparams)
    {
        _core_lstfitpiecewiselinearrdp( x,  y,  n,  eps, out  x2, out  y2, out  nsections, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_polynomialfit(double[] x, double[] y, int n, int m, out int info, out barycentricinterpolant p, out polynomialfitreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_int _d_n = new x_int(n);
        x_int _d_m = new x_int(m);
        x_int _d_info = new x_int();
        void *_d_p = null;
        p = null;
        x_polynomialfitreport _d_rep = new x_polynomialfitreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_polynomialfitreport_init(ref _d_rep);
                _error_code = _i_xv2_polynomialfit(&_s_errormsg, &_d_x, &_d_y, &_d_n, &_d_m, &_d_info, &_d_p, &_d_rep, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "polynomialfit");
            info = _d_info.intval;
            p = new barycentricinterpolant(_d_p);
            rep = null;
            x_polynomialfitreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            if( _d_p!=null && p==null)
                _i_x_obj_free_barycentricinterpolant(_d_p); // on exception clean up X objects which were not attached to C# objects
            x_polynomialfitreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void polynomialfit(double[] x, double[] y, int n, int m, out int info, out barycentricinterpolant p, out polynomialfitreport rep)
    {
        _core_polynomialfit( x,  y,  n,  m, out  info, out  p, out  rep, 0x0);
    }
    
    public static void polynomialfit(double[] x, double[] y, int n, int m, out int info, out barycentricinterpolant p, out polynomialfitreport rep, alglib.xparams _xparams)
    {
        _core_polynomialfit( x,  y,  n,  m, out  info, out  p, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void polynomialfit(double[] x, double[] y, int m, out int info, out barycentricinterpolant p, out polynomialfitreport rep)
    {
        int n;
        if( (ap.len(x)!=ap.len(y)))
            throw new alglibexception("Error while calling 'polynomialfit': looks like one of arguments has wrong size");
        n = ap.len(x);
        _core_polynomialfit( x,  y,  n,  m, out  info, out  p, out  rep, 0x0);
    
        
    }
    
    public static void polynomialfit(double[] x, double[] y, int m, out int info, out barycentricinterpolant p, out polynomialfitreport rep, alglib.xparams _xparams)
    {
        int n;
        if( (ap.len(x)!=ap.len(y)))
            throw new alglibexception("Error while calling 'polynomialfit': looks like one of arguments has wrong size");
        n = ap.len(x);
        _core_polynomialfit( x,  y,  n,  m, out  info, out  p, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_polynomialfitwc(double[] x, double[] y, double[] w, int n, double[] xc, double[] yc, int[] dc, int k, int m, out int info, out barycentricinterpolant p, out polynomialfitreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_vector _d_w = new x_vector();
        x_int _d_n = new x_int(n);
        x_vector _d_xc = new x_vector();
        x_vector _d_yc = new x_vector();
        x_vector _d_dc = new x_vector();
        x_int _d_k = new x_int(k);
        x_int _d_m = new x_int(m);
        x_int _d_info = new x_int();
        void *_d_p = null;
        p = null;
        x_polynomialfitreport _d_rep = new x_polynomialfitreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y, _fp_w = w, _fp_xc = xc, _fp_yc = yc){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_vector_attach_to_array(ref _d_w, _fp_w, ap.len(w));
                x_vector_attach_to_array(ref _d_xc, _fp_xc, ap.len(xc));
                x_vector_attach_to_array(ref _d_yc, _fp_yc, ap.len(yc));
                x_vector_from_array(ref _d_dc, dc, X_CREATE);
                x_polynomialfitreport_init(ref _d_rep);
                _error_code = _i_xv2_polynomialfitwc(&_s_errormsg, &_d_x, &_d_y, &_d_w, &_d_n, &_d_xc, &_d_yc, &_d_dc, &_d_k, &_d_m, &_d_info, &_d_p, &_d_rep, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "polynomialfitwc");
            info = _d_info.intval;
            p = new barycentricinterpolant(_d_p);
            rep = null;
            x_polynomialfitreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            x_vector_clear(ref _d_w);
            x_vector_clear(ref _d_xc);
            x_vector_clear(ref _d_yc);
            x_vector_clear(ref _d_dc);
            if( _d_p!=null && p==null)
                _i_x_obj_free_barycentricinterpolant(_d_p); // on exception clean up X objects which were not attached to C# objects
            x_polynomialfitreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void polynomialfitwc(double[] x, double[] y, double[] w, int n, double[] xc, double[] yc, int[] dc, int k, int m, out int info, out barycentricinterpolant p, out polynomialfitreport rep)
    {
        _core_polynomialfitwc( x,  y,  w,  n,  xc,  yc,  dc,  k,  m, out  info, out  p, out  rep, 0x0);
    }
    
    public static void polynomialfitwc(double[] x, double[] y, double[] w, int n, double[] xc, double[] yc, int[] dc, int k, int m, out int info, out barycentricinterpolant p, out polynomialfitreport rep, alglib.xparams _xparams)
    {
        _core_polynomialfitwc( x,  y,  w,  n,  xc,  yc,  dc,  k,  m, out  info, out  p, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void polynomialfitwc(double[] x, double[] y, double[] w, double[] xc, double[] yc, int[] dc, int m, out int info, out barycentricinterpolant p, out polynomialfitreport rep)
    {
        int n;
        int k;
        if( (ap.len(x)!=ap.len(y)) || (ap.len(x)!=ap.len(w)))
            throw new alglibexception("Error while calling 'polynomialfitwc': looks like one of arguments has wrong size");
        if( (ap.len(xc)!=ap.len(yc)) || (ap.len(xc)!=ap.len(dc)))
            throw new alglibexception("Error while calling 'polynomialfitwc': looks like one of arguments has wrong size");
        n = ap.len(x);
        k = ap.len(xc);
        _core_polynomialfitwc( x,  y,  w,  n,  xc,  yc,  dc,  k,  m, out  info, out  p, out  rep, 0x0);
    
        
    }
    
    public static void polynomialfitwc(double[] x, double[] y, double[] w, double[] xc, double[] yc, int[] dc, int m, out int info, out barycentricinterpolant p, out polynomialfitreport rep, alglib.xparams _xparams)
    {
        int n;
        int k;
        if( (ap.len(x)!=ap.len(y)) || (ap.len(x)!=ap.len(w)))
            throw new alglibexception("Error while calling 'polynomialfitwc': looks like one of arguments has wrong size");
        if( (ap.len(xc)!=ap.len(yc)) || (ap.len(xc)!=ap.len(dc)))
            throw new alglibexception("Error while calling 'polynomialfitwc': looks like one of arguments has wrong size");
        n = ap.len(x);
        k = ap.len(xc);
        _core_polynomialfitwc( x,  y,  w,  n,  xc,  yc,  dc,  k,  m, out  info, out  p, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe double _core_logisticcalc4(double x, double a, double b, double c, double d, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        double _d_x = x;
        double _d_a = a;
        double _d_b = b;
        double _d_c = c;
        double _d_d = d;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_logisticcalc4(&_s_errormsg, &_d_result, &_d_x, &_d_a, &_d_b, &_d_c, &_d_d, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "logisticcalc4");
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double logisticcalc4(double x, double a, double b, double c, double d)
    {
        return _core_logisticcalc4( x,  a,  b,  c,  d, 0x0);
    }
    
    public static double logisticcalc4(double x, double a, double b, double c, double d, alglib.xparams _xparams)
    {
        return _core_logisticcalc4( x,  a,  b,  c,  d, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_logisticcalc5(double x, double a, double b, double c, double d, double g, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        double _d_x = x;
        double _d_a = a;
        double _d_b = b;
        double _d_c = c;
        double _d_d = d;
        double _d_g = g;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_logisticcalc5(&_s_errormsg, &_d_result, &_d_x, &_d_a, &_d_b, &_d_c, &_d_d, &_d_g, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "logisticcalc5");
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double logisticcalc5(double x, double a, double b, double c, double d, double g)
    {
        return _core_logisticcalc5( x,  a,  b,  c,  d,  g, 0x0);
    }
    
    public static double logisticcalc5(double x, double a, double b, double c, double d, double g, alglib.xparams _xparams)
    {
        return _core_logisticcalc5( x,  a,  b,  c,  d,  g, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_logisticfit4(double[] x, double[] y, int n, out double a, out double b, out double c, out double d, out lsfitreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_int _d_n = new x_int(n);
        double _d_a = 0;
        double _d_b = 0;
        double _d_c = 0;
        double _d_d = 0;
        x_lsfitreport _d_rep = new x_lsfitreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_lsfitreport_init(ref _d_rep);
                _error_code = _i_xv2_logisticfit4(&_s_errormsg, &_d_x, &_d_y, &_d_n, &_d_a, &_d_b, &_d_c, &_d_d, &_d_rep, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "logisticfit4");
            a = _d_a;
            b = _d_b;
            c = _d_c;
            d = _d_d;
            rep = null;
            x_lsfitreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            x_lsfitreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void logisticfit4(double[] x, double[] y, int n, out double a, out double b, out double c, out double d, out lsfitreport rep)
    {
        _core_logisticfit4( x,  y,  n, out  a, out  b, out  c, out  d, out  rep, 0x0);
    }
    
    public static void logisticfit4(double[] x, double[] y, int n, out double a, out double b, out double c, out double d, out lsfitreport rep, alglib.xparams _xparams)
    {
        _core_logisticfit4( x,  y,  n, out  a, out  b, out  c, out  d, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_logisticfit4ec(double[] x, double[] y, int n, double cnstrleft, double cnstrright, out double a, out double b, out double c, out double d, out lsfitreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_int _d_n = new x_int(n);
        double _d_cnstrleft = cnstrleft;
        double _d_cnstrright = cnstrright;
        double _d_a = 0;
        double _d_b = 0;
        double _d_c = 0;
        double _d_d = 0;
        x_lsfitreport _d_rep = new x_lsfitreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_lsfitreport_init(ref _d_rep);
                _error_code = _i_xv2_logisticfit4ec(&_s_errormsg, &_d_x, &_d_y, &_d_n, &_d_cnstrleft, &_d_cnstrright, &_d_a, &_d_b, &_d_c, &_d_d, &_d_rep, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "logisticfit4ec");
            a = _d_a;
            b = _d_b;
            c = _d_c;
            d = _d_d;
            rep = null;
            x_lsfitreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            x_lsfitreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void logisticfit4ec(double[] x, double[] y, int n, double cnstrleft, double cnstrright, out double a, out double b, out double c, out double d, out lsfitreport rep)
    {
        _core_logisticfit4ec( x,  y,  n,  cnstrleft,  cnstrright, out  a, out  b, out  c, out  d, out  rep, 0x0);
    }
    
    public static void logisticfit4ec(double[] x, double[] y, int n, double cnstrleft, double cnstrright, out double a, out double b, out double c, out double d, out lsfitreport rep, alglib.xparams _xparams)
    {
        _core_logisticfit4ec( x,  y,  n,  cnstrleft,  cnstrright, out  a, out  b, out  c, out  d, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_logisticfit5(double[] x, double[] y, int n, out double a, out double b, out double c, out double d, out double g, out lsfitreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_int _d_n = new x_int(n);
        double _d_a = 0;
        double _d_b = 0;
        double _d_c = 0;
        double _d_d = 0;
        double _d_g = 0;
        x_lsfitreport _d_rep = new x_lsfitreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_lsfitreport_init(ref _d_rep);
                _error_code = _i_xv2_logisticfit5(&_s_errormsg, &_d_x, &_d_y, &_d_n, &_d_a, &_d_b, &_d_c, &_d_d, &_d_g, &_d_rep, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "logisticfit5");
            a = _d_a;
            b = _d_b;
            c = _d_c;
            d = _d_d;
            g = _d_g;
            rep = null;
            x_lsfitreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            x_lsfitreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void logisticfit5(double[] x, double[] y, int n, out double a, out double b, out double c, out double d, out double g, out lsfitreport rep)
    {
        _core_logisticfit5( x,  y,  n, out  a, out  b, out  c, out  d, out  g, out  rep, 0x0);
    }
    
    public static void logisticfit5(double[] x, double[] y, int n, out double a, out double b, out double c, out double d, out double g, out lsfitreport rep, alglib.xparams _xparams)
    {
        _core_logisticfit5( x,  y,  n, out  a, out  b, out  c, out  d, out  g, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_logisticfit5ec(double[] x, double[] y, int n, double cnstrleft, double cnstrright, out double a, out double b, out double c, out double d, out double g, out lsfitreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_int _d_n = new x_int(n);
        double _d_cnstrleft = cnstrleft;
        double _d_cnstrright = cnstrright;
        double _d_a = 0;
        double _d_b = 0;
        double _d_c = 0;
        double _d_d = 0;
        double _d_g = 0;
        x_lsfitreport _d_rep = new x_lsfitreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_lsfitreport_init(ref _d_rep);
                _error_code = _i_xv2_logisticfit5ec(&_s_errormsg, &_d_x, &_d_y, &_d_n, &_d_cnstrleft, &_d_cnstrright, &_d_a, &_d_b, &_d_c, &_d_d, &_d_g, &_d_rep, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "logisticfit5ec");
            a = _d_a;
            b = _d_b;
            c = _d_c;
            d = _d_d;
            g = _d_g;
            rep = null;
            x_lsfitreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            x_lsfitreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void logisticfit5ec(double[] x, double[] y, int n, double cnstrleft, double cnstrright, out double a, out double b, out double c, out double d, out double g, out lsfitreport rep)
    {
        _core_logisticfit5ec( x,  y,  n,  cnstrleft,  cnstrright, out  a, out  b, out  c, out  d, out  g, out  rep, 0x0);
    }
    
    public static void logisticfit5ec(double[] x, double[] y, int n, double cnstrleft, double cnstrright, out double a, out double b, out double c, out double d, out double g, out lsfitreport rep, alglib.xparams _xparams)
    {
        _core_logisticfit5ec( x,  y,  n,  cnstrleft,  cnstrright, out  a, out  b, out  c, out  d, out  g, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_logisticfit45x(double[] x, double[] y, int n, double cnstrleft, double cnstrright, bool is4pl, double lambdav, double epsx, int rscnt, out double a, out double b, out double c, out double d, out double g, out lsfitreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_int _d_n = new x_int(n);
        double _d_cnstrleft = cnstrleft;
        double _d_cnstrright = cnstrright;
        byte _d_is4pl = (byte)(is4pl ? 1 : 0);
        double _d_lambdav = lambdav;
        double _d_epsx = epsx;
        x_int _d_rscnt = new x_int(rscnt);
        double _d_a = 0;
        double _d_b = 0;
        double _d_c = 0;
        double _d_d = 0;
        double _d_g = 0;
        x_lsfitreport _d_rep = new x_lsfitreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_lsfitreport_init(ref _d_rep);
                _error_code = _i_xv2_logisticfit45x(&_s_errormsg, &_d_x, &_d_y, &_d_n, &_d_cnstrleft, &_d_cnstrright, &_d_is4pl, &_d_lambdav, &_d_epsx, &_d_rscnt, &_d_a, &_d_b, &_d_c, &_d_d, &_d_g, &_d_rep, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "logisticfit45x");
            a = _d_a;
            b = _d_b;
            c = _d_c;
            d = _d_d;
            g = _d_g;
            rep = null;
            x_lsfitreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            x_lsfitreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void logisticfit45x(double[] x, double[] y, int n, double cnstrleft, double cnstrright, bool is4pl, double lambdav, double epsx, int rscnt, out double a, out double b, out double c, out double d, out double g, out lsfitreport rep)
    {
        _core_logisticfit45x( x,  y,  n,  cnstrleft,  cnstrright,  is4pl,  lambdav,  epsx,  rscnt, out  a, out  b, out  c, out  d, out  g, out  rep, 0x0);
    }
    
    public static void logisticfit45x(double[] x, double[] y, int n, double cnstrleft, double cnstrright, bool is4pl, double lambdav, double epsx, int rscnt, out double a, out double b, out double c, out double d, out double g, out lsfitreport rep, alglib.xparams _xparams)
    {
        _core_logisticfit45x( x,  y,  n,  cnstrleft,  cnstrright,  is4pl,  lambdav,  epsx,  rscnt, out  a, out  b, out  c, out  d, out  g, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_barycentricfitfloaterhormannwc(double[] x, double[] y, double[] w, int n, double[] xc, double[] yc, int[] dc, int k, int m, out int info, out barycentricinterpolant b, out barycentricfitreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_vector _d_w = new x_vector();
        x_int _d_n = new x_int(n);
        x_vector _d_xc = new x_vector();
        x_vector _d_yc = new x_vector();
        x_vector _d_dc = new x_vector();
        x_int _d_k = new x_int(k);
        x_int _d_m = new x_int(m);
        x_int _d_info = new x_int();
        void *_d_b = null;
        b = null;
        x_barycentricfitreport _d_rep = new x_barycentricfitreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y, _fp_w = w, _fp_xc = xc, _fp_yc = yc){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_vector_attach_to_array(ref _d_w, _fp_w, ap.len(w));
                x_vector_attach_to_array(ref _d_xc, _fp_xc, ap.len(xc));
                x_vector_attach_to_array(ref _d_yc, _fp_yc, ap.len(yc));
                x_vector_from_array(ref _d_dc, dc, X_CREATE);
                x_barycentricfitreport_init(ref _d_rep);
                _error_code = _i_xv2_barycentricfitfloaterhormannwc(&_s_errormsg, &_d_x, &_d_y, &_d_w, &_d_n, &_d_xc, &_d_yc, &_d_dc, &_d_k, &_d_m, &_d_info, &_d_b, &_d_rep, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "barycentricfitfloaterhormannwc");
            info = _d_info.intval;
            b = new barycentricinterpolant(_d_b);
            rep = null;
            x_barycentricfitreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            x_vector_clear(ref _d_w);
            x_vector_clear(ref _d_xc);
            x_vector_clear(ref _d_yc);
            x_vector_clear(ref _d_dc);
            if( _d_b!=null && b==null)
                _i_x_obj_free_barycentricinterpolant(_d_b); // on exception clean up X objects which were not attached to C# objects
            x_barycentricfitreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void barycentricfitfloaterhormannwc(double[] x, double[] y, double[] w, int n, double[] xc, double[] yc, int[] dc, int k, int m, out int info, out barycentricinterpolant b, out barycentricfitreport rep)
    {
        _core_barycentricfitfloaterhormannwc( x,  y,  w,  n,  xc,  yc,  dc,  k,  m, out  info, out  b, out  rep, 0x0);
    }
    
    public static void barycentricfitfloaterhormannwc(double[] x, double[] y, double[] w, int n, double[] xc, double[] yc, int[] dc, int k, int m, out int info, out barycentricinterpolant b, out barycentricfitreport rep, alglib.xparams _xparams)
    {
        _core_barycentricfitfloaterhormannwc( x,  y,  w,  n,  xc,  yc,  dc,  k,  m, out  info, out  b, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_barycentricfitfloaterhormann(double[] x, double[] y, int n, int m, out int info, out barycentricinterpolant b, out barycentricfitreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_int _d_n = new x_int(n);
        x_int _d_m = new x_int(m);
        x_int _d_info = new x_int();
        void *_d_b = null;
        b = null;
        x_barycentricfitreport _d_rep = new x_barycentricfitreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_barycentricfitreport_init(ref _d_rep);
                _error_code = _i_xv2_barycentricfitfloaterhormann(&_s_errormsg, &_d_x, &_d_y, &_d_n, &_d_m, &_d_info, &_d_b, &_d_rep, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "barycentricfitfloaterhormann");
            info = _d_info.intval;
            b = new barycentricinterpolant(_d_b);
            rep = null;
            x_barycentricfitreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            if( _d_b!=null && b==null)
                _i_x_obj_free_barycentricinterpolant(_d_b); // on exception clean up X objects which were not attached to C# objects
            x_barycentricfitreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void barycentricfitfloaterhormann(double[] x, double[] y, int n, int m, out int info, out barycentricinterpolant b, out barycentricfitreport rep)
    {
        _core_barycentricfitfloaterhormann( x,  y,  n,  m, out  info, out  b, out  rep, 0x0);
    }
    
    public static void barycentricfitfloaterhormann(double[] x, double[] y, int n, int m, out int info, out barycentricinterpolant b, out barycentricfitreport rep, alglib.xparams _xparams)
    {
        _core_barycentricfitfloaterhormann( x,  y,  n,  m, out  info, out  b, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_spline1dfitcubicwc(double[] x, double[] y, double[] w, int n, double[] xc, double[] yc, int[] dc, int k, int m, out int info, out spline1dinterpolant s, out spline1dfitreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_vector _d_w = new x_vector();
        x_int _d_n = new x_int(n);
        x_vector _d_xc = new x_vector();
        x_vector _d_yc = new x_vector();
        x_vector _d_dc = new x_vector();
        x_int _d_k = new x_int(k);
        x_int _d_m = new x_int(m);
        x_int _d_info = new x_int();
        void *_d_s = null;
        s = null;
        x_spline1dfitreport _d_rep = new x_spline1dfitreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y, _fp_w = w, _fp_xc = xc, _fp_yc = yc){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_vector_attach_to_array(ref _d_w, _fp_w, ap.len(w));
                x_vector_attach_to_array(ref _d_xc, _fp_xc, ap.len(xc));
                x_vector_attach_to_array(ref _d_yc, _fp_yc, ap.len(yc));
                x_vector_from_array(ref _d_dc, dc, X_CREATE);
                x_spline1dfitreport_init(ref _d_rep);
                _error_code = _i_xv2_spline1dfitcubicwc(&_s_errormsg, &_d_x, &_d_y, &_d_w, &_d_n, &_d_xc, &_d_yc, &_d_dc, &_d_k, &_d_m, &_d_info, &_d_s, &_d_rep, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spline1dfitcubicwc");
            info = _d_info.intval;
            s = new spline1dinterpolant(_d_s);
            rep = null;
            x_spline1dfitreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            x_vector_clear(ref _d_w);
            x_vector_clear(ref _d_xc);
            x_vector_clear(ref _d_yc);
            x_vector_clear(ref _d_dc);
            if( _d_s!=null && s==null)
                _i_x_obj_free_spline1dinterpolant(_d_s); // on exception clean up X objects which were not attached to C# objects
            x_spline1dfitreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void spline1dfitcubicwc(double[] x, double[] y, double[] w, int n, double[] xc, double[] yc, int[] dc, int k, int m, out int info, out spline1dinterpolant s, out spline1dfitreport rep)
    {
        _core_spline1dfitcubicwc( x,  y,  w,  n,  xc,  yc,  dc,  k,  m, out  info, out  s, out  rep, 0x0);
    }
    
    public static void spline1dfitcubicwc(double[] x, double[] y, double[] w, int n, double[] xc, double[] yc, int[] dc, int k, int m, out int info, out spline1dinterpolant s, out spline1dfitreport rep, alglib.xparams _xparams)
    {
        _core_spline1dfitcubicwc( x,  y,  w,  n,  xc,  yc,  dc,  k,  m, out  info, out  s, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void spline1dfitcubicwc(double[] x, double[] y, double[] w, double[] xc, double[] yc, int[] dc, int m, out int info, out spline1dinterpolant s, out spline1dfitreport rep)
    {
        int n;
        int k;
        if( (ap.len(x)!=ap.len(y)) || (ap.len(x)!=ap.len(w)))
            throw new alglibexception("Error while calling 'spline1dfitcubicwc': looks like one of arguments has wrong size");
        if( (ap.len(xc)!=ap.len(yc)) || (ap.len(xc)!=ap.len(dc)))
            throw new alglibexception("Error while calling 'spline1dfitcubicwc': looks like one of arguments has wrong size");
        n = ap.len(x);
        k = ap.len(xc);
        _core_spline1dfitcubicwc( x,  y,  w,  n,  xc,  yc,  dc,  k,  m, out  info, out  s, out  rep, 0x0);
    
        
    }
    
    public static void spline1dfitcubicwc(double[] x, double[] y, double[] w, double[] xc, double[] yc, int[] dc, int m, out int info, out spline1dinterpolant s, out spline1dfitreport rep, alglib.xparams _xparams)
    {
        int n;
        int k;
        if( (ap.len(x)!=ap.len(y)) || (ap.len(x)!=ap.len(w)))
            throw new alglibexception("Error while calling 'spline1dfitcubicwc': looks like one of arguments has wrong size");
        if( (ap.len(xc)!=ap.len(yc)) || (ap.len(xc)!=ap.len(dc)))
            throw new alglibexception("Error while calling 'spline1dfitcubicwc': looks like one of arguments has wrong size");
        n = ap.len(x);
        k = ap.len(xc);
        _core_spline1dfitcubicwc( x,  y,  w,  n,  xc,  yc,  dc,  k,  m, out  info, out  s, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_spline1dfithermitewc(double[] x, double[] y, double[] w, int n, double[] xc, double[] yc, int[] dc, int k, int m, out int info, out spline1dinterpolant s, out spline1dfitreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_vector _d_w = new x_vector();
        x_int _d_n = new x_int(n);
        x_vector _d_xc = new x_vector();
        x_vector _d_yc = new x_vector();
        x_vector _d_dc = new x_vector();
        x_int _d_k = new x_int(k);
        x_int _d_m = new x_int(m);
        x_int _d_info = new x_int();
        void *_d_s = null;
        s = null;
        x_spline1dfitreport _d_rep = new x_spline1dfitreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y, _fp_w = w, _fp_xc = xc, _fp_yc = yc){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_vector_attach_to_array(ref _d_w, _fp_w, ap.len(w));
                x_vector_attach_to_array(ref _d_xc, _fp_xc, ap.len(xc));
                x_vector_attach_to_array(ref _d_yc, _fp_yc, ap.len(yc));
                x_vector_from_array(ref _d_dc, dc, X_CREATE);
                x_spline1dfitreport_init(ref _d_rep);
                _error_code = _i_xv2_spline1dfithermitewc(&_s_errormsg, &_d_x, &_d_y, &_d_w, &_d_n, &_d_xc, &_d_yc, &_d_dc, &_d_k, &_d_m, &_d_info, &_d_s, &_d_rep, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spline1dfithermitewc");
            info = _d_info.intval;
            s = new spline1dinterpolant(_d_s);
            rep = null;
            x_spline1dfitreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            x_vector_clear(ref _d_w);
            x_vector_clear(ref _d_xc);
            x_vector_clear(ref _d_yc);
            x_vector_clear(ref _d_dc);
            if( _d_s!=null && s==null)
                _i_x_obj_free_spline1dinterpolant(_d_s); // on exception clean up X objects which were not attached to C# objects
            x_spline1dfitreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void spline1dfithermitewc(double[] x, double[] y, double[] w, int n, double[] xc, double[] yc, int[] dc, int k, int m, out int info, out spline1dinterpolant s, out spline1dfitreport rep)
    {
        _core_spline1dfithermitewc( x,  y,  w,  n,  xc,  yc,  dc,  k,  m, out  info, out  s, out  rep, 0x0);
    }
    
    public static void spline1dfithermitewc(double[] x, double[] y, double[] w, int n, double[] xc, double[] yc, int[] dc, int k, int m, out int info, out spline1dinterpolant s, out spline1dfitreport rep, alglib.xparams _xparams)
    {
        _core_spline1dfithermitewc( x,  y,  w,  n,  xc,  yc,  dc,  k,  m, out  info, out  s, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void spline1dfithermitewc(double[] x, double[] y, double[] w, double[] xc, double[] yc, int[] dc, int m, out int info, out spline1dinterpolant s, out spline1dfitreport rep)
    {
        int n;
        int k;
        if( (ap.len(x)!=ap.len(y)) || (ap.len(x)!=ap.len(w)))
            throw new alglibexception("Error while calling 'spline1dfithermitewc': looks like one of arguments has wrong size");
        if( (ap.len(xc)!=ap.len(yc)) || (ap.len(xc)!=ap.len(dc)))
            throw new alglibexception("Error while calling 'spline1dfithermitewc': looks like one of arguments has wrong size");
        n = ap.len(x);
        k = ap.len(xc);
        _core_spline1dfithermitewc( x,  y,  w,  n,  xc,  yc,  dc,  k,  m, out  info, out  s, out  rep, 0x0);
    
        
    }
    
    public static void spline1dfithermitewc(double[] x, double[] y, double[] w, double[] xc, double[] yc, int[] dc, int m, out int info, out spline1dinterpolant s, out spline1dfitreport rep, alglib.xparams _xparams)
    {
        int n;
        int k;
        if( (ap.len(x)!=ap.len(y)) || (ap.len(x)!=ap.len(w)))
            throw new alglibexception("Error while calling 'spline1dfithermitewc': looks like one of arguments has wrong size");
        if( (ap.len(xc)!=ap.len(yc)) || (ap.len(xc)!=ap.len(dc)))
            throw new alglibexception("Error while calling 'spline1dfithermitewc': looks like one of arguments has wrong size");
        n = ap.len(x);
        k = ap.len(xc);
        _core_spline1dfithermitewc( x,  y,  w,  n,  xc,  yc,  dc,  k,  m, out  info, out  s, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_spline1dfitcubic(double[] x, double[] y, int n, int m, out int info, out spline1dinterpolant s, out spline1dfitreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_int _d_n = new x_int(n);
        x_int _d_m = new x_int(m);
        x_int _d_info = new x_int();
        void *_d_s = null;
        s = null;
        x_spline1dfitreport _d_rep = new x_spline1dfitreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_spline1dfitreport_init(ref _d_rep);
                _error_code = _i_xv2_spline1dfitcubic(&_s_errormsg, &_d_x, &_d_y, &_d_n, &_d_m, &_d_info, &_d_s, &_d_rep, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spline1dfitcubic");
            info = _d_info.intval;
            s = new spline1dinterpolant(_d_s);
            rep = null;
            x_spline1dfitreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            if( _d_s!=null && s==null)
                _i_x_obj_free_spline1dinterpolant(_d_s); // on exception clean up X objects which were not attached to C# objects
            x_spline1dfitreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void spline1dfitcubic(double[] x, double[] y, int n, int m, out int info, out spline1dinterpolant s, out spline1dfitreport rep)
    {
        _core_spline1dfitcubic( x,  y,  n,  m, out  info, out  s, out  rep, 0x0);
    }
    
    public static void spline1dfitcubic(double[] x, double[] y, int n, int m, out int info, out spline1dinterpolant s, out spline1dfitreport rep, alglib.xparams _xparams)
    {
        _core_spline1dfitcubic( x,  y,  n,  m, out  info, out  s, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void spline1dfitcubic(double[] x, double[] y, int m, out int info, out spline1dinterpolant s, out spline1dfitreport rep)
    {
        int n;
        if( (ap.len(x)!=ap.len(y)))
            throw new alglibexception("Error while calling 'spline1dfitcubic': looks like one of arguments has wrong size");
        n = ap.len(x);
        _core_spline1dfitcubic( x,  y,  n,  m, out  info, out  s, out  rep, 0x0);
    
        
    }
    
    public static void spline1dfitcubic(double[] x, double[] y, int m, out int info, out spline1dinterpolant s, out spline1dfitreport rep, alglib.xparams _xparams)
    {
        int n;
        if( (ap.len(x)!=ap.len(y)))
            throw new alglibexception("Error while calling 'spline1dfitcubic': looks like one of arguments has wrong size");
        n = ap.len(x);
        _core_spline1dfitcubic( x,  y,  n,  m, out  info, out  s, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_spline1dfithermite(double[] x, double[] y, int n, int m, out int info, out spline1dinterpolant s, out spline1dfitreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_int _d_n = new x_int(n);
        x_int _d_m = new x_int(m);
        x_int _d_info = new x_int();
        void *_d_s = null;
        s = null;
        x_spline1dfitreport _d_rep = new x_spline1dfitreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_spline1dfitreport_init(ref _d_rep);
                _error_code = _i_xv2_spline1dfithermite(&_s_errormsg, &_d_x, &_d_y, &_d_n, &_d_m, &_d_info, &_d_s, &_d_rep, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spline1dfithermite");
            info = _d_info.intval;
            s = new spline1dinterpolant(_d_s);
            rep = null;
            x_spline1dfitreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            if( _d_s!=null && s==null)
                _i_x_obj_free_spline1dinterpolant(_d_s); // on exception clean up X objects which were not attached to C# objects
            x_spline1dfitreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void spline1dfithermite(double[] x, double[] y, int n, int m, out int info, out spline1dinterpolant s, out spline1dfitreport rep)
    {
        _core_spline1dfithermite( x,  y,  n,  m, out  info, out  s, out  rep, 0x0);
    }
    
    public static void spline1dfithermite(double[] x, double[] y, int n, int m, out int info, out spline1dinterpolant s, out spline1dfitreport rep, alglib.xparams _xparams)
    {
        _core_spline1dfithermite( x,  y,  n,  m, out  info, out  s, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void spline1dfithermite(double[] x, double[] y, int m, out int info, out spline1dinterpolant s, out spline1dfitreport rep)
    {
        int n;
        if( (ap.len(x)!=ap.len(y)))
            throw new alglibexception("Error while calling 'spline1dfithermite': looks like one of arguments has wrong size");
        n = ap.len(x);
        _core_spline1dfithermite( x,  y,  n,  m, out  info, out  s, out  rep, 0x0);
    
        
    }
    
    public static void spline1dfithermite(double[] x, double[] y, int m, out int info, out spline1dinterpolant s, out spline1dfitreport rep, alglib.xparams _xparams)
    {
        int n;
        if( (ap.len(x)!=ap.len(y)))
            throw new alglibexception("Error while calling 'spline1dfithermite': looks like one of arguments has wrong size");
        n = ap.len(x);
        _core_spline1dfithermite( x,  y,  n,  m, out  info, out  s, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_lsfitlinearw(double[] y, double[] w, double[,] fmatrix, int n, int m, out int info, out double[] c, out lsfitreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_y = new x_vector();
        x_vector _d_w = new x_vector();
        x_matrix _d_fmatrix = new x_matrix();
        x_int _d_n = new x_int(n);
        x_int _d_m = new x_int(m);
        x_int _d_info = new x_int();
        x_vector _d_c = new x_vector();
        x_lsfitreport _d_rep = new x_lsfitreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_y = y, _fp_w = w, _fp_fmatrix = fmatrix){
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_vector_attach_to_array(ref _d_w, _fp_w, ap.len(w));
                x_matrix_attach_to_array(ref _d_fmatrix, _fp_fmatrix, ap.rows(fmatrix), ap.cols(fmatrix));
                x_vector_create_empty(ref _d_c, DT_REAL);
                c = null;
                x_lsfitreport_init(ref _d_rep);
                _error_code = _i_xv2_lsfitlinearw(&_s_errormsg, &_d_y, &_d_w, &_d_fmatrix, &_d_n, &_d_m, &_d_info, &_d_c, &_d_rep, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "lsfitlinearw");
            info = _d_info.intval;
            if( _d_c.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_c, ref c);
            if( c == null )
                c = new double[0];
            rep = null;
            x_lsfitreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_y);
            x_vector_clear(ref _d_w);
            x_matrix_clear(ref _d_fmatrix);
            x_vector_clear(ref _d_c);
            x_lsfitreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void lsfitlinearw(double[] y, double[] w, double[,] fmatrix, int n, int m, out int info, out double[] c, out lsfitreport rep)
    {
        _core_lsfitlinearw( y,  w,  fmatrix,  n,  m, out  info, out  c, out  rep, 0x0);
    }
    
    public static void lsfitlinearw(double[] y, double[] w, double[,] fmatrix, int n, int m, out int info, out double[] c, out lsfitreport rep, alglib.xparams _xparams)
    {
        _core_lsfitlinearw( y,  w,  fmatrix,  n,  m, out  info, out  c, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void lsfitlinearw(double[] y, double[] w, double[,] fmatrix, out int info, out double[] c, out lsfitreport rep)
    {
        int n;
        int m;
        if( (ap.len(y)!=ap.len(w)) || (ap.len(y)!=ap.rows(fmatrix)))
            throw new alglibexception("Error while calling 'lsfitlinearw': looks like one of arguments has wrong size");
        n = ap.len(y);
        m = ap.cols(fmatrix);
        _core_lsfitlinearw( y,  w,  fmatrix,  n,  m, out  info, out  c, out  rep, 0x0);
    
        
    }
    
    public static void lsfitlinearw(double[] y, double[] w, double[,] fmatrix, out int info, out double[] c, out lsfitreport rep, alglib.xparams _xparams)
    {
        int n;
        int m;
        if( (ap.len(y)!=ap.len(w)) || (ap.len(y)!=ap.rows(fmatrix)))
            throw new alglibexception("Error while calling 'lsfitlinearw': looks like one of arguments has wrong size");
        n = ap.len(y);
        m = ap.cols(fmatrix);
        _core_lsfitlinearw( y,  w,  fmatrix,  n,  m, out  info, out  c, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_lsfitlinearwc(double[] y, double[] w, double[,] fmatrix, double[,] cmatrix, int n, int m, int k, out int info, out double[] c, out lsfitreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_y = new x_vector();
        x_vector _d_w = new x_vector();
        x_matrix _d_fmatrix = new x_matrix();
        x_matrix _d_cmatrix = new x_matrix();
        x_int _d_n = new x_int(n);
        x_int _d_m = new x_int(m);
        x_int _d_k = new x_int(k);
        x_int _d_info = new x_int();
        x_vector _d_c = new x_vector();
        x_lsfitreport _d_rep = new x_lsfitreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_y = y, _fp_w = w, _fp_fmatrix = fmatrix, _fp_cmatrix = cmatrix){
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_vector_attach_to_array(ref _d_w, _fp_w, ap.len(w));
                x_matrix_attach_to_array(ref _d_fmatrix, _fp_fmatrix, ap.rows(fmatrix), ap.cols(fmatrix));
                x_matrix_attach_to_array(ref _d_cmatrix, _fp_cmatrix, ap.rows(cmatrix), ap.cols(cmatrix));
                x_vector_create_empty(ref _d_c, DT_REAL);
                c = null;
                x_lsfitreport_init(ref _d_rep);
                _error_code = _i_xv2_lsfitlinearwc(&_s_errormsg, &_d_y, &_d_w, &_d_fmatrix, &_d_cmatrix, &_d_n, &_d_m, &_d_k, &_d_info, &_d_c, &_d_rep, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "lsfitlinearwc");
            info = _d_info.intval;
            if( _d_c.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_c, ref c);
            if( c == null )
                c = new double[0];
            rep = null;
            x_lsfitreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_y);
            x_vector_clear(ref _d_w);
            x_matrix_clear(ref _d_fmatrix);
            x_matrix_clear(ref _d_cmatrix);
            x_vector_clear(ref _d_c);
            x_lsfitreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void lsfitlinearwc(double[] y, double[] w, double[,] fmatrix, double[,] cmatrix, int n, int m, int k, out int info, out double[] c, out lsfitreport rep)
    {
        _core_lsfitlinearwc( y,  w,  fmatrix,  cmatrix,  n,  m,  k, out  info, out  c, out  rep, 0x0);
    }
    
    public static void lsfitlinearwc(double[] y, double[] w, double[,] fmatrix, double[,] cmatrix, int n, int m, int k, out int info, out double[] c, out lsfitreport rep, alglib.xparams _xparams)
    {
        _core_lsfitlinearwc( y,  w,  fmatrix,  cmatrix,  n,  m,  k, out  info, out  c, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void lsfitlinearwc(double[] y, double[] w, double[,] fmatrix, double[,] cmatrix, out int info, out double[] c, out lsfitreport rep)
    {
        int n;
        int m;
        int k;
        if( (ap.len(y)!=ap.len(w)) || (ap.len(y)!=ap.rows(fmatrix)))
            throw new alglibexception("Error while calling 'lsfitlinearwc': looks like one of arguments has wrong size");
        if( (ap.cols(fmatrix)!=ap.cols(cmatrix)-1))
            throw new alglibexception("Error while calling 'lsfitlinearwc': looks like one of arguments has wrong size");
        n = ap.len(y);
        m = ap.cols(fmatrix);
        k = ap.rows(cmatrix);
        _core_lsfitlinearwc( y,  w,  fmatrix,  cmatrix,  n,  m,  k, out  info, out  c, out  rep, 0x0);
    
        
    }
    
    public static void lsfitlinearwc(double[] y, double[] w, double[,] fmatrix, double[,] cmatrix, out int info, out double[] c, out lsfitreport rep, alglib.xparams _xparams)
    {
        int n;
        int m;
        int k;
        if( (ap.len(y)!=ap.len(w)) || (ap.len(y)!=ap.rows(fmatrix)))
            throw new alglibexception("Error while calling 'lsfitlinearwc': looks like one of arguments has wrong size");
        if( (ap.cols(fmatrix)!=ap.cols(cmatrix)-1))
            throw new alglibexception("Error while calling 'lsfitlinearwc': looks like one of arguments has wrong size");
        n = ap.len(y);
        m = ap.cols(fmatrix);
        k = ap.rows(cmatrix);
        _core_lsfitlinearwc( y,  w,  fmatrix,  cmatrix,  n,  m,  k, out  info, out  c, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_lsfitlinear(double[] y, double[,] fmatrix, int n, int m, out int info, out double[] c, out lsfitreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_y = new x_vector();
        x_matrix _d_fmatrix = new x_matrix();
        x_int _d_n = new x_int(n);
        x_int _d_m = new x_int(m);
        x_int _d_info = new x_int();
        x_vector _d_c = new x_vector();
        x_lsfitreport _d_rep = new x_lsfitreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_y = y, _fp_fmatrix = fmatrix){
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_matrix_attach_to_array(ref _d_fmatrix, _fp_fmatrix, ap.rows(fmatrix), ap.cols(fmatrix));
                x_vector_create_empty(ref _d_c, DT_REAL);
                c = null;
                x_lsfitreport_init(ref _d_rep);
                _error_code = _i_xv2_lsfitlinear(&_s_errormsg, &_d_y, &_d_fmatrix, &_d_n, &_d_m, &_d_info, &_d_c, &_d_rep, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "lsfitlinear");
            info = _d_info.intval;
            if( _d_c.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_c, ref c);
            if( c == null )
                c = new double[0];
            rep = null;
            x_lsfitreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_y);
            x_matrix_clear(ref _d_fmatrix);
            x_vector_clear(ref _d_c);
            x_lsfitreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void lsfitlinear(double[] y, double[,] fmatrix, int n, int m, out int info, out double[] c, out lsfitreport rep)
    {
        _core_lsfitlinear( y,  fmatrix,  n,  m, out  info, out  c, out  rep, 0x0);
    }
    
    public static void lsfitlinear(double[] y, double[,] fmatrix, int n, int m, out int info, out double[] c, out lsfitreport rep, alglib.xparams _xparams)
    {
        _core_lsfitlinear( y,  fmatrix,  n,  m, out  info, out  c, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void lsfitlinear(double[] y, double[,] fmatrix, out int info, out double[] c, out lsfitreport rep)
    {
        int n;
        int m;
        if( (ap.len(y)!=ap.rows(fmatrix)))
            throw new alglibexception("Error while calling 'lsfitlinear': looks like one of arguments has wrong size");
        n = ap.len(y);
        m = ap.cols(fmatrix);
        _core_lsfitlinear( y,  fmatrix,  n,  m, out  info, out  c, out  rep, 0x0);
    
        
    }
    
    public static void lsfitlinear(double[] y, double[,] fmatrix, out int info, out double[] c, out lsfitreport rep, alglib.xparams _xparams)
    {
        int n;
        int m;
        if( (ap.len(y)!=ap.rows(fmatrix)))
            throw new alglibexception("Error while calling 'lsfitlinear': looks like one of arguments has wrong size");
        n = ap.len(y);
        m = ap.cols(fmatrix);
        _core_lsfitlinear( y,  fmatrix,  n,  m, out  info, out  c, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_lsfitlinearc(double[] y, double[,] fmatrix, double[,] cmatrix, int n, int m, int k, out int info, out double[] c, out lsfitreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_y = new x_vector();
        x_matrix _d_fmatrix = new x_matrix();
        x_matrix _d_cmatrix = new x_matrix();
        x_int _d_n = new x_int(n);
        x_int _d_m = new x_int(m);
        x_int _d_k = new x_int(k);
        x_int _d_info = new x_int();
        x_vector _d_c = new x_vector();
        x_lsfitreport _d_rep = new x_lsfitreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_y = y, _fp_fmatrix = fmatrix, _fp_cmatrix = cmatrix){
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_matrix_attach_to_array(ref _d_fmatrix, _fp_fmatrix, ap.rows(fmatrix), ap.cols(fmatrix));
                x_matrix_attach_to_array(ref _d_cmatrix, _fp_cmatrix, ap.rows(cmatrix), ap.cols(cmatrix));
                x_vector_create_empty(ref _d_c, DT_REAL);
                c = null;
                x_lsfitreport_init(ref _d_rep);
                _error_code = _i_xv2_lsfitlinearc(&_s_errormsg, &_d_y, &_d_fmatrix, &_d_cmatrix, &_d_n, &_d_m, &_d_k, &_d_info, &_d_c, &_d_rep, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "lsfitlinearc");
            info = _d_info.intval;
            if( _d_c.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_c, ref c);
            if( c == null )
                c = new double[0];
            rep = null;
            x_lsfitreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_y);
            x_matrix_clear(ref _d_fmatrix);
            x_matrix_clear(ref _d_cmatrix);
            x_vector_clear(ref _d_c);
            x_lsfitreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void lsfitlinearc(double[] y, double[,] fmatrix, double[,] cmatrix, int n, int m, int k, out int info, out double[] c, out lsfitreport rep)
    {
        _core_lsfitlinearc( y,  fmatrix,  cmatrix,  n,  m,  k, out  info, out  c, out  rep, 0x0);
    }
    
    public static void lsfitlinearc(double[] y, double[,] fmatrix, double[,] cmatrix, int n, int m, int k, out int info, out double[] c, out lsfitreport rep, alglib.xparams _xparams)
    {
        _core_lsfitlinearc( y,  fmatrix,  cmatrix,  n,  m,  k, out  info, out  c, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void lsfitlinearc(double[] y, double[,] fmatrix, double[,] cmatrix, out int info, out double[] c, out lsfitreport rep)
    {
        int n;
        int m;
        int k;
        if( (ap.len(y)!=ap.rows(fmatrix)))
            throw new alglibexception("Error while calling 'lsfitlinearc': looks like one of arguments has wrong size");
        if( (ap.cols(fmatrix)!=ap.cols(cmatrix)-1))
            throw new alglibexception("Error while calling 'lsfitlinearc': looks like one of arguments has wrong size");
        n = ap.len(y);
        m = ap.cols(fmatrix);
        k = ap.rows(cmatrix);
        _core_lsfitlinearc( y,  fmatrix,  cmatrix,  n,  m,  k, out  info, out  c, out  rep, 0x0);
    
        
    }
    
    public static void lsfitlinearc(double[] y, double[,] fmatrix, double[,] cmatrix, out int info, out double[] c, out lsfitreport rep, alglib.xparams _xparams)
    {
        int n;
        int m;
        int k;
        if( (ap.len(y)!=ap.rows(fmatrix)))
            throw new alglibexception("Error while calling 'lsfitlinearc': looks like one of arguments has wrong size");
        if( (ap.cols(fmatrix)!=ap.cols(cmatrix)-1))
            throw new alglibexception("Error while calling 'lsfitlinearc': looks like one of arguments has wrong size");
        n = ap.len(y);
        m = ap.cols(fmatrix);
        k = ap.rows(cmatrix);
        _core_lsfitlinearc( y,  fmatrix,  cmatrix,  n,  m,  k, out  info, out  c, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_lsfitcreatewf(double[,] x, double[] y, double[] w, double[] c, int n, int m, int k, double diffstep, out lsfitstate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_x = new x_matrix();
        x_vector _d_y = new x_vector();
        x_vector _d_w = new x_vector();
        x_vector _d_c = new x_vector();
        x_int _d_n = new x_int(n);
        x_int _d_m = new x_int(m);
        x_int _d_k = new x_int(k);
        double _d_diffstep = diffstep;
        void *_d_state = null;
        state = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y, _fp_w = w, _fp_c = c){
                x_matrix_attach_to_array(ref _d_x, _fp_x, ap.rows(x), ap.cols(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_vector_attach_to_array(ref _d_w, _fp_w, ap.len(w));
                x_vector_attach_to_array(ref _d_c, _fp_c, ap.len(c));
                _error_code = _i_xv2_lsfitcreatewf(&_s_errormsg, &_d_x, &_d_y, &_d_w, &_d_c, &_d_n, &_d_m, &_d_k, &_d_diffstep, &_d_state, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "lsfitcreatewf");
            state = new lsfitstate(_d_state);
        }
        finally
        {
            x_matrix_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            x_vector_clear(ref _d_w);
            x_vector_clear(ref _d_c);
            if( _d_state!=null && state==null)
                _i_x_obj_free_lsfitstate(_d_state); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void lsfitcreatewf(double[,] x, double[] y, double[] w, double[] c, int n, int m, int k, double diffstep, out lsfitstate state)
    {
        _core_lsfitcreatewf( x,  y,  w,  c,  n,  m,  k,  diffstep, out  state, 0x0);
    }
    
    public static void lsfitcreatewf(double[,] x, double[] y, double[] w, double[] c, int n, int m, int k, double diffstep, out lsfitstate state, alglib.xparams _xparams)
    {
        _core_lsfitcreatewf( x,  y,  w,  c,  n,  m,  k,  diffstep, out  state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void lsfitcreatewf(double[,] x, double[] y, double[] w, double[] c, double diffstep, out lsfitstate state)
    {
        int n;
        int m;
        int k;
        if( (ap.rows(x)!=ap.len(y)) || (ap.rows(x)!=ap.len(w)))
            throw new alglibexception("Error while calling 'lsfitcreatewf': looks like one of arguments has wrong size");
        n = ap.rows(x);
        m = ap.cols(x);
        k = ap.len(c);
        _core_lsfitcreatewf( x,  y,  w,  c,  n,  m,  k,  diffstep, out  state, 0x0);
    
        
    }
    
    public static void lsfitcreatewf(double[,] x, double[] y, double[] w, double[] c, double diffstep, out lsfitstate state, alglib.xparams _xparams)
    {
        int n;
        int m;
        int k;
        if( (ap.rows(x)!=ap.len(y)) || (ap.rows(x)!=ap.len(w)))
            throw new alglibexception("Error while calling 'lsfitcreatewf': looks like one of arguments has wrong size");
        n = ap.rows(x);
        m = ap.cols(x);
        k = ap.len(c);
        _core_lsfitcreatewf( x,  y,  w,  c,  n,  m,  k,  diffstep, out  state, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_lsfitcreatef(double[,] x, double[] y, double[] c, int n, int m, int k, double diffstep, out lsfitstate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_x = new x_matrix();
        x_vector _d_y = new x_vector();
        x_vector _d_c = new x_vector();
        x_int _d_n = new x_int(n);
        x_int _d_m = new x_int(m);
        x_int _d_k = new x_int(k);
        double _d_diffstep = diffstep;
        void *_d_state = null;
        state = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y, _fp_c = c){
                x_matrix_attach_to_array(ref _d_x, _fp_x, ap.rows(x), ap.cols(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_vector_attach_to_array(ref _d_c, _fp_c, ap.len(c));
                _error_code = _i_xv2_lsfitcreatef(&_s_errormsg, &_d_x, &_d_y, &_d_c, &_d_n, &_d_m, &_d_k, &_d_diffstep, &_d_state, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "lsfitcreatef");
            state = new lsfitstate(_d_state);
        }
        finally
        {
            x_matrix_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            x_vector_clear(ref _d_c);
            if( _d_state!=null && state==null)
                _i_x_obj_free_lsfitstate(_d_state); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void lsfitcreatef(double[,] x, double[] y, double[] c, int n, int m, int k, double diffstep, out lsfitstate state)
    {
        _core_lsfitcreatef( x,  y,  c,  n,  m,  k,  diffstep, out  state, 0x0);
    }
    
    public static void lsfitcreatef(double[,] x, double[] y, double[] c, int n, int m, int k, double diffstep, out lsfitstate state, alglib.xparams _xparams)
    {
        _core_lsfitcreatef( x,  y,  c,  n,  m,  k,  diffstep, out  state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void lsfitcreatef(double[,] x, double[] y, double[] c, double diffstep, out lsfitstate state)
    {
        int n;
        int m;
        int k;
        if( (ap.rows(x)!=ap.len(y)))
            throw new alglibexception("Error while calling 'lsfitcreatef': looks like one of arguments has wrong size");
        n = ap.rows(x);
        m = ap.cols(x);
        k = ap.len(c);
        _core_lsfitcreatef( x,  y,  c,  n,  m,  k,  diffstep, out  state, 0x0);
    
        
    }
    
    public static void lsfitcreatef(double[,] x, double[] y, double[] c, double diffstep, out lsfitstate state, alglib.xparams _xparams)
    {
        int n;
        int m;
        int k;
        if( (ap.rows(x)!=ap.len(y)))
            throw new alglibexception("Error while calling 'lsfitcreatef': looks like one of arguments has wrong size");
        n = ap.rows(x);
        m = ap.cols(x);
        k = ap.len(c);
        _core_lsfitcreatef( x,  y,  c,  n,  m,  k,  diffstep, out  state, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_lsfitcreatewfg(double[,] x, double[] y, double[] w, double[] c, int n, int m, int k, bool cheapfg, out lsfitstate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_x = new x_matrix();
        x_vector _d_y = new x_vector();
        x_vector _d_w = new x_vector();
        x_vector _d_c = new x_vector();
        x_int _d_n = new x_int(n);
        x_int _d_m = new x_int(m);
        x_int _d_k = new x_int(k);
        byte _d_cheapfg = (byte)(cheapfg ? 1 : 0);
        void *_d_state = null;
        state = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y, _fp_w = w, _fp_c = c){
                x_matrix_attach_to_array(ref _d_x, _fp_x, ap.rows(x), ap.cols(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_vector_attach_to_array(ref _d_w, _fp_w, ap.len(w));
                x_vector_attach_to_array(ref _d_c, _fp_c, ap.len(c));
                _error_code = _i_xv2_lsfitcreatewfg(&_s_errormsg, &_d_x, &_d_y, &_d_w, &_d_c, &_d_n, &_d_m, &_d_k, &_d_cheapfg, &_d_state, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "lsfitcreatewfg");
            state = new lsfitstate(_d_state);
        }
        finally
        {
            x_matrix_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            x_vector_clear(ref _d_w);
            x_vector_clear(ref _d_c);
            if( _d_state!=null && state==null)
                _i_x_obj_free_lsfitstate(_d_state); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void lsfitcreatewfg(double[,] x, double[] y, double[] w, double[] c, int n, int m, int k, bool cheapfg, out lsfitstate state)
    {
        _core_lsfitcreatewfg( x,  y,  w,  c,  n,  m,  k,  cheapfg, out  state, 0x0);
    }
    
    public static void lsfitcreatewfg(double[,] x, double[] y, double[] w, double[] c, int n, int m, int k, bool cheapfg, out lsfitstate state, alglib.xparams _xparams)
    {
        _core_lsfitcreatewfg( x,  y,  w,  c,  n,  m,  k,  cheapfg, out  state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void lsfitcreatewfg(double[,] x, double[] y, double[] w, double[] c, bool cheapfg, out lsfitstate state)
    {
        int n;
        int m;
        int k;
        if( (ap.rows(x)!=ap.len(y)) || (ap.rows(x)!=ap.len(w)))
            throw new alglibexception("Error while calling 'lsfitcreatewfg': looks like one of arguments has wrong size");
        n = ap.rows(x);
        m = ap.cols(x);
        k = ap.len(c);
        _core_lsfitcreatewfg( x,  y,  w,  c,  n,  m,  k,  cheapfg, out  state, 0x0);
    
        
    }
    
    public static void lsfitcreatewfg(double[,] x, double[] y, double[] w, double[] c, bool cheapfg, out lsfitstate state, alglib.xparams _xparams)
    {
        int n;
        int m;
        int k;
        if( (ap.rows(x)!=ap.len(y)) || (ap.rows(x)!=ap.len(w)))
            throw new alglibexception("Error while calling 'lsfitcreatewfg': looks like one of arguments has wrong size");
        n = ap.rows(x);
        m = ap.cols(x);
        k = ap.len(c);
        _core_lsfitcreatewfg( x,  y,  w,  c,  n,  m,  k,  cheapfg, out  state, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_lsfitcreatefg(double[,] x, double[] y, double[] c, int n, int m, int k, bool cheapfg, out lsfitstate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_x = new x_matrix();
        x_vector _d_y = new x_vector();
        x_vector _d_c = new x_vector();
        x_int _d_n = new x_int(n);
        x_int _d_m = new x_int(m);
        x_int _d_k = new x_int(k);
        byte _d_cheapfg = (byte)(cheapfg ? 1 : 0);
        void *_d_state = null;
        state = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y, _fp_c = c){
                x_matrix_attach_to_array(ref _d_x, _fp_x, ap.rows(x), ap.cols(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_vector_attach_to_array(ref _d_c, _fp_c, ap.len(c));
                _error_code = _i_xv2_lsfitcreatefg(&_s_errormsg, &_d_x, &_d_y, &_d_c, &_d_n, &_d_m, &_d_k, &_d_cheapfg, &_d_state, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "lsfitcreatefg");
            state = new lsfitstate(_d_state);
        }
        finally
        {
            x_matrix_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            x_vector_clear(ref _d_c);
            if( _d_state!=null && state==null)
                _i_x_obj_free_lsfitstate(_d_state); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void lsfitcreatefg(double[,] x, double[] y, double[] c, int n, int m, int k, bool cheapfg, out lsfitstate state)
    {
        _core_lsfitcreatefg( x,  y,  c,  n,  m,  k,  cheapfg, out  state, 0x0);
    }
    
    public static void lsfitcreatefg(double[,] x, double[] y, double[] c, int n, int m, int k, bool cheapfg, out lsfitstate state, alglib.xparams _xparams)
    {
        _core_lsfitcreatefg( x,  y,  c,  n,  m,  k,  cheapfg, out  state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void lsfitcreatefg(double[,] x, double[] y, double[] c, bool cheapfg, out lsfitstate state)
    {
        int n;
        int m;
        int k;
        if( (ap.rows(x)!=ap.len(y)))
            throw new alglibexception("Error while calling 'lsfitcreatefg': looks like one of arguments has wrong size");
        n = ap.rows(x);
        m = ap.cols(x);
        k = ap.len(c);
        _core_lsfitcreatefg( x,  y,  c,  n,  m,  k,  cheapfg, out  state, 0x0);
    
        
    }
    
    public static void lsfitcreatefg(double[,] x, double[] y, double[] c, bool cheapfg, out lsfitstate state, alglib.xparams _xparams)
    {
        int n;
        int m;
        int k;
        if( (ap.rows(x)!=ap.len(y)))
            throw new alglibexception("Error while calling 'lsfitcreatefg': looks like one of arguments has wrong size");
        n = ap.rows(x);
        m = ap.cols(x);
        k = ap.len(c);
        _core_lsfitcreatefg( x,  y,  c,  n,  m,  k,  cheapfg, out  state, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_lsfitcreatewfgh(double[,] x, double[] y, double[] w, double[] c, int n, int m, int k, out lsfitstate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_x = new x_matrix();
        x_vector _d_y = new x_vector();
        x_vector _d_w = new x_vector();
        x_vector _d_c = new x_vector();
        x_int _d_n = new x_int(n);
        x_int _d_m = new x_int(m);
        x_int _d_k = new x_int(k);
        void *_d_state = null;
        state = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y, _fp_w = w, _fp_c = c){
                x_matrix_attach_to_array(ref _d_x, _fp_x, ap.rows(x), ap.cols(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_vector_attach_to_array(ref _d_w, _fp_w, ap.len(w));
                x_vector_attach_to_array(ref _d_c, _fp_c, ap.len(c));
                _error_code = _i_xv2_lsfitcreatewfgh(&_s_errormsg, &_d_x, &_d_y, &_d_w, &_d_c, &_d_n, &_d_m, &_d_k, &_d_state, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "lsfitcreatewfgh");
            state = new lsfitstate(_d_state);
        }
        finally
        {
            x_matrix_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            x_vector_clear(ref _d_w);
            x_vector_clear(ref _d_c);
            if( _d_state!=null && state==null)
                _i_x_obj_free_lsfitstate(_d_state); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void lsfitcreatewfgh(double[,] x, double[] y, double[] w, double[] c, int n, int m, int k, out lsfitstate state)
    {
        _core_lsfitcreatewfgh( x,  y,  w,  c,  n,  m,  k, out  state, 0x0);
    }
    
    public static void lsfitcreatewfgh(double[,] x, double[] y, double[] w, double[] c, int n, int m, int k, out lsfitstate state, alglib.xparams _xparams)
    {
        _core_lsfitcreatewfgh( x,  y,  w,  c,  n,  m,  k, out  state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void lsfitcreatewfgh(double[,] x, double[] y, double[] w, double[] c, out lsfitstate state)
    {
        int n;
        int m;
        int k;
        if( (ap.rows(x)!=ap.len(y)) || (ap.rows(x)!=ap.len(w)))
            throw new alglibexception("Error while calling 'lsfitcreatewfgh': looks like one of arguments has wrong size");
        n = ap.rows(x);
        m = ap.cols(x);
        k = ap.len(c);
        _core_lsfitcreatewfgh( x,  y,  w,  c,  n,  m,  k, out  state, 0x0);
    
        
    }
    
    public static void lsfitcreatewfgh(double[,] x, double[] y, double[] w, double[] c, out lsfitstate state, alglib.xparams _xparams)
    {
        int n;
        int m;
        int k;
        if( (ap.rows(x)!=ap.len(y)) || (ap.rows(x)!=ap.len(w)))
            throw new alglibexception("Error while calling 'lsfitcreatewfgh': looks like one of arguments has wrong size");
        n = ap.rows(x);
        m = ap.cols(x);
        k = ap.len(c);
        _core_lsfitcreatewfgh( x,  y,  w,  c,  n,  m,  k, out  state, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_lsfitcreatefgh(double[,] x, double[] y, double[] c, int n, int m, int k, out lsfitstate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_x = new x_matrix();
        x_vector _d_y = new x_vector();
        x_vector _d_c = new x_vector();
        x_int _d_n = new x_int(n);
        x_int _d_m = new x_int(m);
        x_int _d_k = new x_int(k);
        void *_d_state = null;
        state = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y, _fp_c = c){
                x_matrix_attach_to_array(ref _d_x, _fp_x, ap.rows(x), ap.cols(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_vector_attach_to_array(ref _d_c, _fp_c, ap.len(c));
                _error_code = _i_xv2_lsfitcreatefgh(&_s_errormsg, &_d_x, &_d_y, &_d_c, &_d_n, &_d_m, &_d_k, &_d_state, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "lsfitcreatefgh");
            state = new lsfitstate(_d_state);
        }
        finally
        {
            x_matrix_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            x_vector_clear(ref _d_c);
            if( _d_state!=null && state==null)
                _i_x_obj_free_lsfitstate(_d_state); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void lsfitcreatefgh(double[,] x, double[] y, double[] c, int n, int m, int k, out lsfitstate state)
    {
        _core_lsfitcreatefgh( x,  y,  c,  n,  m,  k, out  state, 0x0);
    }
    
    public static void lsfitcreatefgh(double[,] x, double[] y, double[] c, int n, int m, int k, out lsfitstate state, alglib.xparams _xparams)
    {
        _core_lsfitcreatefgh( x,  y,  c,  n,  m,  k, out  state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void lsfitcreatefgh(double[,] x, double[] y, double[] c, out lsfitstate state)
    {
        int n;
        int m;
        int k;
        if( (ap.rows(x)!=ap.len(y)))
            throw new alglibexception("Error while calling 'lsfitcreatefgh': looks like one of arguments has wrong size");
        n = ap.rows(x);
        m = ap.cols(x);
        k = ap.len(c);
        _core_lsfitcreatefgh( x,  y,  c,  n,  m,  k, out  state, 0x0);
    
        
    }
    
    public static void lsfitcreatefgh(double[,] x, double[] y, double[] c, out lsfitstate state, alglib.xparams _xparams)
    {
        int n;
        int m;
        int k;
        if( (ap.rows(x)!=ap.len(y)))
            throw new alglibexception("Error while calling 'lsfitcreatefgh': looks like one of arguments has wrong size");
        n = ap.rows(x);
        m = ap.cols(x);
        k = ap.len(c);
        _core_lsfitcreatefgh( x,  y,  c,  n,  m,  k, out  state, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_lsfitsetcond(lsfitstate state, double epsx, int maxits, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_epsx = epsx;
        x_int _d_maxits = new x_int(maxits);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_lsfitsetcond(&_s_errormsg, &_d_state, &_d_epsx, &_d_maxits, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "lsfitsetcond");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void lsfitsetcond(lsfitstate state, double epsx, int maxits)
    {
        _core_lsfitsetcond( state,  epsx,  maxits, 0x0);
    }
    
    public static void lsfitsetcond(lsfitstate state, double epsx, int maxits, alglib.xparams _xparams)
    {
        _core_lsfitsetcond( state,  epsx,  maxits, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_lsfitsetstpmax(lsfitstate state, double stpmax, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_stpmax = stpmax;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_lsfitsetstpmax(&_s_errormsg, &_d_state, &_d_stpmax, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "lsfitsetstpmax");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void lsfitsetstpmax(lsfitstate state, double stpmax)
    {
        _core_lsfitsetstpmax( state,  stpmax, 0x0);
    }
    
    public static void lsfitsetstpmax(lsfitstate state, double stpmax, alglib.xparams _xparams)
    {
        _core_lsfitsetstpmax( state,  stpmax, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_lsfitsetxrep(lsfitstate state, bool needxrep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        byte _d_needxrep = (byte)(needxrep ? 1 : 0);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_lsfitsetxrep(&_s_errormsg, &_d_state, &_d_needxrep, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "lsfitsetxrep");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void lsfitsetxrep(lsfitstate state, bool needxrep)
    {
        _core_lsfitsetxrep( state,  needxrep, 0x0);
    }
    
    public static void lsfitsetxrep(lsfitstate state, bool needxrep, alglib.xparams _xparams)
    {
        _core_lsfitsetxrep( state,  needxrep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_lsfitsetscale(lsfitstate state, double[] s, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_s = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_s = s){
                x_vector_attach_to_array(ref _d_s, _fp_s, ap.len(s));
                _error_code = _i_xv2_lsfitsetscale(&_s_errormsg, &_d_state, &_d_s, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "lsfitsetscale");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_s);
        }
        // This function returns no value.
    }
    
    public static void lsfitsetscale(lsfitstate state, double[] s)
    {
        _core_lsfitsetscale( state,  s, 0x0);
    }
    
    public static void lsfitsetscale(lsfitstate state, double[] s, alglib.xparams _xparams)
    {
        _core_lsfitsetscale( state,  s, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_lsfitsetbc(lsfitstate state, double[] bndl, double[] bndu, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_bndl = new x_vector();
        x_vector _d_bndu = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_bndl = bndl, _fp_bndu = bndu){
                x_vector_attach_to_array(ref _d_bndl, _fp_bndl, ap.len(bndl));
                x_vector_attach_to_array(ref _d_bndu, _fp_bndu, ap.len(bndu));
                _error_code = _i_xv2_lsfitsetbc(&_s_errormsg, &_d_state, &_d_bndl, &_d_bndu, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "lsfitsetbc");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_bndl);
            x_vector_clear(ref _d_bndu);
        }
        // This function returns no value.
    }
    
    public static void lsfitsetbc(lsfitstate state, double[] bndl, double[] bndu)
    {
        _core_lsfitsetbc( state,  bndl,  bndu, 0x0);
    }
    
    public static void lsfitsetbc(lsfitstate state, double[] bndl, double[] bndu, alglib.xparams _xparams)
    {
        _core_lsfitsetbc( state,  bndl,  bndu, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_lsfitsetlc(lsfitstate state, double[,] c, int[] ct, int k, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_matrix _d_c = new x_matrix();
        x_vector _d_ct = new x_vector();
        x_int _d_k = new x_int(k);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_c = c){
                x_matrix_attach_to_array(ref _d_c, _fp_c, ap.rows(c), ap.cols(c));
                x_vector_from_array(ref _d_ct, ct, X_CREATE);
                _error_code = _i_xv2_lsfitsetlc(&_s_errormsg, &_d_state, &_d_c, &_d_ct, &_d_k, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "lsfitsetlc");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_c);
            x_vector_clear(ref _d_ct);
        }
        // This function returns no value.
    }
    
    public static void lsfitsetlc(lsfitstate state, double[,] c, int[] ct, int k)
    {
        _core_lsfitsetlc( state,  c,  ct,  k, 0x0);
    }
    
    public static void lsfitsetlc(lsfitstate state, double[,] c, int[] ct, int k, alglib.xparams _xparams)
    {
        _core_lsfitsetlc( state,  c,  ct,  k, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void lsfitsetlc(lsfitstate state, double[,] c, int[] ct)
    {
        int k;
        if( (ap.rows(c)!=ap.len(ct)))
            throw new alglibexception("Error while calling 'lsfitsetlc': looks like one of arguments has wrong size");
        k = ap.rows(c);
        _core_lsfitsetlc( state,  c,  ct,  k, 0x0);
    
        
    }
    
    public static void lsfitsetlc(lsfitstate state, double[,] c, int[] ct, alglib.xparams _xparams)
    {
        int k;
        if( (ap.rows(c)!=ap.len(ct)))
            throw new alglibexception("Error while calling 'lsfitsetlc': looks like one of arguments has wrong size");
        k = ap.rows(c);
        _core_lsfitsetlc( state,  c,  ct,  k, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe bool _core_lsfititeration(lsfitstate state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        bool result;
        byte _d_result = (byte)0;
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_lsfititeration(&_s_errormsg, &_d_result, &_d_state, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "lsfititeration");
            result = _d_result!=0;
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static bool lsfititeration(lsfitstate state)
    {
        return _core_lsfititeration( state, 0x0);
    }
    
    public static bool lsfititeration(lsfitstate state, alglib.xparams _xparams)
    {
        return _core_lsfititeration( state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static unsafe void lsfitfit(lsfitstate state, ndimensional_pfunc func, ndimensional_rep rep, object obj)
    {
        lsfitfit(state, func, rep, obj, null);
    }
    
    public static unsafe void lsfitfit(lsfitstate state, ndimensional_pfunc func, ndimensional_rep rep, object obj, alglib.xparams _xparams)
    {
        byte *_s_errormsg = null;
        int _error_code = 0;
        byte _b_result = (byte)0;
        byte _xc_xupdated = 0;
        void *_state = state.ptr;
        IntPtr _pre_ptr;
        x_vector _xc_arg = new x_vector();
        double[] _cs_arg = null;
        x_vector _xc_par = new x_vector();
        double[] _cs_par = null;
        double _cs_f = 0;
        byte _xc_needf= 0;
    
        //
        // Check correctness of delegates
        //
        if( func==null )
            throw new alglibexception("ALGLIB: error in 'lsfitfit()' (func is null)");
    
        //
        // Attach x-structures to internal arrays
        //
        x_vector_create_empty(ref _xc_arg, DT_REAL);
        x_vector_create_empty(ref _xc_par, DT_REAL);
        _i_x_lsfitstate_get_c(_state, &_xc_arg);
        _i_x_lsfitstate_get_x(_state, &_xc_par);
        _cs_arg = new double[_xc_arg.cnt];
        _cs_par = new double[_xc_par.cnt];
    
        //
        // Main loop
        //
        for(;;)
        {
            //
            // Call iteration function.
            // Terminate iterations if it returned false.
            //
            _error_code = _i_xv2_lsfititeration(&_s_errormsg, &_b_result, &_state, _xparams==null ? 0x0 : _xparams.flags);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "lsfititeration");
            ap.assert(_state==state.ptr, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _b_result==0 )
                break;
            
            //
            // Reverse communication interface:
            // * fetch flags
            // * make delegate calls
            //
            _i_x_lsfitstate_get_xupdated(_state, &_xc_xupdated);
            _i_x_lsfitstate_get_needf(_state, &_xc_needf);
            x_vector_to_array(ref _xc_arg, ref _cs_arg);
            x_vector_to_array(ref _xc_par, ref _cs_par);
            if( _xc_needf!=0 )
            {
                func(_cs_arg, _cs_par, ref _cs_f, obj);
                _i_x_lsfitstate_set_f(_state, &_cs_f);
                continue;
            }
            if( _xc_xupdated!=0 )
            {
                if( rep!=null )
                {
                    double _local_f;
                    _i_x_lsfitstate_get_f(_state, &_local_f);
                    rep(_cs_arg, _local_f, obj);
                }
                continue;
            }
            throw new alglibexception("ALGLIB: error in 'lsfitfit' (some derivatives were not provided?)");
        }
        
        //
        // Integrity post-check:
        // * make sure that no reverse communication array was reallocated during optimization
        //
        _pre_ptr = _xc_arg.xptr.ptr;
        _i_x_lsfitstate_get_c(_state, &_xc_arg);
        alglib.ap.assert(_xc_arg.xptr.ptr==_pre_ptr, "ALGLIB: integrity check failed in lsfitfit()");
        _pre_ptr = _xc_par.xptr.ptr;
        _i_x_lsfitstate_get_x(_state, &_xc_par);
        alglib.ap.assert(_xc_par.xptr.ptr==_pre_ptr, "ALGLIB: integrity check failed in lsfitfit()");
    }
    
    public static unsafe void lsfitfit(lsfitstate state, ndimensional_pfunc func, ndimensional_pgrad grad, ndimensional_rep rep, object obj)
    {
        lsfitfit(state, func, grad, rep, obj, null);
    }
    
    public static unsafe void lsfitfit(lsfitstate state, ndimensional_pfunc func, ndimensional_pgrad grad, ndimensional_rep rep, object obj, alglib.xparams _xparams)
    {
        byte *_s_errormsg = null;
        int _error_code = 0;
        byte _b_result = (byte)0;
        byte _xc_xupdated = 0;
        void *_state = state.ptr;
        IntPtr _pre_ptr;
        x_vector _xc_arg = new x_vector();
        double[] _cs_arg = null;
        x_vector _xc_par = new x_vector();
        double[] _cs_par = null;
        double _cs_f = 0;
        x_vector _xc_g = new x_vector();
        double[] _cs_g = null;
        byte _xc_needf= 0;
        byte _xc_needfg= 0;
    
        //
        // Check correctness of delegates
        //
        if( func==null )
            throw new alglibexception("ALGLIB: error in 'lsfitfit()' (func is null)");
        if( grad==null )
            throw new alglibexception("ALGLIB: error in 'lsfitfit()' (grad is null)");
    
        //
        // Attach x-structures to internal arrays
        //
        x_vector_create_empty(ref _xc_arg, DT_REAL);
        x_vector_create_empty(ref _xc_par, DT_REAL);
        x_vector_create_empty(ref _xc_g, DT_REAL);
        _i_x_lsfitstate_get_c(_state, &_xc_arg);
        _i_x_lsfitstate_get_x(_state, &_xc_par);
        _i_x_lsfitstate_get_g(_state, &_xc_g);
        _cs_arg = new double[_xc_arg.cnt];
        _cs_par = new double[_xc_par.cnt];
        _cs_g = new double[_xc_g.cnt];
    
        //
        // Main loop
        //
        for(;;)
        {
            //
            // Call iteration function.
            // Terminate iterations if it returned false.
            //
            _error_code = _i_xv2_lsfititeration(&_s_errormsg, &_b_result, &_state, _xparams==null ? 0x0 : _xparams.flags);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "lsfititeration");
            ap.assert(_state==state.ptr, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _b_result==0 )
                break;
            
            //
            // Reverse communication interface:
            // * fetch flags
            // * make delegate calls
            //
            _i_x_lsfitstate_get_xupdated(_state, &_xc_xupdated);
            _i_x_lsfitstate_get_needf(_state, &_xc_needf);
            _i_x_lsfitstate_get_needfg(_state, &_xc_needfg);
            x_vector_to_array(ref _xc_arg, ref _cs_arg);
            x_vector_to_array(ref _xc_par, ref _cs_par);
            if( _xc_needf!=0 )
            {
                func(_cs_arg, _cs_par, ref _cs_f, obj);
                _i_x_lsfitstate_set_f(_state, &_cs_f);
                continue;
            }
            if( _xc_needfg!=0 )
            {
                grad(_cs_arg, _cs_par, ref _cs_f, _cs_g, obj);
                _i_x_lsfitstate_set_f(_state, &_cs_f);
                x_vector_from_array(ref _xc_g, _cs_g, X_REWRITE);
                continue;
            }
            if( _xc_xupdated!=0 )
            {
                if( rep!=null )
                {
                    double _local_f;
                    _i_x_lsfitstate_get_f(_state, &_local_f);
                    rep(_cs_arg, _local_f, obj);
                }
                continue;
            }
            throw new alglibexception("ALGLIB: error in 'lsfitfit' (some derivatives were not provided?)");
        }
        
        //
        // Integrity post-check:
        // * make sure that no reverse communication array was reallocated during optimization
        //
        _pre_ptr = _xc_arg.xptr.ptr;
        _i_x_lsfitstate_get_c(_state, &_xc_arg);
        alglib.ap.assert(_xc_arg.xptr.ptr==_pre_ptr, "ALGLIB: integrity check failed in lsfitfit()");
        _pre_ptr = _xc_par.xptr.ptr;
        _i_x_lsfitstate_get_x(_state, &_xc_par);
        alglib.ap.assert(_xc_par.xptr.ptr==_pre_ptr, "ALGLIB: integrity check failed in lsfitfit()");
        _pre_ptr = _xc_g.xptr.ptr;
        _i_x_lsfitstate_get_g(_state, &_xc_g);
        alglib.ap.assert(_xc_g.xptr.ptr==_pre_ptr, "ALGLIB: integrity check failed in lsfitfit()");
    }
    
    public static unsafe void lsfitfit(lsfitstate state, ndimensional_pfunc func, ndimensional_pgrad grad, ndimensional_phess hess, ndimensional_rep rep, object obj)
    {
        lsfitfit(state, func, grad, hess, rep, obj, null);
    }
    
    public static unsafe void lsfitfit(lsfitstate state, ndimensional_pfunc func, ndimensional_pgrad grad, ndimensional_phess hess, ndimensional_rep rep, object obj, alglib.xparams _xparams)
    {
        byte *_s_errormsg = null;
        int _error_code = 0;
        byte _b_result = (byte)0;
        byte _xc_xupdated = 0;
        void *_state = state.ptr;
        IntPtr _pre_ptr;
        x_vector _xc_arg = new x_vector();
        double[] _cs_arg = null;
        x_vector _xc_par = new x_vector();
        double[] _cs_par = null;
        double _cs_f = 0;
        x_vector _xc_g = new x_vector();
        double[] _cs_g = null;
        x_matrix _xc_h = new x_matrix();
        double[,] _cs_h = null;
        byte _xc_needf= 0;
        byte _xc_needfg= 0;
        byte _xc_needfgh= 0;
    
        //
        // Check correctness of delegates
        //
        if( func==null )
            throw new alglibexception("ALGLIB: error in 'lsfitfit()' (func is null)");
        if( grad==null )
            throw new alglibexception("ALGLIB: error in 'lsfitfit()' (grad is null)");
        if( hess==null )
            throw new alglibexception("ALGLIB: error in 'lsfitfit()' (hess is null)");
    
        //
        // Attach x-structures to internal arrays
        //
        x_vector_create_empty(ref _xc_arg, DT_REAL);
        x_vector_create_empty(ref _xc_par, DT_REAL);
        x_vector_create_empty(ref _xc_g, DT_REAL);
        x_matrix_create_empty(ref _xc_h, DT_REAL);
        _i_x_lsfitstate_get_c(_state, &_xc_arg);
        _i_x_lsfitstate_get_x(_state, &_xc_par);
        _i_x_lsfitstate_get_g(_state, &_xc_g);
        _i_x_lsfitstate_get_h(_state, &_xc_h);
        _cs_arg = new double[_xc_arg.cnt];
        _cs_par = new double[_xc_par.cnt];
        _cs_g = new double[_xc_g.cnt];
        _cs_h = new double[_xc_h.rows,_xc_h.cols];
    
        //
        // Main loop
        //
        for(;;)
        {
            //
            // Call iteration function.
            // Terminate iterations if it returned false.
            //
            _error_code = _i_xv2_lsfititeration(&_s_errormsg, &_b_result, &_state, _xparams==null ? 0x0 : _xparams.flags);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "lsfititeration");
            ap.assert(_state==state.ptr, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _b_result==0 )
                break;
            
            //
            // Reverse communication interface:
            // * fetch flags
            // * make delegate calls
            //
            _i_x_lsfitstate_get_xupdated(_state, &_xc_xupdated);
            _i_x_lsfitstate_get_needf(_state, &_xc_needf);
            _i_x_lsfitstate_get_needfg(_state, &_xc_needfg);
            _i_x_lsfitstate_get_needfgh(_state, &_xc_needfgh);
            x_vector_to_array(ref _xc_arg, ref _cs_arg);
            x_vector_to_array(ref _xc_par, ref _cs_par);
            if( _xc_needf!=0 )
            {
                func(_cs_arg, _cs_par, ref _cs_f, obj);
                _i_x_lsfitstate_set_f(_state, &_cs_f);
                continue;
            }
            if( _xc_needfg!=0 )
            {
                grad(_cs_arg, _cs_par, ref _cs_f, _cs_g, obj);
                _i_x_lsfitstate_set_f(_state, &_cs_f);
                x_vector_from_array(ref _xc_g, _cs_g, X_REWRITE);
                continue;
            }
            if( _xc_needfgh!=0 )
            {
                hess(_cs_arg, _cs_par, ref _cs_f, _cs_g, _cs_h, obj);
                _i_x_lsfitstate_set_f(_state, &_cs_f);
                x_vector_from_array(ref _xc_g, _cs_g, X_REWRITE);
                x_matrix_from_array(ref _xc_h, _cs_h, X_REWRITE);
                continue;
            }
            if( _xc_xupdated!=0 )
            {
                if( rep!=null )
                {
                    double _local_f;
                    _i_x_lsfitstate_get_f(_state, &_local_f);
                    rep(_cs_arg, _local_f, obj);
                }
                continue;
            }
            throw new alglibexception("ALGLIB: error in 'lsfitfit' (some derivatives were not provided?)");
        }
        
        //
        // Integrity post-check:
        // * make sure that no reverse communication array was reallocated during optimization
        //
        _pre_ptr = _xc_arg.xptr.ptr;
        _i_x_lsfitstate_get_c(_state, &_xc_arg);
        alglib.ap.assert(_xc_arg.xptr.ptr==_pre_ptr, "ALGLIB: integrity check failed in lsfitfit()");
        _pre_ptr = _xc_par.xptr.ptr;
        _i_x_lsfitstate_get_x(_state, &_xc_par);
        alglib.ap.assert(_xc_par.xptr.ptr==_pre_ptr, "ALGLIB: integrity check failed in lsfitfit()");
        _pre_ptr = _xc_g.xptr.ptr;
        _i_x_lsfitstate_get_g(_state, &_xc_g);
        alglib.ap.assert(_xc_g.xptr.ptr==_pre_ptr, "ALGLIB: integrity check failed in lsfitfit()");
        _pre_ptr = _xc_h.xptr.ptr;
        _i_x_lsfitstate_get_h(_state, &_xc_h);
        alglib.ap.assert(_xc_h.xptr.ptr==_pre_ptr, "ALGLIB: integrity check failed in lsfitfit()");
    }
    
    private static unsafe void _core_lsfitresults(lsfitstate state, out int info, out double[] c, out lsfitreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_int _d_info = new x_int();
        x_vector _d_c = new x_vector();
        x_lsfitreport _d_rep = new x_lsfitreport();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_c, DT_REAL);
            c = null;
            x_lsfitreport_init(ref _d_rep);
            _error_code = _i_xv2_lsfitresults(&_s_errormsg, &_d_state, &_d_info, &_d_c, &_d_rep, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "lsfitresults");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            info = _d_info.intval;
            if( _d_c.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_c, ref c);
            if( c == null )
                c = new double[0];
            rep = null;
            x_lsfitreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_c);
            x_lsfitreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void lsfitresults(lsfitstate state, out int info, out double[] c, out lsfitreport rep)
    {
        _core_lsfitresults( state, out  info, out  c, out  rep, 0x0);
    }
    
    public static void lsfitresults(lsfitstate state, out int info, out double[] c, out lsfitreport rep, alglib.xparams _xparams)
    {
        _core_lsfitresults( state, out  info, out  c, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_lsfitsetgradientcheck(lsfitstate state, double teststep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_teststep = teststep;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_lsfitsetgradientcheck(&_s_errormsg, &_d_state, &_d_teststep, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "lsfitsetgradientcheck");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void lsfitsetgradientcheck(lsfitstate state, double teststep)
    {
        _core_lsfitsetgradientcheck( state,  teststep, 0x0);
    }
    
    public static void lsfitsetgradientcheck(lsfitstate state, double teststep, alglib.xparams _xparams)
    {
        _core_lsfitsetgradientcheck( state,  teststep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage fitsphere
    //
    
    
    private static unsafe void _core_fitspherels(double[,] xy, int npoints, int nx, out double[] cx, out double r, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        x_int _d_nx = new x_int(nx);
        x_vector _d_cx = new x_vector();
        double _d_r = 0;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                x_vector_create_empty(ref _d_cx, DT_REAL);
                cx = null;
                _error_code = _i_xv2_fitspherels(&_s_errormsg, &_d_xy, &_d_npoints, &_d_nx, &_d_cx, &_d_r, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "fitspherels");
            if( _d_cx.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_cx, ref cx);
            if( cx == null )
                cx = new double[0];
            r = _d_r;
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
            x_vector_clear(ref _d_cx);
        }
        // This function returns no value.
    }
    
    public static void fitspherels(double[,] xy, int npoints, int nx, out double[] cx, out double r)
    {
        _core_fitspherels( xy,  npoints,  nx, out  cx, out  r, 0x0);
    }
    
    public static void fitspherels(double[,] xy, int npoints, int nx, out double[] cx, out double r, alglib.xparams _xparams)
    {
        _core_fitspherels( xy,  npoints,  nx, out  cx, out  r, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_fitspheremc(double[,] xy, int npoints, int nx, out double[] cx, out double rhi, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        x_int _d_nx = new x_int(nx);
        x_vector _d_cx = new x_vector();
        double _d_rhi = 0;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                x_vector_create_empty(ref _d_cx, DT_REAL);
                cx = null;
                _error_code = _i_xv2_fitspheremc(&_s_errormsg, &_d_xy, &_d_npoints, &_d_nx, &_d_cx, &_d_rhi, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "fitspheremc");
            if( _d_cx.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_cx, ref cx);
            if( cx == null )
                cx = new double[0];
            rhi = _d_rhi;
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
            x_vector_clear(ref _d_cx);
        }
        // This function returns no value.
    }
    
    public static void fitspheremc(double[,] xy, int npoints, int nx, out double[] cx, out double rhi)
    {
        _core_fitspheremc( xy,  npoints,  nx, out  cx, out  rhi, 0x0);
    }
    
    public static void fitspheremc(double[,] xy, int npoints, int nx, out double[] cx, out double rhi, alglib.xparams _xparams)
    {
        _core_fitspheremc( xy,  npoints,  nx, out  cx, out  rhi, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_fitspheremi(double[,] xy, int npoints, int nx, out double[] cx, out double rlo, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        x_int _d_nx = new x_int(nx);
        x_vector _d_cx = new x_vector();
        double _d_rlo = 0;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                x_vector_create_empty(ref _d_cx, DT_REAL);
                cx = null;
                _error_code = _i_xv2_fitspheremi(&_s_errormsg, &_d_xy, &_d_npoints, &_d_nx, &_d_cx, &_d_rlo, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "fitspheremi");
            if( _d_cx.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_cx, ref cx);
            if( cx == null )
                cx = new double[0];
            rlo = _d_rlo;
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
            x_vector_clear(ref _d_cx);
        }
        // This function returns no value.
    }
    
    public static void fitspheremi(double[,] xy, int npoints, int nx, out double[] cx, out double rlo)
    {
        _core_fitspheremi( xy,  npoints,  nx, out  cx, out  rlo, 0x0);
    }
    
    public static void fitspheremi(double[,] xy, int npoints, int nx, out double[] cx, out double rlo, alglib.xparams _xparams)
    {
        _core_fitspheremi( xy,  npoints,  nx, out  cx, out  rlo, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_fitspheremz(double[,] xy, int npoints, int nx, out double[] cx, out double rlo, out double rhi, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        x_int _d_nx = new x_int(nx);
        x_vector _d_cx = new x_vector();
        double _d_rlo = 0;
        double _d_rhi = 0;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                x_vector_create_empty(ref _d_cx, DT_REAL);
                cx = null;
                _error_code = _i_xv2_fitspheremz(&_s_errormsg, &_d_xy, &_d_npoints, &_d_nx, &_d_cx, &_d_rlo, &_d_rhi, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "fitspheremz");
            if( _d_cx.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_cx, ref cx);
            if( cx == null )
                cx = new double[0];
            rlo = _d_rlo;
            rhi = _d_rhi;
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
            x_vector_clear(ref _d_cx);
        }
        // This function returns no value.
    }
    
    public static void fitspheremz(double[,] xy, int npoints, int nx, out double[] cx, out double rlo, out double rhi)
    {
        _core_fitspheremz( xy,  npoints,  nx, out  cx, out  rlo, out  rhi, 0x0);
    }
    
    public static void fitspheremz(double[,] xy, int npoints, int nx, out double[] cx, out double rlo, out double rhi, alglib.xparams _xparams)
    {
        _core_fitspheremz( xy,  npoints,  nx, out  cx, out  rlo, out  rhi, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_fitspherex(double[,] xy, int npoints, int nx, int problemtype, double epsx, int aulits, double penalty, out double[] cx, out double rlo, out double rhi, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        x_int _d_nx = new x_int(nx);
        x_int _d_problemtype = new x_int(problemtype);
        double _d_epsx = epsx;
        x_int _d_aulits = new x_int(aulits);
        double _d_penalty = penalty;
        x_vector _d_cx = new x_vector();
        double _d_rlo = 0;
        double _d_rhi = 0;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                x_vector_create_empty(ref _d_cx, DT_REAL);
                cx = null;
                _error_code = _i_xv2_fitspherex(&_s_errormsg, &_d_xy, &_d_npoints, &_d_nx, &_d_problemtype, &_d_epsx, &_d_aulits, &_d_penalty, &_d_cx, &_d_rlo, &_d_rhi, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "fitspherex");
            if( _d_cx.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_cx, ref cx);
            if( cx == null )
                cx = new double[0];
            rlo = _d_rlo;
            rhi = _d_rhi;
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
            x_vector_clear(ref _d_cx);
        }
        // This function returns no value.
    }
    
    public static void fitspherex(double[,] xy, int npoints, int nx, int problemtype, double epsx, int aulits, double penalty, out double[] cx, out double rlo, out double rhi)
    {
        _core_fitspherex( xy,  npoints,  nx,  problemtype,  epsx,  aulits,  penalty, out  cx, out  rlo, out  rhi, 0x0);
    }
    
    public static void fitspherex(double[,] xy, int npoints, int nx, int problemtype, double epsx, int aulits, double penalty, out double[] cx, out double rlo, out double rhi, alglib.xparams _xparams)
    {
        _core_fitspherex( xy,  npoints,  nx,  problemtype,  epsx,  aulits,  penalty, out  cx, out  rlo, out  rhi, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage parametric
    //
    

    public unsafe class pspline2interpolant : alglibobject
    {
        private void *_ptr;
        public pspline2interpolant(void *x)
        {
            _ptr = x;
        }
        ~pspline2interpolant()
        {
            _deallocate();
        }
        public void* ptr { get { return _ptr; } }
        public override alglib.alglibobject make_copy()
        {
            if( _ptr==null )
                return new pspline2interpolant(null);
            return new pspline2interpolant(_i_x_obj_copy_pspline2interpolant(_ptr));
        }
        public override void _deallocate()
        {
            if( _ptr!=null )
                _i_x_obj_free_pspline2interpolant(_ptr);
            _ptr = null;
            System.GC.SuppressFinalize(this);
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_pspline2interpolant(void *x);
    private static _d_x_obj_copy_pspline2interpolant _i_x_obj_copy_pspline2interpolant = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_obj_free_pspline2interpolant(void *x);
    private static _d_x_obj_free_pspline2interpolant _i_x_obj_free_pspline2interpolant = null;

    public unsafe class pspline3interpolant : alglibobject
    {
        private void *_ptr;
        public pspline3interpolant(void *x)
        {
            _ptr = x;
        }
        ~pspline3interpolant()
        {
            _deallocate();
        }
        public void* ptr { get { return _ptr; } }
        public override alglib.alglibobject make_copy()
        {
            if( _ptr==null )
                return new pspline3interpolant(null);
            return new pspline3interpolant(_i_x_obj_copy_pspline3interpolant(_ptr));
        }
        public override void _deallocate()
        {
            if( _ptr!=null )
                _i_x_obj_free_pspline3interpolant(_ptr);
            _ptr = null;
            System.GC.SuppressFinalize(this);
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_pspline3interpolant(void *x);
    private static _d_x_obj_copy_pspline3interpolant _i_x_obj_copy_pspline3interpolant = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_obj_free_pspline3interpolant(void *x);
    private static _d_x_obj_free_pspline3interpolant _i_x_obj_free_pspline3interpolant = null;
    
    private static unsafe void _core_pspline2build(double[,] xy, int n, int st, int pt, out pspline2interpolant p, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_xy = new x_matrix();
        x_int _d_n = new x_int(n);
        x_int _d_st = new x_int(st);
        x_int _d_pt = new x_int(pt);
        void *_d_p = null;
        p = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_xv2_pspline2build(&_s_errormsg, &_d_xy, &_d_n, &_d_st, &_d_pt, &_d_p, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "pspline2build");
            p = new pspline2interpolant(_d_p);
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
            if( _d_p!=null && p==null)
                _i_x_obj_free_pspline2interpolant(_d_p); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void pspline2build(double[,] xy, int n, int st, int pt, out pspline2interpolant p)
    {
        _core_pspline2build( xy,  n,  st,  pt, out  p, 0x0);
    }
    
    public static void pspline2build(double[,] xy, int n, int st, int pt, out pspline2interpolant p, alglib.xparams _xparams)
    {
        _core_pspline2build( xy,  n,  st,  pt, out  p, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_pspline3build(double[,] xy, int n, int st, int pt, out pspline3interpolant p, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_xy = new x_matrix();
        x_int _d_n = new x_int(n);
        x_int _d_st = new x_int(st);
        x_int _d_pt = new x_int(pt);
        void *_d_p = null;
        p = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_xv2_pspline3build(&_s_errormsg, &_d_xy, &_d_n, &_d_st, &_d_pt, &_d_p, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "pspline3build");
            p = new pspline3interpolant(_d_p);
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
            if( _d_p!=null && p==null)
                _i_x_obj_free_pspline3interpolant(_d_p); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void pspline3build(double[,] xy, int n, int st, int pt, out pspline3interpolant p)
    {
        _core_pspline3build( xy,  n,  st,  pt, out  p, 0x0);
    }
    
    public static void pspline3build(double[,] xy, int n, int st, int pt, out pspline3interpolant p, alglib.xparams _xparams)
    {
        _core_pspline3build( xy,  n,  st,  pt, out  p, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_pspline2buildperiodic(double[,] xy, int n, int st, int pt, out pspline2interpolant p, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_xy = new x_matrix();
        x_int _d_n = new x_int(n);
        x_int _d_st = new x_int(st);
        x_int _d_pt = new x_int(pt);
        void *_d_p = null;
        p = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_xv2_pspline2buildperiodic(&_s_errormsg, &_d_xy, &_d_n, &_d_st, &_d_pt, &_d_p, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "pspline2buildperiodic");
            p = new pspline2interpolant(_d_p);
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
            if( _d_p!=null && p==null)
                _i_x_obj_free_pspline2interpolant(_d_p); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void pspline2buildperiodic(double[,] xy, int n, int st, int pt, out pspline2interpolant p)
    {
        _core_pspline2buildperiodic( xy,  n,  st,  pt, out  p, 0x0);
    }
    
    public static void pspline2buildperiodic(double[,] xy, int n, int st, int pt, out pspline2interpolant p, alglib.xparams _xparams)
    {
        _core_pspline2buildperiodic( xy,  n,  st,  pt, out  p, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_pspline3buildperiodic(double[,] xy, int n, int st, int pt, out pspline3interpolant p, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_xy = new x_matrix();
        x_int _d_n = new x_int(n);
        x_int _d_st = new x_int(st);
        x_int _d_pt = new x_int(pt);
        void *_d_p = null;
        p = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_xv2_pspline3buildperiodic(&_s_errormsg, &_d_xy, &_d_n, &_d_st, &_d_pt, &_d_p, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "pspline3buildperiodic");
            p = new pspline3interpolant(_d_p);
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
            if( _d_p!=null && p==null)
                _i_x_obj_free_pspline3interpolant(_d_p); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void pspline3buildperiodic(double[,] xy, int n, int st, int pt, out pspline3interpolant p)
    {
        _core_pspline3buildperiodic( xy,  n,  st,  pt, out  p, 0x0);
    }
    
    public static void pspline3buildperiodic(double[,] xy, int n, int st, int pt, out pspline3interpolant p, alglib.xparams _xparams)
    {
        _core_pspline3buildperiodic( xy,  n,  st,  pt, out  p, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_pspline2parametervalues(pspline2interpolant p, out int n, out double[] t, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_p = p.ptr;
        x_int _d_n = new x_int();
        x_vector _d_t = new x_vector();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_t, DT_REAL);
            t = null;
            _error_code = _i_xv2_pspline2parametervalues(&_s_errormsg, &_d_p, &_d_n, &_d_t, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "pspline2parametervalues");
            ap.assert(p.ptr==_d_p, "ALGLIB: internal error (reference changed for non-out X-object)");
            n = _d_n.intval;
            if( _d_t.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_t, ref t);
            if( t == null )
                t = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_t);
        }
        // This function returns no value.
    }
    
    public static void pspline2parametervalues(pspline2interpolant p, out int n, out double[] t)
    {
        _core_pspline2parametervalues( p, out  n, out  t, 0x0);
    }
    
    public static void pspline2parametervalues(pspline2interpolant p, out int n, out double[] t, alglib.xparams _xparams)
    {
        _core_pspline2parametervalues( p, out  n, out  t, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_pspline3parametervalues(pspline3interpolant p, out int n, out double[] t, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_p = p.ptr;
        x_int _d_n = new x_int();
        x_vector _d_t = new x_vector();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_t, DT_REAL);
            t = null;
            _error_code = _i_xv2_pspline3parametervalues(&_s_errormsg, &_d_p, &_d_n, &_d_t, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "pspline3parametervalues");
            ap.assert(p.ptr==_d_p, "ALGLIB: internal error (reference changed for non-out X-object)");
            n = _d_n.intval;
            if( _d_t.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_t, ref t);
            if( t == null )
                t = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_t);
        }
        // This function returns no value.
    }
    
    public static void pspline3parametervalues(pspline3interpolant p, out int n, out double[] t)
    {
        _core_pspline3parametervalues( p, out  n, out  t, 0x0);
    }
    
    public static void pspline3parametervalues(pspline3interpolant p, out int n, out double[] t, alglib.xparams _xparams)
    {
        _core_pspline3parametervalues( p, out  n, out  t, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_pspline2calc(pspline2interpolant p, double t, out double x, out double y, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_p = p.ptr;
        double _d_t = t;
        double _d_x = 0;
        double _d_y = 0;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_pspline2calc(&_s_errormsg, &_d_p, &_d_t, &_d_x, &_d_y, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "pspline2calc");
            ap.assert(p.ptr==_d_p, "ALGLIB: internal error (reference changed for non-out X-object)");
            x = _d_x;
            y = _d_y;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void pspline2calc(pspline2interpolant p, double t, out double x, out double y)
    {
        _core_pspline2calc( p,  t, out  x, out  y, 0x0);
    }
    
    public static void pspline2calc(pspline2interpolant p, double t, out double x, out double y, alglib.xparams _xparams)
    {
        _core_pspline2calc( p,  t, out  x, out  y, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_pspline3calc(pspline3interpolant p, double t, out double x, out double y, out double z, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_p = p.ptr;
        double _d_t = t;
        double _d_x = 0;
        double _d_y = 0;
        double _d_z = 0;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_pspline3calc(&_s_errormsg, &_d_p, &_d_t, &_d_x, &_d_y, &_d_z, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "pspline3calc");
            ap.assert(p.ptr==_d_p, "ALGLIB: internal error (reference changed for non-out X-object)");
            x = _d_x;
            y = _d_y;
            z = _d_z;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void pspline3calc(pspline3interpolant p, double t, out double x, out double y, out double z)
    {
        _core_pspline3calc( p,  t, out  x, out  y, out  z, 0x0);
    }
    
    public static void pspline3calc(pspline3interpolant p, double t, out double x, out double y, out double z, alglib.xparams _xparams)
    {
        _core_pspline3calc( p,  t, out  x, out  y, out  z, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_pspline2tangent(pspline2interpolant p, double t, out double x, out double y, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_p = p.ptr;
        double _d_t = t;
        double _d_x = 0;
        double _d_y = 0;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_pspline2tangent(&_s_errormsg, &_d_p, &_d_t, &_d_x, &_d_y, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "pspline2tangent");
            ap.assert(p.ptr==_d_p, "ALGLIB: internal error (reference changed for non-out X-object)");
            x = _d_x;
            y = _d_y;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void pspline2tangent(pspline2interpolant p, double t, out double x, out double y)
    {
        _core_pspline2tangent( p,  t, out  x, out  y, 0x0);
    }
    
    public static void pspline2tangent(pspline2interpolant p, double t, out double x, out double y, alglib.xparams _xparams)
    {
        _core_pspline2tangent( p,  t, out  x, out  y, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_pspline3tangent(pspline3interpolant p, double t, out double x, out double y, out double z, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_p = p.ptr;
        double _d_t = t;
        double _d_x = 0;
        double _d_y = 0;
        double _d_z = 0;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_pspline3tangent(&_s_errormsg, &_d_p, &_d_t, &_d_x, &_d_y, &_d_z, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "pspline3tangent");
            ap.assert(p.ptr==_d_p, "ALGLIB: internal error (reference changed for non-out X-object)");
            x = _d_x;
            y = _d_y;
            z = _d_z;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void pspline3tangent(pspline3interpolant p, double t, out double x, out double y, out double z)
    {
        _core_pspline3tangent( p,  t, out  x, out  y, out  z, 0x0);
    }
    
    public static void pspline3tangent(pspline3interpolant p, double t, out double x, out double y, out double z, alglib.xparams _xparams)
    {
        _core_pspline3tangent( p,  t, out  x, out  y, out  z, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_pspline2diff(pspline2interpolant p, double t, out double x, out double dx, out double y, out double dy, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_p = p.ptr;
        double _d_t = t;
        double _d_x = 0;
        double _d_dx = 0;
        double _d_y = 0;
        double _d_dy = 0;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_pspline2diff(&_s_errormsg, &_d_p, &_d_t, &_d_x, &_d_dx, &_d_y, &_d_dy, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "pspline2diff");
            ap.assert(p.ptr==_d_p, "ALGLIB: internal error (reference changed for non-out X-object)");
            x = _d_x;
            dx = _d_dx;
            y = _d_y;
            dy = _d_dy;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void pspline2diff(pspline2interpolant p, double t, out double x, out double dx, out double y, out double dy)
    {
        _core_pspline2diff( p,  t, out  x, out  dx, out  y, out  dy, 0x0);
    }
    
    public static void pspline2diff(pspline2interpolant p, double t, out double x, out double dx, out double y, out double dy, alglib.xparams _xparams)
    {
        _core_pspline2diff( p,  t, out  x, out  dx, out  y, out  dy, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_pspline3diff(pspline3interpolant p, double t, out double x, out double dx, out double y, out double dy, out double z, out double dz, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_p = p.ptr;
        double _d_t = t;
        double _d_x = 0;
        double _d_dx = 0;
        double _d_y = 0;
        double _d_dy = 0;
        double _d_z = 0;
        double _d_dz = 0;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_pspline3diff(&_s_errormsg, &_d_p, &_d_t, &_d_x, &_d_dx, &_d_y, &_d_dy, &_d_z, &_d_dz, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "pspline3diff");
            ap.assert(p.ptr==_d_p, "ALGLIB: internal error (reference changed for non-out X-object)");
            x = _d_x;
            dx = _d_dx;
            y = _d_y;
            dy = _d_dy;
            z = _d_z;
            dz = _d_dz;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void pspline3diff(pspline3interpolant p, double t, out double x, out double dx, out double y, out double dy, out double z, out double dz)
    {
        _core_pspline3diff( p,  t, out  x, out  dx, out  y, out  dy, out  z, out  dz, 0x0);
    }
    
    public static void pspline3diff(pspline3interpolant p, double t, out double x, out double dx, out double y, out double dy, out double z, out double dz, alglib.xparams _xparams)
    {
        _core_pspline3diff( p,  t, out  x, out  dx, out  y, out  dy, out  z, out  dz, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_pspline2diff2(pspline2interpolant p, double t, out double x, out double dx, out double d2x, out double y, out double dy, out double d2y, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_p = p.ptr;
        double _d_t = t;
        double _d_x = 0;
        double _d_dx = 0;
        double _d_d2x = 0;
        double _d_y = 0;
        double _d_dy = 0;
        double _d_d2y = 0;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_pspline2diff2(&_s_errormsg, &_d_p, &_d_t, &_d_x, &_d_dx, &_d_d2x, &_d_y, &_d_dy, &_d_d2y, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "pspline2diff2");
            ap.assert(p.ptr==_d_p, "ALGLIB: internal error (reference changed for non-out X-object)");
            x = _d_x;
            dx = _d_dx;
            d2x = _d_d2x;
            y = _d_y;
            dy = _d_dy;
            d2y = _d_d2y;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void pspline2diff2(pspline2interpolant p, double t, out double x, out double dx, out double d2x, out double y, out double dy, out double d2y)
    {
        _core_pspline2diff2( p,  t, out  x, out  dx, out  d2x, out  y, out  dy, out  d2y, 0x0);
    }
    
    public static void pspline2diff2(pspline2interpolant p, double t, out double x, out double dx, out double d2x, out double y, out double dy, out double d2y, alglib.xparams _xparams)
    {
        _core_pspline2diff2( p,  t, out  x, out  dx, out  d2x, out  y, out  dy, out  d2y, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_pspline3diff2(pspline3interpolant p, double t, out double x, out double dx, out double d2x, out double y, out double dy, out double d2y, out double z, out double dz, out double d2z, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_p = p.ptr;
        double _d_t = t;
        double _d_x = 0;
        double _d_dx = 0;
        double _d_d2x = 0;
        double _d_y = 0;
        double _d_dy = 0;
        double _d_d2y = 0;
        double _d_z = 0;
        double _d_dz = 0;
        double _d_d2z = 0;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_pspline3diff2(&_s_errormsg, &_d_p, &_d_t, &_d_x, &_d_dx, &_d_d2x, &_d_y, &_d_dy, &_d_d2y, &_d_z, &_d_dz, &_d_d2z, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "pspline3diff2");
            ap.assert(p.ptr==_d_p, "ALGLIB: internal error (reference changed for non-out X-object)");
            x = _d_x;
            dx = _d_dx;
            d2x = _d_d2x;
            y = _d_y;
            dy = _d_dy;
            d2y = _d_d2y;
            z = _d_z;
            dz = _d_dz;
            d2z = _d_d2z;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void pspline3diff2(pspline3interpolant p, double t, out double x, out double dx, out double d2x, out double y, out double dy, out double d2y, out double z, out double dz, out double d2z)
    {
        _core_pspline3diff2( p,  t, out  x, out  dx, out  d2x, out  y, out  dy, out  d2y, out  z, out  dz, out  d2z, 0x0);
    }
    
    public static void pspline3diff2(pspline3interpolant p, double t, out double x, out double dx, out double d2x, out double y, out double dy, out double d2y, out double z, out double dz, out double d2z, alglib.xparams _xparams)
    {
        _core_pspline3diff2( p,  t, out  x, out  dx, out  d2x, out  y, out  dy, out  d2y, out  z, out  dz, out  d2z, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_pspline2arclength(pspline2interpolant p, double a, double b, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_p = p.ptr;
        double _d_a = a;
        double _d_b = b;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_pspline2arclength(&_s_errormsg, &_d_result, &_d_p, &_d_a, &_d_b, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "pspline2arclength");
            result = _d_result;
            ap.assert(p.ptr==_d_p, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double pspline2arclength(pspline2interpolant p, double a, double b)
    {
        return _core_pspline2arclength( p,  a,  b, 0x0);
    }
    
    public static double pspline2arclength(pspline2interpolant p, double a, double b, alglib.xparams _xparams)
    {
        return _core_pspline2arclength( p,  a,  b, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_pspline3arclength(pspline3interpolant p, double a, double b, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_p = p.ptr;
        double _d_a = a;
        double _d_b = b;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_pspline3arclength(&_s_errormsg, &_d_result, &_d_p, &_d_a, &_d_b, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "pspline3arclength");
            result = _d_result;
            ap.assert(p.ptr==_d_p, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double pspline3arclength(pspline3interpolant p, double a, double b)
    {
        return _core_pspline3arclength( p,  a,  b, 0x0);
    }
    
    public static double pspline3arclength(pspline3interpolant p, double a, double b, alglib.xparams _xparams)
    {
        return _core_pspline3arclength( p,  a,  b, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_parametricrdpfixed(double[,] x, int n, int d, int stopm, double stopeps, out double[,] x2, out int[] idx2, out int nsections, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_x = new x_matrix();
        x_int _d_n = new x_int(n);
        x_int _d_d = new x_int(d);
        x_int _d_stopm = new x_int(stopm);
        double _d_stopeps = stopeps;
        x_matrix _d_x2 = new x_matrix();
        x_vector _d_idx2 = new x_vector();
        x_int _d_nsections = new x_int();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_matrix_attach_to_array(ref _d_x, _fp_x, ap.rows(x), ap.cols(x));
                x_matrix_create_empty(ref _d_x2, DT_REAL);
                x2 = null;
                x_vector_create_empty(ref _d_idx2, DT_INT);
                idx2 = null;
                _error_code = _i_xv2_parametricrdpfixed(&_s_errormsg, &_d_x, &_d_n, &_d_d, &_d_stopm, &_d_stopeps, &_d_x2, &_d_idx2, &_d_nsections, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "parametricrdpfixed");
            if( _d_x2.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_x2, ref x2);
            if( x2 == null )
                x2 = new double[0,0];
            x_vector_to_array(ref _d_idx2, ref idx2);
            nsections = _d_nsections.intval;
        }
        finally
        {
            x_matrix_clear(ref _d_x);
            x_matrix_clear(ref _d_x2);
            x_vector_clear(ref _d_idx2);
        }
        // This function returns no value.
    }
    
    public static void parametricrdpfixed(double[,] x, int n, int d, int stopm, double stopeps, out double[,] x2, out int[] idx2, out int nsections)
    {
        _core_parametricrdpfixed( x,  n,  d,  stopm,  stopeps, out  x2, out  idx2, out  nsections, 0x0);
    }
    
    public static void parametricrdpfixed(double[,] x, int n, int d, int stopm, double stopeps, out double[,] x2, out int[] idx2, out int nsections, alglib.xparams _xparams)
    {
        _core_parametricrdpfixed( x,  n,  d,  stopm,  stopeps, out  x2, out  idx2, out  nsections, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage rbfv1
    //
    
    
    
    //
    // Subpackage rbfv3farfields
    //
    
    
    
    //
    // Subpackage rbfv3
    //
    
    
    
    //
    // Subpackage spline2d
    //
    

    public unsafe class spline2dinterpolant : alglibobject
    {
        private void *_ptr;
        public spline2dinterpolant(void *x)
        {
            _ptr = x;
        }
        ~spline2dinterpolant()
        {
            _deallocate();
        }
        public void* ptr { get { return _ptr; } }
        public override alglib.alglibobject make_copy()
        {
            if( _ptr==null )
                return new spline2dinterpolant(null);
            return new spline2dinterpolant(_i_x_obj_copy_spline2dinterpolant(_ptr));
        }
        public override void _deallocate()
        {
            if( _ptr!=null )
                _i_x_obj_free_spline2dinterpolant(_ptr);
            _ptr = null;
            System.GC.SuppressFinalize(this);
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_spline2dinterpolant(void *x);
    private static _d_x_obj_copy_spline2dinterpolant _i_x_obj_copy_spline2dinterpolant = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_obj_free_spline2dinterpolant(void *x);
    private static _d_x_obj_free_spline2dinterpolant _i_x_obj_free_spline2dinterpolant = null;

    public unsafe class spline2dbuilder : alglibobject
    {
        private void *_ptr;
        public spline2dbuilder(void *x)
        {
            _ptr = x;
        }
        ~spline2dbuilder()
        {
            _deallocate();
        }
        public void* ptr { get { return _ptr; } }
        public override alglib.alglibobject make_copy()
        {
            if( _ptr==null )
                return new spline2dbuilder(null);
            return new spline2dbuilder(_i_x_obj_copy_spline2dbuilder(_ptr));
        }
        public override void _deallocate()
        {
            if( _ptr!=null )
                _i_x_obj_free_spline2dbuilder(_ptr);
            _ptr = null;
            System.GC.SuppressFinalize(this);
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_spline2dbuilder(void *x);
    private static _d_x_obj_copy_spline2dbuilder _i_x_obj_copy_spline2dbuilder = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_obj_free_spline2dbuilder(void *x);
    private static _d_x_obj_free_spline2dbuilder _i_x_obj_free_spline2dbuilder = null;

    [StructLayout(LayoutKind.Sequential, Pack=8)]
    private struct x_spline2dfitreport
    {
        public double rmserror;
        public double avgerror;
        public double maxerror;
        public double r2;
    }

    public class spline2dfitreport : alglibobject
    {
        public double rmserror;
        public double avgerror;
        public double maxerror;
        public double r2;
        public override alglib.alglibobject make_copy()
        {
            spline2dfitreport dst = new spline2dfitreport();
            dst.rmserror = rmserror;
            dst.avgerror = avgerror;
            dst.maxerror = maxerror;
            dst.r2 = r2;
            return dst;
        }
    }

    // This function initializes X-structure (its previous content is ignored)
    private static void x_spline2dfitreport_init(ref x_spline2dfitreport x)
    {
        x.rmserror = 0;
        x.avgerror = 0;
        x.maxerror = 0;
        x.r2 = 0;
    }

    // This function finalizes fields of X-structure (however, memory occupied by structure itself is not freed)
    // After destruction structure becomes unusable and should be re-initialized if you want to use it
    private static void x_spline2dfitreport_clear(ref x_spline2dfitreport x)
    {
    }

    // This function initializes X-structure by appropriate C# instance
    // (previous content of X structure is ignored)
    private static void x_spline2dfitreport_init_from(ref x_spline2dfitreport x, spline2dfitreport v)
    {
        x.rmserror = v.rmserror;
        x.avgerror = v.avgerror;
        x.maxerror = v.maxerror;
        x.r2 = v.r2;
    }

    // This function initializes C# structure by appropriate X instance
    // (previous content of C# structure is ignored).
    // This function may accept null v, in this case v is automatically allocated with new().
    private static void x_spline2dfitreport_to_record(ref x_spline2dfitreport x, ref spline2dfitreport v)
    {
        if( v==null )
            v = new spline2dfitreport();
        v.rmserror = x.rmserror;
        v.avgerror = x.avgerror;
        v.maxerror = x.maxerror;
        v.r2 = x.r2;
    }
    public static unsafe void spline2dserialize(spline2dinterpolant obj, out string s_out)
    {
        byte *_s_errormsg = null;
        byte *_out = null;
        void *_x = obj.ptr;
        try
        {
            int _error_code = _i_x_spline2dserialize(&_s_errormsg, &_x, &_out);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spline2dserialize");
            s_out = Marshal.PtrToStringAnsi((IntPtr)_out);
        }
        finally
        {
            x_free((IntPtr)_out);
        }
    }
    
    public static unsafe void spline2dunserialize(string s_in, out spline2dinterpolant obj)
    {
        byte *_s_errormsg = null;
        byte[] _ain = System.Text.Encoding.UTF8.GetBytes(s_in);
        fixed(byte *_pin = _ain )
        {
            byte *_in = _pin;
            void *_x = null;
            obj = null;
            try
            {
                int _error_code = _i_x_spline2dunserialize(&_s_errormsg, &_in, &_x);
                if( _error_code!=X_OK )
                    handle_exception(_error_code, _s_errormsg, "spline2dunserialize");
                obj = new spline2dinterpolant(_x);
            }
            finally
            {
                // on exception clean up X objects which were not attached to C# objects
                if( _x!=null && obj==null)
                    _i_x_obj_free_spline2dinterpolant(_x);
            }
        }
    }
    public static unsafe void spline2dserialize(spline2dinterpolant obj, System.IO.Stream s_out)
    {
        byte *_s_errormsg = null;
        void *_x = obj.ptr;
        alglib.native_stream_adapter a = new alglib.native_stream_adapter();
        a.sstart_stream(s_out);
        int _error_code = _i_x_spline2dserialize_stream(&_s_errormsg, &_x, a.writer_callback, IntPtr.Zero);
        if( _error_code!=X_OK )
            handle_exception(_error_code, _s_errormsg, "spline2dserialize");
    }
    
    public static unsafe void spline2dunserialize(System.IO.Stream s_in, out spline2dinterpolant obj)
    {
        byte *_s_errormsg = null;
        void *_x = null;
        obj = null;
        alglib.native_stream_adapter a = new alglib.native_stream_adapter();
        a.ustart_stream(s_in);
        try
        {
            int _error_code = _i_x_spline2dunserialize_stream(&_s_errormsg, a.reader_callback, IntPtr.Zero, &_x);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spline2dunserialize");
            obj = new spline2dinterpolant(_x);
        }
        finally
        {
            // on exception clean up X objects which were not attached to C# objects
            if( _x!=null && obj==null)
                _i_x_obj_free_spline2dinterpolant(_x);
        }
    }
    
    private static unsafe double _core_spline2dcalc(spline2dinterpolant c, double x, double y, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_c = c.ptr;
        double _d_x = x;
        double _d_y = y;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_spline2dcalc(&_s_errormsg, &_d_result, &_d_c, &_d_x, &_d_y, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spline2dcalc");
            result = _d_result;
            ap.assert(c.ptr==_d_c, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double spline2dcalc(spline2dinterpolant c, double x, double y)
    {
        return _core_spline2dcalc( c,  x,  y, 0x0);
    }
    
    public static double spline2dcalc(spline2dinterpolant c, double x, double y, alglib.xparams _xparams)
    {
        return _core_spline2dcalc( c,  x,  y, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_spline2ddiff(spline2dinterpolant c, double x, double y, out double f, out double fx, out double fy, out double fxy, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_c = c.ptr;
        double _d_x = x;
        double _d_y = y;
        double _d_f = 0;
        double _d_fx = 0;
        double _d_fy = 0;
        double _d_fxy = 0;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_spline2ddiff(&_s_errormsg, &_d_c, &_d_x, &_d_y, &_d_f, &_d_fx, &_d_fy, &_d_fxy, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spline2ddiff");
            ap.assert(c.ptr==_d_c, "ALGLIB: internal error (reference changed for non-out X-object)");
            f = _d_f;
            fx = _d_fx;
            fy = _d_fy;
            fxy = _d_fxy;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void spline2ddiff(spline2dinterpolant c, double x, double y, out double f, out double fx, out double fy, out double fxy)
    {
        _core_spline2ddiff( c,  x,  y, out  f, out  fx, out  fy, out  fxy, 0x0);
    }
    
    public static void spline2ddiff(spline2dinterpolant c, double x, double y, out double f, out double fx, out double fy, out double fxy, alglib.xparams _xparams)
    {
        _core_spline2ddiff( c,  x,  y, out  f, out  fx, out  fy, out  fxy, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_spline2dcalcvbuf(spline2dinterpolant c, double x, double y, ref double[] f, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_c = c.ptr;
        double _d_x = x;
        double _d_y = y;
        x_vector _d_f = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_f = f){
                x_vector_attach_to_array(ref _d_f, _fp_f, ap.len(f));
                _error_code = _i_xv2_spline2dcalcvbuf(&_s_errormsg, &_d_c, &_d_x, &_d_y, &_d_f, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spline2dcalcvbuf");
            ap.assert(c.ptr==_d_c, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_f.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_f, ref f);
            if( f == null )
                f = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_f);
        }
        // This function returns no value.
    }
    
    public static void spline2dcalcvbuf(spline2dinterpolant c, double x, double y, ref double[] f)
    {
        _core_spline2dcalcvbuf( c,  x,  y, ref  f, 0x0);
    }
    
    public static void spline2dcalcvbuf(spline2dinterpolant c, double x, double y, ref double[] f, alglib.xparams _xparams)
    {
        _core_spline2dcalcvbuf( c,  x,  y, ref  f, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_spline2dcalcvi(spline2dinterpolant c, double x, double y, int i, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_c = c.ptr;
        double _d_x = x;
        double _d_y = y;
        x_int _d_i = new x_int(i);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_spline2dcalcvi(&_s_errormsg, &_d_result, &_d_c, &_d_x, &_d_y, &_d_i, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spline2dcalcvi");
            result = _d_result;
            ap.assert(c.ptr==_d_c, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double spline2dcalcvi(spline2dinterpolant c, double x, double y, int i)
    {
        return _core_spline2dcalcvi( c,  x,  y,  i, 0x0);
    }
    
    public static double spline2dcalcvi(spline2dinterpolant c, double x, double y, int i, alglib.xparams _xparams)
    {
        return _core_spline2dcalcvi( c,  x,  y,  i, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_spline2dcalcv(spline2dinterpolant c, double x, double y, out double[] f, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_c = c.ptr;
        double _d_x = x;
        double _d_y = y;
        x_vector _d_f = new x_vector();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_f, DT_REAL);
            f = null;
            _error_code = _i_xv2_spline2dcalcv(&_s_errormsg, &_d_c, &_d_x, &_d_y, &_d_f, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spline2dcalcv");
            ap.assert(c.ptr==_d_c, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_f.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_f, ref f);
            if( f == null )
                f = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_f);
        }
        // This function returns no value.
    }
    
    public static void spline2dcalcv(spline2dinterpolant c, double x, double y, out double[] f)
    {
        _core_spline2dcalcv( c,  x,  y, out  f, 0x0);
    }
    
    public static void spline2dcalcv(spline2dinterpolant c, double x, double y, out double[] f, alglib.xparams _xparams)
    {
        _core_spline2dcalcv( c,  x,  y, out  f, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_spline2ddiffvi(spline2dinterpolant c, double x, double y, int i, out double f, out double fx, out double fy, out double fxy, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_c = c.ptr;
        double _d_x = x;
        double _d_y = y;
        x_int _d_i = new x_int(i);
        double _d_f = 0;
        double _d_fx = 0;
        double _d_fy = 0;
        double _d_fxy = 0;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_spline2ddiffvi(&_s_errormsg, &_d_c, &_d_x, &_d_y, &_d_i, &_d_f, &_d_fx, &_d_fy, &_d_fxy, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spline2ddiffvi");
            ap.assert(c.ptr==_d_c, "ALGLIB: internal error (reference changed for non-out X-object)");
            f = _d_f;
            fx = _d_fx;
            fy = _d_fy;
            fxy = _d_fxy;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void spline2ddiffvi(spline2dinterpolant c, double x, double y, int i, out double f, out double fx, out double fy, out double fxy)
    {
        _core_spline2ddiffvi( c,  x,  y,  i, out  f, out  fx, out  fy, out  fxy, 0x0);
    }
    
    public static void spline2ddiffvi(spline2dinterpolant c, double x, double y, int i, out double f, out double fx, out double fy, out double fxy, alglib.xparams _xparams)
    {
        _core_spline2ddiffvi( c,  x,  y,  i, out  f, out  fx, out  fy, out  fxy, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_spline2dlintransxy(spline2dinterpolant c, double ax, double bx, double ay, double by, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_c = c.ptr;
        double _d_ax = ax;
        double _d_bx = bx;
        double _d_ay = ay;
        double _d_by = by;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_spline2dlintransxy(&_s_errormsg, &_d_c, &_d_ax, &_d_bx, &_d_ay, &_d_by, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spline2dlintransxy");
            ap.assert(c.ptr==_d_c, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void spline2dlintransxy(spline2dinterpolant c, double ax, double bx, double ay, double by)
    {
        _core_spline2dlintransxy( c,  ax,  bx,  ay,  by, 0x0);
    }
    
    public static void spline2dlintransxy(spline2dinterpolant c, double ax, double bx, double ay, double by, alglib.xparams _xparams)
    {
        _core_spline2dlintransxy( c,  ax,  bx,  ay,  by, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_spline2dlintransf(spline2dinterpolant c, double a, double b, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_c = c.ptr;
        double _d_a = a;
        double _d_b = b;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_spline2dlintransf(&_s_errormsg, &_d_c, &_d_a, &_d_b, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spline2dlintransf");
            ap.assert(c.ptr==_d_c, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void spline2dlintransf(spline2dinterpolant c, double a, double b)
    {
        _core_spline2dlintransf( c,  a,  b, 0x0);
    }
    
    public static void spline2dlintransf(spline2dinterpolant c, double a, double b, alglib.xparams _xparams)
    {
        _core_spline2dlintransf( c,  a,  b, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_spline2dcopy(spline2dinterpolant c, out spline2dinterpolant cc, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_c = c.ptr;
        void *_d_cc = null;
        cc = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_spline2dcopy(&_s_errormsg, &_d_c, &_d_cc, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spline2dcopy");
            ap.assert(c.ptr==_d_c, "ALGLIB: internal error (reference changed for non-out X-object)");
            cc = new spline2dinterpolant(_d_cc);
        }
        finally
        {
            if( _d_cc!=null && cc==null)
                _i_x_obj_free_spline2dinterpolant(_d_cc); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void spline2dcopy(spline2dinterpolant c, out spline2dinterpolant cc)
    {
        _core_spline2dcopy( c, out  cc, 0x0);
    }
    
    public static void spline2dcopy(spline2dinterpolant c, out spline2dinterpolant cc, alglib.xparams _xparams)
    {
        _core_spline2dcopy( c, out  cc, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_spline2dresamplebicubic(double[,] a, int oldheight, int oldwidth, out double[,] b, int newheight, int newwidth, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_oldheight = new x_int(oldheight);
        x_int _d_oldwidth = new x_int(oldwidth);
        x_matrix _d_b = new x_matrix();
        x_int _d_newheight = new x_int(newheight);
        x_int _d_newwidth = new x_int(newwidth);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matrix_create_empty(ref _d_b, DT_REAL);
                b = null;
                _error_code = _i_xv2_spline2dresamplebicubic(&_s_errormsg, &_d_a, &_d_oldheight, &_d_oldwidth, &_d_b, &_d_newheight, &_d_newwidth, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spline2dresamplebicubic");
            if( _d_b.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_b, ref b);
            if( b == null )
                b = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matrix_clear(ref _d_b);
        }
        // This function returns no value.
    }
    
    public static void spline2dresamplebicubic(double[,] a, int oldheight, int oldwidth, out double[,] b, int newheight, int newwidth)
    {
        _core_spline2dresamplebicubic( a,  oldheight,  oldwidth, out  b,  newheight,  newwidth, 0x0);
    }
    
    public static void spline2dresamplebicubic(double[,] a, int oldheight, int oldwidth, out double[,] b, int newheight, int newwidth, alglib.xparams _xparams)
    {
        _core_spline2dresamplebicubic( a,  oldheight,  oldwidth, out  b,  newheight,  newwidth, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_spline2dresamplebilinear(double[,] a, int oldheight, int oldwidth, out double[,] b, int newheight, int newwidth, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_oldheight = new x_int(oldheight);
        x_int _d_oldwidth = new x_int(oldwidth);
        x_matrix _d_b = new x_matrix();
        x_int _d_newheight = new x_int(newheight);
        x_int _d_newwidth = new x_int(newwidth);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matrix_create_empty(ref _d_b, DT_REAL);
                b = null;
                _error_code = _i_xv2_spline2dresamplebilinear(&_s_errormsg, &_d_a, &_d_oldheight, &_d_oldwidth, &_d_b, &_d_newheight, &_d_newwidth, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spline2dresamplebilinear");
            if( _d_b.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_b, ref b);
            if( b == null )
                b = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matrix_clear(ref _d_b);
        }
        // This function returns no value.
    }
    
    public static void spline2dresamplebilinear(double[,] a, int oldheight, int oldwidth, out double[,] b, int newheight, int newwidth)
    {
        _core_spline2dresamplebilinear( a,  oldheight,  oldwidth, out  b,  newheight,  newwidth, 0x0);
    }
    
    public static void spline2dresamplebilinear(double[,] a, int oldheight, int oldwidth, out double[,] b, int newheight, int newwidth, alglib.xparams _xparams)
    {
        _core_spline2dresamplebilinear( a,  oldheight,  oldwidth, out  b,  newheight,  newwidth, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_spline2dbuildbilinearv(double[] x, int n, double[] y, int m, double[] f, int d, out spline2dinterpolant c, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_int _d_n = new x_int(n);
        x_vector _d_y = new x_vector();
        x_int _d_m = new x_int(m);
        x_vector _d_f = new x_vector();
        x_int _d_d = new x_int(d);
        void *_d_c = null;
        c = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y, _fp_f = f){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_vector_attach_to_array(ref _d_f, _fp_f, ap.len(f));
                _error_code = _i_xv2_spline2dbuildbilinearv(&_s_errormsg, &_d_x, &_d_n, &_d_y, &_d_m, &_d_f, &_d_d, &_d_c, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spline2dbuildbilinearv");
            c = new spline2dinterpolant(_d_c);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            x_vector_clear(ref _d_f);
            if( _d_c!=null && c==null)
                _i_x_obj_free_spline2dinterpolant(_d_c); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void spline2dbuildbilinearv(double[] x, int n, double[] y, int m, double[] f, int d, out spline2dinterpolant c)
    {
        _core_spline2dbuildbilinearv( x,  n,  y,  m,  f,  d, out  c, 0x0);
    }
    
    public static void spline2dbuildbilinearv(double[] x, int n, double[] y, int m, double[] f, int d, out spline2dinterpolant c, alglib.xparams _xparams)
    {
        _core_spline2dbuildbilinearv( x,  n,  y,  m,  f,  d, out  c, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_spline2dbuildbilinearmissing(double[] x, int n, double[] y, int m, double[] f, bool[] missing, int d, out spline2dinterpolant c, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_int _d_n = new x_int(n);
        x_vector _d_y = new x_vector();
        x_int _d_m = new x_int(m);
        x_vector _d_f = new x_vector();
        x_vector _d_missing = new x_vector();
        x_int _d_d = new x_int(d);
        void *_d_c = null;
        c = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y, _fp_f = f){fixed(bool* _fp_missing = missing){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_vector_attach_to_array(ref _d_f, _fp_f, ap.len(f));
                x_vector_attach_to_array(ref _d_missing, _fp_missing, ap.len(missing));
                _error_code = _i_xv2_spline2dbuildbilinearmissing(&_s_errormsg, &_d_x, &_d_n, &_d_y, &_d_m, &_d_f, &_d_missing, &_d_d, &_d_c, _xparams);
            }}
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spline2dbuildbilinearmissing");
            c = new spline2dinterpolant(_d_c);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            x_vector_clear(ref _d_f);
            x_vector_clear(ref _d_missing);
            if( _d_c!=null && c==null)
                _i_x_obj_free_spline2dinterpolant(_d_c); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void spline2dbuildbilinearmissing(double[] x, int n, double[] y, int m, double[] f, bool[] missing, int d, out spline2dinterpolant c)
    {
        _core_spline2dbuildbilinearmissing( x,  n,  y,  m,  f,  missing,  d, out  c, 0x0);
    }
    
    public static void spline2dbuildbilinearmissing(double[] x, int n, double[] y, int m, double[] f, bool[] missing, int d, out spline2dinterpolant c, alglib.xparams _xparams)
    {
        _core_spline2dbuildbilinearmissing( x,  n,  y,  m,  f,  missing,  d, out  c, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_spline2dbuildbicubicv(double[] x, int n, double[] y, int m, double[] f, int d, out spline2dinterpolant c, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_int _d_n = new x_int(n);
        x_vector _d_y = new x_vector();
        x_int _d_m = new x_int(m);
        x_vector _d_f = new x_vector();
        x_int _d_d = new x_int(d);
        void *_d_c = null;
        c = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y, _fp_f = f){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_vector_attach_to_array(ref _d_f, _fp_f, ap.len(f));
                _error_code = _i_xv2_spline2dbuildbicubicv(&_s_errormsg, &_d_x, &_d_n, &_d_y, &_d_m, &_d_f, &_d_d, &_d_c, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spline2dbuildbicubicv");
            c = new spline2dinterpolant(_d_c);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            x_vector_clear(ref _d_f);
            if( _d_c!=null && c==null)
                _i_x_obj_free_spline2dinterpolant(_d_c); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void spline2dbuildbicubicv(double[] x, int n, double[] y, int m, double[] f, int d, out spline2dinterpolant c)
    {
        _core_spline2dbuildbicubicv( x,  n,  y,  m,  f,  d, out  c, 0x0);
    }
    
    public static void spline2dbuildbicubicv(double[] x, int n, double[] y, int m, double[] f, int d, out spline2dinterpolant c, alglib.xparams _xparams)
    {
        _core_spline2dbuildbicubicv( x,  n,  y,  m,  f,  d, out  c, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_spline2dbuildbicubicmissing(double[] x, int n, double[] y, int m, double[] f, bool[] missing, int d, out spline2dinterpolant c, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_int _d_n = new x_int(n);
        x_vector _d_y = new x_vector();
        x_int _d_m = new x_int(m);
        x_vector _d_f = new x_vector();
        x_vector _d_missing = new x_vector();
        x_int _d_d = new x_int(d);
        void *_d_c = null;
        c = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y, _fp_f = f){fixed(bool* _fp_missing = missing){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_vector_attach_to_array(ref _d_f, _fp_f, ap.len(f));
                x_vector_attach_to_array(ref _d_missing, _fp_missing, ap.len(missing));
                _error_code = _i_xv2_spline2dbuildbicubicmissing(&_s_errormsg, &_d_x, &_d_n, &_d_y, &_d_m, &_d_f, &_d_missing, &_d_d, &_d_c, _xparams);
            }}
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spline2dbuildbicubicmissing");
            c = new spline2dinterpolant(_d_c);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            x_vector_clear(ref _d_f);
            x_vector_clear(ref _d_missing);
            if( _d_c!=null && c==null)
                _i_x_obj_free_spline2dinterpolant(_d_c); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void spline2dbuildbicubicmissing(double[] x, int n, double[] y, int m, double[] f, bool[] missing, int d, out spline2dinterpolant c)
    {
        _core_spline2dbuildbicubicmissing( x,  n,  y,  m,  f,  missing,  d, out  c, 0x0);
    }
    
    public static void spline2dbuildbicubicmissing(double[] x, int n, double[] y, int m, double[] f, bool[] missing, int d, out spline2dinterpolant c, alglib.xparams _xparams)
    {
        _core_spline2dbuildbicubicmissing( x,  n,  y,  m,  f,  missing,  d, out  c, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_spline2dunpackv(spline2dinterpolant c, out int m, out int n, out int d, out double[,] tbl, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_c = c.ptr;
        x_int _d_m = new x_int();
        x_int _d_n = new x_int();
        x_int _d_d = new x_int();
        x_matrix _d_tbl = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            x_matrix_create_empty(ref _d_tbl, DT_REAL);
            tbl = null;
            _error_code = _i_xv2_spline2dunpackv(&_s_errormsg, &_d_c, &_d_m, &_d_n, &_d_d, &_d_tbl, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spline2dunpackv");
            ap.assert(c.ptr==_d_c, "ALGLIB: internal error (reference changed for non-out X-object)");
            m = _d_m.intval;
            n = _d_n.intval;
            d = _d_d.intval;
            if( _d_tbl.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_tbl, ref tbl);
            if( tbl == null )
                tbl = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_tbl);
        }
        // This function returns no value.
    }
    
    public static void spline2dunpackv(spline2dinterpolant c, out int m, out int n, out int d, out double[,] tbl)
    {
        _core_spline2dunpackv( c, out  m, out  n, out  d, out  tbl, 0x0);
    }
    
    public static void spline2dunpackv(spline2dinterpolant c, out int m, out int n, out int d, out double[,] tbl, alglib.xparams _xparams)
    {
        _core_spline2dunpackv( c, out  m, out  n, out  d, out  tbl, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_spline2dbuildbilinear(double[] x, double[] y, double[,] f, int m, int n, out spline2dinterpolant c, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_matrix _d_f = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        void *_d_c = null;
        c = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y, _fp_f = f){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_matrix_attach_to_array(ref _d_f, _fp_f, ap.rows(f), ap.cols(f));
                _error_code = _i_xv2_spline2dbuildbilinear(&_s_errormsg, &_d_x, &_d_y, &_d_f, &_d_m, &_d_n, &_d_c, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spline2dbuildbilinear");
            c = new spline2dinterpolant(_d_c);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            x_matrix_clear(ref _d_f);
            if( _d_c!=null && c==null)
                _i_x_obj_free_spline2dinterpolant(_d_c); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void spline2dbuildbilinear(double[] x, double[] y, double[,] f, int m, int n, out spline2dinterpolant c)
    {
        _core_spline2dbuildbilinear( x,  y,  f,  m,  n, out  c, 0x0);
    }
    
    public static void spline2dbuildbilinear(double[] x, double[] y, double[,] f, int m, int n, out spline2dinterpolant c, alglib.xparams _xparams)
    {
        _core_spline2dbuildbilinear( x,  y,  f,  m,  n, out  c, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_spline2dbuildbicubic(double[] x, double[] y, double[,] f, int m, int n, out spline2dinterpolant c, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_matrix _d_f = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        void *_d_c = null;
        c = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y, _fp_f = f){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_matrix_attach_to_array(ref _d_f, _fp_f, ap.rows(f), ap.cols(f));
                _error_code = _i_xv2_spline2dbuildbicubic(&_s_errormsg, &_d_x, &_d_y, &_d_f, &_d_m, &_d_n, &_d_c, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spline2dbuildbicubic");
            c = new spline2dinterpolant(_d_c);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            x_matrix_clear(ref _d_f);
            if( _d_c!=null && c==null)
                _i_x_obj_free_spline2dinterpolant(_d_c); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void spline2dbuildbicubic(double[] x, double[] y, double[,] f, int m, int n, out spline2dinterpolant c)
    {
        _core_spline2dbuildbicubic( x,  y,  f,  m,  n, out  c, 0x0);
    }
    
    public static void spline2dbuildbicubic(double[] x, double[] y, double[,] f, int m, int n, out spline2dinterpolant c, alglib.xparams _xparams)
    {
        _core_spline2dbuildbicubic( x,  y,  f,  m,  n, out  c, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_spline2dunpack(spline2dinterpolant c, out int m, out int n, out double[,] tbl, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_c = c.ptr;
        x_int _d_m = new x_int();
        x_int _d_n = new x_int();
        x_matrix _d_tbl = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            x_matrix_create_empty(ref _d_tbl, DT_REAL);
            tbl = null;
            _error_code = _i_xv2_spline2dunpack(&_s_errormsg, &_d_c, &_d_m, &_d_n, &_d_tbl, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spline2dunpack");
            ap.assert(c.ptr==_d_c, "ALGLIB: internal error (reference changed for non-out X-object)");
            m = _d_m.intval;
            n = _d_n.intval;
            if( _d_tbl.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_tbl, ref tbl);
            if( tbl == null )
                tbl = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_tbl);
        }
        // This function returns no value.
    }
    
    public static void spline2dunpack(spline2dinterpolant c, out int m, out int n, out double[,] tbl)
    {
        _core_spline2dunpack( c, out  m, out  n, out  tbl, 0x0);
    }
    
    public static void spline2dunpack(spline2dinterpolant c, out int m, out int n, out double[,] tbl, alglib.xparams _xparams)
    {
        _core_spline2dunpack( c, out  m, out  n, out  tbl, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_spline2dbuildercreate(int d, out spline2dbuilder state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_d = new x_int(d);
        void *_d_state = null;
        state = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_spline2dbuildercreate(&_s_errormsg, &_d_d, &_d_state, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spline2dbuildercreate");
            state = new spline2dbuilder(_d_state);
        }
        finally
        {
            if( _d_state!=null && state==null)
                _i_x_obj_free_spline2dbuilder(_d_state); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void spline2dbuildercreate(int d, out spline2dbuilder state)
    {
        _core_spline2dbuildercreate( d, out  state, 0x0);
    }
    
    public static void spline2dbuildercreate(int d, out spline2dbuilder state, alglib.xparams _xparams)
    {
        _core_spline2dbuildercreate( d, out  state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_spline2dbuildersetuserterm(spline2dbuilder state, double v, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_v = v;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_spline2dbuildersetuserterm(&_s_errormsg, &_d_state, &_d_v, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spline2dbuildersetuserterm");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void spline2dbuildersetuserterm(spline2dbuilder state, double v)
    {
        _core_spline2dbuildersetuserterm( state,  v, 0x0);
    }
    
    public static void spline2dbuildersetuserterm(spline2dbuilder state, double v, alglib.xparams _xparams)
    {
        _core_spline2dbuildersetuserterm( state,  v, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_spline2dbuildersetlinterm(spline2dbuilder state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_spline2dbuildersetlinterm(&_s_errormsg, &_d_state, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spline2dbuildersetlinterm");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void spline2dbuildersetlinterm(spline2dbuilder state)
    {
        _core_spline2dbuildersetlinterm( state, 0x0);
    }
    
    public static void spline2dbuildersetlinterm(spline2dbuilder state, alglib.xparams _xparams)
    {
        _core_spline2dbuildersetlinterm( state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_spline2dbuildersetconstterm(spline2dbuilder state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_spline2dbuildersetconstterm(&_s_errormsg, &_d_state, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spline2dbuildersetconstterm");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void spline2dbuildersetconstterm(spline2dbuilder state)
    {
        _core_spline2dbuildersetconstterm( state, 0x0);
    }
    
    public static void spline2dbuildersetconstterm(spline2dbuilder state, alglib.xparams _xparams)
    {
        _core_spline2dbuildersetconstterm( state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_spline2dbuildersetzeroterm(spline2dbuilder state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_spline2dbuildersetzeroterm(&_s_errormsg, &_d_state, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spline2dbuildersetzeroterm");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void spline2dbuildersetzeroterm(spline2dbuilder state)
    {
        _core_spline2dbuildersetzeroterm( state, 0x0);
    }
    
    public static void spline2dbuildersetzeroterm(spline2dbuilder state, alglib.xparams _xparams)
    {
        _core_spline2dbuildersetzeroterm( state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_spline2dbuildersetpoints(spline2dbuilder state, double[,] xy, int n, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_n = new x_int(n);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_xv2_spline2dbuildersetpoints(&_s_errormsg, &_d_state, &_d_xy, &_d_n, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spline2dbuildersetpoints");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
        }
        // This function returns no value.
    }
    
    public static void spline2dbuildersetpoints(spline2dbuilder state, double[,] xy, int n)
    {
        _core_spline2dbuildersetpoints( state,  xy,  n, 0x0);
    }
    
    public static void spline2dbuildersetpoints(spline2dbuilder state, double[,] xy, int n, alglib.xparams _xparams)
    {
        _core_spline2dbuildersetpoints( state,  xy,  n, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_spline2dbuildersetareaauto(spline2dbuilder state, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_spline2dbuildersetareaauto(&_s_errormsg, &_d_state, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spline2dbuildersetareaauto");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void spline2dbuildersetareaauto(spline2dbuilder state)
    {
        _core_spline2dbuildersetareaauto( state, 0x0);
    }
    
    public static void spline2dbuildersetareaauto(spline2dbuilder state, alglib.xparams _xparams)
    {
        _core_spline2dbuildersetareaauto( state, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_spline2dbuildersetarea(spline2dbuilder state, double xa, double xb, double ya, double yb, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_xa = xa;
        double _d_xb = xb;
        double _d_ya = ya;
        double _d_yb = yb;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_spline2dbuildersetarea(&_s_errormsg, &_d_state, &_d_xa, &_d_xb, &_d_ya, &_d_yb, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spline2dbuildersetarea");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void spline2dbuildersetarea(spline2dbuilder state, double xa, double xb, double ya, double yb)
    {
        _core_spline2dbuildersetarea( state,  xa,  xb,  ya,  yb, 0x0);
    }
    
    public static void spline2dbuildersetarea(spline2dbuilder state, double xa, double xb, double ya, double yb, alglib.xparams _xparams)
    {
        _core_spline2dbuildersetarea( state,  xa,  xb,  ya,  yb, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_spline2dbuildersetgrid(spline2dbuilder state, int kx, int ky, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_int _d_kx = new x_int(kx);
        x_int _d_ky = new x_int(ky);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_spline2dbuildersetgrid(&_s_errormsg, &_d_state, &_d_kx, &_d_ky, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spline2dbuildersetgrid");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void spline2dbuildersetgrid(spline2dbuilder state, int kx, int ky)
    {
        _core_spline2dbuildersetgrid( state,  kx,  ky, 0x0);
    }
    
    public static void spline2dbuildersetgrid(spline2dbuilder state, int kx, int ky, alglib.xparams _xparams)
    {
        _core_spline2dbuildersetgrid( state,  kx,  ky, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_spline2dbuildersetalgofastddm(spline2dbuilder state, int nlayers, double lambdav, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_int _d_nlayers = new x_int(nlayers);
        double _d_lambdav = lambdav;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_spline2dbuildersetalgofastddm(&_s_errormsg, &_d_state, &_d_nlayers, &_d_lambdav, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spline2dbuildersetalgofastddm");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void spline2dbuildersetalgofastddm(spline2dbuilder state, int nlayers, double lambdav)
    {
        _core_spline2dbuildersetalgofastddm( state,  nlayers,  lambdav, 0x0);
    }
    
    public static void spline2dbuildersetalgofastddm(spline2dbuilder state, int nlayers, double lambdav, alglib.xparams _xparams)
    {
        _core_spline2dbuildersetalgofastddm( state,  nlayers,  lambdav, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_spline2dbuildersetalgoblocklls(spline2dbuilder state, double lambdans, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_lambdans = lambdans;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_spline2dbuildersetalgoblocklls(&_s_errormsg, &_d_state, &_d_lambdans, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spline2dbuildersetalgoblocklls");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void spline2dbuildersetalgoblocklls(spline2dbuilder state, double lambdans)
    {
        _core_spline2dbuildersetalgoblocklls( state,  lambdans, 0x0);
    }
    
    public static void spline2dbuildersetalgoblocklls(spline2dbuilder state, double lambdans, alglib.xparams _xparams)
    {
        _core_spline2dbuildersetalgoblocklls( state,  lambdans, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_spline2dbuildersetalgonaivells(spline2dbuilder state, double lambdans, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_lambdans = lambdans;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_spline2dbuildersetalgonaivells(&_s_errormsg, &_d_state, &_d_lambdans, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spline2dbuildersetalgonaivells");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void spline2dbuildersetalgonaivells(spline2dbuilder state, double lambdans)
    {
        _core_spline2dbuildersetalgonaivells( state,  lambdans, 0x0);
    }
    
    public static void spline2dbuildersetalgonaivells(spline2dbuilder state, double lambdans, alglib.xparams _xparams)
    {
        _core_spline2dbuildersetalgonaivells( state,  lambdans, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_spline2dfit(spline2dbuilder state, out spline2dinterpolant s, out spline2dfitreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        void *_d_s = null;
        s = null;
        x_spline2dfitreport _d_rep = new x_spline2dfitreport();
        
        // Pack, call, unpack
        try
        {
            x_spline2dfitreport_init(ref _d_rep);
            _error_code = _i_xv2_spline2dfit(&_s_errormsg, &_d_state, &_d_s, &_d_rep, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spline2dfit");
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            s = new spline2dinterpolant(_d_s);
            rep = null;
            x_spline2dfitreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            if( _d_s!=null && s==null)
                _i_x_obj_free_spline2dinterpolant(_d_s); // on exception clean up X objects which were not attached to C# objects
            x_spline2dfitreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void spline2dfit(spline2dbuilder state, out spline2dinterpolant s, out spline2dfitreport rep)
    {
        _core_spline2dfit( state, out  s, out  rep, 0x0);
    }
    
    public static void spline2dfit(spline2dbuilder state, out spline2dinterpolant s, out spline2dfitreport rep, alglib.xparams _xparams)
    {
        _core_spline2dfit( state, out  s, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage rbfv2
    //
    
    
    
    //
    // Subpackage spline3d
    //
    

    public unsafe class spline3dinterpolant : alglibobject
    {
        private void *_ptr;
        public spline3dinterpolant(void *x)
        {
            _ptr = x;
        }
        ~spline3dinterpolant()
        {
            _deallocate();
        }
        public void* ptr { get { return _ptr; } }
        public override alglib.alglibobject make_copy()
        {
            if( _ptr==null )
                return new spline3dinterpolant(null);
            return new spline3dinterpolant(_i_x_obj_copy_spline3dinterpolant(_ptr));
        }
        public override void _deallocate()
        {
            if( _ptr!=null )
                _i_x_obj_free_spline3dinterpolant(_ptr);
            _ptr = null;
            System.GC.SuppressFinalize(this);
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_spline3dinterpolant(void *x);
    private static _d_x_obj_copy_spline3dinterpolant _i_x_obj_copy_spline3dinterpolant = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_obj_free_spline3dinterpolant(void *x);
    private static _d_x_obj_free_spline3dinterpolant _i_x_obj_free_spline3dinterpolant = null;
    
    private static unsafe double _core_spline3dcalc(spline3dinterpolant c, double x, double y, double z, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_c = c.ptr;
        double _d_x = x;
        double _d_y = y;
        double _d_z = z;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_spline3dcalc(&_s_errormsg, &_d_result, &_d_c, &_d_x, &_d_y, &_d_z, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spline3dcalc");
            result = _d_result;
            ap.assert(c.ptr==_d_c, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double spline3dcalc(spline3dinterpolant c, double x, double y, double z)
    {
        return _core_spline3dcalc( c,  x,  y,  z, 0x0);
    }
    
    public static double spline3dcalc(spline3dinterpolant c, double x, double y, double z, alglib.xparams _xparams)
    {
        return _core_spline3dcalc( c,  x,  y,  z, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_spline3dlintransxyz(spline3dinterpolant c, double ax, double bx, double ay, double by, double az, double bz, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_c = c.ptr;
        double _d_ax = ax;
        double _d_bx = bx;
        double _d_ay = ay;
        double _d_by = by;
        double _d_az = az;
        double _d_bz = bz;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_spline3dlintransxyz(&_s_errormsg, &_d_c, &_d_ax, &_d_bx, &_d_ay, &_d_by, &_d_az, &_d_bz, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spline3dlintransxyz");
            ap.assert(c.ptr==_d_c, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void spline3dlintransxyz(spline3dinterpolant c, double ax, double bx, double ay, double by, double az, double bz)
    {
        _core_spline3dlintransxyz( c,  ax,  bx,  ay,  by,  az,  bz, 0x0);
    }
    
    public static void spline3dlintransxyz(spline3dinterpolant c, double ax, double bx, double ay, double by, double az, double bz, alglib.xparams _xparams)
    {
        _core_spline3dlintransxyz( c,  ax,  bx,  ay,  by,  az,  bz, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_spline3dlintransf(spline3dinterpolant c, double a, double b, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_c = c.ptr;
        double _d_a = a;
        double _d_b = b;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_spline3dlintransf(&_s_errormsg, &_d_c, &_d_a, &_d_b, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spline3dlintransf");
            ap.assert(c.ptr==_d_c, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void spline3dlintransf(spline3dinterpolant c, double a, double b)
    {
        _core_spline3dlintransf( c,  a,  b, 0x0);
    }
    
    public static void spline3dlintransf(spline3dinterpolant c, double a, double b, alglib.xparams _xparams)
    {
        _core_spline3dlintransf( c,  a,  b, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_spline3dresampletrilinear(double[] a, int oldzcount, int oldycount, int oldxcount, int newzcount, int newycount, int newxcount, out double[] b, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_a = new x_vector();
        x_int _d_oldzcount = new x_int(oldzcount);
        x_int _d_oldycount = new x_int(oldycount);
        x_int _d_oldxcount = new x_int(oldxcount);
        x_int _d_newzcount = new x_int(newzcount);
        x_int _d_newycount = new x_int(newycount);
        x_int _d_newxcount = new x_int(newxcount);
        x_vector _d_b = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_vector_attach_to_array(ref _d_a, _fp_a, ap.len(a));
                x_vector_create_empty(ref _d_b, DT_REAL);
                b = null;
                _error_code = _i_xv2_spline3dresampletrilinear(&_s_errormsg, &_d_a, &_d_oldzcount, &_d_oldycount, &_d_oldxcount, &_d_newzcount, &_d_newycount, &_d_newxcount, &_d_b, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spline3dresampletrilinear");
            if( _d_b.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_b, ref b);
            if( b == null )
                b = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_a);
            x_vector_clear(ref _d_b);
        }
        // This function returns no value.
    }
    
    public static void spline3dresampletrilinear(double[] a, int oldzcount, int oldycount, int oldxcount, int newzcount, int newycount, int newxcount, out double[] b)
    {
        _core_spline3dresampletrilinear( a,  oldzcount,  oldycount,  oldxcount,  newzcount,  newycount,  newxcount, out  b, 0x0);
    }
    
    public static void spline3dresampletrilinear(double[] a, int oldzcount, int oldycount, int oldxcount, int newzcount, int newycount, int newxcount, out double[] b, alglib.xparams _xparams)
    {
        _core_spline3dresampletrilinear( a,  oldzcount,  oldycount,  oldxcount,  newzcount,  newycount,  newxcount, out  b, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_spline3dbuildtrilinearv(double[] x, int n, double[] y, int m, double[] z, int l, double[] f, int d, out spline3dinterpolant c, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_int _d_n = new x_int(n);
        x_vector _d_y = new x_vector();
        x_int _d_m = new x_int(m);
        x_vector _d_z = new x_vector();
        x_int _d_l = new x_int(l);
        x_vector _d_f = new x_vector();
        x_int _d_d = new x_int(d);
        void *_d_c = null;
        c = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y, _fp_z = z, _fp_f = f){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_vector_attach_to_array(ref _d_z, _fp_z, ap.len(z));
                x_vector_attach_to_array(ref _d_f, _fp_f, ap.len(f));
                _error_code = _i_xv2_spline3dbuildtrilinearv(&_s_errormsg, &_d_x, &_d_n, &_d_y, &_d_m, &_d_z, &_d_l, &_d_f, &_d_d, &_d_c, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spline3dbuildtrilinearv");
            c = new spline3dinterpolant(_d_c);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            x_vector_clear(ref _d_z);
            x_vector_clear(ref _d_f);
            if( _d_c!=null && c==null)
                _i_x_obj_free_spline3dinterpolant(_d_c); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void spline3dbuildtrilinearv(double[] x, int n, double[] y, int m, double[] z, int l, double[] f, int d, out spline3dinterpolant c)
    {
        _core_spline3dbuildtrilinearv( x,  n,  y,  m,  z,  l,  f,  d, out  c, 0x0);
    }
    
    public static void spline3dbuildtrilinearv(double[] x, int n, double[] y, int m, double[] z, int l, double[] f, int d, out spline3dinterpolant c, alglib.xparams _xparams)
    {
        _core_spline3dbuildtrilinearv( x,  n,  y,  m,  z,  l,  f,  d, out  c, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_spline3dcalcvbuf(spline3dinterpolant c, double x, double y, double z, ref double[] f, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_c = c.ptr;
        double _d_x = x;
        double _d_y = y;
        double _d_z = z;
        x_vector _d_f = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_f = f){
                x_vector_attach_to_array(ref _d_f, _fp_f, ap.len(f));
                _error_code = _i_xv2_spline3dcalcvbuf(&_s_errormsg, &_d_c, &_d_x, &_d_y, &_d_z, &_d_f, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spline3dcalcvbuf");
            ap.assert(c.ptr==_d_c, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_f.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_f, ref f);
            if( f == null )
                f = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_f);
        }
        // This function returns no value.
    }
    
    public static void spline3dcalcvbuf(spline3dinterpolant c, double x, double y, double z, ref double[] f)
    {
        _core_spline3dcalcvbuf( c,  x,  y,  z, ref  f, 0x0);
    }
    
    public static void spline3dcalcvbuf(spline3dinterpolant c, double x, double y, double z, ref double[] f, alglib.xparams _xparams)
    {
        _core_spline3dcalcvbuf( c,  x,  y,  z, ref  f, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_spline3dcalcv(spline3dinterpolant c, double x, double y, double z, out double[] f, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_c = c.ptr;
        double _d_x = x;
        double _d_y = y;
        double _d_z = z;
        x_vector _d_f = new x_vector();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_f, DT_REAL);
            f = null;
            _error_code = _i_xv2_spline3dcalcv(&_s_errormsg, &_d_c, &_d_x, &_d_y, &_d_z, &_d_f, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spline3dcalcv");
            ap.assert(c.ptr==_d_c, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_f.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_f, ref f);
            if( f == null )
                f = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_f);
        }
        // This function returns no value.
    }
    
    public static void spline3dcalcv(spline3dinterpolant c, double x, double y, double z, out double[] f)
    {
        _core_spline3dcalcv( c,  x,  y,  z, out  f, 0x0);
    }
    
    public static void spline3dcalcv(spline3dinterpolant c, double x, double y, double z, out double[] f, alglib.xparams _xparams)
    {
        _core_spline3dcalcv( c,  x,  y,  z, out  f, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_spline3dunpackv(spline3dinterpolant c, out int n, out int m, out int l, out int d, out int stype, out double[,] tbl, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_c = c.ptr;
        x_int _d_n = new x_int();
        x_int _d_m = new x_int();
        x_int _d_l = new x_int();
        x_int _d_d = new x_int();
        x_int _d_stype = new x_int();
        x_matrix _d_tbl = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            x_matrix_create_empty(ref _d_tbl, DT_REAL);
            tbl = null;
            _error_code = _i_xv2_spline3dunpackv(&_s_errormsg, &_d_c, &_d_n, &_d_m, &_d_l, &_d_d, &_d_stype, &_d_tbl, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spline3dunpackv");
            ap.assert(c.ptr==_d_c, "ALGLIB: internal error (reference changed for non-out X-object)");
            n = _d_n.intval;
            m = _d_m.intval;
            l = _d_l.intval;
            d = _d_d.intval;
            stype = _d_stype.intval;
            if( _d_tbl.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_tbl, ref tbl);
            if( tbl == null )
                tbl = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_tbl);
        }
        // This function returns no value.
    }
    
    public static void spline3dunpackv(spline3dinterpolant c, out int n, out int m, out int l, out int d, out int stype, out double[,] tbl)
    {
        _core_spline3dunpackv( c, out  n, out  m, out  l, out  d, out  stype, out  tbl, 0x0);
    }
    
    public static void spline3dunpackv(spline3dinterpolant c, out int n, out int m, out int l, out int d, out int stype, out double[,] tbl, alglib.xparams _xparams)
    {
        _core_spline3dunpackv( c, out  n, out  m, out  l, out  d, out  stype, out  tbl, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage intcomp
    //
    
    
    private static unsafe void _core_nsfitspheremcc(double[,] xy, int npoints, int nx, out double[] cx, out double rhi, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        x_int _d_nx = new x_int(nx);
        x_vector _d_cx = new x_vector();
        double _d_rhi = 0;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                x_vector_create_empty(ref _d_cx, DT_REAL);
                cx = null;
                _error_code = _i_xv2_nsfitspheremcc(&_s_errormsg, &_d_xy, &_d_npoints, &_d_nx, &_d_cx, &_d_rhi, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "nsfitspheremcc");
            if( _d_cx.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_cx, ref cx);
            if( cx == null )
                cx = new double[0];
            rhi = _d_rhi;
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
            x_vector_clear(ref _d_cx);
        }
        // This function returns no value.
    }
    
    public static void nsfitspheremcc(double[,] xy, int npoints, int nx, out double[] cx, out double rhi)
    {
        _core_nsfitspheremcc( xy,  npoints,  nx, out  cx, out  rhi, 0x0);
    }
    
    public static void nsfitspheremcc(double[,] xy, int npoints, int nx, out double[] cx, out double rhi, alglib.xparams _xparams)
    {
        _core_nsfitspheremcc( xy,  npoints,  nx, out  cx, out  rhi, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_nsfitspheremic(double[,] xy, int npoints, int nx, out double[] cx, out double rlo, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        x_int _d_nx = new x_int(nx);
        x_vector _d_cx = new x_vector();
        double _d_rlo = 0;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                x_vector_create_empty(ref _d_cx, DT_REAL);
                cx = null;
                _error_code = _i_xv2_nsfitspheremic(&_s_errormsg, &_d_xy, &_d_npoints, &_d_nx, &_d_cx, &_d_rlo, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "nsfitspheremic");
            if( _d_cx.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_cx, ref cx);
            if( cx == null )
                cx = new double[0];
            rlo = _d_rlo;
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
            x_vector_clear(ref _d_cx);
        }
        // This function returns no value.
    }
    
    public static void nsfitspheremic(double[,] xy, int npoints, int nx, out double[] cx, out double rlo)
    {
        _core_nsfitspheremic( xy,  npoints,  nx, out  cx, out  rlo, 0x0);
    }
    
    public static void nsfitspheremic(double[,] xy, int npoints, int nx, out double[] cx, out double rlo, alglib.xparams _xparams)
    {
        _core_nsfitspheremic( xy,  npoints,  nx, out  cx, out  rlo, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_nsfitspheremzc(double[,] xy, int npoints, int nx, out double[] cx, out double rlo, out double rhi, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        x_int _d_nx = new x_int(nx);
        x_vector _d_cx = new x_vector();
        double _d_rlo = 0;
        double _d_rhi = 0;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                x_vector_create_empty(ref _d_cx, DT_REAL);
                cx = null;
                _error_code = _i_xv2_nsfitspheremzc(&_s_errormsg, &_d_xy, &_d_npoints, &_d_nx, &_d_cx, &_d_rlo, &_d_rhi, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "nsfitspheremzc");
            if( _d_cx.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_cx, ref cx);
            if( cx == null )
                cx = new double[0];
            rlo = _d_rlo;
            rhi = _d_rhi;
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
            x_vector_clear(ref _d_cx);
        }
        // This function returns no value.
    }
    
    public static void nsfitspheremzc(double[,] xy, int npoints, int nx, out double[] cx, out double rlo, out double rhi)
    {
        _core_nsfitspheremzc( xy,  npoints,  nx, out  cx, out  rlo, out  rhi, 0x0);
    }
    
    public static void nsfitspheremzc(double[,] xy, int npoints, int nx, out double[] cx, out double rlo, out double rhi, alglib.xparams _xparams)
    {
        _core_nsfitspheremzc( xy,  npoints,  nx, out  cx, out  rlo, out  rhi, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_nsfitspherex(double[,] xy, int npoints, int nx, int problemtype, double epsx, int aulits, double penalty, out double[] cx, out double rlo, out double rhi, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        x_int _d_nx = new x_int(nx);
        x_int _d_problemtype = new x_int(problemtype);
        double _d_epsx = epsx;
        x_int _d_aulits = new x_int(aulits);
        double _d_penalty = penalty;
        x_vector _d_cx = new x_vector();
        double _d_rlo = 0;
        double _d_rhi = 0;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                x_vector_create_empty(ref _d_cx, DT_REAL);
                cx = null;
                _error_code = _i_xv2_nsfitspherex(&_s_errormsg, &_d_xy, &_d_npoints, &_d_nx, &_d_problemtype, &_d_epsx, &_d_aulits, &_d_penalty, &_d_cx, &_d_rlo, &_d_rhi, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "nsfitspherex");
            if( _d_cx.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_cx, ref cx);
            if( cx == null )
                cx = new double[0];
            rlo = _d_rlo;
            rhi = _d_rhi;
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
            x_vector_clear(ref _d_cx);
        }
        // This function returns no value.
    }
    
    public static void nsfitspherex(double[,] xy, int npoints, int nx, int problemtype, double epsx, int aulits, double penalty, out double[] cx, out double rlo, out double rhi)
    {
        _core_nsfitspherex( xy,  npoints,  nx,  problemtype,  epsx,  aulits,  penalty, out  cx, out  rlo, out  rhi, 0x0);
    }
    
    public static void nsfitspherex(double[,] xy, int npoints, int nx, int problemtype, double epsx, int aulits, double penalty, out double[] cx, out double rlo, out double rhi, alglib.xparams _xparams)
    {
        _core_nsfitspherex( xy,  npoints,  nx,  problemtype,  epsx,  aulits,  penalty, out  cx, out  rlo, out  rhi, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_spline1dfitpenalized(double[] x, double[] y, int n, int m, double rho, out int info, out spline1dinterpolant s, out spline1dfitreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_int _d_n = new x_int(n);
        x_int _d_m = new x_int(m);
        double _d_rho = rho;
        x_int _d_info = new x_int();
        void *_d_s = null;
        s = null;
        x_spline1dfitreport _d_rep = new x_spline1dfitreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_spline1dfitreport_init(ref _d_rep);
                _error_code = _i_xv2_spline1dfitpenalized(&_s_errormsg, &_d_x, &_d_y, &_d_n, &_d_m, &_d_rho, &_d_info, &_d_s, &_d_rep, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spline1dfitpenalized");
            info = _d_info.intval;
            s = new spline1dinterpolant(_d_s);
            rep = null;
            x_spline1dfitreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            if( _d_s!=null && s==null)
                _i_x_obj_free_spline1dinterpolant(_d_s); // on exception clean up X objects which were not attached to C# objects
            x_spline1dfitreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void spline1dfitpenalized(double[] x, double[] y, int n, int m, double rho, out int info, out spline1dinterpolant s, out spline1dfitreport rep)
    {
        _core_spline1dfitpenalized( x,  y,  n,  m,  rho, out  info, out  s, out  rep, 0x0);
    }
    
    public static void spline1dfitpenalized(double[] x, double[] y, int n, int m, double rho, out int info, out spline1dinterpolant s, out spline1dfitreport rep, alglib.xparams _xparams)
    {
        _core_spline1dfitpenalized( x,  y,  n,  m,  rho, out  info, out  s, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void spline1dfitpenalized(double[] x, double[] y, int m, double rho, out int info, out spline1dinterpolant s, out spline1dfitreport rep)
    {
        int n;
        if( (ap.len(x)!=ap.len(y)))
            throw new alglibexception("Error while calling 'spline1dfitpenalized': looks like one of arguments has wrong size");
        n = ap.len(x);
        _core_spline1dfitpenalized( x,  y,  n,  m,  rho, out  info, out  s, out  rep, 0x0);
    
        
    }
    
    public static void spline1dfitpenalized(double[] x, double[] y, int m, double rho, out int info, out spline1dinterpolant s, out spline1dfitreport rep, alglib.xparams _xparams)
    {
        int n;
        if( (ap.len(x)!=ap.len(y)))
            throw new alglibexception("Error while calling 'spline1dfitpenalized': looks like one of arguments has wrong size");
        n = ap.len(x);
        _core_spline1dfitpenalized( x,  y,  n,  m,  rho, out  info, out  s, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_spline1dfitpenalizedw(double[] x, double[] y, double[] w, int n, int m, double rho, out int info, out spline1dinterpolant s, out spline1dfitreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_vector _d_w = new x_vector();
        x_int _d_n = new x_int(n);
        x_int _d_m = new x_int(m);
        double _d_rho = rho;
        x_int _d_info = new x_int();
        void *_d_s = null;
        s = null;
        x_spline1dfitreport _d_rep = new x_spline1dfitreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y, _fp_w = w){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_vector_attach_to_array(ref _d_w, _fp_w, ap.len(w));
                x_spline1dfitreport_init(ref _d_rep);
                _error_code = _i_xv2_spline1dfitpenalizedw(&_s_errormsg, &_d_x, &_d_y, &_d_w, &_d_n, &_d_m, &_d_rho, &_d_info, &_d_s, &_d_rep, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "spline1dfitpenalizedw");
            info = _d_info.intval;
            s = new spline1dinterpolant(_d_s);
            rep = null;
            x_spline1dfitreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            x_vector_clear(ref _d_w);
            if( _d_s!=null && s==null)
                _i_x_obj_free_spline1dinterpolant(_d_s); // on exception clean up X objects which were not attached to C# objects
            x_spline1dfitreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void spline1dfitpenalizedw(double[] x, double[] y, double[] w, int n, int m, double rho, out int info, out spline1dinterpolant s, out spline1dfitreport rep)
    {
        _core_spline1dfitpenalizedw( x,  y,  w,  n,  m,  rho, out  info, out  s, out  rep, 0x0);
    }
    
    public static void spline1dfitpenalizedw(double[] x, double[] y, double[] w, int n, int m, double rho, out int info, out spline1dinterpolant s, out spline1dfitreport rep, alglib.xparams _xparams)
    {
        _core_spline1dfitpenalizedw( x,  y,  w,  n,  m,  rho, out  info, out  s, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void spline1dfitpenalizedw(double[] x, double[] y, double[] w, int m, double rho, out int info, out spline1dinterpolant s, out spline1dfitreport rep)
    {
        int n;
        if( (ap.len(x)!=ap.len(y)) || (ap.len(x)!=ap.len(w)))
            throw new alglibexception("Error while calling 'spline1dfitpenalizedw': looks like one of arguments has wrong size");
        n = ap.len(x);
        _core_spline1dfitpenalizedw( x,  y,  w,  n,  m,  rho, out  info, out  s, out  rep, 0x0);
    
        
    }
    
    public static void spline1dfitpenalizedw(double[] x, double[] y, double[] w, int m, double rho, out int info, out spline1dinterpolant s, out spline1dfitreport rep, alglib.xparams _xparams)
    {
        int n;
        if( (ap.len(x)!=ap.len(y)) || (ap.len(x)!=ap.len(w)))
            throw new alglibexception("Error while calling 'spline1dfitpenalizedw': looks like one of arguments has wrong size");
        n = ap.len(x);
        _core_spline1dfitpenalizedw( x,  y,  w,  n,  m,  rho, out  info, out  s, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    
    //
    // Subpackage rbf
    //
    

    public unsafe class rbfcalcbuffer : alglibobject
    {
        private void *_ptr;
        public rbfcalcbuffer(void *x)
        {
            _ptr = x;
        }
        ~rbfcalcbuffer()
        {
            _deallocate();
        }
        public void* ptr { get { return _ptr; } }
        public override alglib.alglibobject make_copy()
        {
            if( _ptr==null )
                return new rbfcalcbuffer(null);
            return new rbfcalcbuffer(_i_x_obj_copy_rbfcalcbuffer(_ptr));
        }
        public override void _deallocate()
        {
            if( _ptr!=null )
                _i_x_obj_free_rbfcalcbuffer(_ptr);
            _ptr = null;
            System.GC.SuppressFinalize(this);
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_rbfcalcbuffer(void *x);
    private static _d_x_obj_copy_rbfcalcbuffer _i_x_obj_copy_rbfcalcbuffer = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_obj_free_rbfcalcbuffer(void *x);
    private static _d_x_obj_free_rbfcalcbuffer _i_x_obj_free_rbfcalcbuffer = null;

    public unsafe class rbfmodel : alglibobject
    {
        private void *_ptr;
        public rbfmodel(void *x)
        {
            _ptr = x;
        }
        ~rbfmodel()
        {
            _deallocate();
        }
        public void* ptr { get { return _ptr; } }
        public override alglib.alglibobject make_copy()
        {
            if( _ptr==null )
                return new rbfmodel(null);
            return new rbfmodel(_i_x_obj_copy_rbfmodel(_ptr));
        }
        public override void _deallocate()
        {
            if( _ptr!=null )
                _i_x_obj_free_rbfmodel(_ptr);
            _ptr = null;
            System.GC.SuppressFinalize(this);
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_rbfmodel(void *x);
    private static _d_x_obj_copy_rbfmodel _i_x_obj_copy_rbfmodel = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_obj_free_rbfmodel(void *x);
    private static _d_x_obj_free_rbfmodel _i_x_obj_free_rbfmodel = null;

    [StructLayout(LayoutKind.Sequential, Pack=8)]
    private struct x_rbfreport
    {
        public double rmserror;
        public double maxerror;
        public x_int arows;
        public x_int acols;
        public x_int annz;
        public x_int iterationscount;
        public x_int nmv;
        public x_int terminationtype;
    }

    public class rbfreport : alglibobject
    {
        public double rmserror;
        public double maxerror;
        public int arows;
        public int acols;
        public int annz;
        public int iterationscount;
        public int nmv;
        public int terminationtype;
        public override alglib.alglibobject make_copy()
        {
            rbfreport dst = new rbfreport();
            dst.rmserror = rmserror;
            dst.maxerror = maxerror;
            dst.arows = arows;
            dst.acols = acols;
            dst.annz = annz;
            dst.iterationscount = iterationscount;
            dst.nmv = nmv;
            dst.terminationtype = terminationtype;
            return dst;
        }
    }

    // This function initializes X-structure (its previous content is ignored)
    private static void x_rbfreport_init(ref x_rbfreport x)
    {
        x.rmserror = 0;
        x.maxerror = 0;
        x.arows.longval = 0;
        x.acols.longval = 0;
        x.annz.longval = 0;
        x.iterationscount.longval = 0;
        x.nmv.longval = 0;
        x.terminationtype.longval = 0;
    }

    // This function finalizes fields of X-structure (however, memory occupied by structure itself is not freed)
    // After destruction structure becomes unusable and should be re-initialized if you want to use it
    private static void x_rbfreport_clear(ref x_rbfreport x)
    {
    }

    // This function initializes X-structure by appropriate C# instance
    // (previous content of X structure is ignored)
    private static void x_rbfreport_init_from(ref x_rbfreport x, rbfreport v)
    {
        x.rmserror = v.rmserror;
        x.maxerror = v.maxerror;
        x.arows.longval = v.arows;
        x.acols.longval = v.acols;
        x.annz.longval = v.annz;
        x.iterationscount.longval = v.iterationscount;
        x.nmv.longval = v.nmv;
        x.terminationtype.longval = v.terminationtype;
    }

    // This function initializes C# structure by appropriate X instance
    // (previous content of C# structure is ignored).
    // This function may accept null v, in this case v is automatically allocated with new().
    private static void x_rbfreport_to_record(ref x_rbfreport x, ref rbfreport v)
    {
        if( v==null )
            v = new rbfreport();
        v.rmserror = x.rmserror;
        v.maxerror = x.maxerror;
        v.arows = x.arows.intval; // long is silently truncated to int
        v.acols = x.acols.intval; // long is silently truncated to int
        v.annz = x.annz.intval; // long is silently truncated to int
        v.iterationscount = x.iterationscount.intval; // long is silently truncated to int
        v.nmv = x.nmv.intval; // long is silently truncated to int
        v.terminationtype = x.terminationtype.intval; // long is silently truncated to int
    }
    public static unsafe void rbfserialize(rbfmodel obj, out string s_out)
    {
        byte *_s_errormsg = null;
        byte *_out = null;
        void *_x = obj.ptr;
        try
        {
            int _error_code = _i_x_rbfserialize(&_s_errormsg, &_x, &_out);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rbfserialize");
            s_out = Marshal.PtrToStringAnsi((IntPtr)_out);
        }
        finally
        {
            x_free((IntPtr)_out);
        }
    }
    
    public static unsafe void rbfunserialize(string s_in, out rbfmodel obj)
    {
        byte *_s_errormsg = null;
        byte[] _ain = System.Text.Encoding.UTF8.GetBytes(s_in);
        fixed(byte *_pin = _ain )
        {
            byte *_in = _pin;
            void *_x = null;
            obj = null;
            try
            {
                int _error_code = _i_x_rbfunserialize(&_s_errormsg, &_in, &_x);
                if( _error_code!=X_OK )
                    handle_exception(_error_code, _s_errormsg, "rbfunserialize");
                obj = new rbfmodel(_x);
            }
            finally
            {
                // on exception clean up X objects which were not attached to C# objects
                if( _x!=null && obj==null)
                    _i_x_obj_free_rbfmodel(_x);
            }
        }
    }
    public static unsafe void rbfserialize(rbfmodel obj, System.IO.Stream s_out)
    {
        byte *_s_errormsg = null;
        void *_x = obj.ptr;
        alglib.native_stream_adapter a = new alglib.native_stream_adapter();
        a.sstart_stream(s_out);
        int _error_code = _i_x_rbfserialize_stream(&_s_errormsg, &_x, a.writer_callback, IntPtr.Zero);
        if( _error_code!=X_OK )
            handle_exception(_error_code, _s_errormsg, "rbfserialize");
    }
    
    public static unsafe void rbfunserialize(System.IO.Stream s_in, out rbfmodel obj)
    {
        byte *_s_errormsg = null;
        void *_x = null;
        obj = null;
        alglib.native_stream_adapter a = new alglib.native_stream_adapter();
        a.ustart_stream(s_in);
        try
        {
            int _error_code = _i_x_rbfunserialize_stream(&_s_errormsg, a.reader_callback, IntPtr.Zero, &_x);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rbfunserialize");
            obj = new rbfmodel(_x);
        }
        finally
        {
            // on exception clean up X objects which were not attached to C# objects
            if( _x!=null && obj==null)
                _i_x_obj_free_rbfmodel(_x);
        }
    }
    
    private static unsafe void _core_rbfcreate(int nx, int ny, out rbfmodel s, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_nx = new x_int(nx);
        x_int _d_ny = new x_int(ny);
        void *_d_s = null;
        s = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_rbfcreate(&_s_errormsg, &_d_nx, &_d_ny, &_d_s, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rbfcreate");
            s = new rbfmodel(_d_s);
        }
        finally
        {
            if( _d_s!=null && s==null)
                _i_x_obj_free_rbfmodel(_d_s); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void rbfcreate(int nx, int ny, out rbfmodel s)
    {
        _core_rbfcreate( nx,  ny, out  s, 0x0);
    }
    
    public static void rbfcreate(int nx, int ny, out rbfmodel s, alglib.xparams _xparams)
    {
        _core_rbfcreate( nx,  ny, out  s, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_rbfcreatecalcbuffer(rbfmodel s, out rbfcalcbuffer buf, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        void *_d_buf = null;
        buf = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_rbfcreatecalcbuffer(&_s_errormsg, &_d_s, &_d_buf, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rbfcreatecalcbuffer");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            buf = new rbfcalcbuffer(_d_buf);
        }
        finally
        {
            if( _d_buf!=null && buf==null)
                _i_x_obj_free_rbfcalcbuffer(_d_buf); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void rbfcreatecalcbuffer(rbfmodel s, out rbfcalcbuffer buf)
    {
        _core_rbfcreatecalcbuffer( s, out  buf, 0x0);
    }
    
    public static void rbfcreatecalcbuffer(rbfmodel s, out rbfcalcbuffer buf, alglib.xparams _xparams)
    {
        _core_rbfcreatecalcbuffer( s, out  buf, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_rbfsetpoints(rbfmodel s, double[,] xy, int n, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_n = new x_int(n);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_xv2_rbfsetpoints(&_s_errormsg, &_d_s, &_d_xy, &_d_n, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rbfsetpoints");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
        }
        // This function returns no value.
    }
    
    public static void rbfsetpoints(rbfmodel s, double[,] xy, int n)
    {
        _core_rbfsetpoints( s,  xy,  n, 0x0);
    }
    
    public static void rbfsetpoints(rbfmodel s, double[,] xy, int n, alglib.xparams _xparams)
    {
        _core_rbfsetpoints( s,  xy,  n, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void rbfsetpoints(rbfmodel s, double[,] xy)
    {
        int n;
    
        n = ap.rows(xy);
        _core_rbfsetpoints( s,  xy,  n, 0x0);
    
        
    }
    
    public static void rbfsetpoints(rbfmodel s, double[,] xy, alglib.xparams _xparams)
    {
        int n;
    
        n = ap.rows(xy);
        _core_rbfsetpoints( s,  xy,  n, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_rbfsetpointsandscales(rbfmodel r, double[,] xy, int n, double[] s, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_r = r.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_n = new x_int(n);
        x_vector _d_s = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy, _fp_s = s){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                x_vector_attach_to_array(ref _d_s, _fp_s, ap.len(s));
                _error_code = _i_xv2_rbfsetpointsandscales(&_s_errormsg, &_d_r, &_d_xy, &_d_n, &_d_s, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rbfsetpointsandscales");
            ap.assert(r.ptr==_d_r, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
            x_vector_clear(ref _d_s);
        }
        // This function returns no value.
    }
    
    public static void rbfsetpointsandscales(rbfmodel r, double[,] xy, int n, double[] s)
    {
        _core_rbfsetpointsandscales( r,  xy,  n,  s, 0x0);
    }
    
    public static void rbfsetpointsandscales(rbfmodel r, double[,] xy, int n, double[] s, alglib.xparams _xparams)
    {
        _core_rbfsetpointsandscales( r,  xy,  n,  s, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void rbfsetpointsandscales(rbfmodel r, double[,] xy, double[] s)
    {
        int n;
    
        n = ap.rows(xy);
        _core_rbfsetpointsandscales( r,  xy,  n,  s, 0x0);
    
        
    }
    
    public static void rbfsetpointsandscales(rbfmodel r, double[,] xy, double[] s, alglib.xparams _xparams)
    {
        int n;
    
        n = ap.rows(xy);
        _core_rbfsetpointsandscales( r,  xy,  n,  s, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_rbfsetalgoqnn(rbfmodel s, double q, double z, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        double _d_q = q;
        double _d_z = z;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_rbfsetalgoqnn(&_s_errormsg, &_d_s, &_d_q, &_d_z, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rbfsetalgoqnn");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void rbfsetalgoqnn(rbfmodel s, double q, double z)
    {
        _core_rbfsetalgoqnn( s,  q,  z, 0x0);
    }
    
    public static void rbfsetalgoqnn(rbfmodel s, double q, double z, alglib.xparams _xparams)
    {
        _core_rbfsetalgoqnn( s,  q,  z, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void rbfsetalgoqnn(rbfmodel s)
    {
        double q;
        double z;
    
        q = 1.0;
        z = 5.0;
        _core_rbfsetalgoqnn( s,  q,  z, 0x0);
    
        
    }
    
    public static void rbfsetalgoqnn(rbfmodel s, alglib.xparams _xparams)
    {
        double q;
        double z;
    
        q = 1.0;
        z = 5.0;
        _core_rbfsetalgoqnn( s,  q,  z, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_rbfsetalgomultilayer(rbfmodel s, double rbase, int nlayers, double lambdav, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        double _d_rbase = rbase;
        x_int _d_nlayers = new x_int(nlayers);
        double _d_lambdav = lambdav;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_rbfsetalgomultilayer(&_s_errormsg, &_d_s, &_d_rbase, &_d_nlayers, &_d_lambdav, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rbfsetalgomultilayer");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void rbfsetalgomultilayer(rbfmodel s, double rbase, int nlayers, double lambdav)
    {
        _core_rbfsetalgomultilayer( s,  rbase,  nlayers,  lambdav, 0x0);
    }
    
    public static void rbfsetalgomultilayer(rbfmodel s, double rbase, int nlayers, double lambdav, alglib.xparams _xparams)
    {
        _core_rbfsetalgomultilayer( s,  rbase,  nlayers,  lambdav, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void rbfsetalgomultilayer(rbfmodel s, double rbase, int nlayers)
    {
        double lambdav;
    
        lambdav = 0.01;
        _core_rbfsetalgomultilayer( s,  rbase,  nlayers,  lambdav, 0x0);
    
        
    }
    
    public static void rbfsetalgomultilayer(rbfmodel s, double rbase, int nlayers, alglib.xparams _xparams)
    {
        double lambdav;
    
        lambdav = 0.01;
        _core_rbfsetalgomultilayer( s,  rbase,  nlayers,  lambdav, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_rbfsetalgohierarchical(rbfmodel s, double rbase, int nlayers, double lambdans, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        double _d_rbase = rbase;
        x_int _d_nlayers = new x_int(nlayers);
        double _d_lambdans = lambdans;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_rbfsetalgohierarchical(&_s_errormsg, &_d_s, &_d_rbase, &_d_nlayers, &_d_lambdans, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rbfsetalgohierarchical");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void rbfsetalgohierarchical(rbfmodel s, double rbase, int nlayers, double lambdans)
    {
        _core_rbfsetalgohierarchical( s,  rbase,  nlayers,  lambdans, 0x0);
    }
    
    public static void rbfsetalgohierarchical(rbfmodel s, double rbase, int nlayers, double lambdans, alglib.xparams _xparams)
    {
        _core_rbfsetalgohierarchical( s,  rbase,  nlayers,  lambdans, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_rbfsetalgothinplatespline(rbfmodel s, double lambdav, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        double _d_lambdav = lambdav;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_rbfsetalgothinplatespline(&_s_errormsg, &_d_s, &_d_lambdav, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rbfsetalgothinplatespline");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void rbfsetalgothinplatespline(rbfmodel s, double lambdav)
    {
        _core_rbfsetalgothinplatespline( s,  lambdav, 0x0);
    }
    
    public static void rbfsetalgothinplatespline(rbfmodel s, double lambdav, alglib.xparams _xparams)
    {
        _core_rbfsetalgothinplatespline( s,  lambdav, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void rbfsetalgothinplatespline(rbfmodel s)
    {
        double lambdav;
    
        lambdav = 0.0;
        _core_rbfsetalgothinplatespline( s,  lambdav, 0x0);
    
        
    }
    
    public static void rbfsetalgothinplatespline(rbfmodel s, alglib.xparams _xparams)
    {
        double lambdav;
    
        lambdav = 0.0;
        _core_rbfsetalgothinplatespline( s,  lambdav, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_rbfsetalgomultiquadricmanual(rbfmodel s, double alpha, double lambdav, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        double _d_alpha = alpha;
        double _d_lambdav = lambdav;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_rbfsetalgomultiquadricmanual(&_s_errormsg, &_d_s, &_d_alpha, &_d_lambdav, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rbfsetalgomultiquadricmanual");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void rbfsetalgomultiquadricmanual(rbfmodel s, double alpha, double lambdav)
    {
        _core_rbfsetalgomultiquadricmanual( s,  alpha,  lambdav, 0x0);
    }
    
    public static void rbfsetalgomultiquadricmanual(rbfmodel s, double alpha, double lambdav, alglib.xparams _xparams)
    {
        _core_rbfsetalgomultiquadricmanual( s,  alpha,  lambdav, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void rbfsetalgomultiquadricmanual(rbfmodel s, double alpha)
    {
        double lambdav;
    
        lambdav = 0.0;
        _core_rbfsetalgomultiquadricmanual( s,  alpha,  lambdav, 0x0);
    
        
    }
    
    public static void rbfsetalgomultiquadricmanual(rbfmodel s, double alpha, alglib.xparams _xparams)
    {
        double lambdav;
    
        lambdav = 0.0;
        _core_rbfsetalgomultiquadricmanual( s,  alpha,  lambdav, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_rbfsetalgomultiquadricauto(rbfmodel s, double lambdav, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        double _d_lambdav = lambdav;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_rbfsetalgomultiquadricauto(&_s_errormsg, &_d_s, &_d_lambdav, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rbfsetalgomultiquadricauto");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void rbfsetalgomultiquadricauto(rbfmodel s, double lambdav)
    {
        _core_rbfsetalgomultiquadricauto( s,  lambdav, 0x0);
    }
    
    public static void rbfsetalgomultiquadricauto(rbfmodel s, double lambdav, alglib.xparams _xparams)
    {
        _core_rbfsetalgomultiquadricauto( s,  lambdav, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void rbfsetalgomultiquadricauto(rbfmodel s)
    {
        double lambdav;
    
        lambdav = 0.0;
        _core_rbfsetalgomultiquadricauto( s,  lambdav, 0x0);
    
        
    }
    
    public static void rbfsetalgomultiquadricauto(rbfmodel s, alglib.xparams _xparams)
    {
        double lambdav;
    
        lambdav = 0.0;
        _core_rbfsetalgomultiquadricauto( s,  lambdav, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_rbfsetalgobiharmonic(rbfmodel s, double lambdav, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        double _d_lambdav = lambdav;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_rbfsetalgobiharmonic(&_s_errormsg, &_d_s, &_d_lambdav, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rbfsetalgobiharmonic");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void rbfsetalgobiharmonic(rbfmodel s, double lambdav)
    {
        _core_rbfsetalgobiharmonic( s,  lambdav, 0x0);
    }
    
    public static void rbfsetalgobiharmonic(rbfmodel s, double lambdav, alglib.xparams _xparams)
    {
        _core_rbfsetalgobiharmonic( s,  lambdav, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void rbfsetalgobiharmonic(rbfmodel s)
    {
        double lambdav;
    
        lambdav = 0.0;
        _core_rbfsetalgobiharmonic( s,  lambdav, 0x0);
    
        
    }
    
    public static void rbfsetalgobiharmonic(rbfmodel s, alglib.xparams _xparams)
    {
        double lambdav;
    
        lambdav = 0.0;
        _core_rbfsetalgobiharmonic( s,  lambdav, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_rbfsetlinterm(rbfmodel s, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_rbfsetlinterm(&_s_errormsg, &_d_s, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rbfsetlinterm");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void rbfsetlinterm(rbfmodel s)
    {
        _core_rbfsetlinterm( s, 0x0);
    }
    
    public static void rbfsetlinterm(rbfmodel s, alglib.xparams _xparams)
    {
        _core_rbfsetlinterm( s, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_rbfsetconstterm(rbfmodel s, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_rbfsetconstterm(&_s_errormsg, &_d_s, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rbfsetconstterm");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void rbfsetconstterm(rbfmodel s)
    {
        _core_rbfsetconstterm( s, 0x0);
    }
    
    public static void rbfsetconstterm(rbfmodel s, alglib.xparams _xparams)
    {
        _core_rbfsetconstterm( s, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_rbfsetzeroterm(rbfmodel s, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_rbfsetzeroterm(&_s_errormsg, &_d_s, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rbfsetzeroterm");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void rbfsetzeroterm(rbfmodel s)
    {
        _core_rbfsetzeroterm( s, 0x0);
    }
    
    public static void rbfsetzeroterm(rbfmodel s, alglib.xparams _xparams)
    {
        _core_rbfsetzeroterm( s, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_rbfsetv2bf(rbfmodel s, int bf, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_int _d_bf = new x_int(bf);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_rbfsetv2bf(&_s_errormsg, &_d_s, &_d_bf, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rbfsetv2bf");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void rbfsetv2bf(rbfmodel s, int bf)
    {
        _core_rbfsetv2bf( s,  bf, 0x0);
    }
    
    public static void rbfsetv2bf(rbfmodel s, int bf, alglib.xparams _xparams)
    {
        _core_rbfsetv2bf( s,  bf, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_rbfsetv2its(rbfmodel s, int maxits, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_int _d_maxits = new x_int(maxits);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_rbfsetv2its(&_s_errormsg, &_d_s, &_d_maxits, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rbfsetv2its");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void rbfsetv2its(rbfmodel s, int maxits)
    {
        _core_rbfsetv2its( s,  maxits, 0x0);
    }
    
    public static void rbfsetv2its(rbfmodel s, int maxits, alglib.xparams _xparams)
    {
        _core_rbfsetv2its( s,  maxits, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_rbfsetv2supportr(rbfmodel s, double r, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        double _d_r = r;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_rbfsetv2supportr(&_s_errormsg, &_d_s, &_d_r, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rbfsetv2supportr");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void rbfsetv2supportr(rbfmodel s, double r)
    {
        _core_rbfsetv2supportr( s,  r, 0x0);
    }
    
    public static void rbfsetv2supportr(rbfmodel s, double r, alglib.xparams _xparams)
    {
        _core_rbfsetv2supportr( s,  r, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_rbfsetv3tol(rbfmodel s, double tol, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        double _d_tol = tol;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_rbfsetv3tol(&_s_errormsg, &_d_s, &_d_tol, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rbfsetv3tol");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void rbfsetv3tol(rbfmodel s, double tol)
    {
        _core_rbfsetv3tol( s,  tol, 0x0);
    }
    
    public static void rbfsetv3tol(rbfmodel s, double tol, alglib.xparams _xparams)
    {
        _core_rbfsetv3tol( s,  tol, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_rbfbuildmodel(rbfmodel s, out rbfreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_rbfreport _d_rep = new x_rbfreport();
        
        // Pack, call, unpack
        try
        {
            x_rbfreport_init(ref _d_rep);
            _error_code = _i_xv2_rbfbuildmodel(&_s_errormsg, &_d_s, &_d_rep, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rbfbuildmodel");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            rep = null;
            x_rbfreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_rbfreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void rbfbuildmodel(rbfmodel s, out rbfreport rep)
    {
        _core_rbfbuildmodel( s, out  rep, 0x0);
    }
    
    public static void rbfbuildmodel(rbfmodel s, out rbfreport rep, alglib.xparams _xparams)
    {
        _core_rbfbuildmodel( s, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_rbfcalc1(rbfmodel s, double x0, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_s = s.ptr;
        double _d_x0 = x0;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_rbfcalc1(&_s_errormsg, &_d_result, &_d_s, &_d_x0, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rbfcalc1");
            result = _d_result;
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double rbfcalc1(rbfmodel s, double x0)
    {
        return _core_rbfcalc1( s,  x0, 0x0);
    }
    
    public static double rbfcalc1(rbfmodel s, double x0, alglib.xparams _xparams)
    {
        return _core_rbfcalc1( s,  x0, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_rbfcalc2(rbfmodel s, double x0, double x1, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_s = s.ptr;
        double _d_x0 = x0;
        double _d_x1 = x1;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_rbfcalc2(&_s_errormsg, &_d_result, &_d_s, &_d_x0, &_d_x1, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rbfcalc2");
            result = _d_result;
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double rbfcalc2(rbfmodel s, double x0, double x1)
    {
        return _core_rbfcalc2( s,  x0,  x1, 0x0);
    }
    
    public static double rbfcalc2(rbfmodel s, double x0, double x1, alglib.xparams _xparams)
    {
        return _core_rbfcalc2( s,  x0,  x1, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_rbfcalc3(rbfmodel s, double x0, double x1, double x2, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_s = s.ptr;
        double _d_x0 = x0;
        double _d_x1 = x1;
        double _d_x2 = x2;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_rbfcalc3(&_s_errormsg, &_d_result, &_d_s, &_d_x0, &_d_x1, &_d_x2, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rbfcalc3");
            result = _d_result;
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double rbfcalc3(rbfmodel s, double x0, double x1, double x2)
    {
        return _core_rbfcalc3( s,  x0,  x1,  x2, 0x0);
    }
    
    public static double rbfcalc3(rbfmodel s, double x0, double x1, double x2, alglib.xparams _xparams)
    {
        return _core_rbfcalc3( s,  x0,  x1,  x2, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_rbfdiff1(rbfmodel s, double x0, out double y, out double dy0, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        double _d_x0 = x0;
        double _d_y = 0;
        double _d_dy0 = 0;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_rbfdiff1(&_s_errormsg, &_d_s, &_d_x0, &_d_y, &_d_dy0, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rbfdiff1");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            y = _d_y;
            dy0 = _d_dy0;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void rbfdiff1(rbfmodel s, double x0, out double y, out double dy0)
    {
        _core_rbfdiff1( s,  x0, out  y, out  dy0, 0x0);
    }
    
    public static void rbfdiff1(rbfmodel s, double x0, out double y, out double dy0, alglib.xparams _xparams)
    {
        _core_rbfdiff1( s,  x0, out  y, out  dy0, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_rbfdiff2(rbfmodel s, double x0, double x1, out double y, out double dy0, out double dy1, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        double _d_x0 = x0;
        double _d_x1 = x1;
        double _d_y = 0;
        double _d_dy0 = 0;
        double _d_dy1 = 0;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_rbfdiff2(&_s_errormsg, &_d_s, &_d_x0, &_d_x1, &_d_y, &_d_dy0, &_d_dy1, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rbfdiff2");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            y = _d_y;
            dy0 = _d_dy0;
            dy1 = _d_dy1;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void rbfdiff2(rbfmodel s, double x0, double x1, out double y, out double dy0, out double dy1)
    {
        _core_rbfdiff2( s,  x0,  x1, out  y, out  dy0, out  dy1, 0x0);
    }
    
    public static void rbfdiff2(rbfmodel s, double x0, double x1, out double y, out double dy0, out double dy1, alglib.xparams _xparams)
    {
        _core_rbfdiff2( s,  x0,  x1, out  y, out  dy0, out  dy1, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_rbfdiff3(rbfmodel s, double x0, double x1, double x2, out double y, out double dy0, out double dy1, out double dy2, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        double _d_x0 = x0;
        double _d_x1 = x1;
        double _d_x2 = x2;
        double _d_y = 0;
        double _d_dy0 = 0;
        double _d_dy1 = 0;
        double _d_dy2 = 0;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_rbfdiff3(&_s_errormsg, &_d_s, &_d_x0, &_d_x1, &_d_x2, &_d_y, &_d_dy0, &_d_dy1, &_d_dy2, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rbfdiff3");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            y = _d_y;
            dy0 = _d_dy0;
            dy1 = _d_dy1;
            dy2 = _d_dy2;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void rbfdiff3(rbfmodel s, double x0, double x1, double x2, out double y, out double dy0, out double dy1, out double dy2)
    {
        _core_rbfdiff3( s,  x0,  x1,  x2, out  y, out  dy0, out  dy1, out  dy2, 0x0);
    }
    
    public static void rbfdiff3(rbfmodel s, double x0, double x1, double x2, out double y, out double dy0, out double dy1, out double dy2, alglib.xparams _xparams)
    {
        _core_rbfdiff3( s,  x0,  x1,  x2, out  y, out  dy0, out  dy1, out  dy2, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_rbfsetfastevaltol(rbfmodel s, double tol, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        double _d_tol = tol;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_rbfsetfastevaltol(&_s_errormsg, &_d_s, &_d_tol, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rbfsetfastevaltol");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void rbfsetfastevaltol(rbfmodel s, double tol)
    {
        _core_rbfsetfastevaltol( s,  tol, 0x0);
    }
    
    public static void rbfsetfastevaltol(rbfmodel s, double tol, alglib.xparams _xparams)
    {
        _core_rbfsetfastevaltol( s,  tol, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_rbffastcalc(rbfmodel s, double[] x, out double[] y, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_create_empty(ref _d_y, DT_REAL);
                y = null;
                _error_code = _i_xv2_rbffastcalc(&_s_errormsg, &_d_s, &_d_x, &_d_y, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rbffastcalc");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_y.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_y, ref y);
            if( y == null )
                y = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
        }
        // This function returns no value.
    }
    
    public static void rbffastcalc(rbfmodel s, double[] x, out double[] y)
    {
        _core_rbffastcalc( s,  x, out  y, 0x0);
    }
    
    public static void rbffastcalc(rbfmodel s, double[] x, out double[] y, alglib.xparams _xparams)
    {
        _core_rbffastcalc( s,  x, out  y, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_rbfcalc(rbfmodel s, double[] x, out double[] y, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_create_empty(ref _d_y, DT_REAL);
                y = null;
                _error_code = _i_xv2_rbfcalc(&_s_errormsg, &_d_s, &_d_x, &_d_y, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rbfcalc");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_y.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_y, ref y);
            if( y == null )
                y = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
        }
        // This function returns no value.
    }
    
    public static void rbfcalc(rbfmodel s, double[] x, out double[] y)
    {
        _core_rbfcalc( s,  x, out  y, 0x0);
    }
    
    public static void rbfcalc(rbfmodel s, double[] x, out double[] y, alglib.xparams _xparams)
    {
        _core_rbfcalc( s,  x, out  y, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_rbfdiff(rbfmodel s, double[] x, out double[] y, out double[] dy, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_vector _d_dy = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_create_empty(ref _d_y, DT_REAL);
                y = null;
                x_vector_create_empty(ref _d_dy, DT_REAL);
                dy = null;
                _error_code = _i_xv2_rbfdiff(&_s_errormsg, &_d_s, &_d_x, &_d_y, &_d_dy, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rbfdiff");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_y.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_y, ref y);
            if( y == null )
                y = new double[0];
            if( _d_dy.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_dy, ref dy);
            if( dy == null )
                dy = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            x_vector_clear(ref _d_dy);
        }
        // This function returns no value.
    }
    
    public static void rbfdiff(rbfmodel s, double[] x, out double[] y, out double[] dy)
    {
        _core_rbfdiff( s,  x, out  y, out  dy, 0x0);
    }
    
    public static void rbfdiff(rbfmodel s, double[] x, out double[] y, out double[] dy, alglib.xparams _xparams)
    {
        _core_rbfdiff( s,  x, out  y, out  dy, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_rbfhess(rbfmodel s, double[] x, out double[] y, out double[] dy, out double[] d2y, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_vector _d_dy = new x_vector();
        x_vector _d_d2y = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_create_empty(ref _d_y, DT_REAL);
                y = null;
                x_vector_create_empty(ref _d_dy, DT_REAL);
                dy = null;
                x_vector_create_empty(ref _d_d2y, DT_REAL);
                d2y = null;
                _error_code = _i_xv2_rbfhess(&_s_errormsg, &_d_s, &_d_x, &_d_y, &_d_dy, &_d_d2y, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rbfhess");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_y.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_y, ref y);
            if( y == null )
                y = new double[0];
            if( _d_dy.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_dy, ref dy);
            if( dy == null )
                dy = new double[0];
            if( _d_d2y.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_d2y, ref d2y);
            if( d2y == null )
                d2y = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            x_vector_clear(ref _d_dy);
            x_vector_clear(ref _d_d2y);
        }
        // This function returns no value.
    }
    
    public static void rbfhess(rbfmodel s, double[] x, out double[] y, out double[] dy, out double[] d2y)
    {
        _core_rbfhess( s,  x, out  y, out  dy, out  d2y, 0x0);
    }
    
    public static void rbfhess(rbfmodel s, double[] x, out double[] y, out double[] dy, out double[] d2y, alglib.xparams _xparams)
    {
        _core_rbfhess( s,  x, out  y, out  dy, out  d2y, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_rbfcalcbuf(rbfmodel s, double[] x, ref double[] y, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                _error_code = _i_xv2_rbfcalcbuf(&_s_errormsg, &_d_s, &_d_x, &_d_y, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rbfcalcbuf");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_y.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_y, ref y);
            if( y == null )
                y = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
        }
        // This function returns no value.
    }
    
    public static void rbfcalcbuf(rbfmodel s, double[] x, ref double[] y)
    {
        _core_rbfcalcbuf( s,  x, ref  y, 0x0);
    }
    
    public static void rbfcalcbuf(rbfmodel s, double[] x, ref double[] y, alglib.xparams _xparams)
    {
        _core_rbfcalcbuf( s,  x, ref  y, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_rbfdiffbuf(rbfmodel s, double[] x, ref double[] y, ref double[] dy, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_vector _d_dy = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y, _fp_dy = dy){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_vector_attach_to_array(ref _d_dy, _fp_dy, ap.len(dy));
                _error_code = _i_xv2_rbfdiffbuf(&_s_errormsg, &_d_s, &_d_x, &_d_y, &_d_dy, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rbfdiffbuf");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_y.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_y, ref y);
            if( y == null )
                y = new double[0];
            if( _d_dy.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_dy, ref dy);
            if( dy == null )
                dy = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            x_vector_clear(ref _d_dy);
        }
        // This function returns no value.
    }
    
    public static void rbfdiffbuf(rbfmodel s, double[] x, ref double[] y, ref double[] dy)
    {
        _core_rbfdiffbuf( s,  x, ref  y, ref  dy, 0x0);
    }
    
    public static void rbfdiffbuf(rbfmodel s, double[] x, ref double[] y, ref double[] dy, alglib.xparams _xparams)
    {
        _core_rbfdiffbuf( s,  x, ref  y, ref  dy, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_rbfhessbuf(rbfmodel s, double[] x, ref double[] y, ref double[] dy, ref double[] d2y, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_vector _d_dy = new x_vector();
        x_vector _d_d2y = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y, _fp_dy = dy, _fp_d2y = d2y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_vector_attach_to_array(ref _d_dy, _fp_dy, ap.len(dy));
                x_vector_attach_to_array(ref _d_d2y, _fp_d2y, ap.len(d2y));
                _error_code = _i_xv2_rbfhessbuf(&_s_errormsg, &_d_s, &_d_x, &_d_y, &_d_dy, &_d_d2y, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rbfhessbuf");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_y.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_y, ref y);
            if( y == null )
                y = new double[0];
            if( _d_dy.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_dy, ref dy);
            if( dy == null )
                dy = new double[0];
            if( _d_d2y.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_d2y, ref d2y);
            if( d2y == null )
                d2y = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            x_vector_clear(ref _d_dy);
            x_vector_clear(ref _d_d2y);
        }
        // This function returns no value.
    }
    
    public static void rbfhessbuf(rbfmodel s, double[] x, ref double[] y, ref double[] dy, ref double[] d2y)
    {
        _core_rbfhessbuf( s,  x, ref  y, ref  dy, ref  d2y, 0x0);
    }
    
    public static void rbfhessbuf(rbfmodel s, double[] x, ref double[] y, ref double[] dy, ref double[] d2y, alglib.xparams _xparams)
    {
        _core_rbfhessbuf( s,  x, ref  y, ref  dy, ref  d2y, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_rbftscalcbuf(rbfmodel s, rbfcalcbuffer buf, double[] x, ref double[] y, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        void *_d_buf = buf.ptr;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                _error_code = _i_xv2_rbftscalcbuf(&_s_errormsg, &_d_s, &_d_buf, &_d_x, &_d_y, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rbftscalcbuf");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            ap.assert(buf.ptr==_d_buf, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_y.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_y, ref y);
            if( y == null )
                y = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
        }
        // This function returns no value.
    }
    
    public static void rbftscalcbuf(rbfmodel s, rbfcalcbuffer buf, double[] x, ref double[] y)
    {
        _core_rbftscalcbuf( s,  buf,  x, ref  y, 0x0);
    }
    
    public static void rbftscalcbuf(rbfmodel s, rbfcalcbuffer buf, double[] x, ref double[] y, alglib.xparams _xparams)
    {
        _core_rbftscalcbuf( s,  buf,  x, ref  y, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_rbftsdiffbuf(rbfmodel s, rbfcalcbuffer buf, double[] x, ref double[] y, ref double[] dy, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        void *_d_buf = buf.ptr;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_vector _d_dy = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y, _fp_dy = dy){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_vector_attach_to_array(ref _d_dy, _fp_dy, ap.len(dy));
                _error_code = _i_xv2_rbftsdiffbuf(&_s_errormsg, &_d_s, &_d_buf, &_d_x, &_d_y, &_d_dy, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rbftsdiffbuf");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            ap.assert(buf.ptr==_d_buf, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_y.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_y, ref y);
            if( y == null )
                y = new double[0];
            if( _d_dy.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_dy, ref dy);
            if( dy == null )
                dy = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            x_vector_clear(ref _d_dy);
        }
        // This function returns no value.
    }
    
    public static void rbftsdiffbuf(rbfmodel s, rbfcalcbuffer buf, double[] x, ref double[] y, ref double[] dy)
    {
        _core_rbftsdiffbuf( s,  buf,  x, ref  y, ref  dy, 0x0);
    }
    
    public static void rbftsdiffbuf(rbfmodel s, rbfcalcbuffer buf, double[] x, ref double[] y, ref double[] dy, alglib.xparams _xparams)
    {
        _core_rbftsdiffbuf( s,  buf,  x, ref  y, ref  dy, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_rbftshessbuf(rbfmodel s, rbfcalcbuffer buf, double[] x, ref double[] y, ref double[] dy, ref double[] d2y, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        void *_d_buf = buf.ptr;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_vector _d_dy = new x_vector();
        x_vector _d_d2y = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y, _fp_dy = dy, _fp_d2y = d2y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_vector_attach_to_array(ref _d_dy, _fp_dy, ap.len(dy));
                x_vector_attach_to_array(ref _d_d2y, _fp_d2y, ap.len(d2y));
                _error_code = _i_xv2_rbftshessbuf(&_s_errormsg, &_d_s, &_d_buf, &_d_x, &_d_y, &_d_dy, &_d_d2y, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rbftshessbuf");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            ap.assert(buf.ptr==_d_buf, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_y.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_y, ref y);
            if( y == null )
                y = new double[0];
            if( _d_dy.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_dy, ref dy);
            if( dy == null )
                dy = new double[0];
            if( _d_d2y.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_d2y, ref d2y);
            if( d2y == null )
                d2y = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            x_vector_clear(ref _d_dy);
            x_vector_clear(ref _d_d2y);
        }
        // This function returns no value.
    }
    
    public static void rbftshessbuf(rbfmodel s, rbfcalcbuffer buf, double[] x, ref double[] y, ref double[] dy, ref double[] d2y)
    {
        _core_rbftshessbuf( s,  buf,  x, ref  y, ref  dy, ref  d2y, 0x0);
    }
    
    public static void rbftshessbuf(rbfmodel s, rbfcalcbuffer buf, double[] x, ref double[] y, ref double[] dy, ref double[] d2y, alglib.xparams _xparams)
    {
        _core_rbftshessbuf( s,  buf,  x, ref  y, ref  dy, ref  d2y, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_rbfgridcalc2(rbfmodel s, double[] x0, int n0, double[] x1, int n1, out double[,] y, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_vector _d_x0 = new x_vector();
        x_int _d_n0 = new x_int(n0);
        x_vector _d_x1 = new x_vector();
        x_int _d_n1 = new x_int(n1);
        x_matrix _d_y = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x0 = x0, _fp_x1 = x1){
                x_vector_attach_to_array(ref _d_x0, _fp_x0, ap.len(x0));
                x_vector_attach_to_array(ref _d_x1, _fp_x1, ap.len(x1));
                x_matrix_create_empty(ref _d_y, DT_REAL);
                y = null;
                _error_code = _i_xv2_rbfgridcalc2(&_s_errormsg, &_d_s, &_d_x0, &_d_n0, &_d_x1, &_d_n1, &_d_y, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rbfgridcalc2");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_y.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_y, ref y);
            if( y == null )
                y = new double[0,0];
        }
        finally
        {
            x_vector_clear(ref _d_x0);
            x_vector_clear(ref _d_x1);
            x_matrix_clear(ref _d_y);
        }
        // This function returns no value.
    }
    
    public static void rbfgridcalc2(rbfmodel s, double[] x0, int n0, double[] x1, int n1, out double[,] y)
    {
        _core_rbfgridcalc2( s,  x0,  n0,  x1,  n1, out  y, 0x0);
    }
    
    public static void rbfgridcalc2(rbfmodel s, double[] x0, int n0, double[] x1, int n1, out double[,] y, alglib.xparams _xparams)
    {
        _core_rbfgridcalc2( s,  x0,  n0,  x1,  n1, out  y, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_rbfgridcalc2v(rbfmodel s, double[] x0, int n0, double[] x1, int n1, out double[] y, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_vector _d_x0 = new x_vector();
        x_int _d_n0 = new x_int(n0);
        x_vector _d_x1 = new x_vector();
        x_int _d_n1 = new x_int(n1);
        x_vector _d_y = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x0 = x0, _fp_x1 = x1){
                x_vector_attach_to_array(ref _d_x0, _fp_x0, ap.len(x0));
                x_vector_attach_to_array(ref _d_x1, _fp_x1, ap.len(x1));
                x_vector_create_empty(ref _d_y, DT_REAL);
                y = null;
                _error_code = _i_xv2_rbfgridcalc2v(&_s_errormsg, &_d_s, &_d_x0, &_d_n0, &_d_x1, &_d_n1, &_d_y, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rbfgridcalc2v");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_y.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_y, ref y);
            if( y == null )
                y = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x0);
            x_vector_clear(ref _d_x1);
            x_vector_clear(ref _d_y);
        }
        // This function returns no value.
    }
    
    public static void rbfgridcalc2v(rbfmodel s, double[] x0, int n0, double[] x1, int n1, out double[] y)
    {
        _core_rbfgridcalc2v( s,  x0,  n0,  x1,  n1, out  y, 0x0);
    }
    
    public static void rbfgridcalc2v(rbfmodel s, double[] x0, int n0, double[] x1, int n1, out double[] y, alglib.xparams _xparams)
    {
        _core_rbfgridcalc2v( s,  x0,  n0,  x1,  n1, out  y, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_rbfgridcalc2vsubset(rbfmodel s, double[] x0, int n0, double[] x1, int n1, bool[] flagy, out double[] y, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_vector _d_x0 = new x_vector();
        x_int _d_n0 = new x_int(n0);
        x_vector _d_x1 = new x_vector();
        x_int _d_n1 = new x_int(n1);
        x_vector _d_flagy = new x_vector();
        x_vector _d_y = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x0 = x0, _fp_x1 = x1){fixed(bool* _fp_flagy = flagy){
                x_vector_attach_to_array(ref _d_x0, _fp_x0, ap.len(x0));
                x_vector_attach_to_array(ref _d_x1, _fp_x1, ap.len(x1));
                x_vector_attach_to_array(ref _d_flagy, _fp_flagy, ap.len(flagy));
                x_vector_create_empty(ref _d_y, DT_REAL);
                y = null;
                _error_code = _i_xv2_rbfgridcalc2vsubset(&_s_errormsg, &_d_s, &_d_x0, &_d_n0, &_d_x1, &_d_n1, &_d_flagy, &_d_y, _xparams);
            }}
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rbfgridcalc2vsubset");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_y.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_y, ref y);
            if( y == null )
                y = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x0);
            x_vector_clear(ref _d_x1);
            x_vector_clear(ref _d_flagy);
            x_vector_clear(ref _d_y);
        }
        // This function returns no value.
    }
    
    public static void rbfgridcalc2vsubset(rbfmodel s, double[] x0, int n0, double[] x1, int n1, bool[] flagy, out double[] y)
    {
        _core_rbfgridcalc2vsubset( s,  x0,  n0,  x1,  n1,  flagy, out  y, 0x0);
    }
    
    public static void rbfgridcalc2vsubset(rbfmodel s, double[] x0, int n0, double[] x1, int n1, bool[] flagy, out double[] y, alglib.xparams _xparams)
    {
        _core_rbfgridcalc2vsubset( s,  x0,  n0,  x1,  n1,  flagy, out  y, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_rbfgridcalc3v(rbfmodel s, double[] x0, int n0, double[] x1, int n1, double[] x2, int n2, out double[] y, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_vector _d_x0 = new x_vector();
        x_int _d_n0 = new x_int(n0);
        x_vector _d_x1 = new x_vector();
        x_int _d_n1 = new x_int(n1);
        x_vector _d_x2 = new x_vector();
        x_int _d_n2 = new x_int(n2);
        x_vector _d_y = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x0 = x0, _fp_x1 = x1, _fp_x2 = x2){
                x_vector_attach_to_array(ref _d_x0, _fp_x0, ap.len(x0));
                x_vector_attach_to_array(ref _d_x1, _fp_x1, ap.len(x1));
                x_vector_attach_to_array(ref _d_x2, _fp_x2, ap.len(x2));
                x_vector_create_empty(ref _d_y, DT_REAL);
                y = null;
                _error_code = _i_xv2_rbfgridcalc3v(&_s_errormsg, &_d_s, &_d_x0, &_d_n0, &_d_x1, &_d_n1, &_d_x2, &_d_n2, &_d_y, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rbfgridcalc3v");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_y.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_y, ref y);
            if( y == null )
                y = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x0);
            x_vector_clear(ref _d_x1);
            x_vector_clear(ref _d_x2);
            x_vector_clear(ref _d_y);
        }
        // This function returns no value.
    }
    
    public static void rbfgridcalc3v(rbfmodel s, double[] x0, int n0, double[] x1, int n1, double[] x2, int n2, out double[] y)
    {
        _core_rbfgridcalc3v( s,  x0,  n0,  x1,  n1,  x2,  n2, out  y, 0x0);
    }
    
    public static void rbfgridcalc3v(rbfmodel s, double[] x0, int n0, double[] x1, int n1, double[] x2, int n2, out double[] y, alglib.xparams _xparams)
    {
        _core_rbfgridcalc3v( s,  x0,  n0,  x1,  n1,  x2,  n2, out  y, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_rbfgridcalc3vsubset(rbfmodel s, double[] x0, int n0, double[] x1, int n1, double[] x2, int n2, bool[] flagy, out double[] y, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_vector _d_x0 = new x_vector();
        x_int _d_n0 = new x_int(n0);
        x_vector _d_x1 = new x_vector();
        x_int _d_n1 = new x_int(n1);
        x_vector _d_x2 = new x_vector();
        x_int _d_n2 = new x_int(n2);
        x_vector _d_flagy = new x_vector();
        x_vector _d_y = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x0 = x0, _fp_x1 = x1, _fp_x2 = x2){fixed(bool* _fp_flagy = flagy){
                x_vector_attach_to_array(ref _d_x0, _fp_x0, ap.len(x0));
                x_vector_attach_to_array(ref _d_x1, _fp_x1, ap.len(x1));
                x_vector_attach_to_array(ref _d_x2, _fp_x2, ap.len(x2));
                x_vector_attach_to_array(ref _d_flagy, _fp_flagy, ap.len(flagy));
                x_vector_create_empty(ref _d_y, DT_REAL);
                y = null;
                _error_code = _i_xv2_rbfgridcalc3vsubset(&_s_errormsg, &_d_s, &_d_x0, &_d_n0, &_d_x1, &_d_n1, &_d_x2, &_d_n2, &_d_flagy, &_d_y, _xparams);
            }}
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rbfgridcalc3vsubset");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_y.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_y, ref y);
            if( y == null )
                y = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x0);
            x_vector_clear(ref _d_x1);
            x_vector_clear(ref _d_x2);
            x_vector_clear(ref _d_flagy);
            x_vector_clear(ref _d_y);
        }
        // This function returns no value.
    }
    
    public static void rbfgridcalc3vsubset(rbfmodel s, double[] x0, int n0, double[] x1, int n1, double[] x2, int n2, bool[] flagy, out double[] y)
    {
        _core_rbfgridcalc3vsubset( s,  x0,  n0,  x1,  n1,  x2,  n2,  flagy, out  y, 0x0);
    }
    
    public static void rbfgridcalc3vsubset(rbfmodel s, double[] x0, int n0, double[] x1, int n1, double[] x2, int n2, bool[] flagy, out double[] y, alglib.xparams _xparams)
    {
        _core_rbfgridcalc3vsubset( s,  x0,  n0,  x1,  n1,  x2,  n2,  flagy, out  y, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_rbfunpack(rbfmodel s, out int nx, out int ny, out double[,] xwr, out int nc, out double[,] v, out int modelversion, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_int _d_nx = new x_int();
        x_int _d_ny = new x_int();
        x_matrix _d_xwr = new x_matrix();
        x_int _d_nc = new x_int();
        x_matrix _d_v = new x_matrix();
        x_int _d_modelversion = new x_int();
        
        // Pack, call, unpack
        try
        {
            x_matrix_create_empty(ref _d_xwr, DT_REAL);
            xwr = null;
            x_matrix_create_empty(ref _d_v, DT_REAL);
            v = null;
            _error_code = _i_xv2_rbfunpack(&_s_errormsg, &_d_s, &_d_nx, &_d_ny, &_d_xwr, &_d_nc, &_d_v, &_d_modelversion, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rbfunpack");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            nx = _d_nx.intval;
            ny = _d_ny.intval;
            if( _d_xwr.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_xwr, ref xwr);
            if( xwr == null )
                xwr = new double[0,0];
            nc = _d_nc.intval;
            if( _d_v.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_v, ref v);
            if( v == null )
                v = new double[0,0];
            modelversion = _d_modelversion.intval;
        }
        finally
        {
            x_matrix_clear(ref _d_xwr);
            x_matrix_clear(ref _d_v);
        }
        // This function returns no value.
    }
    
    public static void rbfunpack(rbfmodel s, out int nx, out int ny, out double[,] xwr, out int nc, out double[,] v, out int modelversion)
    {
        _core_rbfunpack( s, out  nx, out  ny, out  xwr, out  nc, out  v, out  modelversion, 0x0);
    }
    
    public static void rbfunpack(rbfmodel s, out int nx, out int ny, out double[,] xwr, out int nc, out double[,] v, out int modelversion, alglib.xparams _xparams)
    {
        _core_rbfunpack( s, out  nx, out  ny, out  xwr, out  nc, out  v, out  modelversion, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe int _core_rbfgetmodelversion(rbfmodel s, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        int result;
        x_int _d_result = new x_int();
        void *_d_s = s.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_rbfgetmodelversion(&_s_errormsg, &_d_result, &_d_s, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rbfgetmodelversion");
            result = _d_result.intval;
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static int rbfgetmodelversion(rbfmodel s)
    {
        return _core_rbfgetmodelversion( s, 0x0);
    }
    
    public static int rbfgetmodelversion(rbfmodel s, alglib.xparams _xparams)
    {
        return _core_rbfgetmodelversion( s, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_rbfpeekprogress(rbfmodel s, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_s = s.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_rbfpeekprogress(&_s_errormsg, &_d_result, &_d_s, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rbfpeekprogress");
            result = _d_result;
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double rbfpeekprogress(rbfmodel s)
    {
        return _core_rbfpeekprogress( s, 0x0);
    }
    
    public static double rbfpeekprogress(rbfmodel s, alglib.xparams _xparams)
    {
        return _core_rbfpeekprogress( s, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_rbfrequesttermination(rbfmodel s, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_rbfrequesttermination(&_s_errormsg, &_d_s, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "rbfrequesttermination");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void rbfrequesttermination(rbfmodel s)
    {
        _core_rbfrequesttermination( s, 0x0);
    }
    
    public static void rbfrequesttermination(rbfmodel s, alglib.xparams _xparams)
    {
        _core_rbfrequesttermination( s, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage fft
    //
    
    
    private static unsafe void _core_fftc1d(ref complex[] a, int n, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_a = new x_vector();
        x_int _d_n = new x_int(n);
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a){
                x_vector_attach_to_array(ref _d_a, _fp_a, ap.len(a));
                _error_code = _i_xv2_fftc1d(&_s_errormsg, &_d_a, &_d_n, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "fftc1d");
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_a, ref a);
            if( a == null )
                a = new alglib.complex[0];
        }
        finally
        {
            x_vector_clear(ref _d_a);
        }
        // This function returns no value.
    }
    
    public static void fftc1d(ref complex[] a, int n)
    {
        _core_fftc1d(ref  a,  n, 0x0);
    }
    
    public static void fftc1d(ref complex[] a, int n, alglib.xparams _xparams)
    {
        _core_fftc1d(ref  a,  n, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void fftc1d(ref complex[] a)
    {
        int n;
    
        n = ap.len(a);
        _core_fftc1d(ref  a,  n, 0x0);
    
        
    }
    
    public static void fftc1d(ref complex[] a, alglib.xparams _xparams)
    {
        int n;
    
        n = ap.len(a);
        _core_fftc1d(ref  a,  n, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_fftc1dinv(ref complex[] a, int n, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_a = new x_vector();
        x_int _d_n = new x_int(n);
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a){
                x_vector_attach_to_array(ref _d_a, _fp_a, ap.len(a));
                _error_code = _i_xv2_fftc1dinv(&_s_errormsg, &_d_a, &_d_n, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "fftc1dinv");
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_a, ref a);
            if( a == null )
                a = new alglib.complex[0];
        }
        finally
        {
            x_vector_clear(ref _d_a);
        }
        // This function returns no value.
    }
    
    public static void fftc1dinv(ref complex[] a, int n)
    {
        _core_fftc1dinv(ref  a,  n, 0x0);
    }
    
    public static void fftc1dinv(ref complex[] a, int n, alglib.xparams _xparams)
    {
        _core_fftc1dinv(ref  a,  n, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void fftc1dinv(ref complex[] a)
    {
        int n;
    
        n = ap.len(a);
        _core_fftc1dinv(ref  a,  n, 0x0);
    
        
    }
    
    public static void fftc1dinv(ref complex[] a, alglib.xparams _xparams)
    {
        int n;
    
        n = ap.len(a);
        _core_fftc1dinv(ref  a,  n, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_fftr1d(double[] a, int n, out complex[] f, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_a = new x_vector();
        x_int _d_n = new x_int(n);
        x_vector _d_f = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_vector_attach_to_array(ref _d_a, _fp_a, ap.len(a));
                x_vector_create_empty(ref _d_f, DT_COMPLEX);
                f = null;
                _error_code = _i_xv2_fftr1d(&_s_errormsg, &_d_a, &_d_n, &_d_f, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "fftr1d");
            if( _d_f.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_f, ref f);
            if( f == null )
                f = new alglib.complex[0];
        }
        finally
        {
            x_vector_clear(ref _d_a);
            x_vector_clear(ref _d_f);
        }
        // This function returns no value.
    }
    
    public static void fftr1d(double[] a, int n, out complex[] f)
    {
        _core_fftr1d( a,  n, out  f, 0x0);
    }
    
    public static void fftr1d(double[] a, int n, out complex[] f, alglib.xparams _xparams)
    {
        _core_fftr1d( a,  n, out  f, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void fftr1d(double[] a, out complex[] f)
    {
        int n;
    
        n = ap.len(a);
        _core_fftr1d( a,  n, out  f, 0x0);
    
        
    }
    
    public static void fftr1d(double[] a, out complex[] f, alglib.xparams _xparams)
    {
        int n;
    
        n = ap.len(a);
        _core_fftr1d( a,  n, out  f, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_fftr1dinv(complex[] f, int n, out double[] a, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_f = new x_vector();
        x_int _d_n = new x_int(n);
        x_vector _d_a = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_f = f){
                x_vector_attach_to_array(ref _d_f, _fp_f, ap.len(f));
                x_vector_create_empty(ref _d_a, DT_REAL);
                a = null;
                _error_code = _i_xv2_fftr1dinv(&_s_errormsg, &_d_f, &_d_n, &_d_a, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "fftr1dinv");
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_a, ref a);
            if( a == null )
                a = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_f);
            x_vector_clear(ref _d_a);
        }
        // This function returns no value.
    }
    
    public static void fftr1dinv(complex[] f, int n, out double[] a)
    {
        _core_fftr1dinv( f,  n, out  a, 0x0);
    }
    
    public static void fftr1dinv(complex[] f, int n, out double[] a, alglib.xparams _xparams)
    {
        _core_fftr1dinv( f,  n, out  a, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void fftr1dinv(complex[] f, out double[] a)
    {
        int n;
    
        n = ap.len(f);
        _core_fftr1dinv( f,  n, out  a, 0x0);
    
        
    }
    
    public static void fftr1dinv(complex[] f, out double[] a, alglib.xparams _xparams)
    {
        int n;
    
        n = ap.len(f);
        _core_fftr1dinv( f,  n, out  a, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    
    //
    // Subpackage fht
    //
    
    
    private static unsafe void _core_fhtr1d(ref double[] a, int n, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_a = new x_vector();
        x_int _d_n = new x_int(n);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_vector_attach_to_array(ref _d_a, _fp_a, ap.len(a));
                _error_code = _i_xv2_fhtr1d(&_s_errormsg, &_d_a, &_d_n, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "fhtr1d");
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_a, ref a);
            if( a == null )
                a = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_a);
        }
        // This function returns no value.
    }
    
    public static void fhtr1d(ref double[] a, int n)
    {
        _core_fhtr1d(ref  a,  n, 0x0);
    }
    
    public static void fhtr1d(ref double[] a, int n, alglib.xparams _xparams)
    {
        _core_fhtr1d(ref  a,  n, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_fhtr1dinv(ref double[] a, int n, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_a = new x_vector();
        x_int _d_n = new x_int(n);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_vector_attach_to_array(ref _d_a, _fp_a, ap.len(a));
                _error_code = _i_xv2_fhtr1dinv(&_s_errormsg, &_d_a, &_d_n, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "fhtr1dinv");
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_a, ref a);
            if( a == null )
                a = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_a);
        }
        // This function returns no value.
    }
    
    public static void fhtr1dinv(ref double[] a, int n)
    {
        _core_fhtr1dinv(ref  a,  n, 0x0);
    }
    
    public static void fhtr1dinv(ref double[] a, int n, alglib.xparams _xparams)
    {
        _core_fhtr1dinv(ref  a,  n, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage conv
    //
    
    
    private static unsafe void _core_convc1d(complex[] a, int m, complex[] b, int n, out complex[] r, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_a = new x_vector();
        x_int _d_m = new x_int(m);
        x_vector _d_b = new x_vector();
        x_int _d_n = new x_int(n);
        x_vector _d_r = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a, _fp_b = b){
                x_vector_attach_to_array(ref _d_a, _fp_a, ap.len(a));
                x_vector_attach_to_array(ref _d_b, _fp_b, ap.len(b));
                x_vector_create_empty(ref _d_r, DT_COMPLEX);
                r = null;
                _error_code = _i_xv2_convc1d(&_s_errormsg, &_d_a, &_d_m, &_d_b, &_d_n, &_d_r, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "convc1d");
            if( _d_r.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_r, ref r);
            if( r == null )
                r = new alglib.complex[0];
        }
        finally
        {
            x_vector_clear(ref _d_a);
            x_vector_clear(ref _d_b);
            x_vector_clear(ref _d_r);
        }
        // This function returns no value.
    }
    
    public static void convc1d(complex[] a, int m, complex[] b, int n, out complex[] r)
    {
        _core_convc1d( a,  m,  b,  n, out  r, 0x0);
    }
    
    public static void convc1d(complex[] a, int m, complex[] b, int n, out complex[] r, alglib.xparams _xparams)
    {
        _core_convc1d( a,  m,  b,  n, out  r, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_convc1dinv(complex[] a, int m, complex[] b, int n, out complex[] r, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_a = new x_vector();
        x_int _d_m = new x_int(m);
        x_vector _d_b = new x_vector();
        x_int _d_n = new x_int(n);
        x_vector _d_r = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a, _fp_b = b){
                x_vector_attach_to_array(ref _d_a, _fp_a, ap.len(a));
                x_vector_attach_to_array(ref _d_b, _fp_b, ap.len(b));
                x_vector_create_empty(ref _d_r, DT_COMPLEX);
                r = null;
                _error_code = _i_xv2_convc1dinv(&_s_errormsg, &_d_a, &_d_m, &_d_b, &_d_n, &_d_r, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "convc1dinv");
            if( _d_r.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_r, ref r);
            if( r == null )
                r = new alglib.complex[0];
        }
        finally
        {
            x_vector_clear(ref _d_a);
            x_vector_clear(ref _d_b);
            x_vector_clear(ref _d_r);
        }
        // This function returns no value.
    }
    
    public static void convc1dinv(complex[] a, int m, complex[] b, int n, out complex[] r)
    {
        _core_convc1dinv( a,  m,  b,  n, out  r, 0x0);
    }
    
    public static void convc1dinv(complex[] a, int m, complex[] b, int n, out complex[] r, alglib.xparams _xparams)
    {
        _core_convc1dinv( a,  m,  b,  n, out  r, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_convc1dcircular(complex[] s, int m, complex[] r, int n, out complex[] c, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_s = new x_vector();
        x_int _d_m = new x_int(m);
        x_vector _d_r = new x_vector();
        x_int _d_n = new x_int(n);
        x_vector _d_c = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_s = s, _fp_r = r){
                x_vector_attach_to_array(ref _d_s, _fp_s, ap.len(s));
                x_vector_attach_to_array(ref _d_r, _fp_r, ap.len(r));
                x_vector_create_empty(ref _d_c, DT_COMPLEX);
                c = null;
                _error_code = _i_xv2_convc1dcircular(&_s_errormsg, &_d_s, &_d_m, &_d_r, &_d_n, &_d_c, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "convc1dcircular");
            if( _d_c.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_c, ref c);
            if( c == null )
                c = new alglib.complex[0];
        }
        finally
        {
            x_vector_clear(ref _d_s);
            x_vector_clear(ref _d_r);
            x_vector_clear(ref _d_c);
        }
        // This function returns no value.
    }
    
    public static void convc1dcircular(complex[] s, int m, complex[] r, int n, out complex[] c)
    {
        _core_convc1dcircular( s,  m,  r,  n, out  c, 0x0);
    }
    
    public static void convc1dcircular(complex[] s, int m, complex[] r, int n, out complex[] c, alglib.xparams _xparams)
    {
        _core_convc1dcircular( s,  m,  r,  n, out  c, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_convc1dcircularinv(complex[] a, int m, complex[] b, int n, out complex[] r, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_a = new x_vector();
        x_int _d_m = new x_int(m);
        x_vector _d_b = new x_vector();
        x_int _d_n = new x_int(n);
        x_vector _d_r = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a, _fp_b = b){
                x_vector_attach_to_array(ref _d_a, _fp_a, ap.len(a));
                x_vector_attach_to_array(ref _d_b, _fp_b, ap.len(b));
                x_vector_create_empty(ref _d_r, DT_COMPLEX);
                r = null;
                _error_code = _i_xv2_convc1dcircularinv(&_s_errormsg, &_d_a, &_d_m, &_d_b, &_d_n, &_d_r, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "convc1dcircularinv");
            if( _d_r.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_r, ref r);
            if( r == null )
                r = new alglib.complex[0];
        }
        finally
        {
            x_vector_clear(ref _d_a);
            x_vector_clear(ref _d_b);
            x_vector_clear(ref _d_r);
        }
        // This function returns no value.
    }
    
    public static void convc1dcircularinv(complex[] a, int m, complex[] b, int n, out complex[] r)
    {
        _core_convc1dcircularinv( a,  m,  b,  n, out  r, 0x0);
    }
    
    public static void convc1dcircularinv(complex[] a, int m, complex[] b, int n, out complex[] r, alglib.xparams _xparams)
    {
        _core_convc1dcircularinv( a,  m,  b,  n, out  r, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_convr1d(double[] a, int m, double[] b, int n, out double[] r, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_a = new x_vector();
        x_int _d_m = new x_int(m);
        x_vector _d_b = new x_vector();
        x_int _d_n = new x_int(n);
        x_vector _d_r = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a, _fp_b = b){
                x_vector_attach_to_array(ref _d_a, _fp_a, ap.len(a));
                x_vector_attach_to_array(ref _d_b, _fp_b, ap.len(b));
                x_vector_create_empty(ref _d_r, DT_REAL);
                r = null;
                _error_code = _i_xv2_convr1d(&_s_errormsg, &_d_a, &_d_m, &_d_b, &_d_n, &_d_r, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "convr1d");
            if( _d_r.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_r, ref r);
            if( r == null )
                r = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_a);
            x_vector_clear(ref _d_b);
            x_vector_clear(ref _d_r);
        }
        // This function returns no value.
    }
    
    public static void convr1d(double[] a, int m, double[] b, int n, out double[] r)
    {
        _core_convr1d( a,  m,  b,  n, out  r, 0x0);
    }
    
    public static void convr1d(double[] a, int m, double[] b, int n, out double[] r, alglib.xparams _xparams)
    {
        _core_convr1d( a,  m,  b,  n, out  r, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_convr1dinv(double[] a, int m, double[] b, int n, out double[] r, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_a = new x_vector();
        x_int _d_m = new x_int(m);
        x_vector _d_b = new x_vector();
        x_int _d_n = new x_int(n);
        x_vector _d_r = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a, _fp_b = b){
                x_vector_attach_to_array(ref _d_a, _fp_a, ap.len(a));
                x_vector_attach_to_array(ref _d_b, _fp_b, ap.len(b));
                x_vector_create_empty(ref _d_r, DT_REAL);
                r = null;
                _error_code = _i_xv2_convr1dinv(&_s_errormsg, &_d_a, &_d_m, &_d_b, &_d_n, &_d_r, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "convr1dinv");
            if( _d_r.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_r, ref r);
            if( r == null )
                r = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_a);
            x_vector_clear(ref _d_b);
            x_vector_clear(ref _d_r);
        }
        // This function returns no value.
    }
    
    public static void convr1dinv(double[] a, int m, double[] b, int n, out double[] r)
    {
        _core_convr1dinv( a,  m,  b,  n, out  r, 0x0);
    }
    
    public static void convr1dinv(double[] a, int m, double[] b, int n, out double[] r, alglib.xparams _xparams)
    {
        _core_convr1dinv( a,  m,  b,  n, out  r, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_convr1dcircular(double[] s, int m, double[] r, int n, out double[] c, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_s = new x_vector();
        x_int _d_m = new x_int(m);
        x_vector _d_r = new x_vector();
        x_int _d_n = new x_int(n);
        x_vector _d_c = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_s = s, _fp_r = r){
                x_vector_attach_to_array(ref _d_s, _fp_s, ap.len(s));
                x_vector_attach_to_array(ref _d_r, _fp_r, ap.len(r));
                x_vector_create_empty(ref _d_c, DT_REAL);
                c = null;
                _error_code = _i_xv2_convr1dcircular(&_s_errormsg, &_d_s, &_d_m, &_d_r, &_d_n, &_d_c, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "convr1dcircular");
            if( _d_c.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_c, ref c);
            if( c == null )
                c = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_s);
            x_vector_clear(ref _d_r);
            x_vector_clear(ref _d_c);
        }
        // This function returns no value.
    }
    
    public static void convr1dcircular(double[] s, int m, double[] r, int n, out double[] c)
    {
        _core_convr1dcircular( s,  m,  r,  n, out  c, 0x0);
    }
    
    public static void convr1dcircular(double[] s, int m, double[] r, int n, out double[] c, alglib.xparams _xparams)
    {
        _core_convr1dcircular( s,  m,  r,  n, out  c, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_convr1dcircularinv(double[] a, int m, double[] b, int n, out double[] r, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_a = new x_vector();
        x_int _d_m = new x_int(m);
        x_vector _d_b = new x_vector();
        x_int _d_n = new x_int(n);
        x_vector _d_r = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a, _fp_b = b){
                x_vector_attach_to_array(ref _d_a, _fp_a, ap.len(a));
                x_vector_attach_to_array(ref _d_b, _fp_b, ap.len(b));
                x_vector_create_empty(ref _d_r, DT_REAL);
                r = null;
                _error_code = _i_xv2_convr1dcircularinv(&_s_errormsg, &_d_a, &_d_m, &_d_b, &_d_n, &_d_r, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "convr1dcircularinv");
            if( _d_r.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_r, ref r);
            if( r == null )
                r = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_a);
            x_vector_clear(ref _d_b);
            x_vector_clear(ref _d_r);
        }
        // This function returns no value.
    }
    
    public static void convr1dcircularinv(double[] a, int m, double[] b, int n, out double[] r)
    {
        _core_convr1dcircularinv( a,  m,  b,  n, out  r, 0x0);
    }
    
    public static void convr1dcircularinv(double[] a, int m, double[] b, int n, out double[] r, alglib.xparams _xparams)
    {
        _core_convr1dcircularinv( a,  m,  b,  n, out  r, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage corr
    //
    
    
    private static unsafe void _core_corrc1d(complex[] signal, int n, complex[] pattern, int m, out complex[] r, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_signal = new x_vector();
        x_int _d_n = new x_int(n);
        x_vector _d_pattern = new x_vector();
        x_int _d_m = new x_int(m);
        x_vector _d_r = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_signal = signal, _fp_pattern = pattern){
                x_vector_attach_to_array(ref _d_signal, _fp_signal, ap.len(signal));
                x_vector_attach_to_array(ref _d_pattern, _fp_pattern, ap.len(pattern));
                x_vector_create_empty(ref _d_r, DT_COMPLEX);
                r = null;
                _error_code = _i_xv2_corrc1d(&_s_errormsg, &_d_signal, &_d_n, &_d_pattern, &_d_m, &_d_r, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "corrc1d");
            if( _d_r.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_r, ref r);
            if( r == null )
                r = new alglib.complex[0];
        }
        finally
        {
            x_vector_clear(ref _d_signal);
            x_vector_clear(ref _d_pattern);
            x_vector_clear(ref _d_r);
        }
        // This function returns no value.
    }
    
    public static void corrc1d(complex[] signal, int n, complex[] pattern, int m, out complex[] r)
    {
        _core_corrc1d( signal,  n,  pattern,  m, out  r, 0x0);
    }
    
    public static void corrc1d(complex[] signal, int n, complex[] pattern, int m, out complex[] r, alglib.xparams _xparams)
    {
        _core_corrc1d( signal,  n,  pattern,  m, out  r, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_corrc1dcircular(complex[] signal, int m, complex[] pattern, int n, out complex[] c, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_signal = new x_vector();
        x_int _d_m = new x_int(m);
        x_vector _d_pattern = new x_vector();
        x_int _d_n = new x_int(n);
        x_vector _d_c = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_signal = signal, _fp_pattern = pattern){
                x_vector_attach_to_array(ref _d_signal, _fp_signal, ap.len(signal));
                x_vector_attach_to_array(ref _d_pattern, _fp_pattern, ap.len(pattern));
                x_vector_create_empty(ref _d_c, DT_COMPLEX);
                c = null;
                _error_code = _i_xv2_corrc1dcircular(&_s_errormsg, &_d_signal, &_d_m, &_d_pattern, &_d_n, &_d_c, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "corrc1dcircular");
            if( _d_c.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_c, ref c);
            if( c == null )
                c = new alglib.complex[0];
        }
        finally
        {
            x_vector_clear(ref _d_signal);
            x_vector_clear(ref _d_pattern);
            x_vector_clear(ref _d_c);
        }
        // This function returns no value.
    }
    
    public static void corrc1dcircular(complex[] signal, int m, complex[] pattern, int n, out complex[] c)
    {
        _core_corrc1dcircular( signal,  m,  pattern,  n, out  c, 0x0);
    }
    
    public static void corrc1dcircular(complex[] signal, int m, complex[] pattern, int n, out complex[] c, alglib.xparams _xparams)
    {
        _core_corrc1dcircular( signal,  m,  pattern,  n, out  c, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_corrr1d(double[] signal, int n, double[] pattern, int m, out double[] r, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_signal = new x_vector();
        x_int _d_n = new x_int(n);
        x_vector _d_pattern = new x_vector();
        x_int _d_m = new x_int(m);
        x_vector _d_r = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_signal = signal, _fp_pattern = pattern){
                x_vector_attach_to_array(ref _d_signal, _fp_signal, ap.len(signal));
                x_vector_attach_to_array(ref _d_pattern, _fp_pattern, ap.len(pattern));
                x_vector_create_empty(ref _d_r, DT_REAL);
                r = null;
                _error_code = _i_xv2_corrr1d(&_s_errormsg, &_d_signal, &_d_n, &_d_pattern, &_d_m, &_d_r, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "corrr1d");
            if( _d_r.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_r, ref r);
            if( r == null )
                r = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_signal);
            x_vector_clear(ref _d_pattern);
            x_vector_clear(ref _d_r);
        }
        // This function returns no value.
    }
    
    public static void corrr1d(double[] signal, int n, double[] pattern, int m, out double[] r)
    {
        _core_corrr1d( signal,  n,  pattern,  m, out  r, 0x0);
    }
    
    public static void corrr1d(double[] signal, int n, double[] pattern, int m, out double[] r, alglib.xparams _xparams)
    {
        _core_corrr1d( signal,  n,  pattern,  m, out  r, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_corrr1dcircular(double[] signal, int m, double[] pattern, int n, out double[] c, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_signal = new x_vector();
        x_int _d_m = new x_int(m);
        x_vector _d_pattern = new x_vector();
        x_int _d_n = new x_int(n);
        x_vector _d_c = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_signal = signal, _fp_pattern = pattern){
                x_vector_attach_to_array(ref _d_signal, _fp_signal, ap.len(signal));
                x_vector_attach_to_array(ref _d_pattern, _fp_pattern, ap.len(pattern));
                x_vector_create_empty(ref _d_c, DT_REAL);
                c = null;
                _error_code = _i_xv2_corrr1dcircular(&_s_errormsg, &_d_signal, &_d_m, &_d_pattern, &_d_n, &_d_c, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "corrr1dcircular");
            if( _d_c.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_c, ref c);
            if( c == null )
                c = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_signal);
            x_vector_clear(ref _d_pattern);
            x_vector_clear(ref _d_c);
        }
        // This function returns no value.
    }
    
    public static void corrr1dcircular(double[] signal, int m, double[] pattern, int n, out double[] c)
    {
        _core_corrr1dcircular( signal,  m,  pattern,  n, out  c, 0x0);
    }
    
    public static void corrr1dcircular(double[] signal, int m, double[] pattern, int n, out double[] c, alglib.xparams _xparams)
    {
        _core_corrr1dcircular( signal,  m,  pattern,  n, out  c, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage expintegrals
    //
    
    
    private static unsafe double _core_exponentialintegralei(double x, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        double _d_x = x;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_exponentialintegralei(&_s_errormsg, &_d_result, &_d_x, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "exponentialintegralei");
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double exponentialintegralei(double x)
    {
        return _core_exponentialintegralei( x, 0x0);
    }
    
    public static double exponentialintegralei(double x, alglib.xparams _xparams)
    {
        return _core_exponentialintegralei( x, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_exponentialintegralen(double x, int n, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        double _d_x = x;
        x_int _d_n = new x_int(n);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_exponentialintegralen(&_s_errormsg, &_d_result, &_d_x, &_d_n, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "exponentialintegralen");
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double exponentialintegralen(double x, int n)
    {
        return _core_exponentialintegralen( x,  n, 0x0);
    }
    
    public static double exponentialintegralen(double x, int n, alglib.xparams _xparams)
    {
        return _core_exponentialintegralen( x,  n, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage jacobianelliptic
    //
    
    
    private static unsafe void _core_jacobianellipticfunctions(double u, double m, out double sn, out double cn, out double dn, out double ph, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double _d_u = u;
        double _d_m = m;
        double _d_sn = 0;
        double _d_cn = 0;
        double _d_dn = 0;
        double _d_ph = 0;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_jacobianellipticfunctions(&_s_errormsg, &_d_u, &_d_m, &_d_sn, &_d_cn, &_d_dn, &_d_ph, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "jacobianellipticfunctions");
            sn = _d_sn;
            cn = _d_cn;
            dn = _d_dn;
            ph = _d_ph;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void jacobianellipticfunctions(double u, double m, out double sn, out double cn, out double dn, out double ph)
    {
        _core_jacobianellipticfunctions( u,  m, out  sn, out  cn, out  dn, out  ph, 0x0);
    }
    
    public static void jacobianellipticfunctions(double u, double m, out double sn, out double cn, out double dn, out double ph, alglib.xparams _xparams)
    {
        _core_jacobianellipticfunctions( u,  m, out  sn, out  cn, out  dn, out  ph, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage trigintegrals
    //
    
    
    private static unsafe void _core_sinecosineintegrals(double x, out double si, out double ci, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double _d_x = x;
        double _d_si = 0;
        double _d_ci = 0;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_sinecosineintegrals(&_s_errormsg, &_d_x, &_d_si, &_d_ci, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "sinecosineintegrals");
            si = _d_si;
            ci = _d_ci;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void sinecosineintegrals(double x, out double si, out double ci)
    {
        _core_sinecosineintegrals( x, out  si, out  ci, 0x0);
    }
    
    public static void sinecosineintegrals(double x, out double si, out double ci, alglib.xparams _xparams)
    {
        _core_sinecosineintegrals( x, out  si, out  ci, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_hyperbolicsinecosineintegrals(double x, out double shi, out double chi, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double _d_x = x;
        double _d_shi = 0;
        double _d_chi = 0;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_hyperbolicsinecosineintegrals(&_s_errormsg, &_d_x, &_d_shi, &_d_chi, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "hyperbolicsinecosineintegrals");
            shi = _d_shi;
            chi = _d_chi;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void hyperbolicsinecosineintegrals(double x, out double shi, out double chi)
    {
        _core_hyperbolicsinecosineintegrals( x, out  shi, out  chi, 0x0);
    }
    
    public static void hyperbolicsinecosineintegrals(double x, out double shi, out double chi, alglib.xparams _xparams)
    {
        _core_hyperbolicsinecosineintegrals( x, out  shi, out  chi, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage chebyshev
    //
    
    
    private static unsafe double _core_chebyshevcalculate(int r, int n, double x, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_int _d_r = new x_int(r);
        x_int _d_n = new x_int(n);
        double _d_x = x;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_chebyshevcalculate(&_s_errormsg, &_d_result, &_d_r, &_d_n, &_d_x, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "chebyshevcalculate");
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double chebyshevcalculate(int r, int n, double x)
    {
        return _core_chebyshevcalculate( r,  n,  x, 0x0);
    }
    
    public static double chebyshevcalculate(int r, int n, double x, alglib.xparams _xparams)
    {
        return _core_chebyshevcalculate( r,  n,  x, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_chebyshevsum(double[] c, int r, int n, double x, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_vector _d_c = new x_vector();
        x_int _d_r = new x_int(r);
        x_int _d_n = new x_int(n);
        double _d_x = x;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_c = c){
                x_vector_attach_to_array(ref _d_c, _fp_c, ap.len(c));
                _error_code = _i_xv2_chebyshevsum(&_s_errormsg, &_d_result, &_d_c, &_d_r, &_d_n, &_d_x, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "chebyshevsum");
            result = _d_result;
        }
        finally
        {
            x_vector_clear(ref _d_c);
        }
        return result;
    }
    
    public static double chebyshevsum(double[] c, int r, int n, double x)
    {
        return _core_chebyshevsum( c,  r,  n,  x, 0x0);
    }
    
    public static double chebyshevsum(double[] c, int r, int n, double x, alglib.xparams _xparams)
    {
        return _core_chebyshevsum( c,  r,  n,  x, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_chebyshevcoefficients(int n, out double[] c, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        x_vector _d_c = new x_vector();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_c, DT_REAL);
            c = null;
            _error_code = _i_xv2_chebyshevcoefficients(&_s_errormsg, &_d_n, &_d_c, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "chebyshevcoefficients");
            if( _d_c.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_c, ref c);
            if( c == null )
                c = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_c);
        }
        // This function returns no value.
    }
    
    public static void chebyshevcoefficients(int n, out double[] c)
    {
        _core_chebyshevcoefficients( n, out  c, 0x0);
    }
    
    public static void chebyshevcoefficients(int n, out double[] c, alglib.xparams _xparams)
    {
        _core_chebyshevcoefficients( n, out  c, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_fromchebyshev(double[] a, int n, out double[] b, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_a = new x_vector();
        x_int _d_n = new x_int(n);
        x_vector _d_b = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_vector_attach_to_array(ref _d_a, _fp_a, ap.len(a));
                x_vector_create_empty(ref _d_b, DT_REAL);
                b = null;
                _error_code = _i_xv2_fromchebyshev(&_s_errormsg, &_d_a, &_d_n, &_d_b, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "fromchebyshev");
            if( _d_b.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_b, ref b);
            if( b == null )
                b = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_a);
            x_vector_clear(ref _d_b);
        }
        // This function returns no value.
    }
    
    public static void fromchebyshev(double[] a, int n, out double[] b)
    {
        _core_fromchebyshev( a,  n, out  b, 0x0);
    }
    
    public static void fromchebyshev(double[] a, int n, out double[] b, alglib.xparams _xparams)
    {
        _core_fromchebyshev( a,  n, out  b, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage poissondistr
    //
    
    
    private static unsafe double _core_poissondistribution(int k, double m, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_int _d_k = new x_int(k);
        double _d_m = m;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_poissondistribution(&_s_errormsg, &_d_result, &_d_k, &_d_m, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "poissondistribution");
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double poissondistribution(int k, double m)
    {
        return _core_poissondistribution( k,  m, 0x0);
    }
    
    public static double poissondistribution(int k, double m, alglib.xparams _xparams)
    {
        return _core_poissondistribution( k,  m, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_poissoncdistribution(int k, double m, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_int _d_k = new x_int(k);
        double _d_m = m;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_poissoncdistribution(&_s_errormsg, &_d_result, &_d_k, &_d_m, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "poissoncdistribution");
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double poissoncdistribution(int k, double m)
    {
        return _core_poissoncdistribution( k,  m, 0x0);
    }
    
    public static double poissoncdistribution(int k, double m, alglib.xparams _xparams)
    {
        return _core_poissoncdistribution( k,  m, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_invpoissondistribution(int k, double y, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_int _d_k = new x_int(k);
        double _d_y = y;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_invpoissondistribution(&_s_errormsg, &_d_result, &_d_k, &_d_y, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "invpoissondistribution");
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double invpoissondistribution(int k, double y)
    {
        return _core_invpoissondistribution( k,  y, 0x0);
    }
    
    public static double invpoissondistribution(int k, double y, alglib.xparams _xparams)
    {
        return _core_invpoissondistribution( k,  y, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage betaf
    //
    
    
    private static unsafe double _core_beta(double a, double b, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        double _d_a = a;
        double _d_b = b;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_beta(&_s_errormsg, &_d_result, &_d_a, &_d_b, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "beta");
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double beta(double a, double b)
    {
        return _core_beta( a,  b, 0x0);
    }
    
    public static double beta(double a, double b, alglib.xparams _xparams)
    {
        return _core_beta( a,  b, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage fresnel
    //
    
    
    private static unsafe void _core_fresnelintegral(double x, ref double c, ref double s, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double _d_x = x;
        double _d_c = c;
        double _d_s = s;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_fresnelintegral(&_s_errormsg, &_d_x, &_d_c, &_d_s, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "fresnelintegral");
            c = _d_c;
            s = _d_s;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void fresnelintegral(double x, ref double c, ref double s)
    {
        _core_fresnelintegral( x, ref  c, ref  s, 0x0);
    }
    
    public static void fresnelintegral(double x, ref double c, ref double s, alglib.xparams _xparams)
    {
        _core_fresnelintegral( x, ref  c, ref  s, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage psif
    //
    
    
    private static unsafe double _core_psi(double x, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        double _d_x = x;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_psi(&_s_errormsg, &_d_result, &_d_x, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "psi");
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double psi(double x)
    {
        return _core_psi( x, 0x0);
    }
    
    public static double psi(double x, alglib.xparams _xparams)
    {
        return _core_psi( x, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage airyf
    //
    
    
    private static unsafe void _core_airy(double x, out double ai, out double aip, out double bi, out double bip, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double _d_x = x;
        double _d_ai = 0;
        double _d_aip = 0;
        double _d_bi = 0;
        double _d_bip = 0;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_airy(&_s_errormsg, &_d_x, &_d_ai, &_d_aip, &_d_bi, &_d_bip, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "airy");
            ai = _d_ai;
            aip = _d_aip;
            bi = _d_bi;
            bip = _d_bip;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void airy(double x, out double ai, out double aip, out double bi, out double bip)
    {
        _core_airy( x, out  ai, out  aip, out  bi, out  bip, 0x0);
    }
    
    public static void airy(double x, out double ai, out double aip, out double bi, out double bip, alglib.xparams _xparams)
    {
        _core_airy( x, out  ai, out  aip, out  bi, out  bip, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage dawson
    //
    
    
    private static unsafe double _core_dawsonintegral(double x, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        double _d_x = x;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_dawsonintegral(&_s_errormsg, &_d_result, &_d_x, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "dawsonintegral");
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double dawsonintegral(double x)
    {
        return _core_dawsonintegral( x, 0x0);
    }
    
    public static double dawsonintegral(double x, alglib.xparams _xparams)
    {
        return _core_dawsonintegral( x, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage hermite
    //
    
    
    private static unsafe double _core_hermitecalculate(int n, double x, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_int _d_n = new x_int(n);
        double _d_x = x;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_hermitecalculate(&_s_errormsg, &_d_result, &_d_n, &_d_x, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "hermitecalculate");
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double hermitecalculate(int n, double x)
    {
        return _core_hermitecalculate( n,  x, 0x0);
    }
    
    public static double hermitecalculate(int n, double x, alglib.xparams _xparams)
    {
        return _core_hermitecalculate( n,  x, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_hermitesum(double[] c, int n, double x, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_vector _d_c = new x_vector();
        x_int _d_n = new x_int(n);
        double _d_x = x;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_c = c){
                x_vector_attach_to_array(ref _d_c, _fp_c, ap.len(c));
                _error_code = _i_xv2_hermitesum(&_s_errormsg, &_d_result, &_d_c, &_d_n, &_d_x, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "hermitesum");
            result = _d_result;
        }
        finally
        {
            x_vector_clear(ref _d_c);
        }
        return result;
    }
    
    public static double hermitesum(double[] c, int n, double x)
    {
        return _core_hermitesum( c,  n,  x, 0x0);
    }
    
    public static double hermitesum(double[] c, int n, double x, alglib.xparams _xparams)
    {
        return _core_hermitesum( c,  n,  x, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_hermitecoefficients(int n, out double[] c, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        x_vector _d_c = new x_vector();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_c, DT_REAL);
            c = null;
            _error_code = _i_xv2_hermitecoefficients(&_s_errormsg, &_d_n, &_d_c, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "hermitecoefficients");
            if( _d_c.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_c, ref c);
            if( c == null )
                c = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_c);
        }
        // This function returns no value.
    }
    
    public static void hermitecoefficients(int n, out double[] c)
    {
        _core_hermitecoefficients( n, out  c, 0x0);
    }
    
    public static void hermitecoefficients(int n, out double[] c, alglib.xparams _xparams)
    {
        _core_hermitecoefficients( n, out  c, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage legendre
    //
    
    
    private static unsafe double _core_legendrecalculate(int n, double x, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_int _d_n = new x_int(n);
        double _d_x = x;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_legendrecalculate(&_s_errormsg, &_d_result, &_d_n, &_d_x, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "legendrecalculate");
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double legendrecalculate(int n, double x)
    {
        return _core_legendrecalculate( n,  x, 0x0);
    }
    
    public static double legendrecalculate(int n, double x, alglib.xparams _xparams)
    {
        return _core_legendrecalculate( n,  x, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_legendresum(double[] c, int n, double x, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_vector _d_c = new x_vector();
        x_int _d_n = new x_int(n);
        double _d_x = x;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_c = c){
                x_vector_attach_to_array(ref _d_c, _fp_c, ap.len(c));
                _error_code = _i_xv2_legendresum(&_s_errormsg, &_d_result, &_d_c, &_d_n, &_d_x, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "legendresum");
            result = _d_result;
        }
        finally
        {
            x_vector_clear(ref _d_c);
        }
        return result;
    }
    
    public static double legendresum(double[] c, int n, double x)
    {
        return _core_legendresum( c,  n,  x, 0x0);
    }
    
    public static double legendresum(double[] c, int n, double x, alglib.xparams _xparams)
    {
        return _core_legendresum( c,  n,  x, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_legendrecoefficients(int n, out double[] c, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        x_vector _d_c = new x_vector();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_c, DT_REAL);
            c = null;
            _error_code = _i_xv2_legendrecoefficients(&_s_errormsg, &_d_n, &_d_c, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "legendrecoefficients");
            if( _d_c.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_c, ref c);
            if( c == null )
                c = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_c);
        }
        // This function returns no value.
    }
    
    public static void legendrecoefficients(int n, out double[] c)
    {
        _core_legendrecoefficients( n, out  c, 0x0);
    }
    
    public static void legendrecoefficients(int n, out double[] c, alglib.xparams _xparams)
    {
        _core_legendrecoefficients( n, out  c, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage bessel
    //
    
    
    private static unsafe double _core_besselj0(double x, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        double _d_x = x;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_besselj0(&_s_errormsg, &_d_result, &_d_x, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "besselj0");
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double besselj0(double x)
    {
        return _core_besselj0( x, 0x0);
    }
    
    public static double besselj0(double x, alglib.xparams _xparams)
    {
        return _core_besselj0( x, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_besselj1(double x, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        double _d_x = x;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_besselj1(&_s_errormsg, &_d_result, &_d_x, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "besselj1");
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double besselj1(double x)
    {
        return _core_besselj1( x, 0x0);
    }
    
    public static double besselj1(double x, alglib.xparams _xparams)
    {
        return _core_besselj1( x, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_besseljn(int n, double x, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_int _d_n = new x_int(n);
        double _d_x = x;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_besseljn(&_s_errormsg, &_d_result, &_d_n, &_d_x, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "besseljn");
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double besseljn(int n, double x)
    {
        return _core_besseljn( n,  x, 0x0);
    }
    
    public static double besseljn(int n, double x, alglib.xparams _xparams)
    {
        return _core_besseljn( n,  x, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_bessely0(double x, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        double _d_x = x;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_bessely0(&_s_errormsg, &_d_result, &_d_x, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "bessely0");
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double bessely0(double x)
    {
        return _core_bessely0( x, 0x0);
    }
    
    public static double bessely0(double x, alglib.xparams _xparams)
    {
        return _core_bessely0( x, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_bessely1(double x, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        double _d_x = x;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_bessely1(&_s_errormsg, &_d_result, &_d_x, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "bessely1");
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double bessely1(double x)
    {
        return _core_bessely1( x, 0x0);
    }
    
    public static double bessely1(double x, alglib.xparams _xparams)
    {
        return _core_bessely1( x, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_besselyn(int n, double x, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_int _d_n = new x_int(n);
        double _d_x = x;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_besselyn(&_s_errormsg, &_d_result, &_d_n, &_d_x, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "besselyn");
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double besselyn(int n, double x)
    {
        return _core_besselyn( n,  x, 0x0);
    }
    
    public static double besselyn(int n, double x, alglib.xparams _xparams)
    {
        return _core_besselyn( n,  x, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_besseli0(double x, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        double _d_x = x;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_besseli0(&_s_errormsg, &_d_result, &_d_x, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "besseli0");
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double besseli0(double x)
    {
        return _core_besseli0( x, 0x0);
    }
    
    public static double besseli0(double x, alglib.xparams _xparams)
    {
        return _core_besseli0( x, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_besseli1(double x, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        double _d_x = x;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_besseli1(&_s_errormsg, &_d_result, &_d_x, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "besseli1");
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double besseli1(double x)
    {
        return _core_besseli1( x, 0x0);
    }
    
    public static double besseli1(double x, alglib.xparams _xparams)
    {
        return _core_besseli1( x, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_besselk0(double x, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        double _d_x = x;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_besselk0(&_s_errormsg, &_d_result, &_d_x, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "besselk0");
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double besselk0(double x)
    {
        return _core_besselk0( x, 0x0);
    }
    
    public static double besselk0(double x, alglib.xparams _xparams)
    {
        return _core_besselk0( x, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_besselk1(double x, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        double _d_x = x;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_besselk1(&_s_errormsg, &_d_result, &_d_x, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "besselk1");
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double besselk1(double x)
    {
        return _core_besselk1( x, 0x0);
    }
    
    public static double besselk1(double x, alglib.xparams _xparams)
    {
        return _core_besselk1( x, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_besselkn(int nn, double x, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_int _d_nn = new x_int(nn);
        double _d_x = x;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_besselkn(&_s_errormsg, &_d_result, &_d_nn, &_d_x, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "besselkn");
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double besselkn(int nn, double x)
    {
        return _core_besselkn( nn,  x, 0x0);
    }
    
    public static double besselkn(int nn, double x, alglib.xparams _xparams)
    {
        return _core_besselkn( nn,  x, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage laguerre
    //
    
    
    private static unsafe double _core_laguerrecalculate(int n, double x, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_int _d_n = new x_int(n);
        double _d_x = x;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_laguerrecalculate(&_s_errormsg, &_d_result, &_d_n, &_d_x, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "laguerrecalculate");
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double laguerrecalculate(int n, double x)
    {
        return _core_laguerrecalculate( n,  x, 0x0);
    }
    
    public static double laguerrecalculate(int n, double x, alglib.xparams _xparams)
    {
        return _core_laguerrecalculate( n,  x, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_laguerresum(double[] c, int n, double x, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_vector _d_c = new x_vector();
        x_int _d_n = new x_int(n);
        double _d_x = x;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_c = c){
                x_vector_attach_to_array(ref _d_c, _fp_c, ap.len(c));
                _error_code = _i_xv2_laguerresum(&_s_errormsg, &_d_result, &_d_c, &_d_n, &_d_x, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "laguerresum");
            result = _d_result;
        }
        finally
        {
            x_vector_clear(ref _d_c);
        }
        return result;
    }
    
    public static double laguerresum(double[] c, int n, double x)
    {
        return _core_laguerresum( c,  n,  x, 0x0);
    }
    
    public static double laguerresum(double[] c, int n, double x, alglib.xparams _xparams)
    {
        return _core_laguerresum( c,  n,  x, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_laguerrecoefficients(int n, out double[] c, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        x_vector _d_c = new x_vector();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_c, DT_REAL);
            c = null;
            _error_code = _i_xv2_laguerrecoefficients(&_s_errormsg, &_d_n, &_d_c, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "laguerrecoefficients");
            if( _d_c.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_c, ref c);
            if( c == null )
                c = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_c);
        }
        // This function returns no value.
    }
    
    public static void laguerrecoefficients(int n, out double[] c)
    {
        _core_laguerrecoefficients( n, out  c, 0x0);
    }
    
    public static void laguerrecoefficients(int n, out double[] c, alglib.xparams _xparams)
    {
        _core_laguerrecoefficients( n, out  c, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage elliptic
    //
    
    
    private static unsafe double _core_ellipticintegralk(double m, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        double _d_m = m;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_ellipticintegralk(&_s_errormsg, &_d_result, &_d_m, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "ellipticintegralk");
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double ellipticintegralk(double m)
    {
        return _core_ellipticintegralk( m, 0x0);
    }
    
    public static double ellipticintegralk(double m, alglib.xparams _xparams)
    {
        return _core_ellipticintegralk( m, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_ellipticintegralkhighprecision(double m1, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        double _d_m1 = m1;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_ellipticintegralkhighprecision(&_s_errormsg, &_d_result, &_d_m1, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "ellipticintegralkhighprecision");
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double ellipticintegralkhighprecision(double m1)
    {
        return _core_ellipticintegralkhighprecision( m1, 0x0);
    }
    
    public static double ellipticintegralkhighprecision(double m1, alglib.xparams _xparams)
    {
        return _core_ellipticintegralkhighprecision( m1, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_incompleteellipticintegralk(double phi, double m, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        double _d_phi = phi;
        double _d_m = m;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_incompleteellipticintegralk(&_s_errormsg, &_d_result, &_d_phi, &_d_m, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "incompleteellipticintegralk");
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double incompleteellipticintegralk(double phi, double m)
    {
        return _core_incompleteellipticintegralk( phi,  m, 0x0);
    }
    
    public static double incompleteellipticintegralk(double phi, double m, alglib.xparams _xparams)
    {
        return _core_incompleteellipticintegralk( phi,  m, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_ellipticintegrale(double m, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        double _d_m = m;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_ellipticintegrale(&_s_errormsg, &_d_result, &_d_m, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "ellipticintegrale");
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double ellipticintegrale(double m)
    {
        return _core_ellipticintegrale( m, 0x0);
    }
    
    public static double ellipticintegrale(double m, alglib.xparams _xparams)
    {
        return _core_ellipticintegrale( m, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_incompleteellipticintegrale(double phi, double m, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        double _d_phi = phi;
        double _d_m = m;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_incompleteellipticintegrale(&_s_errormsg, &_d_result, &_d_phi, &_d_m, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "incompleteellipticintegrale");
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double incompleteellipticintegrale(double phi, double m)
    {
        return _core_incompleteellipticintegrale( phi,  m, 0x0);
    }
    
    public static double incompleteellipticintegrale(double phi, double m, alglib.xparams _xparams)
    {
        return _core_incompleteellipticintegrale( phi,  m, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage pca
    //
    
    
    private static unsafe void _core_pcabuildbasis(double[,] x, int npoints, int nvars, out int info, out double[] s2, out double[,] v, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_x = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        x_int _d_nvars = new x_int(nvars);
        x_int _d_info = new x_int();
        x_vector _d_s2 = new x_vector();
        x_matrix _d_v = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_matrix_attach_to_array(ref _d_x, _fp_x, ap.rows(x), ap.cols(x));
                x_vector_create_empty(ref _d_s2, DT_REAL);
                s2 = null;
                x_matrix_create_empty(ref _d_v, DT_REAL);
                v = null;
                _error_code = _i_xv2_pcabuildbasis(&_s_errormsg, &_d_x, &_d_npoints, &_d_nvars, &_d_info, &_d_s2, &_d_v, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "pcabuildbasis");
            info = _d_info.intval;
            if( _d_s2.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_s2, ref s2);
            if( s2 == null )
                s2 = new double[0];
            if( _d_v.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_v, ref v);
            if( v == null )
                v = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_x);
            x_vector_clear(ref _d_s2);
            x_matrix_clear(ref _d_v);
        }
        // This function returns no value.
    }
    
    public static void pcabuildbasis(double[,] x, int npoints, int nvars, out int info, out double[] s2, out double[,] v)
    {
        _core_pcabuildbasis( x,  npoints,  nvars, out  info, out  s2, out  v, 0x0);
    }
    
    public static void pcabuildbasis(double[,] x, int npoints, int nvars, out int info, out double[] s2, out double[,] v, alglib.xparams _xparams)
    {
        _core_pcabuildbasis( x,  npoints,  nvars, out  info, out  s2, out  v, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_pcatruncatedsubspace(double[,] x, int npoints, int nvars, int nneeded, double eps, int maxits, out double[] s2, out double[,] v, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_x = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        x_int _d_nvars = new x_int(nvars);
        x_int _d_nneeded = new x_int(nneeded);
        double _d_eps = eps;
        x_int _d_maxits = new x_int(maxits);
        x_vector _d_s2 = new x_vector();
        x_matrix _d_v = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_matrix_attach_to_array(ref _d_x, _fp_x, ap.rows(x), ap.cols(x));
                x_vector_create_empty(ref _d_s2, DT_REAL);
                s2 = null;
                x_matrix_create_empty(ref _d_v, DT_REAL);
                v = null;
                _error_code = _i_xv2_pcatruncatedsubspace(&_s_errormsg, &_d_x, &_d_npoints, &_d_nvars, &_d_nneeded, &_d_eps, &_d_maxits, &_d_s2, &_d_v, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "pcatruncatedsubspace");
            if( _d_s2.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_s2, ref s2);
            if( s2 == null )
                s2 = new double[0];
            if( _d_v.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_v, ref v);
            if( v == null )
                v = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_x);
            x_vector_clear(ref _d_s2);
            x_matrix_clear(ref _d_v);
        }
        // This function returns no value.
    }
    
    public static void pcatruncatedsubspace(double[,] x, int npoints, int nvars, int nneeded, double eps, int maxits, out double[] s2, out double[,] v)
    {
        _core_pcatruncatedsubspace( x,  npoints,  nvars,  nneeded,  eps,  maxits, out  s2, out  v, 0x0);
    }
    
    public static void pcatruncatedsubspace(double[,] x, int npoints, int nvars, int nneeded, double eps, int maxits, out double[] s2, out double[,] v, alglib.xparams _xparams)
    {
        _core_pcatruncatedsubspace( x,  npoints,  nvars,  nneeded,  eps,  maxits, out  s2, out  v, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_pcatruncatedsubspacesparse(sparsematrix x, int npoints, int nvars, int nneeded, double eps, int maxits, out double[] s2, out double[,] v, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_x = x.ptr;
        x_int _d_npoints = new x_int(npoints);
        x_int _d_nvars = new x_int(nvars);
        x_int _d_nneeded = new x_int(nneeded);
        double _d_eps = eps;
        x_int _d_maxits = new x_int(maxits);
        x_vector _d_s2 = new x_vector();
        x_matrix _d_v = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_s2, DT_REAL);
            s2 = null;
            x_matrix_create_empty(ref _d_v, DT_REAL);
            v = null;
            _error_code = _i_xv2_pcatruncatedsubspacesparse(&_s_errormsg, &_d_x, &_d_npoints, &_d_nvars, &_d_nneeded, &_d_eps, &_d_maxits, &_d_s2, &_d_v, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "pcatruncatedsubspacesparse");
            ap.assert(x.ptr==_d_x, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_s2.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_s2, ref s2);
            if( s2 == null )
                s2 = new double[0];
            if( _d_v.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_v, ref v);
            if( v == null )
                v = new double[0,0];
        }
        finally
        {
            x_vector_clear(ref _d_s2);
            x_matrix_clear(ref _d_v);
        }
        // This function returns no value.
    }
    
    public static void pcatruncatedsubspacesparse(sparsematrix x, int npoints, int nvars, int nneeded, double eps, int maxits, out double[] s2, out double[,] v)
    {
        _core_pcatruncatedsubspacesparse( x,  npoints,  nvars,  nneeded,  eps,  maxits, out  s2, out  v, 0x0);
    }
    
    public static void pcatruncatedsubspacesparse(sparsematrix x, int npoints, int nvars, int nneeded, double eps, int maxits, out double[] s2, out double[,] v, alglib.xparams _xparams)
    {
        _core_pcatruncatedsubspacesparse( x,  npoints,  nvars,  nneeded,  eps,  maxits, out  s2, out  v, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage bdss
    //
    
    
    private static unsafe void _core_dsoptimalsplit2(double[] a, int[] c, int n, out int info, out double threshold, out double pal, out double pbl, out double par, out double pbr, out double cve, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_a = new x_vector();
        x_vector _d_c = new x_vector();
        x_int _d_n = new x_int(n);
        x_int _d_info = new x_int();
        double _d_threshold = 0;
        double _d_pal = 0;
        double _d_pbl = 0;
        double _d_par = 0;
        double _d_pbr = 0;
        double _d_cve = 0;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_vector_attach_to_array(ref _d_a, _fp_a, ap.len(a));
                x_vector_from_array(ref _d_c, c, X_CREATE);
                _error_code = _i_xv2_dsoptimalsplit2(&_s_errormsg, &_d_a, &_d_c, &_d_n, &_d_info, &_d_threshold, &_d_pal, &_d_pbl, &_d_par, &_d_pbr, &_d_cve, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "dsoptimalsplit2");
            info = _d_info.intval;
            threshold = _d_threshold;
            pal = _d_pal;
            pbl = _d_pbl;
            par = _d_par;
            pbr = _d_pbr;
            cve = _d_cve;
        }
        finally
        {
            x_vector_clear(ref _d_a);
            x_vector_clear(ref _d_c);
        }
        // This function returns no value.
    }
    
    public static void dsoptimalsplit2(double[] a, int[] c, int n, out int info, out double threshold, out double pal, out double pbl, out double par, out double pbr, out double cve)
    {
        _core_dsoptimalsplit2( a,  c,  n, out  info, out  threshold, out  pal, out  pbl, out  par, out  pbr, out  cve, 0x0);
    }
    
    public static void dsoptimalsplit2(double[] a, int[] c, int n, out int info, out double threshold, out double pal, out double pbl, out double par, out double pbr, out double cve, alglib.xparams _xparams)
    {
        _core_dsoptimalsplit2( a,  c,  n, out  info, out  threshold, out  pal, out  pbl, out  par, out  pbr, out  cve, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_dsoptimalsplit2fast(ref double[] a, ref int[] c, ref int[] tiesbuf, ref int[] cntbuf, ref double[] bufr, ref int[] bufi, int n, int nc, double alpha, out int info, out double threshold, out double rms, out double cvrms, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_a = new x_vector();
        x_vector _d_c = new x_vector();
        x_vector _d_tiesbuf = new x_vector();
        x_vector _d_cntbuf = new x_vector();
        x_vector _d_bufr = new x_vector();
        x_vector _d_bufi = new x_vector();
        x_int _d_n = new x_int(n);
        x_int _d_nc = new x_int(nc);
        double _d_alpha = alpha;
        x_int _d_info = new x_int();
        double _d_threshold = 0;
        double _d_rms = 0;
        double _d_cvrms = 0;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a, _fp_bufr = bufr){
                x_vector_attach_to_array(ref _d_a, _fp_a, ap.len(a));
                x_vector_from_array(ref _d_c, c, X_CREATE);
                x_vector_from_array(ref _d_tiesbuf, tiesbuf, X_CREATE);
                x_vector_from_array(ref _d_cntbuf, cntbuf, X_CREATE);
                x_vector_attach_to_array(ref _d_bufr, _fp_bufr, ap.len(bufr));
                x_vector_from_array(ref _d_bufi, bufi, X_CREATE);
                _error_code = _i_xv2_dsoptimalsplit2fast(&_s_errormsg, &_d_a, &_d_c, &_d_tiesbuf, &_d_cntbuf, &_d_bufr, &_d_bufi, &_d_n, &_d_nc, &_d_alpha, &_d_info, &_d_threshold, &_d_rms, &_d_cvrms, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "dsoptimalsplit2fast");
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_a, ref a);
            if( a == null )
                a = new double[0];
            x_vector_to_array(ref _d_c, ref c);
            x_vector_to_array(ref _d_tiesbuf, ref tiesbuf);
            x_vector_to_array(ref _d_cntbuf, ref cntbuf);
            if( _d_bufr.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_bufr, ref bufr);
            if( bufr == null )
                bufr = new double[0];
            x_vector_to_array(ref _d_bufi, ref bufi);
            info = _d_info.intval;
            threshold = _d_threshold;
            rms = _d_rms;
            cvrms = _d_cvrms;
        }
        finally
        {
            x_vector_clear(ref _d_a);
            x_vector_clear(ref _d_c);
            x_vector_clear(ref _d_tiesbuf);
            x_vector_clear(ref _d_cntbuf);
            x_vector_clear(ref _d_bufr);
            x_vector_clear(ref _d_bufi);
        }
        // This function returns no value.
    }
    
    public static void dsoptimalsplit2fast(ref double[] a, ref int[] c, ref int[] tiesbuf, ref int[] cntbuf, ref double[] bufr, ref int[] bufi, int n, int nc, double alpha, out int info, out double threshold, out double rms, out double cvrms)
    {
        _core_dsoptimalsplit2fast(ref  a, ref  c, ref  tiesbuf, ref  cntbuf, ref  bufr, ref  bufi,  n,  nc,  alpha, out  info, out  threshold, out  rms, out  cvrms, 0x0);
    }
    
    public static void dsoptimalsplit2fast(ref double[] a, ref int[] c, ref int[] tiesbuf, ref int[] cntbuf, ref double[] bufr, ref int[] bufi, int n, int nc, double alpha, out int info, out double threshold, out double rms, out double cvrms, alglib.xparams _xparams)
    {
        _core_dsoptimalsplit2fast(ref  a, ref  c, ref  tiesbuf, ref  cntbuf, ref  bufr, ref  bufi,  n,  nc,  alpha, out  info, out  threshold, out  rms, out  cvrms, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage mlpbase
    //
    

    [StructLayout(LayoutKind.Sequential, Pack=8)]
    private struct x_modelerrors
    {
        public double relclserror;
        public double avgce;
        public double rmserror;
        public double avgerror;
        public double avgrelerror;
    }

    public class modelerrors : alglibobject
    {
        public double relclserror;
        public double avgce;
        public double rmserror;
        public double avgerror;
        public double avgrelerror;
        public override alglib.alglibobject make_copy()
        {
            modelerrors dst = new modelerrors();
            dst.relclserror = relclserror;
            dst.avgce = avgce;
            dst.rmserror = rmserror;
            dst.avgerror = avgerror;
            dst.avgrelerror = avgrelerror;
            return dst;
        }
    }

    // This function initializes X-structure (its previous content is ignored)
    private static void x_modelerrors_init(ref x_modelerrors x)
    {
        x.relclserror = 0;
        x.avgce = 0;
        x.rmserror = 0;
        x.avgerror = 0;
        x.avgrelerror = 0;
    }

    // This function finalizes fields of X-structure (however, memory occupied by structure itself is not freed)
    // After destruction structure becomes unusable and should be re-initialized if you want to use it
    private static void x_modelerrors_clear(ref x_modelerrors x)
    {
    }

    // This function initializes X-structure by appropriate C# instance
    // (previous content of X structure is ignored)
    private static void x_modelerrors_init_from(ref x_modelerrors x, modelerrors v)
    {
        x.relclserror = v.relclserror;
        x.avgce = v.avgce;
        x.rmserror = v.rmserror;
        x.avgerror = v.avgerror;
        x.avgrelerror = v.avgrelerror;
    }

    // This function initializes C# structure by appropriate X instance
    // (previous content of C# structure is ignored).
    // This function may accept null v, in this case v is automatically allocated with new().
    private static void x_modelerrors_to_record(ref x_modelerrors x, ref modelerrors v)
    {
        if( v==null )
            v = new modelerrors();
        v.relclserror = x.relclserror;
        v.avgce = x.avgce;
        v.rmserror = x.rmserror;
        v.avgerror = x.avgerror;
        v.avgrelerror = x.avgrelerror;
    }

    public unsafe class multilayerperceptron : alglibobject
    {
        private void *_ptr;
        public multilayerperceptron(void *x)
        {
            _ptr = x;
        }
        ~multilayerperceptron()
        {
            _deallocate();
        }
        public void* ptr { get { return _ptr; } }
        public override alglib.alglibobject make_copy()
        {
            if( _ptr==null )
                return new multilayerperceptron(null);
            return new multilayerperceptron(_i_x_obj_copy_multilayerperceptron(_ptr));
        }
        public override void _deallocate()
        {
            if( _ptr!=null )
                _i_x_obj_free_multilayerperceptron(_ptr);
            _ptr = null;
            System.GC.SuppressFinalize(this);
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_multilayerperceptron(void *x);
    private static _d_x_obj_copy_multilayerperceptron _i_x_obj_copy_multilayerperceptron = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_obj_free_multilayerperceptron(void *x);
    private static _d_x_obj_free_multilayerperceptron _i_x_obj_free_multilayerperceptron = null;
    public static unsafe void mlpserialize(multilayerperceptron obj, out string s_out)
    {
        byte *_s_errormsg = null;
        byte *_out = null;
        void *_x = obj.ptr;
        try
        {
            int _error_code = _i_x_mlpserialize(&_s_errormsg, &_x, &_out);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpserialize");
            s_out = Marshal.PtrToStringAnsi((IntPtr)_out);
        }
        finally
        {
            x_free((IntPtr)_out);
        }
    }
    
    public static unsafe void mlpunserialize(string s_in, out multilayerperceptron obj)
    {
        byte *_s_errormsg = null;
        byte[] _ain = System.Text.Encoding.UTF8.GetBytes(s_in);
        fixed(byte *_pin = _ain )
        {
            byte *_in = _pin;
            void *_x = null;
            obj = null;
            try
            {
                int _error_code = _i_x_mlpunserialize(&_s_errormsg, &_in, &_x);
                if( _error_code!=X_OK )
                    handle_exception(_error_code, _s_errormsg, "mlpunserialize");
                obj = new multilayerperceptron(_x);
            }
            finally
            {
                // on exception clean up X objects which were not attached to C# objects
                if( _x!=null && obj==null)
                    _i_x_obj_free_multilayerperceptron(_x);
            }
        }
    }
    public static unsafe void mlpserialize(multilayerperceptron obj, System.IO.Stream s_out)
    {
        byte *_s_errormsg = null;
        void *_x = obj.ptr;
        alglib.native_stream_adapter a = new alglib.native_stream_adapter();
        a.sstart_stream(s_out);
        int _error_code = _i_x_mlpserialize_stream(&_s_errormsg, &_x, a.writer_callback, IntPtr.Zero);
        if( _error_code!=X_OK )
            handle_exception(_error_code, _s_errormsg, "mlpserialize");
    }
    
    public static unsafe void mlpunserialize(System.IO.Stream s_in, out multilayerperceptron obj)
    {
        byte *_s_errormsg = null;
        void *_x = null;
        obj = null;
        alglib.native_stream_adapter a = new alglib.native_stream_adapter();
        a.ustart_stream(s_in);
        try
        {
            int _error_code = _i_x_mlpunserialize_stream(&_s_errormsg, a.reader_callback, IntPtr.Zero, &_x);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpunserialize");
            obj = new multilayerperceptron(_x);
        }
        finally
        {
            // on exception clean up X objects which were not attached to C# objects
            if( _x!=null && obj==null)
                _i_x_obj_free_multilayerperceptron(_x);
        }
    }
    
    private static unsafe void _core_mlpcreate0(int nin, int nout, out multilayerperceptron network, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_nin = new x_int(nin);
        x_int _d_nout = new x_int(nout);
        void *_d_network = null;
        network = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_mlpcreate0(&_s_errormsg, &_d_nin, &_d_nout, &_d_network, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpcreate0");
            network = new multilayerperceptron(_d_network);
        }
        finally
        {
            if( _d_network!=null && network==null)
                _i_x_obj_free_multilayerperceptron(_d_network); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void mlpcreate0(int nin, int nout, out multilayerperceptron network)
    {
        _core_mlpcreate0( nin,  nout, out  network, 0x0);
    }
    
    public static void mlpcreate0(int nin, int nout, out multilayerperceptron network, alglib.xparams _xparams)
    {
        _core_mlpcreate0( nin,  nout, out  network, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mlpcreate1(int nin, int nhid, int nout, out multilayerperceptron network, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_nin = new x_int(nin);
        x_int _d_nhid = new x_int(nhid);
        x_int _d_nout = new x_int(nout);
        void *_d_network = null;
        network = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_mlpcreate1(&_s_errormsg, &_d_nin, &_d_nhid, &_d_nout, &_d_network, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpcreate1");
            network = new multilayerperceptron(_d_network);
        }
        finally
        {
            if( _d_network!=null && network==null)
                _i_x_obj_free_multilayerperceptron(_d_network); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void mlpcreate1(int nin, int nhid, int nout, out multilayerperceptron network)
    {
        _core_mlpcreate1( nin,  nhid,  nout, out  network, 0x0);
    }
    
    public static void mlpcreate1(int nin, int nhid, int nout, out multilayerperceptron network, alglib.xparams _xparams)
    {
        _core_mlpcreate1( nin,  nhid,  nout, out  network, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mlpcreate2(int nin, int nhid1, int nhid2, int nout, out multilayerperceptron network, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_nin = new x_int(nin);
        x_int _d_nhid1 = new x_int(nhid1);
        x_int _d_nhid2 = new x_int(nhid2);
        x_int _d_nout = new x_int(nout);
        void *_d_network = null;
        network = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_mlpcreate2(&_s_errormsg, &_d_nin, &_d_nhid1, &_d_nhid2, &_d_nout, &_d_network, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpcreate2");
            network = new multilayerperceptron(_d_network);
        }
        finally
        {
            if( _d_network!=null && network==null)
                _i_x_obj_free_multilayerperceptron(_d_network); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void mlpcreate2(int nin, int nhid1, int nhid2, int nout, out multilayerperceptron network)
    {
        _core_mlpcreate2( nin,  nhid1,  nhid2,  nout, out  network, 0x0);
    }
    
    public static void mlpcreate2(int nin, int nhid1, int nhid2, int nout, out multilayerperceptron network, alglib.xparams _xparams)
    {
        _core_mlpcreate2( nin,  nhid1,  nhid2,  nout, out  network, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mlpcreateb0(int nin, int nout, double b, double d, out multilayerperceptron network, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_nin = new x_int(nin);
        x_int _d_nout = new x_int(nout);
        double _d_b = b;
        double _d_d = d;
        void *_d_network = null;
        network = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_mlpcreateb0(&_s_errormsg, &_d_nin, &_d_nout, &_d_b, &_d_d, &_d_network, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpcreateb0");
            network = new multilayerperceptron(_d_network);
        }
        finally
        {
            if( _d_network!=null && network==null)
                _i_x_obj_free_multilayerperceptron(_d_network); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void mlpcreateb0(int nin, int nout, double b, double d, out multilayerperceptron network)
    {
        _core_mlpcreateb0( nin,  nout,  b,  d, out  network, 0x0);
    }
    
    public static void mlpcreateb0(int nin, int nout, double b, double d, out multilayerperceptron network, alglib.xparams _xparams)
    {
        _core_mlpcreateb0( nin,  nout,  b,  d, out  network, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mlpcreateb1(int nin, int nhid, int nout, double b, double d, out multilayerperceptron network, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_nin = new x_int(nin);
        x_int _d_nhid = new x_int(nhid);
        x_int _d_nout = new x_int(nout);
        double _d_b = b;
        double _d_d = d;
        void *_d_network = null;
        network = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_mlpcreateb1(&_s_errormsg, &_d_nin, &_d_nhid, &_d_nout, &_d_b, &_d_d, &_d_network, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpcreateb1");
            network = new multilayerperceptron(_d_network);
        }
        finally
        {
            if( _d_network!=null && network==null)
                _i_x_obj_free_multilayerperceptron(_d_network); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void mlpcreateb1(int nin, int nhid, int nout, double b, double d, out multilayerperceptron network)
    {
        _core_mlpcreateb1( nin,  nhid,  nout,  b,  d, out  network, 0x0);
    }
    
    public static void mlpcreateb1(int nin, int nhid, int nout, double b, double d, out multilayerperceptron network, alglib.xparams _xparams)
    {
        _core_mlpcreateb1( nin,  nhid,  nout,  b,  d, out  network, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mlpcreateb2(int nin, int nhid1, int nhid2, int nout, double b, double d, out multilayerperceptron network, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_nin = new x_int(nin);
        x_int _d_nhid1 = new x_int(nhid1);
        x_int _d_nhid2 = new x_int(nhid2);
        x_int _d_nout = new x_int(nout);
        double _d_b = b;
        double _d_d = d;
        void *_d_network = null;
        network = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_mlpcreateb2(&_s_errormsg, &_d_nin, &_d_nhid1, &_d_nhid2, &_d_nout, &_d_b, &_d_d, &_d_network, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpcreateb2");
            network = new multilayerperceptron(_d_network);
        }
        finally
        {
            if( _d_network!=null && network==null)
                _i_x_obj_free_multilayerperceptron(_d_network); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void mlpcreateb2(int nin, int nhid1, int nhid2, int nout, double b, double d, out multilayerperceptron network)
    {
        _core_mlpcreateb2( nin,  nhid1,  nhid2,  nout,  b,  d, out  network, 0x0);
    }
    
    public static void mlpcreateb2(int nin, int nhid1, int nhid2, int nout, double b, double d, out multilayerperceptron network, alglib.xparams _xparams)
    {
        _core_mlpcreateb2( nin,  nhid1,  nhid2,  nout,  b,  d, out  network, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mlpcreater0(int nin, int nout, double a, double b, out multilayerperceptron network, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_nin = new x_int(nin);
        x_int _d_nout = new x_int(nout);
        double _d_a = a;
        double _d_b = b;
        void *_d_network = null;
        network = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_mlpcreater0(&_s_errormsg, &_d_nin, &_d_nout, &_d_a, &_d_b, &_d_network, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpcreater0");
            network = new multilayerperceptron(_d_network);
        }
        finally
        {
            if( _d_network!=null && network==null)
                _i_x_obj_free_multilayerperceptron(_d_network); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void mlpcreater0(int nin, int nout, double a, double b, out multilayerperceptron network)
    {
        _core_mlpcreater0( nin,  nout,  a,  b, out  network, 0x0);
    }
    
    public static void mlpcreater0(int nin, int nout, double a, double b, out multilayerperceptron network, alglib.xparams _xparams)
    {
        _core_mlpcreater0( nin,  nout,  a,  b, out  network, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mlpcreater1(int nin, int nhid, int nout, double a, double b, out multilayerperceptron network, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_nin = new x_int(nin);
        x_int _d_nhid = new x_int(nhid);
        x_int _d_nout = new x_int(nout);
        double _d_a = a;
        double _d_b = b;
        void *_d_network = null;
        network = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_mlpcreater1(&_s_errormsg, &_d_nin, &_d_nhid, &_d_nout, &_d_a, &_d_b, &_d_network, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpcreater1");
            network = new multilayerperceptron(_d_network);
        }
        finally
        {
            if( _d_network!=null && network==null)
                _i_x_obj_free_multilayerperceptron(_d_network); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void mlpcreater1(int nin, int nhid, int nout, double a, double b, out multilayerperceptron network)
    {
        _core_mlpcreater1( nin,  nhid,  nout,  a,  b, out  network, 0x0);
    }
    
    public static void mlpcreater1(int nin, int nhid, int nout, double a, double b, out multilayerperceptron network, alglib.xparams _xparams)
    {
        _core_mlpcreater1( nin,  nhid,  nout,  a,  b, out  network, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mlpcreater2(int nin, int nhid1, int nhid2, int nout, double a, double b, out multilayerperceptron network, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_nin = new x_int(nin);
        x_int _d_nhid1 = new x_int(nhid1);
        x_int _d_nhid2 = new x_int(nhid2);
        x_int _d_nout = new x_int(nout);
        double _d_a = a;
        double _d_b = b;
        void *_d_network = null;
        network = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_mlpcreater2(&_s_errormsg, &_d_nin, &_d_nhid1, &_d_nhid2, &_d_nout, &_d_a, &_d_b, &_d_network, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpcreater2");
            network = new multilayerperceptron(_d_network);
        }
        finally
        {
            if( _d_network!=null && network==null)
                _i_x_obj_free_multilayerperceptron(_d_network); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void mlpcreater2(int nin, int nhid1, int nhid2, int nout, double a, double b, out multilayerperceptron network)
    {
        _core_mlpcreater2( nin,  nhid1,  nhid2,  nout,  a,  b, out  network, 0x0);
    }
    
    public static void mlpcreater2(int nin, int nhid1, int nhid2, int nout, double a, double b, out multilayerperceptron network, alglib.xparams _xparams)
    {
        _core_mlpcreater2( nin,  nhid1,  nhid2,  nout,  a,  b, out  network, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mlpcreatec0(int nin, int nout, out multilayerperceptron network, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_nin = new x_int(nin);
        x_int _d_nout = new x_int(nout);
        void *_d_network = null;
        network = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_mlpcreatec0(&_s_errormsg, &_d_nin, &_d_nout, &_d_network, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpcreatec0");
            network = new multilayerperceptron(_d_network);
        }
        finally
        {
            if( _d_network!=null && network==null)
                _i_x_obj_free_multilayerperceptron(_d_network); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void mlpcreatec0(int nin, int nout, out multilayerperceptron network)
    {
        _core_mlpcreatec0( nin,  nout, out  network, 0x0);
    }
    
    public static void mlpcreatec0(int nin, int nout, out multilayerperceptron network, alglib.xparams _xparams)
    {
        _core_mlpcreatec0( nin,  nout, out  network, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mlpcreatec1(int nin, int nhid, int nout, out multilayerperceptron network, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_nin = new x_int(nin);
        x_int _d_nhid = new x_int(nhid);
        x_int _d_nout = new x_int(nout);
        void *_d_network = null;
        network = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_mlpcreatec1(&_s_errormsg, &_d_nin, &_d_nhid, &_d_nout, &_d_network, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpcreatec1");
            network = new multilayerperceptron(_d_network);
        }
        finally
        {
            if( _d_network!=null && network==null)
                _i_x_obj_free_multilayerperceptron(_d_network); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void mlpcreatec1(int nin, int nhid, int nout, out multilayerperceptron network)
    {
        _core_mlpcreatec1( nin,  nhid,  nout, out  network, 0x0);
    }
    
    public static void mlpcreatec1(int nin, int nhid, int nout, out multilayerperceptron network, alglib.xparams _xparams)
    {
        _core_mlpcreatec1( nin,  nhid,  nout, out  network, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mlpcreatec2(int nin, int nhid1, int nhid2, int nout, out multilayerperceptron network, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_nin = new x_int(nin);
        x_int _d_nhid1 = new x_int(nhid1);
        x_int _d_nhid2 = new x_int(nhid2);
        x_int _d_nout = new x_int(nout);
        void *_d_network = null;
        network = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_mlpcreatec2(&_s_errormsg, &_d_nin, &_d_nhid1, &_d_nhid2, &_d_nout, &_d_network, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpcreatec2");
            network = new multilayerperceptron(_d_network);
        }
        finally
        {
            if( _d_network!=null && network==null)
                _i_x_obj_free_multilayerperceptron(_d_network); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void mlpcreatec2(int nin, int nhid1, int nhid2, int nout, out multilayerperceptron network)
    {
        _core_mlpcreatec2( nin,  nhid1,  nhid2,  nout, out  network, 0x0);
    }
    
    public static void mlpcreatec2(int nin, int nhid1, int nhid2, int nout, out multilayerperceptron network, alglib.xparams _xparams)
    {
        _core_mlpcreatec2( nin,  nhid1,  nhid2,  nout, out  network, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mlpcopy(multilayerperceptron network1, out multilayerperceptron network2, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_network1 = network1.ptr;
        void *_d_network2 = null;
        network2 = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_mlpcopy(&_s_errormsg, &_d_network1, &_d_network2, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpcopy");
            ap.assert(network1.ptr==_d_network1, "ALGLIB: internal error (reference changed for non-out X-object)");
            network2 = new multilayerperceptron(_d_network2);
        }
        finally
        {
            if( _d_network2!=null && network2==null)
                _i_x_obj_free_multilayerperceptron(_d_network2); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void mlpcopy(multilayerperceptron network1, out multilayerperceptron network2)
    {
        _core_mlpcopy( network1, out  network2, 0x0);
    }
    
    public static void mlpcopy(multilayerperceptron network1, out multilayerperceptron network2, alglib.xparams _xparams)
    {
        _core_mlpcopy( network1, out  network2, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mlpcopytunableparameters(multilayerperceptron network1, multilayerperceptron network2, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_network1 = network1.ptr;
        void *_d_network2 = network2.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_mlpcopytunableparameters(&_s_errormsg, &_d_network1, &_d_network2, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpcopytunableparameters");
            ap.assert(network1.ptr==_d_network1, "ALGLIB: internal error (reference changed for non-out X-object)");
            ap.assert(network2.ptr==_d_network2, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void mlpcopytunableparameters(multilayerperceptron network1, multilayerperceptron network2)
    {
        _core_mlpcopytunableparameters( network1,  network2, 0x0);
    }
    
    public static void mlpcopytunableparameters(multilayerperceptron network1, multilayerperceptron network2, alglib.xparams _xparams)
    {
        _core_mlpcopytunableparameters( network1,  network2, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mlprandomize(multilayerperceptron network, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_network = network.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_mlprandomize(&_s_errormsg, &_d_network, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlprandomize");
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void mlprandomize(multilayerperceptron network)
    {
        _core_mlprandomize( network, 0x0);
    }
    
    public static void mlprandomize(multilayerperceptron network, alglib.xparams _xparams)
    {
        _core_mlprandomize( network, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mlprandomizefull(multilayerperceptron network, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_network = network.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_mlprandomizefull(&_s_errormsg, &_d_network, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlprandomizefull");
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void mlprandomizefull(multilayerperceptron network)
    {
        _core_mlprandomizefull( network, 0x0);
    }
    
    public static void mlprandomizefull(multilayerperceptron network, alglib.xparams _xparams)
    {
        _core_mlprandomizefull( network, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mlpinitpreprocessor(multilayerperceptron network, double[,] xy, int ssize, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_network = network.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_ssize = new x_int(ssize);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_xv2_mlpinitpreprocessor(&_s_errormsg, &_d_network, &_d_xy, &_d_ssize, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpinitpreprocessor");
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
        }
        // This function returns no value.
    }
    
    public static void mlpinitpreprocessor(multilayerperceptron network, double[,] xy, int ssize)
    {
        _core_mlpinitpreprocessor( network,  xy,  ssize, 0x0);
    }
    
    public static void mlpinitpreprocessor(multilayerperceptron network, double[,] xy, int ssize, alglib.xparams _xparams)
    {
        _core_mlpinitpreprocessor( network,  xy,  ssize, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mlpproperties(multilayerperceptron network, out int nin, out int nout, out int wcount, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_network = network.ptr;
        x_int _d_nin = new x_int();
        x_int _d_nout = new x_int();
        x_int _d_wcount = new x_int();
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_mlpproperties(&_s_errormsg, &_d_network, &_d_nin, &_d_nout, &_d_wcount, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpproperties");
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
            nin = _d_nin.intval;
            nout = _d_nout.intval;
            wcount = _d_wcount.intval;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void mlpproperties(multilayerperceptron network, out int nin, out int nout, out int wcount)
    {
        _core_mlpproperties( network, out  nin, out  nout, out  wcount, 0x0);
    }
    
    public static void mlpproperties(multilayerperceptron network, out int nin, out int nout, out int wcount, alglib.xparams _xparams)
    {
        _core_mlpproperties( network, out  nin, out  nout, out  wcount, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe int _core_mlpgetinputscount(multilayerperceptron network, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        int result;
        x_int _d_result = new x_int();
        void *_d_network = network.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_mlpgetinputscount(&_s_errormsg, &_d_result, &_d_network, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpgetinputscount");
            result = _d_result.intval;
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static int mlpgetinputscount(multilayerperceptron network)
    {
        return _core_mlpgetinputscount( network, 0x0);
    }
    
    public static int mlpgetinputscount(multilayerperceptron network, alglib.xparams _xparams)
    {
        return _core_mlpgetinputscount( network, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe int _core_mlpgetoutputscount(multilayerperceptron network, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        int result;
        x_int _d_result = new x_int();
        void *_d_network = network.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_mlpgetoutputscount(&_s_errormsg, &_d_result, &_d_network, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpgetoutputscount");
            result = _d_result.intval;
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static int mlpgetoutputscount(multilayerperceptron network)
    {
        return _core_mlpgetoutputscount( network, 0x0);
    }
    
    public static int mlpgetoutputscount(multilayerperceptron network, alglib.xparams _xparams)
    {
        return _core_mlpgetoutputscount( network, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe int _core_mlpgetweightscount(multilayerperceptron network, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        int result;
        x_int _d_result = new x_int();
        void *_d_network = network.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_mlpgetweightscount(&_s_errormsg, &_d_result, &_d_network, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpgetweightscount");
            result = _d_result.intval;
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static int mlpgetweightscount(multilayerperceptron network)
    {
        return _core_mlpgetweightscount( network, 0x0);
    }
    
    public static int mlpgetweightscount(multilayerperceptron network, alglib.xparams _xparams)
    {
        return _core_mlpgetweightscount( network, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe bool _core_mlpissoftmax(multilayerperceptron network, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        bool result;
        byte _d_result = (byte)0;
        void *_d_network = network.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_mlpissoftmax(&_s_errormsg, &_d_result, &_d_network, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpissoftmax");
            result = _d_result!=0;
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static bool mlpissoftmax(multilayerperceptron network)
    {
        return _core_mlpissoftmax( network, 0x0);
    }
    
    public static bool mlpissoftmax(multilayerperceptron network, alglib.xparams _xparams)
    {
        return _core_mlpissoftmax( network, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe int _core_mlpgetlayerscount(multilayerperceptron network, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        int result;
        x_int _d_result = new x_int();
        void *_d_network = network.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_mlpgetlayerscount(&_s_errormsg, &_d_result, &_d_network, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpgetlayerscount");
            result = _d_result.intval;
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static int mlpgetlayerscount(multilayerperceptron network)
    {
        return _core_mlpgetlayerscount( network, 0x0);
    }
    
    public static int mlpgetlayerscount(multilayerperceptron network, alglib.xparams _xparams)
    {
        return _core_mlpgetlayerscount( network, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe int _core_mlpgetlayersize(multilayerperceptron network, int k, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        int result;
        x_int _d_result = new x_int();
        void *_d_network = network.ptr;
        x_int _d_k = new x_int(k);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_mlpgetlayersize(&_s_errormsg, &_d_result, &_d_network, &_d_k, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpgetlayersize");
            result = _d_result.intval;
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static int mlpgetlayersize(multilayerperceptron network, int k)
    {
        return _core_mlpgetlayersize( network,  k, 0x0);
    }
    
    public static int mlpgetlayersize(multilayerperceptron network, int k, alglib.xparams _xparams)
    {
        return _core_mlpgetlayersize( network,  k, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mlpgetinputscaling(multilayerperceptron network, int i, out double mean, out double sigma, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_network = network.ptr;
        x_int _d_i = new x_int(i);
        double _d_mean = 0;
        double _d_sigma = 0;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_mlpgetinputscaling(&_s_errormsg, &_d_network, &_d_i, &_d_mean, &_d_sigma, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpgetinputscaling");
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
            mean = _d_mean;
            sigma = _d_sigma;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void mlpgetinputscaling(multilayerperceptron network, int i, out double mean, out double sigma)
    {
        _core_mlpgetinputscaling( network,  i, out  mean, out  sigma, 0x0);
    }
    
    public static void mlpgetinputscaling(multilayerperceptron network, int i, out double mean, out double sigma, alglib.xparams _xparams)
    {
        _core_mlpgetinputscaling( network,  i, out  mean, out  sigma, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mlpgetoutputscaling(multilayerperceptron network, int i, out double mean, out double sigma, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_network = network.ptr;
        x_int _d_i = new x_int(i);
        double _d_mean = 0;
        double _d_sigma = 0;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_mlpgetoutputscaling(&_s_errormsg, &_d_network, &_d_i, &_d_mean, &_d_sigma, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpgetoutputscaling");
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
            mean = _d_mean;
            sigma = _d_sigma;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void mlpgetoutputscaling(multilayerperceptron network, int i, out double mean, out double sigma)
    {
        _core_mlpgetoutputscaling( network,  i, out  mean, out  sigma, 0x0);
    }
    
    public static void mlpgetoutputscaling(multilayerperceptron network, int i, out double mean, out double sigma, alglib.xparams _xparams)
    {
        _core_mlpgetoutputscaling( network,  i, out  mean, out  sigma, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mlpgetneuroninfo(multilayerperceptron network, int k, int i, out int fkind, out double threshold, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_network = network.ptr;
        x_int _d_k = new x_int(k);
        x_int _d_i = new x_int(i);
        x_int _d_fkind = new x_int();
        double _d_threshold = 0;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_mlpgetneuroninfo(&_s_errormsg, &_d_network, &_d_k, &_d_i, &_d_fkind, &_d_threshold, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpgetneuroninfo");
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
            fkind = _d_fkind.intval;
            threshold = _d_threshold;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void mlpgetneuroninfo(multilayerperceptron network, int k, int i, out int fkind, out double threshold)
    {
        _core_mlpgetneuroninfo( network,  k,  i, out  fkind, out  threshold, 0x0);
    }
    
    public static void mlpgetneuroninfo(multilayerperceptron network, int k, int i, out int fkind, out double threshold, alglib.xparams _xparams)
    {
        _core_mlpgetneuroninfo( network,  k,  i, out  fkind, out  threshold, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_mlpgetweight(multilayerperceptron network, int k0, int i0, int k1, int i1, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_network = network.ptr;
        x_int _d_k0 = new x_int(k0);
        x_int _d_i0 = new x_int(i0);
        x_int _d_k1 = new x_int(k1);
        x_int _d_i1 = new x_int(i1);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_mlpgetweight(&_s_errormsg, &_d_result, &_d_network, &_d_k0, &_d_i0, &_d_k1, &_d_i1, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpgetweight");
            result = _d_result;
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double mlpgetweight(multilayerperceptron network, int k0, int i0, int k1, int i1)
    {
        return _core_mlpgetweight( network,  k0,  i0,  k1,  i1, 0x0);
    }
    
    public static double mlpgetweight(multilayerperceptron network, int k0, int i0, int k1, int i1, alglib.xparams _xparams)
    {
        return _core_mlpgetweight( network,  k0,  i0,  k1,  i1, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mlpsetinputscaling(multilayerperceptron network, int i, double mean, double sigma, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_network = network.ptr;
        x_int _d_i = new x_int(i);
        double _d_mean = mean;
        double _d_sigma = sigma;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_mlpsetinputscaling(&_s_errormsg, &_d_network, &_d_i, &_d_mean, &_d_sigma, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpsetinputscaling");
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void mlpsetinputscaling(multilayerperceptron network, int i, double mean, double sigma)
    {
        _core_mlpsetinputscaling( network,  i,  mean,  sigma, 0x0);
    }
    
    public static void mlpsetinputscaling(multilayerperceptron network, int i, double mean, double sigma, alglib.xparams _xparams)
    {
        _core_mlpsetinputscaling( network,  i,  mean,  sigma, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mlpsetoutputscaling(multilayerperceptron network, int i, double mean, double sigma, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_network = network.ptr;
        x_int _d_i = new x_int(i);
        double _d_mean = mean;
        double _d_sigma = sigma;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_mlpsetoutputscaling(&_s_errormsg, &_d_network, &_d_i, &_d_mean, &_d_sigma, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpsetoutputscaling");
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void mlpsetoutputscaling(multilayerperceptron network, int i, double mean, double sigma)
    {
        _core_mlpsetoutputscaling( network,  i,  mean,  sigma, 0x0);
    }
    
    public static void mlpsetoutputscaling(multilayerperceptron network, int i, double mean, double sigma, alglib.xparams _xparams)
    {
        _core_mlpsetoutputscaling( network,  i,  mean,  sigma, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mlpsetneuroninfo(multilayerperceptron network, int k, int i, int fkind, double threshold, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_network = network.ptr;
        x_int _d_k = new x_int(k);
        x_int _d_i = new x_int(i);
        x_int _d_fkind = new x_int(fkind);
        double _d_threshold = threshold;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_mlpsetneuroninfo(&_s_errormsg, &_d_network, &_d_k, &_d_i, &_d_fkind, &_d_threshold, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpsetneuroninfo");
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void mlpsetneuroninfo(multilayerperceptron network, int k, int i, int fkind, double threshold)
    {
        _core_mlpsetneuroninfo( network,  k,  i,  fkind,  threshold, 0x0);
    }
    
    public static void mlpsetneuroninfo(multilayerperceptron network, int k, int i, int fkind, double threshold, alglib.xparams _xparams)
    {
        _core_mlpsetneuroninfo( network,  k,  i,  fkind,  threshold, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mlpsetweight(multilayerperceptron network, int k0, int i0, int k1, int i1, double w, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_network = network.ptr;
        x_int _d_k0 = new x_int(k0);
        x_int _d_i0 = new x_int(i0);
        x_int _d_k1 = new x_int(k1);
        x_int _d_i1 = new x_int(i1);
        double _d_w = w;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_mlpsetweight(&_s_errormsg, &_d_network, &_d_k0, &_d_i0, &_d_k1, &_d_i1, &_d_w, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpsetweight");
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void mlpsetweight(multilayerperceptron network, int k0, int i0, int k1, int i1, double w)
    {
        _core_mlpsetweight( network,  k0,  i0,  k1,  i1,  w, 0x0);
    }
    
    public static void mlpsetweight(multilayerperceptron network, int k0, int i0, int k1, int i1, double w, alglib.xparams _xparams)
    {
        _core_mlpsetweight( network,  k0,  i0,  k1,  i1,  w, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mlpactivationfunction(double net, int k, out double f, out double df, out double d2f, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double _d_net = net;
        x_int _d_k = new x_int(k);
        double _d_f = 0;
        double _d_df = 0;
        double _d_d2f = 0;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_mlpactivationfunction(&_s_errormsg, &_d_net, &_d_k, &_d_f, &_d_df, &_d_d2f, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpactivationfunction");
            f = _d_f;
            df = _d_df;
            d2f = _d_d2f;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void mlpactivationfunction(double net, int k, out double f, out double df, out double d2f)
    {
        _core_mlpactivationfunction( net,  k, out  f, out  df, out  d2f, 0x0);
    }
    
    public static void mlpactivationfunction(double net, int k, out double f, out double df, out double d2f, alglib.xparams _xparams)
    {
        _core_mlpactivationfunction( net,  k, out  f, out  df, out  d2f, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mlpprocess(multilayerperceptron network, double[] x, ref double[] y, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_network = network.ptr;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                _error_code = _i_xv2_mlpprocess(&_s_errormsg, &_d_network, &_d_x, &_d_y, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpprocess");
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_y.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_y, ref y);
            if( y == null )
                y = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
        }
        // This function returns no value.
    }
    
    public static void mlpprocess(multilayerperceptron network, double[] x, ref double[] y)
    {
        _core_mlpprocess( network,  x, ref  y, 0x0);
    }
    
    public static void mlpprocess(multilayerperceptron network, double[] x, ref double[] y, alglib.xparams _xparams)
    {
        _core_mlpprocess( network,  x, ref  y, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mlpprocessi(multilayerperceptron network, double[] x, out double[] y, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_network = network.ptr;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_create_empty(ref _d_y, DT_REAL);
                y = null;
                _error_code = _i_xv2_mlpprocessi(&_s_errormsg, &_d_network, &_d_x, &_d_y, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpprocessi");
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_y.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_y, ref y);
            if( y == null )
                y = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
        }
        // This function returns no value.
    }
    
    public static void mlpprocessi(multilayerperceptron network, double[] x, out double[] y)
    {
        _core_mlpprocessi( network,  x, out  y, 0x0);
    }
    
    public static void mlpprocessi(multilayerperceptron network, double[] x, out double[] y, alglib.xparams _xparams)
    {
        _core_mlpprocessi( network,  x, out  y, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_mlperror(multilayerperceptron network, double[,] xy, int npoints, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_network = network.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_xv2_mlperror(&_s_errormsg, &_d_result, &_d_network, &_d_xy, &_d_npoints, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlperror");
            result = _d_result;
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
        }
        return result;
    }
    
    public static double mlperror(multilayerperceptron network, double[,] xy, int npoints)
    {
        return _core_mlperror( network,  xy,  npoints, 0x0);
    }
    
    public static double mlperror(multilayerperceptron network, double[,] xy, int npoints, alglib.xparams _xparams)
    {
        return _core_mlperror( network,  xy,  npoints, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_mlperrorsparse(multilayerperceptron network, sparsematrix xy, int npoints, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_network = network.ptr;
        void *_d_xy = xy.ptr;
        x_int _d_npoints = new x_int(npoints);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_mlperrorsparse(&_s_errormsg, &_d_result, &_d_network, &_d_xy, &_d_npoints, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlperrorsparse");
            result = _d_result;
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
            ap.assert(xy.ptr==_d_xy, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double mlperrorsparse(multilayerperceptron network, sparsematrix xy, int npoints)
    {
        return _core_mlperrorsparse( network,  xy,  npoints, 0x0);
    }
    
    public static double mlperrorsparse(multilayerperceptron network, sparsematrix xy, int npoints, alglib.xparams _xparams)
    {
        return _core_mlperrorsparse( network,  xy,  npoints, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_mlperrorn(multilayerperceptron network, double[,] xy, int ssize, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_network = network.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_ssize = new x_int(ssize);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_xv2_mlperrorn(&_s_errormsg, &_d_result, &_d_network, &_d_xy, &_d_ssize, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlperrorn");
            result = _d_result;
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
        }
        return result;
    }
    
    public static double mlperrorn(multilayerperceptron network, double[,] xy, int ssize)
    {
        return _core_mlperrorn( network,  xy,  ssize, 0x0);
    }
    
    public static double mlperrorn(multilayerperceptron network, double[,] xy, int ssize, alglib.xparams _xparams)
    {
        return _core_mlperrorn( network,  xy,  ssize, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe int _core_mlpclserror(multilayerperceptron network, double[,] xy, int npoints, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        int result;
        x_int _d_result = new x_int();
        void *_d_network = network.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_xv2_mlpclserror(&_s_errormsg, &_d_result, &_d_network, &_d_xy, &_d_npoints, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpclserror");
            result = _d_result.intval;
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
        }
        return result;
    }
    
    public static int mlpclserror(multilayerperceptron network, double[,] xy, int npoints)
    {
        return _core_mlpclserror( network,  xy,  npoints, 0x0);
    }
    
    public static int mlpclserror(multilayerperceptron network, double[,] xy, int npoints, alglib.xparams _xparams)
    {
        return _core_mlpclserror( network,  xy,  npoints, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_mlprelclserror(multilayerperceptron network, double[,] xy, int npoints, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_network = network.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_xv2_mlprelclserror(&_s_errormsg, &_d_result, &_d_network, &_d_xy, &_d_npoints, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlprelclserror");
            result = _d_result;
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
        }
        return result;
    }
    
    public static double mlprelclserror(multilayerperceptron network, double[,] xy, int npoints)
    {
        return _core_mlprelclserror( network,  xy,  npoints, 0x0);
    }
    
    public static double mlprelclserror(multilayerperceptron network, double[,] xy, int npoints, alglib.xparams _xparams)
    {
        return _core_mlprelclserror( network,  xy,  npoints, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_mlprelclserrorsparse(multilayerperceptron network, sparsematrix xy, int npoints, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_network = network.ptr;
        void *_d_xy = xy.ptr;
        x_int _d_npoints = new x_int(npoints);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_mlprelclserrorsparse(&_s_errormsg, &_d_result, &_d_network, &_d_xy, &_d_npoints, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlprelclserrorsparse");
            result = _d_result;
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
            ap.assert(xy.ptr==_d_xy, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double mlprelclserrorsparse(multilayerperceptron network, sparsematrix xy, int npoints)
    {
        return _core_mlprelclserrorsparse( network,  xy,  npoints, 0x0);
    }
    
    public static double mlprelclserrorsparse(multilayerperceptron network, sparsematrix xy, int npoints, alglib.xparams _xparams)
    {
        return _core_mlprelclserrorsparse( network,  xy,  npoints, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_mlpavgce(multilayerperceptron network, double[,] xy, int npoints, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_network = network.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_xv2_mlpavgce(&_s_errormsg, &_d_result, &_d_network, &_d_xy, &_d_npoints, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpavgce");
            result = _d_result;
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
        }
        return result;
    }
    
    public static double mlpavgce(multilayerperceptron network, double[,] xy, int npoints)
    {
        return _core_mlpavgce( network,  xy,  npoints, 0x0);
    }
    
    public static double mlpavgce(multilayerperceptron network, double[,] xy, int npoints, alglib.xparams _xparams)
    {
        return _core_mlpavgce( network,  xy,  npoints, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_mlpavgcesparse(multilayerperceptron network, sparsematrix xy, int npoints, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_network = network.ptr;
        void *_d_xy = xy.ptr;
        x_int _d_npoints = new x_int(npoints);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_mlpavgcesparse(&_s_errormsg, &_d_result, &_d_network, &_d_xy, &_d_npoints, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpavgcesparse");
            result = _d_result;
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
            ap.assert(xy.ptr==_d_xy, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double mlpavgcesparse(multilayerperceptron network, sparsematrix xy, int npoints)
    {
        return _core_mlpavgcesparse( network,  xy,  npoints, 0x0);
    }
    
    public static double mlpavgcesparse(multilayerperceptron network, sparsematrix xy, int npoints, alglib.xparams _xparams)
    {
        return _core_mlpavgcesparse( network,  xy,  npoints, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_mlprmserror(multilayerperceptron network, double[,] xy, int npoints, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_network = network.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_xv2_mlprmserror(&_s_errormsg, &_d_result, &_d_network, &_d_xy, &_d_npoints, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlprmserror");
            result = _d_result;
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
        }
        return result;
    }
    
    public static double mlprmserror(multilayerperceptron network, double[,] xy, int npoints)
    {
        return _core_mlprmserror( network,  xy,  npoints, 0x0);
    }
    
    public static double mlprmserror(multilayerperceptron network, double[,] xy, int npoints, alglib.xparams _xparams)
    {
        return _core_mlprmserror( network,  xy,  npoints, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_mlprmserrorsparse(multilayerperceptron network, sparsematrix xy, int npoints, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_network = network.ptr;
        void *_d_xy = xy.ptr;
        x_int _d_npoints = new x_int(npoints);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_mlprmserrorsparse(&_s_errormsg, &_d_result, &_d_network, &_d_xy, &_d_npoints, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlprmserrorsparse");
            result = _d_result;
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
            ap.assert(xy.ptr==_d_xy, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double mlprmserrorsparse(multilayerperceptron network, sparsematrix xy, int npoints)
    {
        return _core_mlprmserrorsparse( network,  xy,  npoints, 0x0);
    }
    
    public static double mlprmserrorsparse(multilayerperceptron network, sparsematrix xy, int npoints, alglib.xparams _xparams)
    {
        return _core_mlprmserrorsparse( network,  xy,  npoints, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_mlpavgerror(multilayerperceptron network, double[,] xy, int npoints, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_network = network.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_xv2_mlpavgerror(&_s_errormsg, &_d_result, &_d_network, &_d_xy, &_d_npoints, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpavgerror");
            result = _d_result;
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
        }
        return result;
    }
    
    public static double mlpavgerror(multilayerperceptron network, double[,] xy, int npoints)
    {
        return _core_mlpavgerror( network,  xy,  npoints, 0x0);
    }
    
    public static double mlpavgerror(multilayerperceptron network, double[,] xy, int npoints, alglib.xparams _xparams)
    {
        return _core_mlpavgerror( network,  xy,  npoints, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_mlpavgerrorsparse(multilayerperceptron network, sparsematrix xy, int npoints, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_network = network.ptr;
        void *_d_xy = xy.ptr;
        x_int _d_npoints = new x_int(npoints);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_mlpavgerrorsparse(&_s_errormsg, &_d_result, &_d_network, &_d_xy, &_d_npoints, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpavgerrorsparse");
            result = _d_result;
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
            ap.assert(xy.ptr==_d_xy, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double mlpavgerrorsparse(multilayerperceptron network, sparsematrix xy, int npoints)
    {
        return _core_mlpavgerrorsparse( network,  xy,  npoints, 0x0);
    }
    
    public static double mlpavgerrorsparse(multilayerperceptron network, sparsematrix xy, int npoints, alglib.xparams _xparams)
    {
        return _core_mlpavgerrorsparse( network,  xy,  npoints, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_mlpavgrelerror(multilayerperceptron network, double[,] xy, int npoints, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_network = network.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_xv2_mlpavgrelerror(&_s_errormsg, &_d_result, &_d_network, &_d_xy, &_d_npoints, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpavgrelerror");
            result = _d_result;
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
        }
        return result;
    }
    
    public static double mlpavgrelerror(multilayerperceptron network, double[,] xy, int npoints)
    {
        return _core_mlpavgrelerror( network,  xy,  npoints, 0x0);
    }
    
    public static double mlpavgrelerror(multilayerperceptron network, double[,] xy, int npoints, alglib.xparams _xparams)
    {
        return _core_mlpavgrelerror( network,  xy,  npoints, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_mlpavgrelerrorsparse(multilayerperceptron network, sparsematrix xy, int npoints, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_network = network.ptr;
        void *_d_xy = xy.ptr;
        x_int _d_npoints = new x_int(npoints);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_mlpavgrelerrorsparse(&_s_errormsg, &_d_result, &_d_network, &_d_xy, &_d_npoints, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpavgrelerrorsparse");
            result = _d_result;
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
            ap.assert(xy.ptr==_d_xy, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double mlpavgrelerrorsparse(multilayerperceptron network, sparsematrix xy, int npoints)
    {
        return _core_mlpavgrelerrorsparse( network,  xy,  npoints, 0x0);
    }
    
    public static double mlpavgrelerrorsparse(multilayerperceptron network, sparsematrix xy, int npoints, alglib.xparams _xparams)
    {
        return _core_mlpavgrelerrorsparse( network,  xy,  npoints, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mlpgrad(multilayerperceptron network, double[] x, double[] desiredy, out double e, ref double[] grad, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_network = network.ptr;
        x_vector _d_x = new x_vector();
        x_vector _d_desiredy = new x_vector();
        double _d_e = 0;
        x_vector _d_grad = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_desiredy = desiredy, _fp_grad = grad){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_desiredy, _fp_desiredy, ap.len(desiredy));
                x_vector_attach_to_array(ref _d_grad, _fp_grad, ap.len(grad));
                _error_code = _i_xv2_mlpgrad(&_s_errormsg, &_d_network, &_d_x, &_d_desiredy, &_d_e, &_d_grad, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpgrad");
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
            e = _d_e;
            if( _d_grad.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_grad, ref grad);
            if( grad == null )
                grad = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_desiredy);
            x_vector_clear(ref _d_grad);
        }
        // This function returns no value.
    }
    
    public static void mlpgrad(multilayerperceptron network, double[] x, double[] desiredy, out double e, ref double[] grad)
    {
        _core_mlpgrad( network,  x,  desiredy, out  e, ref  grad, 0x0);
    }
    
    public static void mlpgrad(multilayerperceptron network, double[] x, double[] desiredy, out double e, ref double[] grad, alglib.xparams _xparams)
    {
        _core_mlpgrad( network,  x,  desiredy, out  e, ref  grad, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mlpgradn(multilayerperceptron network, double[] x, double[] desiredy, out double e, ref double[] grad, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_network = network.ptr;
        x_vector _d_x = new x_vector();
        x_vector _d_desiredy = new x_vector();
        double _d_e = 0;
        x_vector _d_grad = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_desiredy = desiredy, _fp_grad = grad){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_desiredy, _fp_desiredy, ap.len(desiredy));
                x_vector_attach_to_array(ref _d_grad, _fp_grad, ap.len(grad));
                _error_code = _i_xv2_mlpgradn(&_s_errormsg, &_d_network, &_d_x, &_d_desiredy, &_d_e, &_d_grad, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpgradn");
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
            e = _d_e;
            if( _d_grad.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_grad, ref grad);
            if( grad == null )
                grad = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_desiredy);
            x_vector_clear(ref _d_grad);
        }
        // This function returns no value.
    }
    
    public static void mlpgradn(multilayerperceptron network, double[] x, double[] desiredy, out double e, ref double[] grad)
    {
        _core_mlpgradn( network,  x,  desiredy, out  e, ref  grad, 0x0);
    }
    
    public static void mlpgradn(multilayerperceptron network, double[] x, double[] desiredy, out double e, ref double[] grad, alglib.xparams _xparams)
    {
        _core_mlpgradn( network,  x,  desiredy, out  e, ref  grad, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mlpgradbatch(multilayerperceptron network, double[,] xy, int ssize, out double e, ref double[] grad, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_network = network.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_ssize = new x_int(ssize);
        double _d_e = 0;
        x_vector _d_grad = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy, _fp_grad = grad){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                x_vector_attach_to_array(ref _d_grad, _fp_grad, ap.len(grad));
                _error_code = _i_xv2_mlpgradbatch(&_s_errormsg, &_d_network, &_d_xy, &_d_ssize, &_d_e, &_d_grad, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpgradbatch");
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
            e = _d_e;
            if( _d_grad.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_grad, ref grad);
            if( grad == null )
                grad = new double[0];
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
            x_vector_clear(ref _d_grad);
        }
        // This function returns no value.
    }
    
    public static void mlpgradbatch(multilayerperceptron network, double[,] xy, int ssize, out double e, ref double[] grad)
    {
        _core_mlpgradbatch( network,  xy,  ssize, out  e, ref  grad, 0x0);
    }
    
    public static void mlpgradbatch(multilayerperceptron network, double[,] xy, int ssize, out double e, ref double[] grad, alglib.xparams _xparams)
    {
        _core_mlpgradbatch( network,  xy,  ssize, out  e, ref  grad, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mlpgradbatchsparse(multilayerperceptron network, sparsematrix xy, int ssize, out double e, ref double[] grad, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_network = network.ptr;
        void *_d_xy = xy.ptr;
        x_int _d_ssize = new x_int(ssize);
        double _d_e = 0;
        x_vector _d_grad = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_grad = grad){
                x_vector_attach_to_array(ref _d_grad, _fp_grad, ap.len(grad));
                _error_code = _i_xv2_mlpgradbatchsparse(&_s_errormsg, &_d_network, &_d_xy, &_d_ssize, &_d_e, &_d_grad, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpgradbatchsparse");
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
            ap.assert(xy.ptr==_d_xy, "ALGLIB: internal error (reference changed for non-out X-object)");
            e = _d_e;
            if( _d_grad.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_grad, ref grad);
            if( grad == null )
                grad = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_grad);
        }
        // This function returns no value.
    }
    
    public static void mlpgradbatchsparse(multilayerperceptron network, sparsematrix xy, int ssize, out double e, ref double[] grad)
    {
        _core_mlpgradbatchsparse( network,  xy,  ssize, out  e, ref  grad, 0x0);
    }
    
    public static void mlpgradbatchsparse(multilayerperceptron network, sparsematrix xy, int ssize, out double e, ref double[] grad, alglib.xparams _xparams)
    {
        _core_mlpgradbatchsparse( network,  xy,  ssize, out  e, ref  grad, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mlpgradbatchsubset(multilayerperceptron network, double[,] xy, int setsize, int[] idx, int subsetsize, out double e, ref double[] grad, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_network = network.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_setsize = new x_int(setsize);
        x_vector _d_idx = new x_vector();
        x_int _d_subsetsize = new x_int(subsetsize);
        double _d_e = 0;
        x_vector _d_grad = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy, _fp_grad = grad){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                x_vector_from_array(ref _d_idx, idx, X_CREATE);
                x_vector_attach_to_array(ref _d_grad, _fp_grad, ap.len(grad));
                _error_code = _i_xv2_mlpgradbatchsubset(&_s_errormsg, &_d_network, &_d_xy, &_d_setsize, &_d_idx, &_d_subsetsize, &_d_e, &_d_grad, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpgradbatchsubset");
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
            e = _d_e;
            if( _d_grad.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_grad, ref grad);
            if( grad == null )
                grad = new double[0];
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
            x_vector_clear(ref _d_idx);
            x_vector_clear(ref _d_grad);
        }
        // This function returns no value.
    }
    
    public static void mlpgradbatchsubset(multilayerperceptron network, double[,] xy, int setsize, int[] idx, int subsetsize, out double e, ref double[] grad)
    {
        _core_mlpgradbatchsubset( network,  xy,  setsize,  idx,  subsetsize, out  e, ref  grad, 0x0);
    }
    
    public static void mlpgradbatchsubset(multilayerperceptron network, double[,] xy, int setsize, int[] idx, int subsetsize, out double e, ref double[] grad, alglib.xparams _xparams)
    {
        _core_mlpgradbatchsubset( network,  xy,  setsize,  idx,  subsetsize, out  e, ref  grad, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mlpgradbatchsparsesubset(multilayerperceptron network, sparsematrix xy, int setsize, int[] idx, int subsetsize, out double e, ref double[] grad, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_network = network.ptr;
        void *_d_xy = xy.ptr;
        x_int _d_setsize = new x_int(setsize);
        x_vector _d_idx = new x_vector();
        x_int _d_subsetsize = new x_int(subsetsize);
        double _d_e = 0;
        x_vector _d_grad = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_grad = grad){
                x_vector_from_array(ref _d_idx, idx, X_CREATE);
                x_vector_attach_to_array(ref _d_grad, _fp_grad, ap.len(grad));
                _error_code = _i_xv2_mlpgradbatchsparsesubset(&_s_errormsg, &_d_network, &_d_xy, &_d_setsize, &_d_idx, &_d_subsetsize, &_d_e, &_d_grad, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpgradbatchsparsesubset");
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
            ap.assert(xy.ptr==_d_xy, "ALGLIB: internal error (reference changed for non-out X-object)");
            e = _d_e;
            if( _d_grad.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_grad, ref grad);
            if( grad == null )
                grad = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_idx);
            x_vector_clear(ref _d_grad);
        }
        // This function returns no value.
    }
    
    public static void mlpgradbatchsparsesubset(multilayerperceptron network, sparsematrix xy, int setsize, int[] idx, int subsetsize, out double e, ref double[] grad)
    {
        _core_mlpgradbatchsparsesubset( network,  xy,  setsize,  idx,  subsetsize, out  e, ref  grad, 0x0);
    }
    
    public static void mlpgradbatchsparsesubset(multilayerperceptron network, sparsematrix xy, int setsize, int[] idx, int subsetsize, out double e, ref double[] grad, alglib.xparams _xparams)
    {
        _core_mlpgradbatchsparsesubset( network,  xy,  setsize,  idx,  subsetsize, out  e, ref  grad, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mlpgradnbatch(multilayerperceptron network, double[,] xy, int ssize, out double e, ref double[] grad, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_network = network.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_ssize = new x_int(ssize);
        double _d_e = 0;
        x_vector _d_grad = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy, _fp_grad = grad){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                x_vector_attach_to_array(ref _d_grad, _fp_grad, ap.len(grad));
                _error_code = _i_xv2_mlpgradnbatch(&_s_errormsg, &_d_network, &_d_xy, &_d_ssize, &_d_e, &_d_grad, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpgradnbatch");
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
            e = _d_e;
            if( _d_grad.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_grad, ref grad);
            if( grad == null )
                grad = new double[0];
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
            x_vector_clear(ref _d_grad);
        }
        // This function returns no value.
    }
    
    public static void mlpgradnbatch(multilayerperceptron network, double[,] xy, int ssize, out double e, ref double[] grad)
    {
        _core_mlpgradnbatch( network,  xy,  ssize, out  e, ref  grad, 0x0);
    }
    
    public static void mlpgradnbatch(multilayerperceptron network, double[,] xy, int ssize, out double e, ref double[] grad, alglib.xparams _xparams)
    {
        _core_mlpgradnbatch( network,  xy,  ssize, out  e, ref  grad, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mlphessiannbatch(multilayerperceptron network, double[,] xy, int ssize, out double e, ref double[] grad, ref double[,] h, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_network = network.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_ssize = new x_int(ssize);
        double _d_e = 0;
        x_vector _d_grad = new x_vector();
        x_matrix _d_h = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy, _fp_grad = grad, _fp_h = h){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                x_vector_attach_to_array(ref _d_grad, _fp_grad, ap.len(grad));
                x_matrix_attach_to_array(ref _d_h, _fp_h, ap.rows(h), ap.cols(h));
                _error_code = _i_xv2_mlphessiannbatch(&_s_errormsg, &_d_network, &_d_xy, &_d_ssize, &_d_e, &_d_grad, &_d_h, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlphessiannbatch");
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
            e = _d_e;
            if( _d_grad.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_grad, ref grad);
            if( grad == null )
                grad = new double[0];
            if( _d_h.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_h, ref h);
            if( h == null )
                h = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
            x_vector_clear(ref _d_grad);
            x_matrix_clear(ref _d_h);
        }
        // This function returns no value.
    }
    
    public static void mlphessiannbatch(multilayerperceptron network, double[,] xy, int ssize, out double e, ref double[] grad, ref double[,] h)
    {
        _core_mlphessiannbatch( network,  xy,  ssize, out  e, ref  grad, ref  h, 0x0);
    }
    
    public static void mlphessiannbatch(multilayerperceptron network, double[,] xy, int ssize, out double e, ref double[] grad, ref double[,] h, alglib.xparams _xparams)
    {
        _core_mlphessiannbatch( network,  xy,  ssize, out  e, ref  grad, ref  h, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mlphessianbatch(multilayerperceptron network, double[,] xy, int ssize, out double e, ref double[] grad, ref double[,] h, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_network = network.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_ssize = new x_int(ssize);
        double _d_e = 0;
        x_vector _d_grad = new x_vector();
        x_matrix _d_h = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy, _fp_grad = grad, _fp_h = h){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                x_vector_attach_to_array(ref _d_grad, _fp_grad, ap.len(grad));
                x_matrix_attach_to_array(ref _d_h, _fp_h, ap.rows(h), ap.cols(h));
                _error_code = _i_xv2_mlphessianbatch(&_s_errormsg, &_d_network, &_d_xy, &_d_ssize, &_d_e, &_d_grad, &_d_h, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlphessianbatch");
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
            e = _d_e;
            if( _d_grad.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_grad, ref grad);
            if( grad == null )
                grad = new double[0];
            if( _d_h.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_h, ref h);
            if( h == null )
                h = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
            x_vector_clear(ref _d_grad);
            x_matrix_clear(ref _d_h);
        }
        // This function returns no value.
    }
    
    public static void mlphessianbatch(multilayerperceptron network, double[,] xy, int ssize, out double e, ref double[] grad, ref double[,] h)
    {
        _core_mlphessianbatch( network,  xy,  ssize, out  e, ref  grad, ref  h, 0x0);
    }
    
    public static void mlphessianbatch(multilayerperceptron network, double[,] xy, int ssize, out double e, ref double[] grad, ref double[,] h, alglib.xparams _xparams)
    {
        _core_mlphessianbatch( network,  xy,  ssize, out  e, ref  grad, ref  h, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mlpallerrorssubset(multilayerperceptron network, double[,] xy, int setsize, int[] subset, int subsetsize, out modelerrors rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_network = network.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_setsize = new x_int(setsize);
        x_vector _d_subset = new x_vector();
        x_int _d_subsetsize = new x_int(subsetsize);
        x_modelerrors _d_rep = new x_modelerrors();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                x_vector_from_array(ref _d_subset, subset, X_CREATE);
                x_modelerrors_init(ref _d_rep);
                _error_code = _i_xv2_mlpallerrorssubset(&_s_errormsg, &_d_network, &_d_xy, &_d_setsize, &_d_subset, &_d_subsetsize, &_d_rep, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpallerrorssubset");
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
            rep = null;
            x_modelerrors_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
            x_vector_clear(ref _d_subset);
            x_modelerrors_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void mlpallerrorssubset(multilayerperceptron network, double[,] xy, int setsize, int[] subset, int subsetsize, out modelerrors rep)
    {
        _core_mlpallerrorssubset( network,  xy,  setsize,  subset,  subsetsize, out  rep, 0x0);
    }
    
    public static void mlpallerrorssubset(multilayerperceptron network, double[,] xy, int setsize, int[] subset, int subsetsize, out modelerrors rep, alglib.xparams _xparams)
    {
        _core_mlpallerrorssubset( network,  xy,  setsize,  subset,  subsetsize, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mlpallerrorssparsesubset(multilayerperceptron network, sparsematrix xy, int setsize, int[] subset, int subsetsize, out modelerrors rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_network = network.ptr;
        void *_d_xy = xy.ptr;
        x_int _d_setsize = new x_int(setsize);
        x_vector _d_subset = new x_vector();
        x_int _d_subsetsize = new x_int(subsetsize);
        x_modelerrors _d_rep = new x_modelerrors();
        
        // Pack, call, unpack
        try
        {
            x_vector_from_array(ref _d_subset, subset, X_CREATE);
            x_modelerrors_init(ref _d_rep);
            _error_code = _i_xv2_mlpallerrorssparsesubset(&_s_errormsg, &_d_network, &_d_xy, &_d_setsize, &_d_subset, &_d_subsetsize, &_d_rep, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpallerrorssparsesubset");
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
            ap.assert(xy.ptr==_d_xy, "ALGLIB: internal error (reference changed for non-out X-object)");
            rep = null;
            x_modelerrors_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_subset);
            x_modelerrors_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void mlpallerrorssparsesubset(multilayerperceptron network, sparsematrix xy, int setsize, int[] subset, int subsetsize, out modelerrors rep)
    {
        _core_mlpallerrorssparsesubset( network,  xy,  setsize,  subset,  subsetsize, out  rep, 0x0);
    }
    
    public static void mlpallerrorssparsesubset(multilayerperceptron network, sparsematrix xy, int setsize, int[] subset, int subsetsize, out modelerrors rep, alglib.xparams _xparams)
    {
        _core_mlpallerrorssparsesubset( network,  xy,  setsize,  subset,  subsetsize, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_mlperrorsubset(multilayerperceptron network, double[,] xy, int setsize, int[] subset, int subsetsize, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_network = network.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_setsize = new x_int(setsize);
        x_vector _d_subset = new x_vector();
        x_int _d_subsetsize = new x_int(subsetsize);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                x_vector_from_array(ref _d_subset, subset, X_CREATE);
                _error_code = _i_xv2_mlperrorsubset(&_s_errormsg, &_d_result, &_d_network, &_d_xy, &_d_setsize, &_d_subset, &_d_subsetsize, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlperrorsubset");
            result = _d_result;
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
            x_vector_clear(ref _d_subset);
        }
        return result;
    }
    
    public static double mlperrorsubset(multilayerperceptron network, double[,] xy, int setsize, int[] subset, int subsetsize)
    {
        return _core_mlperrorsubset( network,  xy,  setsize,  subset,  subsetsize, 0x0);
    }
    
    public static double mlperrorsubset(multilayerperceptron network, double[,] xy, int setsize, int[] subset, int subsetsize, alglib.xparams _xparams)
    {
        return _core_mlperrorsubset( network,  xy,  setsize,  subset,  subsetsize, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_mlperrorsparsesubset(multilayerperceptron network, sparsematrix xy, int setsize, int[] subset, int subsetsize, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_network = network.ptr;
        void *_d_xy = xy.ptr;
        x_int _d_setsize = new x_int(setsize);
        x_vector _d_subset = new x_vector();
        x_int _d_subsetsize = new x_int(subsetsize);
        
        // Pack, call, unpack
        try
        {
            x_vector_from_array(ref _d_subset, subset, X_CREATE);
            _error_code = _i_xv2_mlperrorsparsesubset(&_s_errormsg, &_d_result, &_d_network, &_d_xy, &_d_setsize, &_d_subset, &_d_subsetsize, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlperrorsparsesubset");
            result = _d_result;
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
            ap.assert(xy.ptr==_d_xy, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_subset);
        }
        return result;
    }
    
    public static double mlperrorsparsesubset(multilayerperceptron network, sparsematrix xy, int setsize, int[] subset, int subsetsize)
    {
        return _core_mlperrorsparsesubset( network,  xy,  setsize,  subset,  subsetsize, 0x0);
    }
    
    public static double mlperrorsparsesubset(multilayerperceptron network, sparsematrix xy, int setsize, int[] subset, int subsetsize, alglib.xparams _xparams)
    {
        return _core_mlperrorsparsesubset( network,  xy,  setsize,  subset,  subsetsize, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage mlpe
    //
    

    public unsafe class mlpensemble : alglibobject
    {
        private void *_ptr;
        public mlpensemble(void *x)
        {
            _ptr = x;
        }
        ~mlpensemble()
        {
            _deallocate();
        }
        public void* ptr { get { return _ptr; } }
        public override alglib.alglibobject make_copy()
        {
            if( _ptr==null )
                return new mlpensemble(null);
            return new mlpensemble(_i_x_obj_copy_mlpensemble(_ptr));
        }
        public override void _deallocate()
        {
            if( _ptr!=null )
                _i_x_obj_free_mlpensemble(_ptr);
            _ptr = null;
            System.GC.SuppressFinalize(this);
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_mlpensemble(void *x);
    private static _d_x_obj_copy_mlpensemble _i_x_obj_copy_mlpensemble = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_obj_free_mlpensemble(void *x);
    private static _d_x_obj_free_mlpensemble _i_x_obj_free_mlpensemble = null;
    public static unsafe void mlpeserialize(mlpensemble obj, out string s_out)
    {
        byte *_s_errormsg = null;
        byte *_out = null;
        void *_x = obj.ptr;
        try
        {
            int _error_code = _i_x_mlpeserialize(&_s_errormsg, &_x, &_out);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpeserialize");
            s_out = Marshal.PtrToStringAnsi((IntPtr)_out);
        }
        finally
        {
            x_free((IntPtr)_out);
        }
    }
    
    public static unsafe void mlpeunserialize(string s_in, out mlpensemble obj)
    {
        byte *_s_errormsg = null;
        byte[] _ain = System.Text.Encoding.UTF8.GetBytes(s_in);
        fixed(byte *_pin = _ain )
        {
            byte *_in = _pin;
            void *_x = null;
            obj = null;
            try
            {
                int _error_code = _i_x_mlpeunserialize(&_s_errormsg, &_in, &_x);
                if( _error_code!=X_OK )
                    handle_exception(_error_code, _s_errormsg, "mlpeunserialize");
                obj = new mlpensemble(_x);
            }
            finally
            {
                // on exception clean up X objects which were not attached to C# objects
                if( _x!=null && obj==null)
                    _i_x_obj_free_mlpensemble(_x);
            }
        }
    }
    public static unsafe void mlpeserialize(mlpensemble obj, System.IO.Stream s_out)
    {
        byte *_s_errormsg = null;
        void *_x = obj.ptr;
        alglib.native_stream_adapter a = new alglib.native_stream_adapter();
        a.sstart_stream(s_out);
        int _error_code = _i_x_mlpeserialize_stream(&_s_errormsg, &_x, a.writer_callback, IntPtr.Zero);
        if( _error_code!=X_OK )
            handle_exception(_error_code, _s_errormsg, "mlpeserialize");
    }
    
    public static unsafe void mlpeunserialize(System.IO.Stream s_in, out mlpensemble obj)
    {
        byte *_s_errormsg = null;
        void *_x = null;
        obj = null;
        alglib.native_stream_adapter a = new alglib.native_stream_adapter();
        a.ustart_stream(s_in);
        try
        {
            int _error_code = _i_x_mlpeunserialize_stream(&_s_errormsg, a.reader_callback, IntPtr.Zero, &_x);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpeunserialize");
            obj = new mlpensemble(_x);
        }
        finally
        {
            // on exception clean up X objects which were not attached to C# objects
            if( _x!=null && obj==null)
                _i_x_obj_free_mlpensemble(_x);
        }
    }
    
    private static unsafe void _core_mlpecreate0(int nin, int nout, int ensemblesize, out mlpensemble ensemble, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_nin = new x_int(nin);
        x_int _d_nout = new x_int(nout);
        x_int _d_ensemblesize = new x_int(ensemblesize);
        void *_d_ensemble = null;
        ensemble = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_mlpecreate0(&_s_errormsg, &_d_nin, &_d_nout, &_d_ensemblesize, &_d_ensemble, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpecreate0");
            ensemble = new mlpensemble(_d_ensemble);
        }
        finally
        {
            if( _d_ensemble!=null && ensemble==null)
                _i_x_obj_free_mlpensemble(_d_ensemble); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void mlpecreate0(int nin, int nout, int ensemblesize, out mlpensemble ensemble)
    {
        _core_mlpecreate0( nin,  nout,  ensemblesize, out  ensemble, 0x0);
    }
    
    public static void mlpecreate0(int nin, int nout, int ensemblesize, out mlpensemble ensemble, alglib.xparams _xparams)
    {
        _core_mlpecreate0( nin,  nout,  ensemblesize, out  ensemble, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mlpecreate1(int nin, int nhid, int nout, int ensemblesize, out mlpensemble ensemble, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_nin = new x_int(nin);
        x_int _d_nhid = new x_int(nhid);
        x_int _d_nout = new x_int(nout);
        x_int _d_ensemblesize = new x_int(ensemblesize);
        void *_d_ensemble = null;
        ensemble = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_mlpecreate1(&_s_errormsg, &_d_nin, &_d_nhid, &_d_nout, &_d_ensemblesize, &_d_ensemble, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpecreate1");
            ensemble = new mlpensemble(_d_ensemble);
        }
        finally
        {
            if( _d_ensemble!=null && ensemble==null)
                _i_x_obj_free_mlpensemble(_d_ensemble); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void mlpecreate1(int nin, int nhid, int nout, int ensemblesize, out mlpensemble ensemble)
    {
        _core_mlpecreate1( nin,  nhid,  nout,  ensemblesize, out  ensemble, 0x0);
    }
    
    public static void mlpecreate1(int nin, int nhid, int nout, int ensemblesize, out mlpensemble ensemble, alglib.xparams _xparams)
    {
        _core_mlpecreate1( nin,  nhid,  nout,  ensemblesize, out  ensemble, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mlpecreate2(int nin, int nhid1, int nhid2, int nout, int ensemblesize, out mlpensemble ensemble, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_nin = new x_int(nin);
        x_int _d_nhid1 = new x_int(nhid1);
        x_int _d_nhid2 = new x_int(nhid2);
        x_int _d_nout = new x_int(nout);
        x_int _d_ensemblesize = new x_int(ensemblesize);
        void *_d_ensemble = null;
        ensemble = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_mlpecreate2(&_s_errormsg, &_d_nin, &_d_nhid1, &_d_nhid2, &_d_nout, &_d_ensemblesize, &_d_ensemble, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpecreate2");
            ensemble = new mlpensemble(_d_ensemble);
        }
        finally
        {
            if( _d_ensemble!=null && ensemble==null)
                _i_x_obj_free_mlpensemble(_d_ensemble); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void mlpecreate2(int nin, int nhid1, int nhid2, int nout, int ensemblesize, out mlpensemble ensemble)
    {
        _core_mlpecreate2( nin,  nhid1,  nhid2,  nout,  ensemblesize, out  ensemble, 0x0);
    }
    
    public static void mlpecreate2(int nin, int nhid1, int nhid2, int nout, int ensemblesize, out mlpensemble ensemble, alglib.xparams _xparams)
    {
        _core_mlpecreate2( nin,  nhid1,  nhid2,  nout,  ensemblesize, out  ensemble, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mlpecreateb0(int nin, int nout, double b, double d, int ensemblesize, out mlpensemble ensemble, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_nin = new x_int(nin);
        x_int _d_nout = new x_int(nout);
        double _d_b = b;
        double _d_d = d;
        x_int _d_ensemblesize = new x_int(ensemblesize);
        void *_d_ensemble = null;
        ensemble = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_mlpecreateb0(&_s_errormsg, &_d_nin, &_d_nout, &_d_b, &_d_d, &_d_ensemblesize, &_d_ensemble, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpecreateb0");
            ensemble = new mlpensemble(_d_ensemble);
        }
        finally
        {
            if( _d_ensemble!=null && ensemble==null)
                _i_x_obj_free_mlpensemble(_d_ensemble); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void mlpecreateb0(int nin, int nout, double b, double d, int ensemblesize, out mlpensemble ensemble)
    {
        _core_mlpecreateb0( nin,  nout,  b,  d,  ensemblesize, out  ensemble, 0x0);
    }
    
    public static void mlpecreateb0(int nin, int nout, double b, double d, int ensemblesize, out mlpensemble ensemble, alglib.xparams _xparams)
    {
        _core_mlpecreateb0( nin,  nout,  b,  d,  ensemblesize, out  ensemble, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mlpecreateb1(int nin, int nhid, int nout, double b, double d, int ensemblesize, out mlpensemble ensemble, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_nin = new x_int(nin);
        x_int _d_nhid = new x_int(nhid);
        x_int _d_nout = new x_int(nout);
        double _d_b = b;
        double _d_d = d;
        x_int _d_ensemblesize = new x_int(ensemblesize);
        void *_d_ensemble = null;
        ensemble = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_mlpecreateb1(&_s_errormsg, &_d_nin, &_d_nhid, &_d_nout, &_d_b, &_d_d, &_d_ensemblesize, &_d_ensemble, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpecreateb1");
            ensemble = new mlpensemble(_d_ensemble);
        }
        finally
        {
            if( _d_ensemble!=null && ensemble==null)
                _i_x_obj_free_mlpensemble(_d_ensemble); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void mlpecreateb1(int nin, int nhid, int nout, double b, double d, int ensemblesize, out mlpensemble ensemble)
    {
        _core_mlpecreateb1( nin,  nhid,  nout,  b,  d,  ensemblesize, out  ensemble, 0x0);
    }
    
    public static void mlpecreateb1(int nin, int nhid, int nout, double b, double d, int ensemblesize, out mlpensemble ensemble, alglib.xparams _xparams)
    {
        _core_mlpecreateb1( nin,  nhid,  nout,  b,  d,  ensemblesize, out  ensemble, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mlpecreateb2(int nin, int nhid1, int nhid2, int nout, double b, double d, int ensemblesize, out mlpensemble ensemble, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_nin = new x_int(nin);
        x_int _d_nhid1 = new x_int(nhid1);
        x_int _d_nhid2 = new x_int(nhid2);
        x_int _d_nout = new x_int(nout);
        double _d_b = b;
        double _d_d = d;
        x_int _d_ensemblesize = new x_int(ensemblesize);
        void *_d_ensemble = null;
        ensemble = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_mlpecreateb2(&_s_errormsg, &_d_nin, &_d_nhid1, &_d_nhid2, &_d_nout, &_d_b, &_d_d, &_d_ensemblesize, &_d_ensemble, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpecreateb2");
            ensemble = new mlpensemble(_d_ensemble);
        }
        finally
        {
            if( _d_ensemble!=null && ensemble==null)
                _i_x_obj_free_mlpensemble(_d_ensemble); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void mlpecreateb2(int nin, int nhid1, int nhid2, int nout, double b, double d, int ensemblesize, out mlpensemble ensemble)
    {
        _core_mlpecreateb2( nin,  nhid1,  nhid2,  nout,  b,  d,  ensemblesize, out  ensemble, 0x0);
    }
    
    public static void mlpecreateb2(int nin, int nhid1, int nhid2, int nout, double b, double d, int ensemblesize, out mlpensemble ensemble, alglib.xparams _xparams)
    {
        _core_mlpecreateb2( nin,  nhid1,  nhid2,  nout,  b,  d,  ensemblesize, out  ensemble, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mlpecreater0(int nin, int nout, double a, double b, int ensemblesize, out mlpensemble ensemble, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_nin = new x_int(nin);
        x_int _d_nout = new x_int(nout);
        double _d_a = a;
        double _d_b = b;
        x_int _d_ensemblesize = new x_int(ensemblesize);
        void *_d_ensemble = null;
        ensemble = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_mlpecreater0(&_s_errormsg, &_d_nin, &_d_nout, &_d_a, &_d_b, &_d_ensemblesize, &_d_ensemble, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpecreater0");
            ensemble = new mlpensemble(_d_ensemble);
        }
        finally
        {
            if( _d_ensemble!=null && ensemble==null)
                _i_x_obj_free_mlpensemble(_d_ensemble); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void mlpecreater0(int nin, int nout, double a, double b, int ensemblesize, out mlpensemble ensemble)
    {
        _core_mlpecreater0( nin,  nout,  a,  b,  ensemblesize, out  ensemble, 0x0);
    }
    
    public static void mlpecreater0(int nin, int nout, double a, double b, int ensemblesize, out mlpensemble ensemble, alglib.xparams _xparams)
    {
        _core_mlpecreater0( nin,  nout,  a,  b,  ensemblesize, out  ensemble, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mlpecreater1(int nin, int nhid, int nout, double a, double b, int ensemblesize, out mlpensemble ensemble, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_nin = new x_int(nin);
        x_int _d_nhid = new x_int(nhid);
        x_int _d_nout = new x_int(nout);
        double _d_a = a;
        double _d_b = b;
        x_int _d_ensemblesize = new x_int(ensemblesize);
        void *_d_ensemble = null;
        ensemble = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_mlpecreater1(&_s_errormsg, &_d_nin, &_d_nhid, &_d_nout, &_d_a, &_d_b, &_d_ensemblesize, &_d_ensemble, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpecreater1");
            ensemble = new mlpensemble(_d_ensemble);
        }
        finally
        {
            if( _d_ensemble!=null && ensemble==null)
                _i_x_obj_free_mlpensemble(_d_ensemble); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void mlpecreater1(int nin, int nhid, int nout, double a, double b, int ensemblesize, out mlpensemble ensemble)
    {
        _core_mlpecreater1( nin,  nhid,  nout,  a,  b,  ensemblesize, out  ensemble, 0x0);
    }
    
    public static void mlpecreater1(int nin, int nhid, int nout, double a, double b, int ensemblesize, out mlpensemble ensemble, alglib.xparams _xparams)
    {
        _core_mlpecreater1( nin,  nhid,  nout,  a,  b,  ensemblesize, out  ensemble, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mlpecreater2(int nin, int nhid1, int nhid2, int nout, double a, double b, int ensemblesize, out mlpensemble ensemble, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_nin = new x_int(nin);
        x_int _d_nhid1 = new x_int(nhid1);
        x_int _d_nhid2 = new x_int(nhid2);
        x_int _d_nout = new x_int(nout);
        double _d_a = a;
        double _d_b = b;
        x_int _d_ensemblesize = new x_int(ensemblesize);
        void *_d_ensemble = null;
        ensemble = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_mlpecreater2(&_s_errormsg, &_d_nin, &_d_nhid1, &_d_nhid2, &_d_nout, &_d_a, &_d_b, &_d_ensemblesize, &_d_ensemble, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpecreater2");
            ensemble = new mlpensemble(_d_ensemble);
        }
        finally
        {
            if( _d_ensemble!=null && ensemble==null)
                _i_x_obj_free_mlpensemble(_d_ensemble); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void mlpecreater2(int nin, int nhid1, int nhid2, int nout, double a, double b, int ensemblesize, out mlpensemble ensemble)
    {
        _core_mlpecreater2( nin,  nhid1,  nhid2,  nout,  a,  b,  ensemblesize, out  ensemble, 0x0);
    }
    
    public static void mlpecreater2(int nin, int nhid1, int nhid2, int nout, double a, double b, int ensemblesize, out mlpensemble ensemble, alglib.xparams _xparams)
    {
        _core_mlpecreater2( nin,  nhid1,  nhid2,  nout,  a,  b,  ensemblesize, out  ensemble, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mlpecreatec0(int nin, int nout, int ensemblesize, out mlpensemble ensemble, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_nin = new x_int(nin);
        x_int _d_nout = new x_int(nout);
        x_int _d_ensemblesize = new x_int(ensemblesize);
        void *_d_ensemble = null;
        ensemble = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_mlpecreatec0(&_s_errormsg, &_d_nin, &_d_nout, &_d_ensemblesize, &_d_ensemble, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpecreatec0");
            ensemble = new mlpensemble(_d_ensemble);
        }
        finally
        {
            if( _d_ensemble!=null && ensemble==null)
                _i_x_obj_free_mlpensemble(_d_ensemble); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void mlpecreatec0(int nin, int nout, int ensemblesize, out mlpensemble ensemble)
    {
        _core_mlpecreatec0( nin,  nout,  ensemblesize, out  ensemble, 0x0);
    }
    
    public static void mlpecreatec0(int nin, int nout, int ensemblesize, out mlpensemble ensemble, alglib.xparams _xparams)
    {
        _core_mlpecreatec0( nin,  nout,  ensemblesize, out  ensemble, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mlpecreatec1(int nin, int nhid, int nout, int ensemblesize, out mlpensemble ensemble, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_nin = new x_int(nin);
        x_int _d_nhid = new x_int(nhid);
        x_int _d_nout = new x_int(nout);
        x_int _d_ensemblesize = new x_int(ensemblesize);
        void *_d_ensemble = null;
        ensemble = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_mlpecreatec1(&_s_errormsg, &_d_nin, &_d_nhid, &_d_nout, &_d_ensemblesize, &_d_ensemble, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpecreatec1");
            ensemble = new mlpensemble(_d_ensemble);
        }
        finally
        {
            if( _d_ensemble!=null && ensemble==null)
                _i_x_obj_free_mlpensemble(_d_ensemble); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void mlpecreatec1(int nin, int nhid, int nout, int ensemblesize, out mlpensemble ensemble)
    {
        _core_mlpecreatec1( nin,  nhid,  nout,  ensemblesize, out  ensemble, 0x0);
    }
    
    public static void mlpecreatec1(int nin, int nhid, int nout, int ensemblesize, out mlpensemble ensemble, alglib.xparams _xparams)
    {
        _core_mlpecreatec1( nin,  nhid,  nout,  ensemblesize, out  ensemble, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mlpecreatec2(int nin, int nhid1, int nhid2, int nout, int ensemblesize, out mlpensemble ensemble, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_nin = new x_int(nin);
        x_int _d_nhid1 = new x_int(nhid1);
        x_int _d_nhid2 = new x_int(nhid2);
        x_int _d_nout = new x_int(nout);
        x_int _d_ensemblesize = new x_int(ensemblesize);
        void *_d_ensemble = null;
        ensemble = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_mlpecreatec2(&_s_errormsg, &_d_nin, &_d_nhid1, &_d_nhid2, &_d_nout, &_d_ensemblesize, &_d_ensemble, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpecreatec2");
            ensemble = new mlpensemble(_d_ensemble);
        }
        finally
        {
            if( _d_ensemble!=null && ensemble==null)
                _i_x_obj_free_mlpensemble(_d_ensemble); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void mlpecreatec2(int nin, int nhid1, int nhid2, int nout, int ensemblesize, out mlpensemble ensemble)
    {
        _core_mlpecreatec2( nin,  nhid1,  nhid2,  nout,  ensemblesize, out  ensemble, 0x0);
    }
    
    public static void mlpecreatec2(int nin, int nhid1, int nhid2, int nout, int ensemblesize, out mlpensemble ensemble, alglib.xparams _xparams)
    {
        _core_mlpecreatec2( nin,  nhid1,  nhid2,  nout,  ensemblesize, out  ensemble, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mlpecreatefromnetwork(multilayerperceptron network, int ensemblesize, out mlpensemble ensemble, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_network = network.ptr;
        x_int _d_ensemblesize = new x_int(ensemblesize);
        void *_d_ensemble = null;
        ensemble = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_mlpecreatefromnetwork(&_s_errormsg, &_d_network, &_d_ensemblesize, &_d_ensemble, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpecreatefromnetwork");
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
            ensemble = new mlpensemble(_d_ensemble);
        }
        finally
        {
            if( _d_ensemble!=null && ensemble==null)
                _i_x_obj_free_mlpensemble(_d_ensemble); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void mlpecreatefromnetwork(multilayerperceptron network, int ensemblesize, out mlpensemble ensemble)
    {
        _core_mlpecreatefromnetwork( network,  ensemblesize, out  ensemble, 0x0);
    }
    
    public static void mlpecreatefromnetwork(multilayerperceptron network, int ensemblesize, out mlpensemble ensemble, alglib.xparams _xparams)
    {
        _core_mlpecreatefromnetwork( network,  ensemblesize, out  ensemble, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mlperandomize(mlpensemble ensemble, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_ensemble = ensemble.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_mlperandomize(&_s_errormsg, &_d_ensemble, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlperandomize");
            ap.assert(ensemble.ptr==_d_ensemble, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void mlperandomize(mlpensemble ensemble)
    {
        _core_mlperandomize( ensemble, 0x0);
    }
    
    public static void mlperandomize(mlpensemble ensemble, alglib.xparams _xparams)
    {
        _core_mlperandomize( ensemble, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mlpeproperties(mlpensemble ensemble, out int nin, out int nout, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_ensemble = ensemble.ptr;
        x_int _d_nin = new x_int();
        x_int _d_nout = new x_int();
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_mlpeproperties(&_s_errormsg, &_d_ensemble, &_d_nin, &_d_nout, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpeproperties");
            ap.assert(ensemble.ptr==_d_ensemble, "ALGLIB: internal error (reference changed for non-out X-object)");
            nin = _d_nin.intval;
            nout = _d_nout.intval;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void mlpeproperties(mlpensemble ensemble, out int nin, out int nout)
    {
        _core_mlpeproperties( ensemble, out  nin, out  nout, 0x0);
    }
    
    public static void mlpeproperties(mlpensemble ensemble, out int nin, out int nout, alglib.xparams _xparams)
    {
        _core_mlpeproperties( ensemble, out  nin, out  nout, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe bool _core_mlpeissoftmax(mlpensemble ensemble, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        bool result;
        byte _d_result = (byte)0;
        void *_d_ensemble = ensemble.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_mlpeissoftmax(&_s_errormsg, &_d_result, &_d_ensemble, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpeissoftmax");
            result = _d_result!=0;
            ap.assert(ensemble.ptr==_d_ensemble, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static bool mlpeissoftmax(mlpensemble ensemble)
    {
        return _core_mlpeissoftmax( ensemble, 0x0);
    }
    
    public static bool mlpeissoftmax(mlpensemble ensemble, alglib.xparams _xparams)
    {
        return _core_mlpeissoftmax( ensemble, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mlpeprocess(mlpensemble ensemble, double[] x, ref double[] y, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_ensemble = ensemble.ptr;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                _error_code = _i_xv2_mlpeprocess(&_s_errormsg, &_d_ensemble, &_d_x, &_d_y, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpeprocess");
            ap.assert(ensemble.ptr==_d_ensemble, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_y.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_y, ref y);
            if( y == null )
                y = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
        }
        // This function returns no value.
    }
    
    public static void mlpeprocess(mlpensemble ensemble, double[] x, ref double[] y)
    {
        _core_mlpeprocess( ensemble,  x, ref  y, 0x0);
    }
    
    public static void mlpeprocess(mlpensemble ensemble, double[] x, ref double[] y, alglib.xparams _xparams)
    {
        _core_mlpeprocess( ensemble,  x, ref  y, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mlpeprocessi(mlpensemble ensemble, double[] x, out double[] y, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_ensemble = ensemble.ptr;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_create_empty(ref _d_y, DT_REAL);
                y = null;
                _error_code = _i_xv2_mlpeprocessi(&_s_errormsg, &_d_ensemble, &_d_x, &_d_y, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpeprocessi");
            ap.assert(ensemble.ptr==_d_ensemble, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_y.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_y, ref y);
            if( y == null )
                y = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
        }
        // This function returns no value.
    }
    
    public static void mlpeprocessi(mlpensemble ensemble, double[] x, out double[] y)
    {
        _core_mlpeprocessi( ensemble,  x, out  y, 0x0);
    }
    
    public static void mlpeprocessi(mlpensemble ensemble, double[] x, out double[] y, alglib.xparams _xparams)
    {
        _core_mlpeprocessi( ensemble,  x, out  y, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_mlperelclserror(mlpensemble ensemble, double[,] xy, int npoints, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_ensemble = ensemble.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_xv2_mlperelclserror(&_s_errormsg, &_d_result, &_d_ensemble, &_d_xy, &_d_npoints, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlperelclserror");
            result = _d_result;
            ap.assert(ensemble.ptr==_d_ensemble, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
        }
        return result;
    }
    
    public static double mlperelclserror(mlpensemble ensemble, double[,] xy, int npoints)
    {
        return _core_mlperelclserror( ensemble,  xy,  npoints, 0x0);
    }
    
    public static double mlperelclserror(mlpensemble ensemble, double[,] xy, int npoints, alglib.xparams _xparams)
    {
        return _core_mlperelclserror( ensemble,  xy,  npoints, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_mlpeavgce(mlpensemble ensemble, double[,] xy, int npoints, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_ensemble = ensemble.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_xv2_mlpeavgce(&_s_errormsg, &_d_result, &_d_ensemble, &_d_xy, &_d_npoints, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpeavgce");
            result = _d_result;
            ap.assert(ensemble.ptr==_d_ensemble, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
        }
        return result;
    }
    
    public static double mlpeavgce(mlpensemble ensemble, double[,] xy, int npoints)
    {
        return _core_mlpeavgce( ensemble,  xy,  npoints, 0x0);
    }
    
    public static double mlpeavgce(mlpensemble ensemble, double[,] xy, int npoints, alglib.xparams _xparams)
    {
        return _core_mlpeavgce( ensemble,  xy,  npoints, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_mlpermserror(mlpensemble ensemble, double[,] xy, int npoints, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_ensemble = ensemble.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_xv2_mlpermserror(&_s_errormsg, &_d_result, &_d_ensemble, &_d_xy, &_d_npoints, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpermserror");
            result = _d_result;
            ap.assert(ensemble.ptr==_d_ensemble, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
        }
        return result;
    }
    
    public static double mlpermserror(mlpensemble ensemble, double[,] xy, int npoints)
    {
        return _core_mlpermserror( ensemble,  xy,  npoints, 0x0);
    }
    
    public static double mlpermserror(mlpensemble ensemble, double[,] xy, int npoints, alglib.xparams _xparams)
    {
        return _core_mlpermserror( ensemble,  xy,  npoints, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_mlpeavgerror(mlpensemble ensemble, double[,] xy, int npoints, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_ensemble = ensemble.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_xv2_mlpeavgerror(&_s_errormsg, &_d_result, &_d_ensemble, &_d_xy, &_d_npoints, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpeavgerror");
            result = _d_result;
            ap.assert(ensemble.ptr==_d_ensemble, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
        }
        return result;
    }
    
    public static double mlpeavgerror(mlpensemble ensemble, double[,] xy, int npoints)
    {
        return _core_mlpeavgerror( ensemble,  xy,  npoints, 0x0);
    }
    
    public static double mlpeavgerror(mlpensemble ensemble, double[,] xy, int npoints, alglib.xparams _xparams)
    {
        return _core_mlpeavgerror( ensemble,  xy,  npoints, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_mlpeavgrelerror(mlpensemble ensemble, double[,] xy, int npoints, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_ensemble = ensemble.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_xv2_mlpeavgrelerror(&_s_errormsg, &_d_result, &_d_ensemble, &_d_xy, &_d_npoints, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpeavgrelerror");
            result = _d_result;
            ap.assert(ensemble.ptr==_d_ensemble, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
        }
        return result;
    }
    
    public static double mlpeavgrelerror(mlpensemble ensemble, double[,] xy, int npoints)
    {
        return _core_mlpeavgrelerror( ensemble,  xy,  npoints, 0x0);
    }
    
    public static double mlpeavgrelerror(mlpensemble ensemble, double[,] xy, int npoints, alglib.xparams _xparams)
    {
        return _core_mlpeavgrelerror( ensemble,  xy,  npoints, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage clustering
    //
    

    public unsafe class clusterizerstate : alglibobject
    {
        private void *_ptr;
        public clusterizerstate(void *x)
        {
            _ptr = x;
        }
        ~clusterizerstate()
        {
            _deallocate();
        }
        public void* ptr { get { return _ptr; } }
        public override alglib.alglibobject make_copy()
        {
            if( _ptr==null )
                return new clusterizerstate(null);
            return new clusterizerstate(_i_x_obj_copy_clusterizerstate(_ptr));
        }
        public override void _deallocate()
        {
            if( _ptr!=null )
                _i_x_obj_free_clusterizerstate(_ptr);
            _ptr = null;
            System.GC.SuppressFinalize(this);
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_clusterizerstate(void *x);
    private static _d_x_obj_copy_clusterizerstate _i_x_obj_copy_clusterizerstate = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_obj_free_clusterizerstate(void *x);
    private static _d_x_obj_free_clusterizerstate _i_x_obj_free_clusterizerstate = null;

    [StructLayout(LayoutKind.Sequential, Pack=8)]
    private struct x_ahcreport
    {
        public x_int terminationtype;
        public x_int npoints;
        public x_vector p;
        public x_matrix z;
        public x_matrix pz;
        public x_matrix pm;
        public x_vector mergedist;
    }

    public class ahcreport : alglibobject
    {
        public int terminationtype;
        public int npoints;
        public int[] p;
        public int[,] z;
        public int[,] pz;
        public int[,] pm;
        public double[] mergedist;
        public override alglib.alglibobject make_copy()
        {
            ahcreport dst = new ahcreport();
            dst.terminationtype = terminationtype;
            dst.npoints = npoints;
            dst.p = (int[])p.Clone();        dst.z = (int[,])z.Clone();        dst.pz = (int[,])pz.Clone();        dst.pm = (int[,])pm.Clone();        dst.mergedist = (double[])mergedist.Clone();        return dst;
        }
    }

    // This function initializes X-structure (its previous content is ignored)
    private static void x_ahcreport_init(ref x_ahcreport x)
    {
        x.terminationtype.longval = 0;
        x.npoints.longval = 0;
        x_vector_create_empty(ref x.p, DT_INT);
        x_matrix_create_empty(ref x.z, DT_INT);
        x_matrix_create_empty(ref x.pz, DT_INT);
        x_matrix_create_empty(ref x.pm, DT_INT);
        x_vector_create_empty(ref x.mergedist, DT_REAL);
    }

    // This function finalizes fields of X-structure (however, memory occupied by structure itself is not freed)
    // After destruction structure becomes unusable and should be re-initialized if you want to use it
    private static void x_ahcreport_clear(ref x_ahcreport x)
    {
        x_vector_clear(ref x.p);
        x_matrix_clear(ref x.z);
        x_matrix_clear(ref x.pz);
        x_matrix_clear(ref x.pm);
        x_vector_clear(ref x.mergedist);
    }

    // This function initializes X-structure by appropriate C# instance
    // (previous content of X structure is ignored)
    private static void x_ahcreport_init_from(ref x_ahcreport x, ahcreport v)
    {
        x.terminationtype.longval = v.terminationtype;
        x.npoints.longval = v.npoints;
        x_vector_from_array(ref x.p, v.p, X_CREATE);
        x_matrix_from_array(ref x.z, v.z, X_CREATE);
        x_matrix_from_array(ref x.pz, v.pz, X_CREATE);
        x_matrix_from_array(ref x.pm, v.pm, X_CREATE);
        x_vector_from_array(ref x.mergedist, v.mergedist, X_CREATE);
    }

    // This function initializes C# structure by appropriate X instance
    // (previous content of C# structure is ignored).
    // This function may accept null v, in this case v is automatically allocated with new().
    private static void x_ahcreport_to_record(ref x_ahcreport x, ref ahcreport v)
    {
        if( v==null )
            v = new ahcreport();
        v.terminationtype = x.terminationtype.intval; // long is silently truncated to int
        v.npoints = x.npoints.intval; // long is silently truncated to int
        x_vector_to_array(ref x.p, ref v.p);
        x_matrix_to_array(ref x.z, ref v.z);
        x_matrix_to_array(ref x.pz, ref v.pz);
        x_matrix_to_array(ref x.pm, ref v.pm);
        x_vector_to_array(ref x.mergedist, ref v.mergedist);
    }

    [StructLayout(LayoutKind.Sequential, Pack=8)]
    private struct x_kmeansreport
    {
        public x_int npoints;
        public x_int nfeatures;
        public x_int terminationtype;
        public x_int iterationscount;
        public double energy;
        public x_int k;
        public x_matrix c;
        public x_vector cidx;
    }

    public class kmeansreport : alglibobject
    {
        public int npoints;
        public int nfeatures;
        public int terminationtype;
        public int iterationscount;
        public double energy;
        public int k;
        public double[,] c;
        public int[] cidx;
        public override alglib.alglibobject make_copy()
        {
            kmeansreport dst = new kmeansreport();
            dst.npoints = npoints;
            dst.nfeatures = nfeatures;
            dst.terminationtype = terminationtype;
            dst.iterationscount = iterationscount;
            dst.energy = energy;
            dst.k = k;
            dst.c = (double[,])c.Clone();        dst.cidx = (int[])cidx.Clone();        return dst;
        }
    }

    // This function initializes X-structure (its previous content is ignored)
    private static void x_kmeansreport_init(ref x_kmeansreport x)
    {
        x.npoints.longval = 0;
        x.nfeatures.longval = 0;
        x.terminationtype.longval = 0;
        x.iterationscount.longval = 0;
        x.energy = 0;
        x.k.longval = 0;
        x_matrix_create_empty(ref x.c, DT_REAL);
        x_vector_create_empty(ref x.cidx, DT_INT);
    }

    // This function finalizes fields of X-structure (however, memory occupied by structure itself is not freed)
    // After destruction structure becomes unusable and should be re-initialized if you want to use it
    private static void x_kmeansreport_clear(ref x_kmeansreport x)
    {
        x_matrix_clear(ref x.c);
        x_vector_clear(ref x.cidx);
    }

    // This function initializes X-structure by appropriate C# instance
    // (previous content of X structure is ignored)
    private static void x_kmeansreport_init_from(ref x_kmeansreport x, kmeansreport v)
    {
        x.npoints.longval = v.npoints;
        x.nfeatures.longval = v.nfeatures;
        x.terminationtype.longval = v.terminationtype;
        x.iterationscount.longval = v.iterationscount;
        x.energy = v.energy;
        x.k.longval = v.k;
        x_matrix_from_array(ref x.c, v.c, X_CREATE);
        x_vector_from_array(ref x.cidx, v.cidx, X_CREATE);
    }

    // This function initializes C# structure by appropriate X instance
    // (previous content of C# structure is ignored).
    // This function may accept null v, in this case v is automatically allocated with new().
    private static void x_kmeansreport_to_record(ref x_kmeansreport x, ref kmeansreport v)
    {
        if( v==null )
            v = new kmeansreport();
        v.npoints = x.npoints.intval; // long is silently truncated to int
        v.nfeatures = x.nfeatures.intval; // long is silently truncated to int
        v.terminationtype = x.terminationtype.intval; // long is silently truncated to int
        v.iterationscount = x.iterationscount.intval; // long is silently truncated to int
        v.energy = x.energy;
        v.k = x.k.intval; // long is silently truncated to int
        x_matrix_to_array(ref x.c, ref v.c);
        x_vector_to_array(ref x.cidx, ref v.cidx);
    }
    
    private static unsafe void _core_clusterizercreate(out clusterizerstate s, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = null;
        s = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_clusterizercreate(&_s_errormsg, &_d_s, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "clusterizercreate");
            s = new clusterizerstate(_d_s);
        }
        finally
        {
            if( _d_s!=null && s==null)
                _i_x_obj_free_clusterizerstate(_d_s); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void clusterizercreate(out clusterizerstate s)
    {
        _core_clusterizercreate(out  s, 0x0);
    }
    
    public static void clusterizercreate(out clusterizerstate s, alglib.xparams _xparams)
    {
        _core_clusterizercreate(out  s, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_clusterizersetpoints(clusterizerstate s, double[,] xy, int npoints, int nfeatures, int disttype, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        x_int _d_nfeatures = new x_int(nfeatures);
        x_int _d_disttype = new x_int(disttype);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_xv2_clusterizersetpoints(&_s_errormsg, &_d_s, &_d_xy, &_d_npoints, &_d_nfeatures, &_d_disttype, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "clusterizersetpoints");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
        }
        // This function returns no value.
    }
    
    public static void clusterizersetpoints(clusterizerstate s, double[,] xy, int npoints, int nfeatures, int disttype)
    {
        _core_clusterizersetpoints( s,  xy,  npoints,  nfeatures,  disttype, 0x0);
    }
    
    public static void clusterizersetpoints(clusterizerstate s, double[,] xy, int npoints, int nfeatures, int disttype, alglib.xparams _xparams)
    {
        _core_clusterizersetpoints( s,  xy,  npoints,  nfeatures,  disttype, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void clusterizersetpoints(clusterizerstate s, double[,] xy, int disttype)
    {
        int npoints;
        int nfeatures;
    
        npoints = ap.rows(xy);
        nfeatures = ap.cols(xy);
        _core_clusterizersetpoints( s,  xy,  npoints,  nfeatures,  disttype, 0x0);
    
        
    }
    
    public static void clusterizersetpoints(clusterizerstate s, double[,] xy, int disttype, alglib.xparams _xparams)
    {
        int npoints;
        int nfeatures;
    
        npoints = ap.rows(xy);
        nfeatures = ap.cols(xy);
        _core_clusterizersetpoints( s,  xy,  npoints,  nfeatures,  disttype, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_clusterizersetdistances(clusterizerstate s, double[,] d, int npoints, bool isupper, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_matrix _d_d = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_d = d){
                x_matrix_attach_to_array(ref _d_d, _fp_d, ap.rows(d), ap.cols(d));
                _error_code = _i_xv2_clusterizersetdistances(&_s_errormsg, &_d_s, &_d_d, &_d_npoints, &_d_isupper, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "clusterizersetdistances");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_d);
        }
        // This function returns no value.
    }
    
    public static void clusterizersetdistances(clusterizerstate s, double[,] d, int npoints, bool isupper)
    {
        _core_clusterizersetdistances( s,  d,  npoints,  isupper, 0x0);
    }
    
    public static void clusterizersetdistances(clusterizerstate s, double[,] d, int npoints, bool isupper, alglib.xparams _xparams)
    {
        _core_clusterizersetdistances( s,  d,  npoints,  isupper, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void clusterizersetdistances(clusterizerstate s, double[,] d, bool isupper)
    {
        int npoints;
        if( (ap.rows(d)!=ap.cols(d)))
            throw new alglibexception("Error while calling 'clusterizersetdistances': looks like one of arguments has wrong size");
        npoints = ap.rows(d);
        _core_clusterizersetdistances( s,  d,  npoints,  isupper, 0x0);
    
        
    }
    
    public static void clusterizersetdistances(clusterizerstate s, double[,] d, bool isupper, alglib.xparams _xparams)
    {
        int npoints;
        if( (ap.rows(d)!=ap.cols(d)))
            throw new alglibexception("Error while calling 'clusterizersetdistances': looks like one of arguments has wrong size");
        npoints = ap.rows(d);
        _core_clusterizersetdistances( s,  d,  npoints,  isupper, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_clusterizersetahcalgo(clusterizerstate s, int algo, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_int _d_algo = new x_int(algo);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_clusterizersetahcalgo(&_s_errormsg, &_d_s, &_d_algo, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "clusterizersetahcalgo");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void clusterizersetahcalgo(clusterizerstate s, int algo)
    {
        _core_clusterizersetahcalgo( s,  algo, 0x0);
    }
    
    public static void clusterizersetahcalgo(clusterizerstate s, int algo, alglib.xparams _xparams)
    {
        _core_clusterizersetahcalgo( s,  algo, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_clusterizersetkmeanslimits(clusterizerstate s, int restarts, int maxits, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_int _d_restarts = new x_int(restarts);
        x_int _d_maxits = new x_int(maxits);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_clusterizersetkmeanslimits(&_s_errormsg, &_d_s, &_d_restarts, &_d_maxits, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "clusterizersetkmeanslimits");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void clusterizersetkmeanslimits(clusterizerstate s, int restarts, int maxits)
    {
        _core_clusterizersetkmeanslimits( s,  restarts,  maxits, 0x0);
    }
    
    public static void clusterizersetkmeanslimits(clusterizerstate s, int restarts, int maxits, alglib.xparams _xparams)
    {
        _core_clusterizersetkmeanslimits( s,  restarts,  maxits, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_clusterizersetkmeansinit(clusterizerstate s, int initalgo, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_int _d_initalgo = new x_int(initalgo);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_clusterizersetkmeansinit(&_s_errormsg, &_d_s, &_d_initalgo, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "clusterizersetkmeansinit");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void clusterizersetkmeansinit(clusterizerstate s, int initalgo)
    {
        _core_clusterizersetkmeansinit( s,  initalgo, 0x0);
    }
    
    public static void clusterizersetkmeansinit(clusterizerstate s, int initalgo, alglib.xparams _xparams)
    {
        _core_clusterizersetkmeansinit( s,  initalgo, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_clusterizersetseed(clusterizerstate s, int seed, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_int _d_seed = new x_int(seed);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_clusterizersetseed(&_s_errormsg, &_d_s, &_d_seed, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "clusterizersetseed");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void clusterizersetseed(clusterizerstate s, int seed)
    {
        _core_clusterizersetseed( s,  seed, 0x0);
    }
    
    public static void clusterizersetseed(clusterizerstate s, int seed, alglib.xparams _xparams)
    {
        _core_clusterizersetseed( s,  seed, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_clusterizerrunahc(clusterizerstate s, out ahcreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_ahcreport _d_rep = new x_ahcreport();
        
        // Pack, call, unpack
        try
        {
            x_ahcreport_init(ref _d_rep);
            _error_code = _i_xv2_clusterizerrunahc(&_s_errormsg, &_d_s, &_d_rep, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "clusterizerrunahc");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            rep = null;
            x_ahcreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_ahcreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void clusterizerrunahc(clusterizerstate s, out ahcreport rep)
    {
        _core_clusterizerrunahc( s, out  rep, 0x0);
    }
    
    public static void clusterizerrunahc(clusterizerstate s, out ahcreport rep, alglib.xparams _xparams)
    {
        _core_clusterizerrunahc( s, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_clusterizerrunkmeans(clusterizerstate s, int k, out kmeansreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_int _d_k = new x_int(k);
        x_kmeansreport _d_rep = new x_kmeansreport();
        
        // Pack, call, unpack
        try
        {
            x_kmeansreport_init(ref _d_rep);
            _error_code = _i_xv2_clusterizerrunkmeans(&_s_errormsg, &_d_s, &_d_k, &_d_rep, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "clusterizerrunkmeans");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            rep = null;
            x_kmeansreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_kmeansreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void clusterizerrunkmeans(clusterizerstate s, int k, out kmeansreport rep)
    {
        _core_clusterizerrunkmeans( s,  k, out  rep, 0x0);
    }
    
    public static void clusterizerrunkmeans(clusterizerstate s, int k, out kmeansreport rep, alglib.xparams _xparams)
    {
        _core_clusterizerrunkmeans( s,  k, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_clusterizergetdistances(double[,] xy, int npoints, int nfeatures, int disttype, out double[,] d, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        x_int _d_nfeatures = new x_int(nfeatures);
        x_int _d_disttype = new x_int(disttype);
        x_matrix _d_d = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                x_matrix_create_empty(ref _d_d, DT_REAL);
                d = null;
                _error_code = _i_xv2_clusterizergetdistances(&_s_errormsg, &_d_xy, &_d_npoints, &_d_nfeatures, &_d_disttype, &_d_d, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "clusterizergetdistances");
            if( _d_d.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_d, ref d);
            if( d == null )
                d = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
            x_matrix_clear(ref _d_d);
        }
        // This function returns no value.
    }
    
    public static void clusterizergetdistances(double[,] xy, int npoints, int nfeatures, int disttype, out double[,] d)
    {
        _core_clusterizergetdistances( xy,  npoints,  nfeatures,  disttype, out  d, 0x0);
    }
    
    public static void clusterizergetdistances(double[,] xy, int npoints, int nfeatures, int disttype, out double[,] d, alglib.xparams _xparams)
    {
        _core_clusterizergetdistances( xy,  npoints,  nfeatures,  disttype, out  d, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_clusterizergetkclusters(ahcreport rep, int k, out int[] cidx, out int[] cz, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_ahcreport _d_rep = new x_ahcreport();
        x_int _d_k = new x_int(k);
        x_vector _d_cidx = new x_vector();
        x_vector _d_cz = new x_vector();
        
        // Pack, call, unpack
        try
        {
            x_ahcreport_init_from(ref _d_rep, rep);
            x_vector_create_empty(ref _d_cidx, DT_INT);
            cidx = null;
            x_vector_create_empty(ref _d_cz, DT_INT);
            cz = null;
            _error_code = _i_xv2_clusterizergetkclusters(&_s_errormsg, &_d_rep, &_d_k, &_d_cidx, &_d_cz, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "clusterizergetkclusters");
            x_vector_to_array(ref _d_cidx, ref cidx);
            x_vector_to_array(ref _d_cz, ref cz);
        }
        finally
        {
            x_ahcreport_clear(ref _d_rep);
            x_vector_clear(ref _d_cidx);
            x_vector_clear(ref _d_cz);
        }
        // This function returns no value.
    }
    
    public static void clusterizergetkclusters(ahcreport rep, int k, out int[] cidx, out int[] cz)
    {
        _core_clusterizergetkclusters( rep,  k, out  cidx, out  cz, 0x0);
    }
    
    public static void clusterizergetkclusters(ahcreport rep, int k, out int[] cidx, out int[] cz, alglib.xparams _xparams)
    {
        _core_clusterizergetkclusters( rep,  k, out  cidx, out  cz, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_clusterizerseparatedbydist(ahcreport rep, double r, out int k, out int[] cidx, out int[] cz, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_ahcreport _d_rep = new x_ahcreport();
        double _d_r = r;
        x_int _d_k = new x_int();
        x_vector _d_cidx = new x_vector();
        x_vector _d_cz = new x_vector();
        
        // Pack, call, unpack
        try
        {
            x_ahcreport_init_from(ref _d_rep, rep);
            x_vector_create_empty(ref _d_cidx, DT_INT);
            cidx = null;
            x_vector_create_empty(ref _d_cz, DT_INT);
            cz = null;
            _error_code = _i_xv2_clusterizerseparatedbydist(&_s_errormsg, &_d_rep, &_d_r, &_d_k, &_d_cidx, &_d_cz, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "clusterizerseparatedbydist");
            k = _d_k.intval;
            x_vector_to_array(ref _d_cidx, ref cidx);
            x_vector_to_array(ref _d_cz, ref cz);
        }
        finally
        {
            x_ahcreport_clear(ref _d_rep);
            x_vector_clear(ref _d_cidx);
            x_vector_clear(ref _d_cz);
        }
        // This function returns no value.
    }
    
    public static void clusterizerseparatedbydist(ahcreport rep, double r, out int k, out int[] cidx, out int[] cz)
    {
        _core_clusterizerseparatedbydist( rep,  r, out  k, out  cidx, out  cz, 0x0);
    }
    
    public static void clusterizerseparatedbydist(ahcreport rep, double r, out int k, out int[] cidx, out int[] cz, alglib.xparams _xparams)
    {
        _core_clusterizerseparatedbydist( rep,  r, out  k, out  cidx, out  cz, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_clusterizerseparatedbycorr(ahcreport rep, double r, out int k, out int[] cidx, out int[] cz, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_ahcreport _d_rep = new x_ahcreport();
        double _d_r = r;
        x_int _d_k = new x_int();
        x_vector _d_cidx = new x_vector();
        x_vector _d_cz = new x_vector();
        
        // Pack, call, unpack
        try
        {
            x_ahcreport_init_from(ref _d_rep, rep);
            x_vector_create_empty(ref _d_cidx, DT_INT);
            cidx = null;
            x_vector_create_empty(ref _d_cz, DT_INT);
            cz = null;
            _error_code = _i_xv2_clusterizerseparatedbycorr(&_s_errormsg, &_d_rep, &_d_r, &_d_k, &_d_cidx, &_d_cz, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "clusterizerseparatedbycorr");
            k = _d_k.intval;
            x_vector_to_array(ref _d_cidx, ref cidx);
            x_vector_to_array(ref _d_cz, ref cz);
        }
        finally
        {
            x_ahcreport_clear(ref _d_rep);
            x_vector_clear(ref _d_cidx);
            x_vector_clear(ref _d_cz);
        }
        // This function returns no value.
    }
    
    public static void clusterizerseparatedbycorr(ahcreport rep, double r, out int k, out int[] cidx, out int[] cz)
    {
        _core_clusterizerseparatedbycorr( rep,  r, out  k, out  cidx, out  cz, 0x0);
    }
    
    public static void clusterizerseparatedbycorr(ahcreport rep, double r, out int k, out int[] cidx, out int[] cz, alglib.xparams _xparams)
    {
        _core_clusterizerseparatedbycorr( rep,  r, out  k, out  cidx, out  cz, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage dforest
    //
    

    public unsafe class decisionforestbuilder : alglibobject
    {
        private void *_ptr;
        public decisionforestbuilder(void *x)
        {
            _ptr = x;
        }
        ~decisionforestbuilder()
        {
            _deallocate();
        }
        public void* ptr { get { return _ptr; } }
        public override alglib.alglibobject make_copy()
        {
            if( _ptr==null )
                return new decisionforestbuilder(null);
            return new decisionforestbuilder(_i_x_obj_copy_decisionforestbuilder(_ptr));
        }
        public override void _deallocate()
        {
            if( _ptr!=null )
                _i_x_obj_free_decisionforestbuilder(_ptr);
            _ptr = null;
            System.GC.SuppressFinalize(this);
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_decisionforestbuilder(void *x);
    private static _d_x_obj_copy_decisionforestbuilder _i_x_obj_copy_decisionforestbuilder = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_obj_free_decisionforestbuilder(void *x);
    private static _d_x_obj_free_decisionforestbuilder _i_x_obj_free_decisionforestbuilder = null;

    public unsafe class decisionforestbuffer : alglibobject
    {
        private void *_ptr;
        public decisionforestbuffer(void *x)
        {
            _ptr = x;
        }
        ~decisionforestbuffer()
        {
            _deallocate();
        }
        public void* ptr { get { return _ptr; } }
        public override alglib.alglibobject make_copy()
        {
            if( _ptr==null )
                return new decisionforestbuffer(null);
            return new decisionforestbuffer(_i_x_obj_copy_decisionforestbuffer(_ptr));
        }
        public override void _deallocate()
        {
            if( _ptr!=null )
                _i_x_obj_free_decisionforestbuffer(_ptr);
            _ptr = null;
            System.GC.SuppressFinalize(this);
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_decisionforestbuffer(void *x);
    private static _d_x_obj_copy_decisionforestbuffer _i_x_obj_copy_decisionforestbuffer = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_obj_free_decisionforestbuffer(void *x);
    private static _d_x_obj_free_decisionforestbuffer _i_x_obj_free_decisionforestbuffer = null;

    public unsafe class decisionforest : alglibobject
    {
        private void *_ptr;
        public decisionforest(void *x)
        {
            _ptr = x;
        }
        ~decisionforest()
        {
            _deallocate();
        }
        public void* ptr { get { return _ptr; } }
        public override alglib.alglibobject make_copy()
        {
            if( _ptr==null )
                return new decisionforest(null);
            return new decisionforest(_i_x_obj_copy_decisionforest(_ptr));
        }
        public override void _deallocate()
        {
            if( _ptr!=null )
                _i_x_obj_free_decisionforest(_ptr);
            _ptr = null;
            System.GC.SuppressFinalize(this);
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_decisionforest(void *x);
    private static _d_x_obj_copy_decisionforest _i_x_obj_copy_decisionforest = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_obj_free_decisionforest(void *x);
    private static _d_x_obj_free_decisionforest _i_x_obj_free_decisionforest = null;

    [StructLayout(LayoutKind.Sequential, Pack=8)]
    private struct x_dfreport
    {
        public double relclserror;
        public double avgce;
        public double rmserror;
        public double avgerror;
        public double avgrelerror;
        public double oobrelclserror;
        public double oobavgce;
        public double oobrmserror;
        public double oobavgerror;
        public double oobavgrelerror;
        public x_vector topvars;
        public x_vector varimportances;
    }

    public class dfreport : alglibobject
    {
        public double relclserror;
        public double avgce;
        public double rmserror;
        public double avgerror;
        public double avgrelerror;
        public double oobrelclserror;
        public double oobavgce;
        public double oobrmserror;
        public double oobavgerror;
        public double oobavgrelerror;
        public int[] topvars;
        public double[] varimportances;
        public override alglib.alglibobject make_copy()
        {
            dfreport dst = new dfreport();
            dst.relclserror = relclserror;
            dst.avgce = avgce;
            dst.rmserror = rmserror;
            dst.avgerror = avgerror;
            dst.avgrelerror = avgrelerror;
            dst.oobrelclserror = oobrelclserror;
            dst.oobavgce = oobavgce;
            dst.oobrmserror = oobrmserror;
            dst.oobavgerror = oobavgerror;
            dst.oobavgrelerror = oobavgrelerror;
            dst.topvars = (int[])topvars.Clone();        dst.varimportances = (double[])varimportances.Clone();        return dst;
        }
    }

    // This function initializes X-structure (its previous content is ignored)
    private static void x_dfreport_init(ref x_dfreport x)
    {
        x.relclserror = 0;
        x.avgce = 0;
        x.rmserror = 0;
        x.avgerror = 0;
        x.avgrelerror = 0;
        x.oobrelclserror = 0;
        x.oobavgce = 0;
        x.oobrmserror = 0;
        x.oobavgerror = 0;
        x.oobavgrelerror = 0;
        x_vector_create_empty(ref x.topvars, DT_INT);
        x_vector_create_empty(ref x.varimportances, DT_REAL);
    }

    // This function finalizes fields of X-structure (however, memory occupied by structure itself is not freed)
    // After destruction structure becomes unusable and should be re-initialized if you want to use it
    private static void x_dfreport_clear(ref x_dfreport x)
    {
        x_vector_clear(ref x.topvars);
        x_vector_clear(ref x.varimportances);
    }

    // This function initializes X-structure by appropriate C# instance
    // (previous content of X structure is ignored)
    private static void x_dfreport_init_from(ref x_dfreport x, dfreport v)
    {
        x.relclserror = v.relclserror;
        x.avgce = v.avgce;
        x.rmserror = v.rmserror;
        x.avgerror = v.avgerror;
        x.avgrelerror = v.avgrelerror;
        x.oobrelclserror = v.oobrelclserror;
        x.oobavgce = v.oobavgce;
        x.oobrmserror = v.oobrmserror;
        x.oobavgerror = v.oobavgerror;
        x.oobavgrelerror = v.oobavgrelerror;
        x_vector_from_array(ref x.topvars, v.topvars, X_CREATE);
        x_vector_from_array(ref x.varimportances, v.varimportances, X_CREATE);
    }

    // This function initializes C# structure by appropriate X instance
    // (previous content of C# structure is ignored).
    // This function may accept null v, in this case v is automatically allocated with new().
    private static void x_dfreport_to_record(ref x_dfreport x, ref dfreport v)
    {
        if( v==null )
            v = new dfreport();
        v.relclserror = x.relclserror;
        v.avgce = x.avgce;
        v.rmserror = x.rmserror;
        v.avgerror = x.avgerror;
        v.avgrelerror = x.avgrelerror;
        v.oobrelclserror = x.oobrelclserror;
        v.oobavgce = x.oobavgce;
        v.oobrmserror = x.oobrmserror;
        v.oobavgerror = x.oobavgerror;
        v.oobavgrelerror = x.oobavgrelerror;
        x_vector_to_array(ref x.topvars, ref v.topvars);
        x_vector_to_array(ref x.varimportances, ref v.varimportances);
    }
    public static unsafe void dfserialize(decisionforest obj, out string s_out)
    {
        byte *_s_errormsg = null;
        byte *_out = null;
        void *_x = obj.ptr;
        try
        {
            int _error_code = _i_x_dfserialize(&_s_errormsg, &_x, &_out);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "dfserialize");
            s_out = Marshal.PtrToStringAnsi((IntPtr)_out);
        }
        finally
        {
            x_free((IntPtr)_out);
        }
    }
    
    public static unsafe void dfunserialize(string s_in, out decisionforest obj)
    {
        byte *_s_errormsg = null;
        byte[] _ain = System.Text.Encoding.UTF8.GetBytes(s_in);
        fixed(byte *_pin = _ain )
        {
            byte *_in = _pin;
            void *_x = null;
            obj = null;
            try
            {
                int _error_code = _i_x_dfunserialize(&_s_errormsg, &_in, &_x);
                if( _error_code!=X_OK )
                    handle_exception(_error_code, _s_errormsg, "dfunserialize");
                obj = new decisionforest(_x);
            }
            finally
            {
                // on exception clean up X objects which were not attached to C# objects
                if( _x!=null && obj==null)
                    _i_x_obj_free_decisionforest(_x);
            }
        }
    }
    public static unsafe void dfserialize(decisionforest obj, System.IO.Stream s_out)
    {
        byte *_s_errormsg = null;
        void *_x = obj.ptr;
        alglib.native_stream_adapter a = new alglib.native_stream_adapter();
        a.sstart_stream(s_out);
        int _error_code = _i_x_dfserialize_stream(&_s_errormsg, &_x, a.writer_callback, IntPtr.Zero);
        if( _error_code!=X_OK )
            handle_exception(_error_code, _s_errormsg, "dfserialize");
    }
    
    public static unsafe void dfunserialize(System.IO.Stream s_in, out decisionforest obj)
    {
        byte *_s_errormsg = null;
        void *_x = null;
        obj = null;
        alglib.native_stream_adapter a = new alglib.native_stream_adapter();
        a.ustart_stream(s_in);
        try
        {
            int _error_code = _i_x_dfunserialize_stream(&_s_errormsg, a.reader_callback, IntPtr.Zero, &_x);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "dfunserialize");
            obj = new decisionforest(_x);
        }
        finally
        {
            // on exception clean up X objects which were not attached to C# objects
            if( _x!=null && obj==null)
                _i_x_obj_free_decisionforest(_x);
        }
    }
    
    private static unsafe void _core_dfcreatebuffer(decisionforest model, out decisionforestbuffer buf, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_model = model.ptr;
        void *_d_buf = null;
        buf = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_dfcreatebuffer(&_s_errormsg, &_d_model, &_d_buf, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "dfcreatebuffer");
            ap.assert(model.ptr==_d_model, "ALGLIB: internal error (reference changed for non-out X-object)");
            buf = new decisionforestbuffer(_d_buf);
        }
        finally
        {
            if( _d_buf!=null && buf==null)
                _i_x_obj_free_decisionforestbuffer(_d_buf); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void dfcreatebuffer(decisionforest model, out decisionforestbuffer buf)
    {
        _core_dfcreatebuffer( model, out  buf, 0x0);
    }
    
    public static void dfcreatebuffer(decisionforest model, out decisionforestbuffer buf, alglib.xparams _xparams)
    {
        _core_dfcreatebuffer( model, out  buf, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_dfbuildercreate(out decisionforestbuilder s, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = null;
        s = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_dfbuildercreate(&_s_errormsg, &_d_s, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "dfbuildercreate");
            s = new decisionforestbuilder(_d_s);
        }
        finally
        {
            if( _d_s!=null && s==null)
                _i_x_obj_free_decisionforestbuilder(_d_s); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void dfbuildercreate(out decisionforestbuilder s)
    {
        _core_dfbuildercreate(out  s, 0x0);
    }
    
    public static void dfbuildercreate(out decisionforestbuilder s, alglib.xparams _xparams)
    {
        _core_dfbuildercreate(out  s, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_dfbuildersetdataset(decisionforestbuilder s, double[,] xy, int npoints, int nvars, int nclasses, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        x_int _d_nvars = new x_int(nvars);
        x_int _d_nclasses = new x_int(nclasses);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_xv2_dfbuildersetdataset(&_s_errormsg, &_d_s, &_d_xy, &_d_npoints, &_d_nvars, &_d_nclasses, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "dfbuildersetdataset");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
        }
        // This function returns no value.
    }
    
    public static void dfbuildersetdataset(decisionforestbuilder s, double[,] xy, int npoints, int nvars, int nclasses)
    {
        _core_dfbuildersetdataset( s,  xy,  npoints,  nvars,  nclasses, 0x0);
    }
    
    public static void dfbuildersetdataset(decisionforestbuilder s, double[,] xy, int npoints, int nvars, int nclasses, alglib.xparams _xparams)
    {
        _core_dfbuildersetdataset( s,  xy,  npoints,  nvars,  nclasses, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_dfbuildersetrndvars(decisionforestbuilder s, int rndvars, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_int _d_rndvars = new x_int(rndvars);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_dfbuildersetrndvars(&_s_errormsg, &_d_s, &_d_rndvars, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "dfbuildersetrndvars");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void dfbuildersetrndvars(decisionforestbuilder s, int rndvars)
    {
        _core_dfbuildersetrndvars( s,  rndvars, 0x0);
    }
    
    public static void dfbuildersetrndvars(decisionforestbuilder s, int rndvars, alglib.xparams _xparams)
    {
        _core_dfbuildersetrndvars( s,  rndvars, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_dfbuildersetrndvarsratio(decisionforestbuilder s, double f, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        double _d_f = f;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_dfbuildersetrndvarsratio(&_s_errormsg, &_d_s, &_d_f, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "dfbuildersetrndvarsratio");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void dfbuildersetrndvarsratio(decisionforestbuilder s, double f)
    {
        _core_dfbuildersetrndvarsratio( s,  f, 0x0);
    }
    
    public static void dfbuildersetrndvarsratio(decisionforestbuilder s, double f, alglib.xparams _xparams)
    {
        _core_dfbuildersetrndvarsratio( s,  f, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_dfbuildersetrndvarsauto(decisionforestbuilder s, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_dfbuildersetrndvarsauto(&_s_errormsg, &_d_s, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "dfbuildersetrndvarsauto");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void dfbuildersetrndvarsauto(decisionforestbuilder s)
    {
        _core_dfbuildersetrndvarsauto( s, 0x0);
    }
    
    public static void dfbuildersetrndvarsauto(decisionforestbuilder s, alglib.xparams _xparams)
    {
        _core_dfbuildersetrndvarsauto( s, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_dfbuildersetsubsampleratio(decisionforestbuilder s, double f, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        double _d_f = f;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_dfbuildersetsubsampleratio(&_s_errormsg, &_d_s, &_d_f, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "dfbuildersetsubsampleratio");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void dfbuildersetsubsampleratio(decisionforestbuilder s, double f)
    {
        _core_dfbuildersetsubsampleratio( s,  f, 0x0);
    }
    
    public static void dfbuildersetsubsampleratio(decisionforestbuilder s, double f, alglib.xparams _xparams)
    {
        _core_dfbuildersetsubsampleratio( s,  f, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_dfbuildersetseed(decisionforestbuilder s, int seedval, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_int _d_seedval = new x_int(seedval);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_dfbuildersetseed(&_s_errormsg, &_d_s, &_d_seedval, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "dfbuildersetseed");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void dfbuildersetseed(decisionforestbuilder s, int seedval)
    {
        _core_dfbuildersetseed( s,  seedval, 0x0);
    }
    
    public static void dfbuildersetseed(decisionforestbuilder s, int seedval, alglib.xparams _xparams)
    {
        _core_dfbuildersetseed( s,  seedval, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_dfbuildersetrdfalgo(decisionforestbuilder s, int algotype, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_int _d_algotype = new x_int(algotype);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_dfbuildersetrdfalgo(&_s_errormsg, &_d_s, &_d_algotype, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "dfbuildersetrdfalgo");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void dfbuildersetrdfalgo(decisionforestbuilder s, int algotype)
    {
        _core_dfbuildersetrdfalgo( s,  algotype, 0x0);
    }
    
    public static void dfbuildersetrdfalgo(decisionforestbuilder s, int algotype, alglib.xparams _xparams)
    {
        _core_dfbuildersetrdfalgo( s,  algotype, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_dfbuildersetrdfsplitstrength(decisionforestbuilder s, int splitstrength, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_int _d_splitstrength = new x_int(splitstrength);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_dfbuildersetrdfsplitstrength(&_s_errormsg, &_d_s, &_d_splitstrength, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "dfbuildersetrdfsplitstrength");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void dfbuildersetrdfsplitstrength(decisionforestbuilder s, int splitstrength)
    {
        _core_dfbuildersetrdfsplitstrength( s,  splitstrength, 0x0);
    }
    
    public static void dfbuildersetrdfsplitstrength(decisionforestbuilder s, int splitstrength, alglib.xparams _xparams)
    {
        _core_dfbuildersetrdfsplitstrength( s,  splitstrength, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_dfbuildersetimportancetrngini(decisionforestbuilder s, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_dfbuildersetimportancetrngini(&_s_errormsg, &_d_s, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "dfbuildersetimportancetrngini");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void dfbuildersetimportancetrngini(decisionforestbuilder s)
    {
        _core_dfbuildersetimportancetrngini( s, 0x0);
    }
    
    public static void dfbuildersetimportancetrngini(decisionforestbuilder s, alglib.xparams _xparams)
    {
        _core_dfbuildersetimportancetrngini( s, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_dfbuildersetimportanceoobgini(decisionforestbuilder s, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_dfbuildersetimportanceoobgini(&_s_errormsg, &_d_s, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "dfbuildersetimportanceoobgini");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void dfbuildersetimportanceoobgini(decisionforestbuilder s)
    {
        _core_dfbuildersetimportanceoobgini( s, 0x0);
    }
    
    public static void dfbuildersetimportanceoobgini(decisionforestbuilder s, alglib.xparams _xparams)
    {
        _core_dfbuildersetimportanceoobgini( s, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_dfbuildersetimportancepermutation(decisionforestbuilder s, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_dfbuildersetimportancepermutation(&_s_errormsg, &_d_s, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "dfbuildersetimportancepermutation");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void dfbuildersetimportancepermutation(decisionforestbuilder s)
    {
        _core_dfbuildersetimportancepermutation( s, 0x0);
    }
    
    public static void dfbuildersetimportancepermutation(decisionforestbuilder s, alglib.xparams _xparams)
    {
        _core_dfbuildersetimportancepermutation( s, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_dfbuildersetimportancenone(decisionforestbuilder s, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_dfbuildersetimportancenone(&_s_errormsg, &_d_s, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "dfbuildersetimportancenone");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void dfbuildersetimportancenone(decisionforestbuilder s)
    {
        _core_dfbuildersetimportancenone( s, 0x0);
    }
    
    public static void dfbuildersetimportancenone(decisionforestbuilder s, alglib.xparams _xparams)
    {
        _core_dfbuildersetimportancenone( s, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_dfbuildergetprogress(decisionforestbuilder s, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_s = s.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_dfbuildergetprogress(&_s_errormsg, &_d_result, &_d_s, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "dfbuildergetprogress");
            result = _d_result;
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double dfbuildergetprogress(decisionforestbuilder s)
    {
        return _core_dfbuildergetprogress( s, 0x0);
    }
    
    public static double dfbuildergetprogress(decisionforestbuilder s, alglib.xparams _xparams)
    {
        return _core_dfbuildergetprogress( s, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_dfbuilderpeekprogress(decisionforestbuilder s, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_s = s.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_dfbuilderpeekprogress(&_s_errormsg, &_d_result, &_d_s, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "dfbuilderpeekprogress");
            result = _d_result;
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double dfbuilderpeekprogress(decisionforestbuilder s)
    {
        return _core_dfbuilderpeekprogress( s, 0x0);
    }
    
    public static double dfbuilderpeekprogress(decisionforestbuilder s, alglib.xparams _xparams)
    {
        return _core_dfbuilderpeekprogress( s, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_dfbuilderbuildrandomforest(decisionforestbuilder s, int ntrees, out decisionforest df, out dfreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_int _d_ntrees = new x_int(ntrees);
        void *_d_df = null;
        df = null;
        x_dfreport _d_rep = new x_dfreport();
        
        // Pack, call, unpack
        try
        {
            x_dfreport_init(ref _d_rep);
            _error_code = _i_xv2_dfbuilderbuildrandomforest(&_s_errormsg, &_d_s, &_d_ntrees, &_d_df, &_d_rep, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "dfbuilderbuildrandomforest");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            df = new decisionforest(_d_df);
            rep = null;
            x_dfreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            if( _d_df!=null && df==null)
                _i_x_obj_free_decisionforest(_d_df); // on exception clean up X objects which were not attached to C# objects
            x_dfreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void dfbuilderbuildrandomforest(decisionforestbuilder s, int ntrees, out decisionforest df, out dfreport rep)
    {
        _core_dfbuilderbuildrandomforest( s,  ntrees, out  df, out  rep, 0x0);
    }
    
    public static void dfbuilderbuildrandomforest(decisionforestbuilder s, int ntrees, out decisionforest df, out dfreport rep, alglib.xparams _xparams)
    {
        _core_dfbuilderbuildrandomforest( s,  ntrees, out  df, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_dfbinarycompression(decisionforest df, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_df = df.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_dfbinarycompression(&_s_errormsg, &_d_result, &_d_df, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "dfbinarycompression");
            result = _d_result;
            ap.assert(df.ptr==_d_df, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static double dfbinarycompression(decisionforest df)
    {
        return _core_dfbinarycompression( df, 0x0);
    }
    
    public static double dfbinarycompression(decisionforest df, alglib.xparams _xparams)
    {
        return _core_dfbinarycompression( df, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_dfprocess(decisionforest df, double[] x, ref double[] y, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_df = df.ptr;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                _error_code = _i_xv2_dfprocess(&_s_errormsg, &_d_df, &_d_x, &_d_y, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "dfprocess");
            ap.assert(df.ptr==_d_df, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_y.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_y, ref y);
            if( y == null )
                y = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
        }
        // This function returns no value.
    }
    
    public static void dfprocess(decisionforest df, double[] x, ref double[] y)
    {
        _core_dfprocess( df,  x, ref  y, 0x0);
    }
    
    public static void dfprocess(decisionforest df, double[] x, ref double[] y, alglib.xparams _xparams)
    {
        _core_dfprocess( df,  x, ref  y, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_dfprocessi(decisionforest df, double[] x, out double[] y, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_df = df.ptr;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_create_empty(ref _d_y, DT_REAL);
                y = null;
                _error_code = _i_xv2_dfprocessi(&_s_errormsg, &_d_df, &_d_x, &_d_y, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "dfprocessi");
            ap.assert(df.ptr==_d_df, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_y.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_y, ref y);
            if( y == null )
                y = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
        }
        // This function returns no value.
    }
    
    public static void dfprocessi(decisionforest df, double[] x, out double[] y)
    {
        _core_dfprocessi( df,  x, out  y, 0x0);
    }
    
    public static void dfprocessi(decisionforest df, double[] x, out double[] y, alglib.xparams _xparams)
    {
        _core_dfprocessi( df,  x, out  y, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_dfprocess0(decisionforest model, double[] x, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_model = model.ptr;
        x_vector _d_x = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_xv2_dfprocess0(&_s_errormsg, &_d_result, &_d_model, &_d_x, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "dfprocess0");
            result = _d_result;
            ap.assert(model.ptr==_d_model, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_x);
        }
        return result;
    }
    
    public static double dfprocess0(decisionforest model, double[] x)
    {
        return _core_dfprocess0( model,  x, 0x0);
    }
    
    public static double dfprocess0(decisionforest model, double[] x, alglib.xparams _xparams)
    {
        return _core_dfprocess0( model,  x, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe int _core_dfclassify(decisionforest model, double[] x, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        int result;
        x_int _d_result = new x_int();
        void *_d_model = model.ptr;
        x_vector _d_x = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_xv2_dfclassify(&_s_errormsg, &_d_result, &_d_model, &_d_x, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "dfclassify");
            result = _d_result.intval;
            ap.assert(model.ptr==_d_model, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_x);
        }
        return result;
    }
    
    public static int dfclassify(decisionforest model, double[] x)
    {
        return _core_dfclassify( model,  x, 0x0);
    }
    
    public static int dfclassify(decisionforest model, double[] x, alglib.xparams _xparams)
    {
        return _core_dfclassify( model,  x, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_dftsprocess(decisionforest df, decisionforestbuffer buf, double[] x, ref double[] y, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_df = df.ptr;
        void *_d_buf = buf.ptr;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                _error_code = _i_xv2_dftsprocess(&_s_errormsg, &_d_df, &_d_buf, &_d_x, &_d_y, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "dftsprocess");
            ap.assert(df.ptr==_d_df, "ALGLIB: internal error (reference changed for non-out X-object)");
            ap.assert(buf.ptr==_d_buf, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_y.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_y, ref y);
            if( y == null )
                y = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
        }
        // This function returns no value.
    }
    
    public static void dftsprocess(decisionforest df, decisionforestbuffer buf, double[] x, ref double[] y)
    {
        _core_dftsprocess( df,  buf,  x, ref  y, 0x0);
    }
    
    public static void dftsprocess(decisionforest df, decisionforestbuffer buf, double[] x, ref double[] y, alglib.xparams _xparams)
    {
        _core_dftsprocess( df,  buf,  x, ref  y, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_dfrelclserror(decisionforest df, double[,] xy, int npoints, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_df = df.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_xv2_dfrelclserror(&_s_errormsg, &_d_result, &_d_df, &_d_xy, &_d_npoints, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "dfrelclserror");
            result = _d_result;
            ap.assert(df.ptr==_d_df, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
        }
        return result;
    }
    
    public static double dfrelclserror(decisionforest df, double[,] xy, int npoints)
    {
        return _core_dfrelclserror( df,  xy,  npoints, 0x0);
    }
    
    public static double dfrelclserror(decisionforest df, double[,] xy, int npoints, alglib.xparams _xparams)
    {
        return _core_dfrelclserror( df,  xy,  npoints, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_dfavgce(decisionforest df, double[,] xy, int npoints, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_df = df.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_xv2_dfavgce(&_s_errormsg, &_d_result, &_d_df, &_d_xy, &_d_npoints, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "dfavgce");
            result = _d_result;
            ap.assert(df.ptr==_d_df, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
        }
        return result;
    }
    
    public static double dfavgce(decisionforest df, double[,] xy, int npoints)
    {
        return _core_dfavgce( df,  xy,  npoints, 0x0);
    }
    
    public static double dfavgce(decisionforest df, double[,] xy, int npoints, alglib.xparams _xparams)
    {
        return _core_dfavgce( df,  xy,  npoints, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_dfrmserror(decisionforest df, double[,] xy, int npoints, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_df = df.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_xv2_dfrmserror(&_s_errormsg, &_d_result, &_d_df, &_d_xy, &_d_npoints, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "dfrmserror");
            result = _d_result;
            ap.assert(df.ptr==_d_df, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
        }
        return result;
    }
    
    public static double dfrmserror(decisionforest df, double[,] xy, int npoints)
    {
        return _core_dfrmserror( df,  xy,  npoints, 0x0);
    }
    
    public static double dfrmserror(decisionforest df, double[,] xy, int npoints, alglib.xparams _xparams)
    {
        return _core_dfrmserror( df,  xy,  npoints, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_dfavgerror(decisionforest df, double[,] xy, int npoints, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_df = df.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_xv2_dfavgerror(&_s_errormsg, &_d_result, &_d_df, &_d_xy, &_d_npoints, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "dfavgerror");
            result = _d_result;
            ap.assert(df.ptr==_d_df, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
        }
        return result;
    }
    
    public static double dfavgerror(decisionforest df, double[,] xy, int npoints)
    {
        return _core_dfavgerror( df,  xy,  npoints, 0x0);
    }
    
    public static double dfavgerror(decisionforest df, double[,] xy, int npoints, alglib.xparams _xparams)
    {
        return _core_dfavgerror( df,  xy,  npoints, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_dfavgrelerror(decisionforest df, double[,] xy, int npoints, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_df = df.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_xv2_dfavgrelerror(&_s_errormsg, &_d_result, &_d_df, &_d_xy, &_d_npoints, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "dfavgrelerror");
            result = _d_result;
            ap.assert(df.ptr==_d_df, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
        }
        return result;
    }
    
    public static double dfavgrelerror(decisionforest df, double[,] xy, int npoints)
    {
        return _core_dfavgrelerror( df,  xy,  npoints, 0x0);
    }
    
    public static double dfavgrelerror(decisionforest df, double[,] xy, int npoints, alglib.xparams _xparams)
    {
        return _core_dfavgrelerror( df,  xy,  npoints, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_dfbuildrandomdecisionforest(double[,] xy, int npoints, int nvars, int nclasses, int ntrees, double r, out int info, out decisionforest df, out dfreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        x_int _d_nvars = new x_int(nvars);
        x_int _d_nclasses = new x_int(nclasses);
        x_int _d_ntrees = new x_int(ntrees);
        double _d_r = r;
        x_int _d_info = new x_int();
        void *_d_df = null;
        df = null;
        x_dfreport _d_rep = new x_dfreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                x_dfreport_init(ref _d_rep);
                _error_code = _i_xv2_dfbuildrandomdecisionforest(&_s_errormsg, &_d_xy, &_d_npoints, &_d_nvars, &_d_nclasses, &_d_ntrees, &_d_r, &_d_info, &_d_df, &_d_rep, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "dfbuildrandomdecisionforest");
            info = _d_info.intval;
            df = new decisionforest(_d_df);
            rep = null;
            x_dfreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
            if( _d_df!=null && df==null)
                _i_x_obj_free_decisionforest(_d_df); // on exception clean up X objects which were not attached to C# objects
            x_dfreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void dfbuildrandomdecisionforest(double[,] xy, int npoints, int nvars, int nclasses, int ntrees, double r, out int info, out decisionforest df, out dfreport rep)
    {
        _core_dfbuildrandomdecisionforest( xy,  npoints,  nvars,  nclasses,  ntrees,  r, out  info, out  df, out  rep, 0x0);
    }
    
    public static void dfbuildrandomdecisionforest(double[,] xy, int npoints, int nvars, int nclasses, int ntrees, double r, out int info, out decisionforest df, out dfreport rep, alglib.xparams _xparams)
    {
        _core_dfbuildrandomdecisionforest( xy,  npoints,  nvars,  nclasses,  ntrees,  r, out  info, out  df, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_dfbuildrandomdecisionforestx1(double[,] xy, int npoints, int nvars, int nclasses, int ntrees, int nrndvars, double r, out int info, out decisionforest df, out dfreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        x_int _d_nvars = new x_int(nvars);
        x_int _d_nclasses = new x_int(nclasses);
        x_int _d_ntrees = new x_int(ntrees);
        x_int _d_nrndvars = new x_int(nrndvars);
        double _d_r = r;
        x_int _d_info = new x_int();
        void *_d_df = null;
        df = null;
        x_dfreport _d_rep = new x_dfreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                x_dfreport_init(ref _d_rep);
                _error_code = _i_xv2_dfbuildrandomdecisionforestx1(&_s_errormsg, &_d_xy, &_d_npoints, &_d_nvars, &_d_nclasses, &_d_ntrees, &_d_nrndvars, &_d_r, &_d_info, &_d_df, &_d_rep, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "dfbuildrandomdecisionforestx1");
            info = _d_info.intval;
            df = new decisionforest(_d_df);
            rep = null;
            x_dfreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
            if( _d_df!=null && df==null)
                _i_x_obj_free_decisionforest(_d_df); // on exception clean up X objects which were not attached to C# objects
            x_dfreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void dfbuildrandomdecisionforestx1(double[,] xy, int npoints, int nvars, int nclasses, int ntrees, int nrndvars, double r, out int info, out decisionforest df, out dfreport rep)
    {
        _core_dfbuildrandomdecisionforestx1( xy,  npoints,  nvars,  nclasses,  ntrees,  nrndvars,  r, out  info, out  df, out  rep, 0x0);
    }
    
    public static void dfbuildrandomdecisionforestx1(double[,] xy, int npoints, int nvars, int nclasses, int ntrees, int nrndvars, double r, out int info, out decisionforest df, out dfreport rep, alglib.xparams _xparams)
    {
        _core_dfbuildrandomdecisionforestx1( xy,  npoints,  nvars,  nclasses,  ntrees,  nrndvars,  r, out  info, out  df, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage linreg
    //
    

    public unsafe class linearmodel : alglibobject
    {
        private void *_ptr;
        public linearmodel(void *x)
        {
            _ptr = x;
        }
        ~linearmodel()
        {
            _deallocate();
        }
        public void* ptr { get { return _ptr; } }
        public override alglib.alglibobject make_copy()
        {
            if( _ptr==null )
                return new linearmodel(null);
            return new linearmodel(_i_x_obj_copy_linearmodel(_ptr));
        }
        public override void _deallocate()
        {
            if( _ptr!=null )
                _i_x_obj_free_linearmodel(_ptr);
            _ptr = null;
            System.GC.SuppressFinalize(this);
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_linearmodel(void *x);
    private static _d_x_obj_copy_linearmodel _i_x_obj_copy_linearmodel = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_obj_free_linearmodel(void *x);
    private static _d_x_obj_free_linearmodel _i_x_obj_free_linearmodel = null;

    [StructLayout(LayoutKind.Sequential, Pack=8)]
    private struct x_lrreport
    {
        public x_matrix c;
        public double rmserror;
        public double avgerror;
        public double avgrelerror;
        public double cvrmserror;
        public double cvavgerror;
        public double cvavgrelerror;
        public x_int ncvdefects;
        public x_vector cvdefects;
    }

    public class lrreport : alglibobject
    {
        public double[,] c;
        public double rmserror;
        public double avgerror;
        public double avgrelerror;
        public double cvrmserror;
        public double cvavgerror;
        public double cvavgrelerror;
        public int ncvdefects;
        public int[] cvdefects;
        public override alglib.alglibobject make_copy()
        {
            lrreport dst = new lrreport();
            dst.c = (double[,])c.Clone();        dst.rmserror = rmserror;
            dst.avgerror = avgerror;
            dst.avgrelerror = avgrelerror;
            dst.cvrmserror = cvrmserror;
            dst.cvavgerror = cvavgerror;
            dst.cvavgrelerror = cvavgrelerror;
            dst.ncvdefects = ncvdefects;
            dst.cvdefects = (int[])cvdefects.Clone();        return dst;
        }
    }

    // This function initializes X-structure (its previous content is ignored)
    private static void x_lrreport_init(ref x_lrreport x)
    {
        x_matrix_create_empty(ref x.c, DT_REAL);
        x.rmserror = 0;
        x.avgerror = 0;
        x.avgrelerror = 0;
        x.cvrmserror = 0;
        x.cvavgerror = 0;
        x.cvavgrelerror = 0;
        x.ncvdefects.longval = 0;
        x_vector_create_empty(ref x.cvdefects, DT_INT);
    }

    // This function finalizes fields of X-structure (however, memory occupied by structure itself is not freed)
    // After destruction structure becomes unusable and should be re-initialized if you want to use it
    private static void x_lrreport_clear(ref x_lrreport x)
    {
        x_matrix_clear(ref x.c);
        x_vector_clear(ref x.cvdefects);
    }

    // This function initializes X-structure by appropriate C# instance
    // (previous content of X structure is ignored)
    private static void x_lrreport_init_from(ref x_lrreport x, lrreport v)
    {
        x_matrix_from_array(ref x.c, v.c, X_CREATE);
        x.rmserror = v.rmserror;
        x.avgerror = v.avgerror;
        x.avgrelerror = v.avgrelerror;
        x.cvrmserror = v.cvrmserror;
        x.cvavgerror = v.cvavgerror;
        x.cvavgrelerror = v.cvavgrelerror;
        x.ncvdefects.longval = v.ncvdefects;
        x_vector_from_array(ref x.cvdefects, v.cvdefects, X_CREATE);
    }

    // This function initializes C# structure by appropriate X instance
    // (previous content of C# structure is ignored).
    // This function may accept null v, in this case v is automatically allocated with new().
    private static void x_lrreport_to_record(ref x_lrreport x, ref lrreport v)
    {
        if( v==null )
            v = new lrreport();
        x_matrix_to_array(ref x.c, ref v.c);
        v.rmserror = x.rmserror;
        v.avgerror = x.avgerror;
        v.avgrelerror = x.avgrelerror;
        v.cvrmserror = x.cvrmserror;
        v.cvavgerror = x.cvavgerror;
        v.cvavgrelerror = x.cvavgrelerror;
        v.ncvdefects = x.ncvdefects.intval; // long is silently truncated to int
        x_vector_to_array(ref x.cvdefects, ref v.cvdefects);
    }
    
    private static unsafe void _core_lrbuild(double[,] xy, int npoints, int nvars, out int info, out linearmodel lm, out lrreport ar, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        x_int _d_nvars = new x_int(nvars);
        x_int _d_info = new x_int();
        void *_d_lm = null;
        lm = null;
        x_lrreport _d_ar = new x_lrreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                x_lrreport_init(ref _d_ar);
                _error_code = _i_xv2_lrbuild(&_s_errormsg, &_d_xy, &_d_npoints, &_d_nvars, &_d_info, &_d_lm, &_d_ar, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "lrbuild");
            info = _d_info.intval;
            lm = new linearmodel(_d_lm);
            ar = null;
            x_lrreport_to_record(ref _d_ar, ref ar);
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
            if( _d_lm!=null && lm==null)
                _i_x_obj_free_linearmodel(_d_lm); // on exception clean up X objects which were not attached to C# objects
            x_lrreport_clear(ref _d_ar);
        }
        // This function returns no value.
    }
    
    public static void lrbuild(double[,] xy, int npoints, int nvars, out int info, out linearmodel lm, out lrreport ar)
    {
        _core_lrbuild( xy,  npoints,  nvars, out  info, out  lm, out  ar, 0x0);
    }
    
    public static void lrbuild(double[,] xy, int npoints, int nvars, out int info, out linearmodel lm, out lrreport ar, alglib.xparams _xparams)
    {
        _core_lrbuild( xy,  npoints,  nvars, out  info, out  lm, out  ar, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_lrbuilds(double[,] xy, double[] s, int npoints, int nvars, out int info, out linearmodel lm, out lrreport ar, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_xy = new x_matrix();
        x_vector _d_s = new x_vector();
        x_int _d_npoints = new x_int(npoints);
        x_int _d_nvars = new x_int(nvars);
        x_int _d_info = new x_int();
        void *_d_lm = null;
        lm = null;
        x_lrreport _d_ar = new x_lrreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy, _fp_s = s){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                x_vector_attach_to_array(ref _d_s, _fp_s, ap.len(s));
                x_lrreport_init(ref _d_ar);
                _error_code = _i_xv2_lrbuilds(&_s_errormsg, &_d_xy, &_d_s, &_d_npoints, &_d_nvars, &_d_info, &_d_lm, &_d_ar, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "lrbuilds");
            info = _d_info.intval;
            lm = new linearmodel(_d_lm);
            ar = null;
            x_lrreport_to_record(ref _d_ar, ref ar);
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
            x_vector_clear(ref _d_s);
            if( _d_lm!=null && lm==null)
                _i_x_obj_free_linearmodel(_d_lm); // on exception clean up X objects which were not attached to C# objects
            x_lrreport_clear(ref _d_ar);
        }
        // This function returns no value.
    }
    
    public static void lrbuilds(double[,] xy, double[] s, int npoints, int nvars, out int info, out linearmodel lm, out lrreport ar)
    {
        _core_lrbuilds( xy,  s,  npoints,  nvars, out  info, out  lm, out  ar, 0x0);
    }
    
    public static void lrbuilds(double[,] xy, double[] s, int npoints, int nvars, out int info, out linearmodel lm, out lrreport ar, alglib.xparams _xparams)
    {
        _core_lrbuilds( xy,  s,  npoints,  nvars, out  info, out  lm, out  ar, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_lrbuildzs(double[,] xy, double[] s, int npoints, int nvars, out int info, out linearmodel lm, out lrreport ar, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_xy = new x_matrix();
        x_vector _d_s = new x_vector();
        x_int _d_npoints = new x_int(npoints);
        x_int _d_nvars = new x_int(nvars);
        x_int _d_info = new x_int();
        void *_d_lm = null;
        lm = null;
        x_lrreport _d_ar = new x_lrreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy, _fp_s = s){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                x_vector_attach_to_array(ref _d_s, _fp_s, ap.len(s));
                x_lrreport_init(ref _d_ar);
                _error_code = _i_xv2_lrbuildzs(&_s_errormsg, &_d_xy, &_d_s, &_d_npoints, &_d_nvars, &_d_info, &_d_lm, &_d_ar, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "lrbuildzs");
            info = _d_info.intval;
            lm = new linearmodel(_d_lm);
            ar = null;
            x_lrreport_to_record(ref _d_ar, ref ar);
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
            x_vector_clear(ref _d_s);
            if( _d_lm!=null && lm==null)
                _i_x_obj_free_linearmodel(_d_lm); // on exception clean up X objects which were not attached to C# objects
            x_lrreport_clear(ref _d_ar);
        }
        // This function returns no value.
    }
    
    public static void lrbuildzs(double[,] xy, double[] s, int npoints, int nvars, out int info, out linearmodel lm, out lrreport ar)
    {
        _core_lrbuildzs( xy,  s,  npoints,  nvars, out  info, out  lm, out  ar, 0x0);
    }
    
    public static void lrbuildzs(double[,] xy, double[] s, int npoints, int nvars, out int info, out linearmodel lm, out lrreport ar, alglib.xparams _xparams)
    {
        _core_lrbuildzs( xy,  s,  npoints,  nvars, out  info, out  lm, out  ar, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_lrbuildz(double[,] xy, int npoints, int nvars, out int info, out linearmodel lm, out lrreport ar, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        x_int _d_nvars = new x_int(nvars);
        x_int _d_info = new x_int();
        void *_d_lm = null;
        lm = null;
        x_lrreport _d_ar = new x_lrreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                x_lrreport_init(ref _d_ar);
                _error_code = _i_xv2_lrbuildz(&_s_errormsg, &_d_xy, &_d_npoints, &_d_nvars, &_d_info, &_d_lm, &_d_ar, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "lrbuildz");
            info = _d_info.intval;
            lm = new linearmodel(_d_lm);
            ar = null;
            x_lrreport_to_record(ref _d_ar, ref ar);
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
            if( _d_lm!=null && lm==null)
                _i_x_obj_free_linearmodel(_d_lm); // on exception clean up X objects which were not attached to C# objects
            x_lrreport_clear(ref _d_ar);
        }
        // This function returns no value.
    }
    
    public static void lrbuildz(double[,] xy, int npoints, int nvars, out int info, out linearmodel lm, out lrreport ar)
    {
        _core_lrbuildz( xy,  npoints,  nvars, out  info, out  lm, out  ar, 0x0);
    }
    
    public static void lrbuildz(double[,] xy, int npoints, int nvars, out int info, out linearmodel lm, out lrreport ar, alglib.xparams _xparams)
    {
        _core_lrbuildz( xy,  npoints,  nvars, out  info, out  lm, out  ar, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_lrunpack(linearmodel lm, out double[] v, out int nvars, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_lm = lm.ptr;
        x_vector _d_v = new x_vector();
        x_int _d_nvars = new x_int();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_v, DT_REAL);
            v = null;
            _error_code = _i_xv2_lrunpack(&_s_errormsg, &_d_lm, &_d_v, &_d_nvars, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "lrunpack");
            ap.assert(lm.ptr==_d_lm, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_v.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_v, ref v);
            if( v == null )
                v = new double[0];
            nvars = _d_nvars.intval;
        }
        finally
        {
            x_vector_clear(ref _d_v);
        }
        // This function returns no value.
    }
    
    public static void lrunpack(linearmodel lm, out double[] v, out int nvars)
    {
        _core_lrunpack( lm, out  v, out  nvars, 0x0);
    }
    
    public static void lrunpack(linearmodel lm, out double[] v, out int nvars, alglib.xparams _xparams)
    {
        _core_lrunpack( lm, out  v, out  nvars, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_lrpack(double[] v, int nvars, out linearmodel lm, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_v = new x_vector();
        x_int _d_nvars = new x_int(nvars);
        void *_d_lm = null;
        lm = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_v = v){
                x_vector_attach_to_array(ref _d_v, _fp_v, ap.len(v));
                _error_code = _i_xv2_lrpack(&_s_errormsg, &_d_v, &_d_nvars, &_d_lm, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "lrpack");
            lm = new linearmodel(_d_lm);
        }
        finally
        {
            x_vector_clear(ref _d_v);
            if( _d_lm!=null && lm==null)
                _i_x_obj_free_linearmodel(_d_lm); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void lrpack(double[] v, int nvars, out linearmodel lm)
    {
        _core_lrpack( v,  nvars, out  lm, 0x0);
    }
    
    public static void lrpack(double[] v, int nvars, out linearmodel lm, alglib.xparams _xparams)
    {
        _core_lrpack( v,  nvars, out  lm, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_lrprocess(linearmodel lm, double[] x, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_lm = lm.ptr;
        x_vector _d_x = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_xv2_lrprocess(&_s_errormsg, &_d_result, &_d_lm, &_d_x, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "lrprocess");
            result = _d_result;
            ap.assert(lm.ptr==_d_lm, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_x);
        }
        return result;
    }
    
    public static double lrprocess(linearmodel lm, double[] x)
    {
        return _core_lrprocess( lm,  x, 0x0);
    }
    
    public static double lrprocess(linearmodel lm, double[] x, alglib.xparams _xparams)
    {
        return _core_lrprocess( lm,  x, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_lrrmserror(linearmodel lm, double[,] xy, int npoints, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_lm = lm.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_xv2_lrrmserror(&_s_errormsg, &_d_result, &_d_lm, &_d_xy, &_d_npoints, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "lrrmserror");
            result = _d_result;
            ap.assert(lm.ptr==_d_lm, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
        }
        return result;
    }
    
    public static double lrrmserror(linearmodel lm, double[,] xy, int npoints)
    {
        return _core_lrrmserror( lm,  xy,  npoints, 0x0);
    }
    
    public static double lrrmserror(linearmodel lm, double[,] xy, int npoints, alglib.xparams _xparams)
    {
        return _core_lrrmserror( lm,  xy,  npoints, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_lravgerror(linearmodel lm, double[,] xy, int npoints, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_lm = lm.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_xv2_lravgerror(&_s_errormsg, &_d_result, &_d_lm, &_d_xy, &_d_npoints, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "lravgerror");
            result = _d_result;
            ap.assert(lm.ptr==_d_lm, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
        }
        return result;
    }
    
    public static double lravgerror(linearmodel lm, double[,] xy, int npoints)
    {
        return _core_lravgerror( lm,  xy,  npoints, 0x0);
    }
    
    public static double lravgerror(linearmodel lm, double[,] xy, int npoints, alglib.xparams _xparams)
    {
        return _core_lravgerror( lm,  xy,  npoints, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_lravgrelerror(linearmodel lm, double[,] xy, int npoints, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_lm = lm.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_xv2_lravgrelerror(&_s_errormsg, &_d_result, &_d_lm, &_d_xy, &_d_npoints, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "lravgrelerror");
            result = _d_result;
            ap.assert(lm.ptr==_d_lm, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
        }
        return result;
    }
    
    public static double lravgrelerror(linearmodel lm, double[,] xy, int npoints)
    {
        return _core_lravgrelerror( lm,  xy,  npoints, 0x0);
    }
    
    public static double lravgrelerror(linearmodel lm, double[,] xy, int npoints, alglib.xparams _xparams)
    {
        return _core_lravgrelerror( lm,  xy,  npoints, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage filters
    //
    
    
    private static unsafe void _core_filtersma(ref double[] x, int n, int k, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_int _d_n = new x_int(n);
        x_int _d_k = new x_int(k);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_xv2_filtersma(&_s_errormsg, &_d_x, &_d_n, &_d_k, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "filtersma");
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
        }
        // This function returns no value.
    }
    
    public static void filtersma(ref double[] x, int n, int k)
    {
        _core_filtersma(ref  x,  n,  k, 0x0);
    }
    
    public static void filtersma(ref double[] x, int n, int k, alglib.xparams _xparams)
    {
        _core_filtersma(ref  x,  n,  k, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void filtersma(ref double[] x, int k)
    {
        int n;
    
        n = ap.len(x);
        _core_filtersma(ref  x,  n,  k, 0x0);
    
        
    }
    
    public static void filtersma(ref double[] x, int k, alglib.xparams _xparams)
    {
        int n;
    
        n = ap.len(x);
        _core_filtersma(ref  x,  n,  k, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_filterema(ref double[] x, int n, double alpha, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_int _d_n = new x_int(n);
        double _d_alpha = alpha;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_xv2_filterema(&_s_errormsg, &_d_x, &_d_n, &_d_alpha, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "filterema");
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
        }
        // This function returns no value.
    }
    
    public static void filterema(ref double[] x, int n, double alpha)
    {
        _core_filterema(ref  x,  n,  alpha, 0x0);
    }
    
    public static void filterema(ref double[] x, int n, double alpha, alglib.xparams _xparams)
    {
        _core_filterema(ref  x,  n,  alpha, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void filterema(ref double[] x, double alpha)
    {
        int n;
    
        n = ap.len(x);
        _core_filterema(ref  x,  n,  alpha, 0x0);
    
        
    }
    
    public static void filterema(ref double[] x, double alpha, alglib.xparams _xparams)
    {
        int n;
    
        n = ap.len(x);
        _core_filterema(ref  x,  n,  alpha, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_filterlrma(ref double[] x, int n, int k, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_int _d_n = new x_int(n);
        x_int _d_k = new x_int(k);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_xv2_filterlrma(&_s_errormsg, &_d_x, &_d_n, &_d_k, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "filterlrma");
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
        }
        // This function returns no value.
    }
    
    public static void filterlrma(ref double[] x, int n, int k)
    {
        _core_filterlrma(ref  x,  n,  k, 0x0);
    }
    
    public static void filterlrma(ref double[] x, int n, int k, alglib.xparams _xparams)
    {
        _core_filterlrma(ref  x,  n,  k, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void filterlrma(ref double[] x, int k)
    {
        int n;
    
        n = ap.len(x);
        _core_filterlrma(ref  x,  n,  k, 0x0);
    
        
    }
    
    public static void filterlrma(ref double[] x, int k, alglib.xparams _xparams)
    {
        int n;
    
        n = ap.len(x);
        _core_filterlrma(ref  x,  n,  k, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    
    //
    // Subpackage ssa
    //
    

    public unsafe class ssamodel : alglibobject
    {
        private void *_ptr;
        public ssamodel(void *x)
        {
            _ptr = x;
        }
        ~ssamodel()
        {
            _deallocate();
        }
        public void* ptr { get { return _ptr; } }
        public override alglib.alglibobject make_copy()
        {
            if( _ptr==null )
                return new ssamodel(null);
            return new ssamodel(_i_x_obj_copy_ssamodel(_ptr));
        }
        public override void _deallocate()
        {
            if( _ptr!=null )
                _i_x_obj_free_ssamodel(_ptr);
            _ptr = null;
            System.GC.SuppressFinalize(this);
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_ssamodel(void *x);
    private static _d_x_obj_copy_ssamodel _i_x_obj_copy_ssamodel = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_obj_free_ssamodel(void *x);
    private static _d_x_obj_free_ssamodel _i_x_obj_free_ssamodel = null;
    
    private static unsafe void _core_ssacreate(out ssamodel s, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = null;
        s = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_ssacreate(&_s_errormsg, &_d_s, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "ssacreate");
            s = new ssamodel(_d_s);
        }
        finally
        {
            if( _d_s!=null && s==null)
                _i_x_obj_free_ssamodel(_d_s); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void ssacreate(out ssamodel s)
    {
        _core_ssacreate(out  s, 0x0);
    }
    
    public static void ssacreate(out ssamodel s, alglib.xparams _xparams)
    {
        _core_ssacreate(out  s, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_ssasetwindow(ssamodel s, int windowwidth, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_int _d_windowwidth = new x_int(windowwidth);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_ssasetwindow(&_s_errormsg, &_d_s, &_d_windowwidth, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "ssasetwindow");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void ssasetwindow(ssamodel s, int windowwidth)
    {
        _core_ssasetwindow( s,  windowwidth, 0x0);
    }
    
    public static void ssasetwindow(ssamodel s, int windowwidth, alglib.xparams _xparams)
    {
        _core_ssasetwindow( s,  windowwidth, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_ssasetseed(ssamodel s, int seed, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_int _d_seed = new x_int(seed);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_ssasetseed(&_s_errormsg, &_d_s, &_d_seed, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "ssasetseed");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void ssasetseed(ssamodel s, int seed)
    {
        _core_ssasetseed( s,  seed, 0x0);
    }
    
    public static void ssasetseed(ssamodel s, int seed, alglib.xparams _xparams)
    {
        _core_ssasetseed( s,  seed, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_ssasetpoweruplength(ssamodel s, int pwlen, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_int _d_pwlen = new x_int(pwlen);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_ssasetpoweruplength(&_s_errormsg, &_d_s, &_d_pwlen, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "ssasetpoweruplength");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void ssasetpoweruplength(ssamodel s, int pwlen)
    {
        _core_ssasetpoweruplength( s,  pwlen, 0x0);
    }
    
    public static void ssasetpoweruplength(ssamodel s, int pwlen, alglib.xparams _xparams)
    {
        _core_ssasetpoweruplength( s,  pwlen, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_ssasetmemorylimit(ssamodel s, int memlimit, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_int _d_memlimit = new x_int(memlimit);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_ssasetmemorylimit(&_s_errormsg, &_d_s, &_d_memlimit, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "ssasetmemorylimit");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void ssasetmemorylimit(ssamodel s, int memlimit)
    {
        _core_ssasetmemorylimit( s,  memlimit, 0x0);
    }
    
    public static void ssasetmemorylimit(ssamodel s, int memlimit, alglib.xparams _xparams)
    {
        _core_ssasetmemorylimit( s,  memlimit, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_ssaaddsequence(ssamodel s, double[] x, int n, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_vector _d_x = new x_vector();
        x_int _d_n = new x_int(n);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_xv2_ssaaddsequence(&_s_errormsg, &_d_s, &_d_x, &_d_n, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "ssaaddsequence");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_x);
        }
        // This function returns no value.
    }
    
    public static void ssaaddsequence(ssamodel s, double[] x, int n)
    {
        _core_ssaaddsequence( s,  x,  n, 0x0);
    }
    
    public static void ssaaddsequence(ssamodel s, double[] x, int n, alglib.xparams _xparams)
    {
        _core_ssaaddsequence( s,  x,  n, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void ssaaddsequence(ssamodel s, double[] x)
    {
        int n;
    
        n = ap.len(x);
        _core_ssaaddsequence( s,  x,  n, 0x0);
    
        
    }
    
    public static void ssaaddsequence(ssamodel s, double[] x, alglib.xparams _xparams)
    {
        int n;
    
        n = ap.len(x);
        _core_ssaaddsequence( s,  x,  n, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_ssaappendpointandupdate(ssamodel s, double x, double updateits, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        double _d_x = x;
        double _d_updateits = updateits;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_ssaappendpointandupdate(&_s_errormsg, &_d_s, &_d_x, &_d_updateits, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "ssaappendpointandupdate");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void ssaappendpointandupdate(ssamodel s, double x, double updateits)
    {
        _core_ssaappendpointandupdate( s,  x,  updateits, 0x0);
    }
    
    public static void ssaappendpointandupdate(ssamodel s, double x, double updateits, alglib.xparams _xparams)
    {
        _core_ssaappendpointandupdate( s,  x,  updateits, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_ssaappendsequenceandupdate(ssamodel s, double[] x, int nticks, double updateits, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_vector _d_x = new x_vector();
        x_int _d_nticks = new x_int(nticks);
        double _d_updateits = updateits;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_xv2_ssaappendsequenceandupdate(&_s_errormsg, &_d_s, &_d_x, &_d_nticks, &_d_updateits, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "ssaappendsequenceandupdate");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_x);
        }
        // This function returns no value.
    }
    
    public static void ssaappendsequenceandupdate(ssamodel s, double[] x, int nticks, double updateits)
    {
        _core_ssaappendsequenceandupdate( s,  x,  nticks,  updateits, 0x0);
    }
    
    public static void ssaappendsequenceandupdate(ssamodel s, double[] x, int nticks, double updateits, alglib.xparams _xparams)
    {
        _core_ssaappendsequenceandupdate( s,  x,  nticks,  updateits, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void ssaappendsequenceandupdate(ssamodel s, double[] x, double updateits)
    {
        int nticks;
    
        nticks = ap.len(x);
        _core_ssaappendsequenceandupdate( s,  x,  nticks,  updateits, 0x0);
    
        
    }
    
    public static void ssaappendsequenceandupdate(ssamodel s, double[] x, double updateits, alglib.xparams _xparams)
    {
        int nticks;
    
        nticks = ap.len(x);
        _core_ssaappendsequenceandupdate( s,  x,  nticks,  updateits, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_ssasetalgoprecomputed(ssamodel s, double[,] a, int windowwidth, int nbasis, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_matrix _d_a = new x_matrix();
        x_int _d_windowwidth = new x_int(windowwidth);
        x_int _d_nbasis = new x_int(nbasis);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                _error_code = _i_xv2_ssasetalgoprecomputed(&_s_errormsg, &_d_s, &_d_a, &_d_windowwidth, &_d_nbasis, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "ssasetalgoprecomputed");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        // This function returns no value.
    }
    
    public static void ssasetalgoprecomputed(ssamodel s, double[,] a, int windowwidth, int nbasis)
    {
        _core_ssasetalgoprecomputed( s,  a,  windowwidth,  nbasis, 0x0);
    }
    
    public static void ssasetalgoprecomputed(ssamodel s, double[,] a, int windowwidth, int nbasis, alglib.xparams _xparams)
    {
        _core_ssasetalgoprecomputed( s,  a,  windowwidth,  nbasis, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void ssasetalgoprecomputed(ssamodel s, double[,] a)
    {
        int windowwidth;
        int nbasis;
    
        windowwidth = ap.rows(a);
        nbasis = ap.cols(a);
        _core_ssasetalgoprecomputed( s,  a,  windowwidth,  nbasis, 0x0);
    
        
    }
    
    public static void ssasetalgoprecomputed(ssamodel s, double[,] a, alglib.xparams _xparams)
    {
        int windowwidth;
        int nbasis;
    
        windowwidth = ap.rows(a);
        nbasis = ap.cols(a);
        _core_ssasetalgoprecomputed( s,  a,  windowwidth,  nbasis, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_ssasetalgotopkdirect(ssamodel s, int topk, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_int _d_topk = new x_int(topk);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_ssasetalgotopkdirect(&_s_errormsg, &_d_s, &_d_topk, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "ssasetalgotopkdirect");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void ssasetalgotopkdirect(ssamodel s, int topk)
    {
        _core_ssasetalgotopkdirect( s,  topk, 0x0);
    }
    
    public static void ssasetalgotopkdirect(ssamodel s, int topk, alglib.xparams _xparams)
    {
        _core_ssasetalgotopkdirect( s,  topk, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_ssasetalgotopkrealtime(ssamodel s, int topk, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_int _d_topk = new x_int(topk);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_ssasetalgotopkrealtime(&_s_errormsg, &_d_s, &_d_topk, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "ssasetalgotopkrealtime");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void ssasetalgotopkrealtime(ssamodel s, int topk)
    {
        _core_ssasetalgotopkrealtime( s,  topk, 0x0);
    }
    
    public static void ssasetalgotopkrealtime(ssamodel s, int topk, alglib.xparams _xparams)
    {
        _core_ssasetalgotopkrealtime( s,  topk, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_ssacleardata(ssamodel s, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_ssacleardata(&_s_errormsg, &_d_s, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "ssacleardata");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void ssacleardata(ssamodel s)
    {
        _core_ssacleardata( s, 0x0);
    }
    
    public static void ssacleardata(ssamodel s, alglib.xparams _xparams)
    {
        _core_ssacleardata( s, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_ssagetbasis(ssamodel s, out double[,] a, out double[] sv, out int windowwidth, out int nbasis, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_matrix _d_a = new x_matrix();
        x_vector _d_sv = new x_vector();
        x_int _d_windowwidth = new x_int();
        x_int _d_nbasis = new x_int();
        
        // Pack, call, unpack
        try
        {
            x_matrix_create_empty(ref _d_a, DT_REAL);
            a = null;
            x_vector_create_empty(ref _d_sv, DT_REAL);
            sv = null;
            _error_code = _i_xv2_ssagetbasis(&_s_errormsg, &_d_s, &_d_a, &_d_sv, &_d_windowwidth, &_d_nbasis, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "ssagetbasis");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new double[0,0];
            if( _d_sv.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_sv, ref sv);
            if( sv == null )
                sv = new double[0];
            windowwidth = _d_windowwidth.intval;
            nbasis = _d_nbasis.intval;
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_sv);
        }
        // This function returns no value.
    }
    
    public static void ssagetbasis(ssamodel s, out double[,] a, out double[] sv, out int windowwidth, out int nbasis)
    {
        _core_ssagetbasis( s, out  a, out  sv, out  windowwidth, out  nbasis, 0x0);
    }
    
    public static void ssagetbasis(ssamodel s, out double[,] a, out double[] sv, out int windowwidth, out int nbasis, alglib.xparams _xparams)
    {
        _core_ssagetbasis( s, out  a, out  sv, out  windowwidth, out  nbasis, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_ssagetlrr(ssamodel s, out double[] a, out int windowwidth, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_vector _d_a = new x_vector();
        x_int _d_windowwidth = new x_int();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_a, DT_REAL);
            a = null;
            _error_code = _i_xv2_ssagetlrr(&_s_errormsg, &_d_s, &_d_a, &_d_windowwidth, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "ssagetlrr");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_a, ref a);
            if( a == null )
                a = new double[0];
            windowwidth = _d_windowwidth.intval;
        }
        finally
        {
            x_vector_clear(ref _d_a);
        }
        // This function returns no value.
    }
    
    public static void ssagetlrr(ssamodel s, out double[] a, out int windowwidth)
    {
        _core_ssagetlrr( s, out  a, out  windowwidth, 0x0);
    }
    
    public static void ssagetlrr(ssamodel s, out double[] a, out int windowwidth, alglib.xparams _xparams)
    {
        _core_ssagetlrr( s, out  a, out  windowwidth, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_ssaanalyzelastwindow(ssamodel s, out double[] trend, out double[] noise, out int nticks, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_vector _d_trend = new x_vector();
        x_vector _d_noise = new x_vector();
        x_int _d_nticks = new x_int();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_trend, DT_REAL);
            trend = null;
            x_vector_create_empty(ref _d_noise, DT_REAL);
            noise = null;
            _error_code = _i_xv2_ssaanalyzelastwindow(&_s_errormsg, &_d_s, &_d_trend, &_d_noise, &_d_nticks, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "ssaanalyzelastwindow");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_trend.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_trend, ref trend);
            if( trend == null )
                trend = new double[0];
            if( _d_noise.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_noise, ref noise);
            if( noise == null )
                noise = new double[0];
            nticks = _d_nticks.intval;
        }
        finally
        {
            x_vector_clear(ref _d_trend);
            x_vector_clear(ref _d_noise);
        }
        // This function returns no value.
    }
    
    public static void ssaanalyzelastwindow(ssamodel s, out double[] trend, out double[] noise, out int nticks)
    {
        _core_ssaanalyzelastwindow( s, out  trend, out  noise, out  nticks, 0x0);
    }
    
    public static void ssaanalyzelastwindow(ssamodel s, out double[] trend, out double[] noise, out int nticks, alglib.xparams _xparams)
    {
        _core_ssaanalyzelastwindow( s, out  trend, out  noise, out  nticks, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_ssaanalyzelast(ssamodel s, int nticks, out double[] trend, out double[] noise, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_int _d_nticks = new x_int(nticks);
        x_vector _d_trend = new x_vector();
        x_vector _d_noise = new x_vector();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_trend, DT_REAL);
            trend = null;
            x_vector_create_empty(ref _d_noise, DT_REAL);
            noise = null;
            _error_code = _i_xv2_ssaanalyzelast(&_s_errormsg, &_d_s, &_d_nticks, &_d_trend, &_d_noise, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "ssaanalyzelast");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_trend.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_trend, ref trend);
            if( trend == null )
                trend = new double[0];
            if( _d_noise.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_noise, ref noise);
            if( noise == null )
                noise = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_trend);
            x_vector_clear(ref _d_noise);
        }
        // This function returns no value.
    }
    
    public static void ssaanalyzelast(ssamodel s, int nticks, out double[] trend, out double[] noise)
    {
        _core_ssaanalyzelast( s,  nticks, out  trend, out  noise, 0x0);
    }
    
    public static void ssaanalyzelast(ssamodel s, int nticks, out double[] trend, out double[] noise, alglib.xparams _xparams)
    {
        _core_ssaanalyzelast( s,  nticks, out  trend, out  noise, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_ssaanalyzesequence(ssamodel s, double[] data, int nticks, out double[] trend, out double[] noise, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_vector _d_data = new x_vector();
        x_int _d_nticks = new x_int(nticks);
        x_vector _d_trend = new x_vector();
        x_vector _d_noise = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_data = data){
                x_vector_attach_to_array(ref _d_data, _fp_data, ap.len(data));
                x_vector_create_empty(ref _d_trend, DT_REAL);
                trend = null;
                x_vector_create_empty(ref _d_noise, DT_REAL);
                noise = null;
                _error_code = _i_xv2_ssaanalyzesequence(&_s_errormsg, &_d_s, &_d_data, &_d_nticks, &_d_trend, &_d_noise, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "ssaanalyzesequence");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_trend.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_trend, ref trend);
            if( trend == null )
                trend = new double[0];
            if( _d_noise.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_noise, ref noise);
            if( noise == null )
                noise = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_data);
            x_vector_clear(ref _d_trend);
            x_vector_clear(ref _d_noise);
        }
        // This function returns no value.
    }
    
    public static void ssaanalyzesequence(ssamodel s, double[] data, int nticks, out double[] trend, out double[] noise)
    {
        _core_ssaanalyzesequence( s,  data,  nticks, out  trend, out  noise, 0x0);
    }
    
    public static void ssaanalyzesequence(ssamodel s, double[] data, int nticks, out double[] trend, out double[] noise, alglib.xparams _xparams)
    {
        _core_ssaanalyzesequence( s,  data,  nticks, out  trend, out  noise, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void ssaanalyzesequence(ssamodel s, double[] data, out double[] trend, out double[] noise)
    {
        int nticks;
    
        nticks = ap.len(data);
        _core_ssaanalyzesequence( s,  data,  nticks, out  trend, out  noise, 0x0);
    
        
    }
    
    public static void ssaanalyzesequence(ssamodel s, double[] data, out double[] trend, out double[] noise, alglib.xparams _xparams)
    {
        int nticks;
    
        nticks = ap.len(data);
        _core_ssaanalyzesequence( s,  data,  nticks, out  trend, out  noise, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_ssaforecastlast(ssamodel s, int nticks, out double[] trend, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_int _d_nticks = new x_int(nticks);
        x_vector _d_trend = new x_vector();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_trend, DT_REAL);
            trend = null;
            _error_code = _i_xv2_ssaforecastlast(&_s_errormsg, &_d_s, &_d_nticks, &_d_trend, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "ssaforecastlast");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_trend.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_trend, ref trend);
            if( trend == null )
                trend = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_trend);
        }
        // This function returns no value.
    }
    
    public static void ssaforecastlast(ssamodel s, int nticks, out double[] trend)
    {
        _core_ssaforecastlast( s,  nticks, out  trend, 0x0);
    }
    
    public static void ssaforecastlast(ssamodel s, int nticks, out double[] trend, alglib.xparams _xparams)
    {
        _core_ssaforecastlast( s,  nticks, out  trend, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_ssaforecastsequence(ssamodel s, double[] data, int datalen, int forecastlen, bool applysmoothing, out double[] trend, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_vector _d_data = new x_vector();
        x_int _d_datalen = new x_int(datalen);
        x_int _d_forecastlen = new x_int(forecastlen);
        byte _d_applysmoothing = (byte)(applysmoothing ? 1 : 0);
        x_vector _d_trend = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_data = data){
                x_vector_attach_to_array(ref _d_data, _fp_data, ap.len(data));
                x_vector_create_empty(ref _d_trend, DT_REAL);
                trend = null;
                _error_code = _i_xv2_ssaforecastsequence(&_s_errormsg, &_d_s, &_d_data, &_d_datalen, &_d_forecastlen, &_d_applysmoothing, &_d_trend, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "ssaforecastsequence");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_trend.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_trend, ref trend);
            if( trend == null )
                trend = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_data);
            x_vector_clear(ref _d_trend);
        }
        // This function returns no value.
    }
    
    public static void ssaforecastsequence(ssamodel s, double[] data, int datalen, int forecastlen, bool applysmoothing, out double[] trend)
    {
        _core_ssaforecastsequence( s,  data,  datalen,  forecastlen,  applysmoothing, out  trend, 0x0);
    }
    
    public static void ssaforecastsequence(ssamodel s, double[] data, int datalen, int forecastlen, bool applysmoothing, out double[] trend, alglib.xparams _xparams)
    {
        _core_ssaforecastsequence( s,  data,  datalen,  forecastlen,  applysmoothing, out  trend, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void ssaforecastsequence(ssamodel s, double[] data, int forecastlen, out double[] trend)
    {
        int datalen;
        bool applysmoothing;
    
        datalen = ap.len(data);
        applysmoothing = true;
        _core_ssaforecastsequence( s,  data,  datalen,  forecastlen,  applysmoothing, out  trend, 0x0);
    
        
    }
    
    public static void ssaforecastsequence(ssamodel s, double[] data, int forecastlen, out double[] trend, alglib.xparams _xparams)
    {
        int datalen;
        bool applysmoothing;
    
        datalen = ap.len(data);
        applysmoothing = true;
        _core_ssaforecastsequence( s,  data,  datalen,  forecastlen,  applysmoothing, out  trend, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_ssaforecastavglast(ssamodel s, int m, int nticks, out double[] trend, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_int _d_m = new x_int(m);
        x_int _d_nticks = new x_int(nticks);
        x_vector _d_trend = new x_vector();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_trend, DT_REAL);
            trend = null;
            _error_code = _i_xv2_ssaforecastavglast(&_s_errormsg, &_d_s, &_d_m, &_d_nticks, &_d_trend, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "ssaforecastavglast");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_trend.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_trend, ref trend);
            if( trend == null )
                trend = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_trend);
        }
        // This function returns no value.
    }
    
    public static void ssaforecastavglast(ssamodel s, int m, int nticks, out double[] trend)
    {
        _core_ssaforecastavglast( s,  m,  nticks, out  trend, 0x0);
    }
    
    public static void ssaforecastavglast(ssamodel s, int m, int nticks, out double[] trend, alglib.xparams _xparams)
    {
        _core_ssaforecastavglast( s,  m,  nticks, out  trend, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_ssaforecastavgsequence(ssamodel s, double[] data, int datalen, int m, int forecastlen, bool applysmoothing, out double[] trend, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_vector _d_data = new x_vector();
        x_int _d_datalen = new x_int(datalen);
        x_int _d_m = new x_int(m);
        x_int _d_forecastlen = new x_int(forecastlen);
        byte _d_applysmoothing = (byte)(applysmoothing ? 1 : 0);
        x_vector _d_trend = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_data = data){
                x_vector_attach_to_array(ref _d_data, _fp_data, ap.len(data));
                x_vector_create_empty(ref _d_trend, DT_REAL);
                trend = null;
                _error_code = _i_xv2_ssaforecastavgsequence(&_s_errormsg, &_d_s, &_d_data, &_d_datalen, &_d_m, &_d_forecastlen, &_d_applysmoothing, &_d_trend, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "ssaforecastavgsequence");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_trend.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_trend, ref trend);
            if( trend == null )
                trend = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_data);
            x_vector_clear(ref _d_trend);
        }
        // This function returns no value.
    }
    
    public static void ssaforecastavgsequence(ssamodel s, double[] data, int datalen, int m, int forecastlen, bool applysmoothing, out double[] trend)
    {
        _core_ssaforecastavgsequence( s,  data,  datalen,  m,  forecastlen,  applysmoothing, out  trend, 0x0);
    }
    
    public static void ssaforecastavgsequence(ssamodel s, double[] data, int datalen, int m, int forecastlen, bool applysmoothing, out double[] trend, alglib.xparams _xparams)
    {
        _core_ssaforecastavgsequence( s,  data,  datalen,  m,  forecastlen,  applysmoothing, out  trend, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void ssaforecastavgsequence(ssamodel s, double[] data, int m, int forecastlen, out double[] trend)
    {
        int datalen;
        bool applysmoothing;
    
        datalen = ap.len(data);
        applysmoothing = true;
        _core_ssaforecastavgsequence( s,  data,  datalen,  m,  forecastlen,  applysmoothing, out  trend, 0x0);
    
        
    }
    
    public static void ssaforecastavgsequence(ssamodel s, double[] data, int m, int forecastlen, out double[] trend, alglib.xparams _xparams)
    {
        int datalen;
        bool applysmoothing;
    
        datalen = ap.len(data);
        applysmoothing = true;
        _core_ssaforecastavgsequence( s,  data,  datalen,  m,  forecastlen,  applysmoothing, out  trend, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    
    //
    // Subpackage lda
    //
    
    
    private static unsafe void _core_fisherlda(double[,] xy, int npoints, int nvars, int nclasses, out int info, out double[] w, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        x_int _d_nvars = new x_int(nvars);
        x_int _d_nclasses = new x_int(nclasses);
        x_int _d_info = new x_int();
        x_vector _d_w = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                x_vector_create_empty(ref _d_w, DT_REAL);
                w = null;
                _error_code = _i_xv2_fisherlda(&_s_errormsg, &_d_xy, &_d_npoints, &_d_nvars, &_d_nclasses, &_d_info, &_d_w, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "fisherlda");
            info = _d_info.intval;
            if( _d_w.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_w, ref w);
            if( w == null )
                w = new double[0];
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
            x_vector_clear(ref _d_w);
        }
        // This function returns no value.
    }
    
    public static void fisherlda(double[,] xy, int npoints, int nvars, int nclasses, out int info, out double[] w)
    {
        _core_fisherlda( xy,  npoints,  nvars,  nclasses, out  info, out  w, 0x0);
    }
    
    public static void fisherlda(double[,] xy, int npoints, int nvars, int nclasses, out int info, out double[] w, alglib.xparams _xparams)
    {
        _core_fisherlda( xy,  npoints,  nvars,  nclasses, out  info, out  w, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_fisherldan(double[,] xy, int npoints, int nvars, int nclasses, out int info, out double[,] w, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        x_int _d_nvars = new x_int(nvars);
        x_int _d_nclasses = new x_int(nclasses);
        x_int _d_info = new x_int();
        x_matrix _d_w = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                x_matrix_create_empty(ref _d_w, DT_REAL);
                w = null;
                _error_code = _i_xv2_fisherldan(&_s_errormsg, &_d_xy, &_d_npoints, &_d_nvars, &_d_nclasses, &_d_info, &_d_w, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "fisherldan");
            info = _d_info.intval;
            if( _d_w.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_w, ref w);
            if( w == null )
                w = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
            x_matrix_clear(ref _d_w);
        }
        // This function returns no value.
    }
    
    public static void fisherldan(double[,] xy, int npoints, int nvars, int nclasses, out int info, out double[,] w)
    {
        _core_fisherldan( xy,  npoints,  nvars,  nclasses, out  info, out  w, 0x0);
    }
    
    public static void fisherldan(double[,] xy, int npoints, int nvars, int nclasses, out int info, out double[,] w, alglib.xparams _xparams)
    {
        _core_fisherldan( xy,  npoints,  nvars,  nclasses, out  info, out  w, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage mcpd
    //
    

    public unsafe class mcpdstate : alglibobject
    {
        private void *_ptr;
        public mcpdstate(void *x)
        {
            _ptr = x;
        }
        ~mcpdstate()
        {
            _deallocate();
        }
        public void* ptr { get { return _ptr; } }
        public override alglib.alglibobject make_copy()
        {
            if( _ptr==null )
                return new mcpdstate(null);
            return new mcpdstate(_i_x_obj_copy_mcpdstate(_ptr));
        }
        public override void _deallocate()
        {
            if( _ptr!=null )
                _i_x_obj_free_mcpdstate(_ptr);
            _ptr = null;
            System.GC.SuppressFinalize(this);
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_mcpdstate(void *x);
    private static _d_x_obj_copy_mcpdstate _i_x_obj_copy_mcpdstate = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_obj_free_mcpdstate(void *x);
    private static _d_x_obj_free_mcpdstate _i_x_obj_free_mcpdstate = null;

    [StructLayout(LayoutKind.Sequential, Pack=8)]
    private struct x_mcpdreport
    {
        public x_int inneriterationscount;
        public x_int outeriterationscount;
        public x_int nfev;
        public x_int terminationtype;
    }

    public class mcpdreport : alglibobject
    {
        public int inneriterationscount;
        public int outeriterationscount;
        public int nfev;
        public int terminationtype;
        public override alglib.alglibobject make_copy()
        {
            mcpdreport dst = new mcpdreport();
            dst.inneriterationscount = inneriterationscount;
            dst.outeriterationscount = outeriterationscount;
            dst.nfev = nfev;
            dst.terminationtype = terminationtype;
            return dst;
        }
    }

    // This function initializes X-structure (its previous content is ignored)
    private static void x_mcpdreport_init(ref x_mcpdreport x)
    {
        x.inneriterationscount.longval = 0;
        x.outeriterationscount.longval = 0;
        x.nfev.longval = 0;
        x.terminationtype.longval = 0;
    }

    // This function finalizes fields of X-structure (however, memory occupied by structure itself is not freed)
    // After destruction structure becomes unusable and should be re-initialized if you want to use it
    private static void x_mcpdreport_clear(ref x_mcpdreport x)
    {
    }

    // This function initializes X-structure by appropriate C# instance
    // (previous content of X structure is ignored)
    private static void x_mcpdreport_init_from(ref x_mcpdreport x, mcpdreport v)
    {
        x.inneriterationscount.longval = v.inneriterationscount;
        x.outeriterationscount.longval = v.outeriterationscount;
        x.nfev.longval = v.nfev;
        x.terminationtype.longval = v.terminationtype;
    }

    // This function initializes C# structure by appropriate X instance
    // (previous content of C# structure is ignored).
    // This function may accept null v, in this case v is automatically allocated with new().
    private static void x_mcpdreport_to_record(ref x_mcpdreport x, ref mcpdreport v)
    {
        if( v==null )
            v = new mcpdreport();
        v.inneriterationscount = x.inneriterationscount.intval; // long is silently truncated to int
        v.outeriterationscount = x.outeriterationscount.intval; // long is silently truncated to int
        v.nfev = x.nfev.intval; // long is silently truncated to int
        v.terminationtype = x.terminationtype.intval; // long is silently truncated to int
    }
    
    private static unsafe void _core_mcpdcreate(int n, out mcpdstate s, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        void *_d_s = null;
        s = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_mcpdcreate(&_s_errormsg, &_d_n, &_d_s, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mcpdcreate");
            s = new mcpdstate(_d_s);
        }
        finally
        {
            if( _d_s!=null && s==null)
                _i_x_obj_free_mcpdstate(_d_s); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void mcpdcreate(int n, out mcpdstate s)
    {
        _core_mcpdcreate( n, out  s, 0x0);
    }
    
    public static void mcpdcreate(int n, out mcpdstate s, alglib.xparams _xparams)
    {
        _core_mcpdcreate( n, out  s, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mcpdcreateentry(int n, int entrystate, out mcpdstate s, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        x_int _d_entrystate = new x_int(entrystate);
        void *_d_s = null;
        s = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_mcpdcreateentry(&_s_errormsg, &_d_n, &_d_entrystate, &_d_s, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mcpdcreateentry");
            s = new mcpdstate(_d_s);
        }
        finally
        {
            if( _d_s!=null && s==null)
                _i_x_obj_free_mcpdstate(_d_s); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void mcpdcreateentry(int n, int entrystate, out mcpdstate s)
    {
        _core_mcpdcreateentry( n,  entrystate, out  s, 0x0);
    }
    
    public static void mcpdcreateentry(int n, int entrystate, out mcpdstate s, alglib.xparams _xparams)
    {
        _core_mcpdcreateentry( n,  entrystate, out  s, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mcpdcreateexit(int n, int exitstate, out mcpdstate s, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        x_int _d_exitstate = new x_int(exitstate);
        void *_d_s = null;
        s = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_mcpdcreateexit(&_s_errormsg, &_d_n, &_d_exitstate, &_d_s, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mcpdcreateexit");
            s = new mcpdstate(_d_s);
        }
        finally
        {
            if( _d_s!=null && s==null)
                _i_x_obj_free_mcpdstate(_d_s); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void mcpdcreateexit(int n, int exitstate, out mcpdstate s)
    {
        _core_mcpdcreateexit( n,  exitstate, out  s, 0x0);
    }
    
    public static void mcpdcreateexit(int n, int exitstate, out mcpdstate s, alglib.xparams _xparams)
    {
        _core_mcpdcreateexit( n,  exitstate, out  s, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mcpdcreateentryexit(int n, int entrystate, int exitstate, out mcpdstate s, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        x_int _d_entrystate = new x_int(entrystate);
        x_int _d_exitstate = new x_int(exitstate);
        void *_d_s = null;
        s = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_mcpdcreateentryexit(&_s_errormsg, &_d_n, &_d_entrystate, &_d_exitstate, &_d_s, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mcpdcreateentryexit");
            s = new mcpdstate(_d_s);
        }
        finally
        {
            if( _d_s!=null && s==null)
                _i_x_obj_free_mcpdstate(_d_s); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void mcpdcreateentryexit(int n, int entrystate, int exitstate, out mcpdstate s)
    {
        _core_mcpdcreateentryexit( n,  entrystate,  exitstate, out  s, 0x0);
    }
    
    public static void mcpdcreateentryexit(int n, int entrystate, int exitstate, out mcpdstate s, alglib.xparams _xparams)
    {
        _core_mcpdcreateentryexit( n,  entrystate,  exitstate, out  s, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mcpdaddtrack(mcpdstate s, double[,] xy, int k, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_k = new x_int(k);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_xv2_mcpdaddtrack(&_s_errormsg, &_d_s, &_d_xy, &_d_k, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mcpdaddtrack");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
        }
        // This function returns no value.
    }
    
    public static void mcpdaddtrack(mcpdstate s, double[,] xy, int k)
    {
        _core_mcpdaddtrack( s,  xy,  k, 0x0);
    }
    
    public static void mcpdaddtrack(mcpdstate s, double[,] xy, int k, alglib.xparams _xparams)
    {
        _core_mcpdaddtrack( s,  xy,  k, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void mcpdaddtrack(mcpdstate s, double[,] xy)
    {
        int k;
    
        k = ap.rows(xy);
        _core_mcpdaddtrack( s,  xy,  k, 0x0);
    
        
    }
    
    public static void mcpdaddtrack(mcpdstate s, double[,] xy, alglib.xparams _xparams)
    {
        int k;
    
        k = ap.rows(xy);
        _core_mcpdaddtrack( s,  xy,  k, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_mcpdsetec(mcpdstate s, double[,] ec, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_matrix _d_ec = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_ec = ec){
                x_matrix_attach_to_array(ref _d_ec, _fp_ec, ap.rows(ec), ap.cols(ec));
                _error_code = _i_xv2_mcpdsetec(&_s_errormsg, &_d_s, &_d_ec, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mcpdsetec");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_ec);
        }
        // This function returns no value.
    }
    
    public static void mcpdsetec(mcpdstate s, double[,] ec)
    {
        _core_mcpdsetec( s,  ec, 0x0);
    }
    
    public static void mcpdsetec(mcpdstate s, double[,] ec, alglib.xparams _xparams)
    {
        _core_mcpdsetec( s,  ec, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mcpdaddec(mcpdstate s, int i, int j, double c, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_int _d_i = new x_int(i);
        x_int _d_j = new x_int(j);
        double _d_c = c;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_mcpdaddec(&_s_errormsg, &_d_s, &_d_i, &_d_j, &_d_c, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mcpdaddec");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void mcpdaddec(mcpdstate s, int i, int j, double c)
    {
        _core_mcpdaddec( s,  i,  j,  c, 0x0);
    }
    
    public static void mcpdaddec(mcpdstate s, int i, int j, double c, alglib.xparams _xparams)
    {
        _core_mcpdaddec( s,  i,  j,  c, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mcpdsetbc(mcpdstate s, double[,] bndl, double[,] bndu, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_matrix _d_bndl = new x_matrix();
        x_matrix _d_bndu = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_bndl = bndl, _fp_bndu = bndu){
                x_matrix_attach_to_array(ref _d_bndl, _fp_bndl, ap.rows(bndl), ap.cols(bndl));
                x_matrix_attach_to_array(ref _d_bndu, _fp_bndu, ap.rows(bndu), ap.cols(bndu));
                _error_code = _i_xv2_mcpdsetbc(&_s_errormsg, &_d_s, &_d_bndl, &_d_bndu, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mcpdsetbc");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_bndl);
            x_matrix_clear(ref _d_bndu);
        }
        // This function returns no value.
    }
    
    public static void mcpdsetbc(mcpdstate s, double[,] bndl, double[,] bndu)
    {
        _core_mcpdsetbc( s,  bndl,  bndu, 0x0);
    }
    
    public static void mcpdsetbc(mcpdstate s, double[,] bndl, double[,] bndu, alglib.xparams _xparams)
    {
        _core_mcpdsetbc( s,  bndl,  bndu, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mcpdaddbc(mcpdstate s, int i, int j, double bndl, double bndu, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_int _d_i = new x_int(i);
        x_int _d_j = new x_int(j);
        double _d_bndl = bndl;
        double _d_bndu = bndu;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_mcpdaddbc(&_s_errormsg, &_d_s, &_d_i, &_d_j, &_d_bndl, &_d_bndu, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mcpdaddbc");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void mcpdaddbc(mcpdstate s, int i, int j, double bndl, double bndu)
    {
        _core_mcpdaddbc( s,  i,  j,  bndl,  bndu, 0x0);
    }
    
    public static void mcpdaddbc(mcpdstate s, int i, int j, double bndl, double bndu, alglib.xparams _xparams)
    {
        _core_mcpdaddbc( s,  i,  j,  bndl,  bndu, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mcpdsetlc(mcpdstate s, double[,] c, int[] ct, int k, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_matrix _d_c = new x_matrix();
        x_vector _d_ct = new x_vector();
        x_int _d_k = new x_int(k);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_c = c){
                x_matrix_attach_to_array(ref _d_c, _fp_c, ap.rows(c), ap.cols(c));
                x_vector_from_array(ref _d_ct, ct, X_CREATE);
                _error_code = _i_xv2_mcpdsetlc(&_s_errormsg, &_d_s, &_d_c, &_d_ct, &_d_k, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mcpdsetlc");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_c);
            x_vector_clear(ref _d_ct);
        }
        // This function returns no value.
    }
    
    public static void mcpdsetlc(mcpdstate s, double[,] c, int[] ct, int k)
    {
        _core_mcpdsetlc( s,  c,  ct,  k, 0x0);
    }
    
    public static void mcpdsetlc(mcpdstate s, double[,] c, int[] ct, int k, alglib.xparams _xparams)
    {
        _core_mcpdsetlc( s,  c,  ct,  k, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    public static void mcpdsetlc(mcpdstate s, double[,] c, int[] ct)
    {
        int k;
        if( (ap.rows(c)!=ap.len(ct)))
            throw new alglibexception("Error while calling 'mcpdsetlc': looks like one of arguments has wrong size");
        k = ap.rows(c);
        _core_mcpdsetlc( s,  c,  ct,  k, 0x0);
    
        
    }
    
    public static void mcpdsetlc(mcpdstate s, double[,] c, int[] ct, alglib.xparams _xparams)
    {
        int k;
        if( (ap.rows(c)!=ap.len(ct)))
            throw new alglibexception("Error while calling 'mcpdsetlc': looks like one of arguments has wrong size");
        k = ap.rows(c);
        _core_mcpdsetlc( s,  c,  ct,  k, _xparams==null ? 0x0 : _xparams.flags);
    
        
    }
    
    private static unsafe void _core_mcpdsettikhonovregularizer(mcpdstate s, double v, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        double _d_v = v;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_mcpdsettikhonovregularizer(&_s_errormsg, &_d_s, &_d_v, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mcpdsettikhonovregularizer");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void mcpdsettikhonovregularizer(mcpdstate s, double v)
    {
        _core_mcpdsettikhonovregularizer( s,  v, 0x0);
    }
    
    public static void mcpdsettikhonovregularizer(mcpdstate s, double v, alglib.xparams _xparams)
    {
        _core_mcpdsettikhonovregularizer( s,  v, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mcpdsetprior(mcpdstate s, double[,] pp, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_matrix _d_pp = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_pp = pp){
                x_matrix_attach_to_array(ref _d_pp, _fp_pp, ap.rows(pp), ap.cols(pp));
                _error_code = _i_xv2_mcpdsetprior(&_s_errormsg, &_d_s, &_d_pp, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mcpdsetprior");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_pp);
        }
        // This function returns no value.
    }
    
    public static void mcpdsetprior(mcpdstate s, double[,] pp)
    {
        _core_mcpdsetprior( s,  pp, 0x0);
    }
    
    public static void mcpdsetprior(mcpdstate s, double[,] pp, alglib.xparams _xparams)
    {
        _core_mcpdsetprior( s,  pp, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mcpdsetpredictionweights(mcpdstate s, double[] pw, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_vector _d_pw = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_pw = pw){
                x_vector_attach_to_array(ref _d_pw, _fp_pw, ap.len(pw));
                _error_code = _i_xv2_mcpdsetpredictionweights(&_s_errormsg, &_d_s, &_d_pw, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mcpdsetpredictionweights");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_pw);
        }
        // This function returns no value.
    }
    
    public static void mcpdsetpredictionweights(mcpdstate s, double[] pw)
    {
        _core_mcpdsetpredictionweights( s,  pw, 0x0);
    }
    
    public static void mcpdsetpredictionweights(mcpdstate s, double[] pw, alglib.xparams _xparams)
    {
        _core_mcpdsetpredictionweights( s,  pw, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mcpdsolve(mcpdstate s, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_mcpdsolve(&_s_errormsg, &_d_s, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mcpdsolve");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void mcpdsolve(mcpdstate s)
    {
        _core_mcpdsolve( s, 0x0);
    }
    
    public static void mcpdsolve(mcpdstate s, alglib.xparams _xparams)
    {
        _core_mcpdsolve( s, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mcpdresults(mcpdstate s, out double[,] p, out mcpdreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_matrix _d_p = new x_matrix();
        x_mcpdreport _d_rep = new x_mcpdreport();
        
        // Pack, call, unpack
        try
        {
            x_matrix_create_empty(ref _d_p, DT_REAL);
            p = null;
            x_mcpdreport_init(ref _d_rep);
            _error_code = _i_xv2_mcpdresults(&_s_errormsg, &_d_s, &_d_p, &_d_rep, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mcpdresults");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_p.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_p, ref p);
            if( p == null )
                p = new double[0,0];
            rep = null;
            x_mcpdreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_matrix_clear(ref _d_p);
            x_mcpdreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void mcpdresults(mcpdstate s, out double[,] p, out mcpdreport rep)
    {
        _core_mcpdresults( s, out  p, out  rep, 0x0);
    }
    
    public static void mcpdresults(mcpdstate s, out double[,] p, out mcpdreport rep, alglib.xparams _xparams)
    {
        _core_mcpdresults( s, out  p, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage logit
    //
    

    public unsafe class logitmodel : alglibobject
    {
        private void *_ptr;
        public logitmodel(void *x)
        {
            _ptr = x;
        }
        ~logitmodel()
        {
            _deallocate();
        }
        public void* ptr { get { return _ptr; } }
        public override alglib.alglibobject make_copy()
        {
            if( _ptr==null )
                return new logitmodel(null);
            return new logitmodel(_i_x_obj_copy_logitmodel(_ptr));
        }
        public override void _deallocate()
        {
            if( _ptr!=null )
                _i_x_obj_free_logitmodel(_ptr);
            _ptr = null;
            System.GC.SuppressFinalize(this);
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_logitmodel(void *x);
    private static _d_x_obj_copy_logitmodel _i_x_obj_copy_logitmodel = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_obj_free_logitmodel(void *x);
    private static _d_x_obj_free_logitmodel _i_x_obj_free_logitmodel = null;

    [StructLayout(LayoutKind.Sequential, Pack=8)]
    private struct x_mnlreport
    {
        public x_int ngrad;
        public x_int nhess;
    }

    public class mnlreport : alglibobject
    {
        public int ngrad;
        public int nhess;
        public override alglib.alglibobject make_copy()
        {
            mnlreport dst = new mnlreport();
            dst.ngrad = ngrad;
            dst.nhess = nhess;
            return dst;
        }
    }

    // This function initializes X-structure (its previous content is ignored)
    private static void x_mnlreport_init(ref x_mnlreport x)
    {
        x.ngrad.longval = 0;
        x.nhess.longval = 0;
    }

    // This function finalizes fields of X-structure (however, memory occupied by structure itself is not freed)
    // After destruction structure becomes unusable and should be re-initialized if you want to use it
    private static void x_mnlreport_clear(ref x_mnlreport x)
    {
    }

    // This function initializes X-structure by appropriate C# instance
    // (previous content of X structure is ignored)
    private static void x_mnlreport_init_from(ref x_mnlreport x, mnlreport v)
    {
        x.ngrad.longval = v.ngrad;
        x.nhess.longval = v.nhess;
    }

    // This function initializes C# structure by appropriate X instance
    // (previous content of C# structure is ignored).
    // This function may accept null v, in this case v is automatically allocated with new().
    private static void x_mnlreport_to_record(ref x_mnlreport x, ref mnlreport v)
    {
        if( v==null )
            v = new mnlreport();
        v.ngrad = x.ngrad.intval; // long is silently truncated to int
        v.nhess = x.nhess.intval; // long is silently truncated to int
    }
    
    private static unsafe void _core_mnltrainh(double[,] xy, int npoints, int nvars, int nclasses, out int info, out logitmodel lm, out mnlreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        x_int _d_nvars = new x_int(nvars);
        x_int _d_nclasses = new x_int(nclasses);
        x_int _d_info = new x_int();
        void *_d_lm = null;
        lm = null;
        x_mnlreport _d_rep = new x_mnlreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                x_mnlreport_init(ref _d_rep);
                _error_code = _i_xv2_mnltrainh(&_s_errormsg, &_d_xy, &_d_npoints, &_d_nvars, &_d_nclasses, &_d_info, &_d_lm, &_d_rep, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mnltrainh");
            info = _d_info.intval;
            lm = new logitmodel(_d_lm);
            rep = null;
            x_mnlreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
            if( _d_lm!=null && lm==null)
                _i_x_obj_free_logitmodel(_d_lm); // on exception clean up X objects which were not attached to C# objects
            x_mnlreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void mnltrainh(double[,] xy, int npoints, int nvars, int nclasses, out int info, out logitmodel lm, out mnlreport rep)
    {
        _core_mnltrainh( xy,  npoints,  nvars,  nclasses, out  info, out  lm, out  rep, 0x0);
    }
    
    public static void mnltrainh(double[,] xy, int npoints, int nvars, int nclasses, out int info, out logitmodel lm, out mnlreport rep, alglib.xparams _xparams)
    {
        _core_mnltrainh( xy,  npoints,  nvars,  nclasses, out  info, out  lm, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mnlprocess(logitmodel lm, double[] x, ref double[] y, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_lm = lm.ptr;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                _error_code = _i_xv2_mnlprocess(&_s_errormsg, &_d_lm, &_d_x, &_d_y, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mnlprocess");
            ap.assert(lm.ptr==_d_lm, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_y.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_y, ref y);
            if( y == null )
                y = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
        }
        // This function returns no value.
    }
    
    public static void mnlprocess(logitmodel lm, double[] x, ref double[] y)
    {
        _core_mnlprocess( lm,  x, ref  y, 0x0);
    }
    
    public static void mnlprocess(logitmodel lm, double[] x, ref double[] y, alglib.xparams _xparams)
    {
        _core_mnlprocess( lm,  x, ref  y, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mnlprocessi(logitmodel lm, double[] x, out double[] y, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_lm = lm.ptr;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_create_empty(ref _d_y, DT_REAL);
                y = null;
                _error_code = _i_xv2_mnlprocessi(&_s_errormsg, &_d_lm, &_d_x, &_d_y, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mnlprocessi");
            ap.assert(lm.ptr==_d_lm, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_y.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_y, ref y);
            if( y == null )
                y = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
        }
        // This function returns no value.
    }
    
    public static void mnlprocessi(logitmodel lm, double[] x, out double[] y)
    {
        _core_mnlprocessi( lm,  x, out  y, 0x0);
    }
    
    public static void mnlprocessi(logitmodel lm, double[] x, out double[] y, alglib.xparams _xparams)
    {
        _core_mnlprocessi( lm,  x, out  y, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mnlunpack(logitmodel lm, out double[,] a, out int nvars, out int nclasses, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_lm = lm.ptr;
        x_matrix _d_a = new x_matrix();
        x_int _d_nvars = new x_int();
        x_int _d_nclasses = new x_int();
        
        // Pack, call, unpack
        try
        {
            x_matrix_create_empty(ref _d_a, DT_REAL);
            a = null;
            _error_code = _i_xv2_mnlunpack(&_s_errormsg, &_d_lm, &_d_a, &_d_nvars, &_d_nclasses, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mnlunpack");
            ap.assert(lm.ptr==_d_lm, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new double[0,0];
            nvars = _d_nvars.intval;
            nclasses = _d_nclasses.intval;
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        // This function returns no value.
    }
    
    public static void mnlunpack(logitmodel lm, out double[,] a, out int nvars, out int nclasses)
    {
        _core_mnlunpack( lm, out  a, out  nvars, out  nclasses, 0x0);
    }
    
    public static void mnlunpack(logitmodel lm, out double[,] a, out int nvars, out int nclasses, alglib.xparams _xparams)
    {
        _core_mnlunpack( lm, out  a, out  nvars, out  nclasses, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mnlpack(double[,] a, int nvars, int nclasses, out logitmodel lm, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_nvars = new x_int(nvars);
        x_int _d_nclasses = new x_int(nclasses);
        void *_d_lm = null;
        lm = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                _error_code = _i_xv2_mnlpack(&_s_errormsg, &_d_a, &_d_nvars, &_d_nclasses, &_d_lm, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mnlpack");
            lm = new logitmodel(_d_lm);
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            if( _d_lm!=null && lm==null)
                _i_x_obj_free_logitmodel(_d_lm); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void mnlpack(double[,] a, int nvars, int nclasses, out logitmodel lm)
    {
        _core_mnlpack( a,  nvars,  nclasses, out  lm, 0x0);
    }
    
    public static void mnlpack(double[,] a, int nvars, int nclasses, out logitmodel lm, alglib.xparams _xparams)
    {
        _core_mnlpack( a,  nvars,  nclasses, out  lm, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_mnlavgce(logitmodel lm, double[,] xy, int npoints, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_lm = lm.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_xv2_mnlavgce(&_s_errormsg, &_d_result, &_d_lm, &_d_xy, &_d_npoints, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mnlavgce");
            result = _d_result;
            ap.assert(lm.ptr==_d_lm, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
        }
        return result;
    }
    
    public static double mnlavgce(logitmodel lm, double[,] xy, int npoints)
    {
        return _core_mnlavgce( lm,  xy,  npoints, 0x0);
    }
    
    public static double mnlavgce(logitmodel lm, double[,] xy, int npoints, alglib.xparams _xparams)
    {
        return _core_mnlavgce( lm,  xy,  npoints, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_mnlrelclserror(logitmodel lm, double[,] xy, int npoints, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_lm = lm.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_xv2_mnlrelclserror(&_s_errormsg, &_d_result, &_d_lm, &_d_xy, &_d_npoints, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mnlrelclserror");
            result = _d_result;
            ap.assert(lm.ptr==_d_lm, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
        }
        return result;
    }
    
    public static double mnlrelclserror(logitmodel lm, double[,] xy, int npoints)
    {
        return _core_mnlrelclserror( lm,  xy,  npoints, 0x0);
    }
    
    public static double mnlrelclserror(logitmodel lm, double[,] xy, int npoints, alglib.xparams _xparams)
    {
        return _core_mnlrelclserror( lm,  xy,  npoints, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_mnlrmserror(logitmodel lm, double[,] xy, int npoints, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_lm = lm.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_xv2_mnlrmserror(&_s_errormsg, &_d_result, &_d_lm, &_d_xy, &_d_npoints, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mnlrmserror");
            result = _d_result;
            ap.assert(lm.ptr==_d_lm, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
        }
        return result;
    }
    
    public static double mnlrmserror(logitmodel lm, double[,] xy, int npoints)
    {
        return _core_mnlrmserror( lm,  xy,  npoints, 0x0);
    }
    
    public static double mnlrmserror(logitmodel lm, double[,] xy, int npoints, alglib.xparams _xparams)
    {
        return _core_mnlrmserror( lm,  xy,  npoints, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_mnlavgerror(logitmodel lm, double[,] xy, int npoints, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_lm = lm.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_xv2_mnlavgerror(&_s_errormsg, &_d_result, &_d_lm, &_d_xy, &_d_npoints, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mnlavgerror");
            result = _d_result;
            ap.assert(lm.ptr==_d_lm, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
        }
        return result;
    }
    
    public static double mnlavgerror(logitmodel lm, double[,] xy, int npoints)
    {
        return _core_mnlavgerror( lm,  xy,  npoints, 0x0);
    }
    
    public static double mnlavgerror(logitmodel lm, double[,] xy, int npoints, alglib.xparams _xparams)
    {
        return _core_mnlavgerror( lm,  xy,  npoints, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_mnlavgrelerror(logitmodel lm, double[,] xy, int ssize, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_lm = lm.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_ssize = new x_int(ssize);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_xv2_mnlavgrelerror(&_s_errormsg, &_d_result, &_d_lm, &_d_xy, &_d_ssize, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mnlavgrelerror");
            result = _d_result;
            ap.assert(lm.ptr==_d_lm, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
        }
        return result;
    }
    
    public static double mnlavgrelerror(logitmodel lm, double[,] xy, int ssize)
    {
        return _core_mnlavgrelerror( lm,  xy,  ssize, 0x0);
    }
    
    public static double mnlavgrelerror(logitmodel lm, double[,] xy, int ssize, alglib.xparams _xparams)
    {
        return _core_mnlavgrelerror( lm,  xy,  ssize, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe int _core_mnlclserror(logitmodel lm, double[,] xy, int npoints, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        int result;
        x_int _d_result = new x_int();
        void *_d_lm = lm.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_xv2_mnlclserror(&_s_errormsg, &_d_result, &_d_lm, &_d_xy, &_d_npoints, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mnlclserror");
            result = _d_result.intval;
            ap.assert(lm.ptr==_d_lm, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
        }
        return result;
    }
    
    public static int mnlclserror(logitmodel lm, double[,] xy, int npoints)
    {
        return _core_mnlclserror( lm,  xy,  npoints, 0x0);
    }
    
    public static int mnlclserror(logitmodel lm, double[,] xy, int npoints, alglib.xparams _xparams)
    {
        return _core_mnlclserror( lm,  xy,  npoints, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage knn
    //
    

    public unsafe class knnbuffer : alglibobject
    {
        private void *_ptr;
        public knnbuffer(void *x)
        {
            _ptr = x;
        }
        ~knnbuffer()
        {
            _deallocate();
        }
        public void* ptr { get { return _ptr; } }
        public override alglib.alglibobject make_copy()
        {
            if( _ptr==null )
                return new knnbuffer(null);
            return new knnbuffer(_i_x_obj_copy_knnbuffer(_ptr));
        }
        public override void _deallocate()
        {
            if( _ptr!=null )
                _i_x_obj_free_knnbuffer(_ptr);
            _ptr = null;
            System.GC.SuppressFinalize(this);
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_knnbuffer(void *x);
    private static _d_x_obj_copy_knnbuffer _i_x_obj_copy_knnbuffer = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_obj_free_knnbuffer(void *x);
    private static _d_x_obj_free_knnbuffer _i_x_obj_free_knnbuffer = null;

    public unsafe class knnbuilder : alglibobject
    {
        private void *_ptr;
        public knnbuilder(void *x)
        {
            _ptr = x;
        }
        ~knnbuilder()
        {
            _deallocate();
        }
        public void* ptr { get { return _ptr; } }
        public override alglib.alglibobject make_copy()
        {
            if( _ptr==null )
                return new knnbuilder(null);
            return new knnbuilder(_i_x_obj_copy_knnbuilder(_ptr));
        }
        public override void _deallocate()
        {
            if( _ptr!=null )
                _i_x_obj_free_knnbuilder(_ptr);
            _ptr = null;
            System.GC.SuppressFinalize(this);
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_knnbuilder(void *x);
    private static _d_x_obj_copy_knnbuilder _i_x_obj_copy_knnbuilder = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_obj_free_knnbuilder(void *x);
    private static _d_x_obj_free_knnbuilder _i_x_obj_free_knnbuilder = null;

    public unsafe class knnmodel : alglibobject
    {
        private void *_ptr;
        public knnmodel(void *x)
        {
            _ptr = x;
        }
        ~knnmodel()
        {
            _deallocate();
        }
        public void* ptr { get { return _ptr; } }
        public override alglib.alglibobject make_copy()
        {
            if( _ptr==null )
                return new knnmodel(null);
            return new knnmodel(_i_x_obj_copy_knnmodel(_ptr));
        }
        public override void _deallocate()
        {
            if( _ptr!=null )
                _i_x_obj_free_knnmodel(_ptr);
            _ptr = null;
            System.GC.SuppressFinalize(this);
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_knnmodel(void *x);
    private static _d_x_obj_copy_knnmodel _i_x_obj_copy_knnmodel = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_obj_free_knnmodel(void *x);
    private static _d_x_obj_free_knnmodel _i_x_obj_free_knnmodel = null;

    [StructLayout(LayoutKind.Sequential, Pack=8)]
    private struct x_knnreport
    {
        public double relclserror;
        public double avgce;
        public double rmserror;
        public double avgerror;
        public double avgrelerror;
    }

    public class knnreport : alglibobject
    {
        public double relclserror;
        public double avgce;
        public double rmserror;
        public double avgerror;
        public double avgrelerror;
        public override alglib.alglibobject make_copy()
        {
            knnreport dst = new knnreport();
            dst.relclserror = relclserror;
            dst.avgce = avgce;
            dst.rmserror = rmserror;
            dst.avgerror = avgerror;
            dst.avgrelerror = avgrelerror;
            return dst;
        }
    }

    // This function initializes X-structure (its previous content is ignored)
    private static void x_knnreport_init(ref x_knnreport x)
    {
        x.relclserror = 0;
        x.avgce = 0;
        x.rmserror = 0;
        x.avgerror = 0;
        x.avgrelerror = 0;
    }

    // This function finalizes fields of X-structure (however, memory occupied by structure itself is not freed)
    // After destruction structure becomes unusable and should be re-initialized if you want to use it
    private static void x_knnreport_clear(ref x_knnreport x)
    {
    }

    // This function initializes X-structure by appropriate C# instance
    // (previous content of X structure is ignored)
    private static void x_knnreport_init_from(ref x_knnreport x, knnreport v)
    {
        x.relclserror = v.relclserror;
        x.avgce = v.avgce;
        x.rmserror = v.rmserror;
        x.avgerror = v.avgerror;
        x.avgrelerror = v.avgrelerror;
    }

    // This function initializes C# structure by appropriate X instance
    // (previous content of C# structure is ignored).
    // This function may accept null v, in this case v is automatically allocated with new().
    private static void x_knnreport_to_record(ref x_knnreport x, ref knnreport v)
    {
        if( v==null )
            v = new knnreport();
        v.relclserror = x.relclserror;
        v.avgce = x.avgce;
        v.rmserror = x.rmserror;
        v.avgerror = x.avgerror;
        v.avgrelerror = x.avgrelerror;
    }
    public static unsafe void knnserialize(knnmodel obj, out string s_out)
    {
        byte *_s_errormsg = null;
        byte *_out = null;
        void *_x = obj.ptr;
        try
        {
            int _error_code = _i_x_knnserialize(&_s_errormsg, &_x, &_out);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "knnserialize");
            s_out = Marshal.PtrToStringAnsi((IntPtr)_out);
        }
        finally
        {
            x_free((IntPtr)_out);
        }
    }
    
    public static unsafe void knnunserialize(string s_in, out knnmodel obj)
    {
        byte *_s_errormsg = null;
        byte[] _ain = System.Text.Encoding.UTF8.GetBytes(s_in);
        fixed(byte *_pin = _ain )
        {
            byte *_in = _pin;
            void *_x = null;
            obj = null;
            try
            {
                int _error_code = _i_x_knnunserialize(&_s_errormsg, &_in, &_x);
                if( _error_code!=X_OK )
                    handle_exception(_error_code, _s_errormsg, "knnunserialize");
                obj = new knnmodel(_x);
            }
            finally
            {
                // on exception clean up X objects which were not attached to C# objects
                if( _x!=null && obj==null)
                    _i_x_obj_free_knnmodel(_x);
            }
        }
    }
    public static unsafe void knnserialize(knnmodel obj, System.IO.Stream s_out)
    {
        byte *_s_errormsg = null;
        void *_x = obj.ptr;
        alglib.native_stream_adapter a = new alglib.native_stream_adapter();
        a.sstart_stream(s_out);
        int _error_code = _i_x_knnserialize_stream(&_s_errormsg, &_x, a.writer_callback, IntPtr.Zero);
        if( _error_code!=X_OK )
            handle_exception(_error_code, _s_errormsg, "knnserialize");
    }
    
    public static unsafe void knnunserialize(System.IO.Stream s_in, out knnmodel obj)
    {
        byte *_s_errormsg = null;
        void *_x = null;
        obj = null;
        alglib.native_stream_adapter a = new alglib.native_stream_adapter();
        a.ustart_stream(s_in);
        try
        {
            int _error_code = _i_x_knnunserialize_stream(&_s_errormsg, a.reader_callback, IntPtr.Zero, &_x);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "knnunserialize");
            obj = new knnmodel(_x);
        }
        finally
        {
            // on exception clean up X objects which were not attached to C# objects
            if( _x!=null && obj==null)
                _i_x_obj_free_knnmodel(_x);
        }
    }
    
    private static unsafe void _core_knncreatebuffer(knnmodel model, out knnbuffer buf, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_model = model.ptr;
        void *_d_buf = null;
        buf = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_knncreatebuffer(&_s_errormsg, &_d_model, &_d_buf, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "knncreatebuffer");
            ap.assert(model.ptr==_d_model, "ALGLIB: internal error (reference changed for non-out X-object)");
            buf = new knnbuffer(_d_buf);
        }
        finally
        {
            if( _d_buf!=null && buf==null)
                _i_x_obj_free_knnbuffer(_d_buf); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void knncreatebuffer(knnmodel model, out knnbuffer buf)
    {
        _core_knncreatebuffer( model, out  buf, 0x0);
    }
    
    public static void knncreatebuffer(knnmodel model, out knnbuffer buf, alglib.xparams _xparams)
    {
        _core_knncreatebuffer( model, out  buf, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_knnbuildercreate(out knnbuilder s, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = null;
        s = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_knnbuildercreate(&_s_errormsg, &_d_s, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "knnbuildercreate");
            s = new knnbuilder(_d_s);
        }
        finally
        {
            if( _d_s!=null && s==null)
                _i_x_obj_free_knnbuilder(_d_s); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void knnbuildercreate(out knnbuilder s)
    {
        _core_knnbuildercreate(out  s, 0x0);
    }
    
    public static void knnbuildercreate(out knnbuilder s, alglib.xparams _xparams)
    {
        _core_knnbuildercreate(out  s, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_knnbuildersetdatasetreg(knnbuilder s, double[,] xy, int npoints, int nvars, int nout, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        x_int _d_nvars = new x_int(nvars);
        x_int _d_nout = new x_int(nout);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_xv2_knnbuildersetdatasetreg(&_s_errormsg, &_d_s, &_d_xy, &_d_npoints, &_d_nvars, &_d_nout, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "knnbuildersetdatasetreg");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
        }
        // This function returns no value.
    }
    
    public static void knnbuildersetdatasetreg(knnbuilder s, double[,] xy, int npoints, int nvars, int nout)
    {
        _core_knnbuildersetdatasetreg( s,  xy,  npoints,  nvars,  nout, 0x0);
    }
    
    public static void knnbuildersetdatasetreg(knnbuilder s, double[,] xy, int npoints, int nvars, int nout, alglib.xparams _xparams)
    {
        _core_knnbuildersetdatasetreg( s,  xy,  npoints,  nvars,  nout, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_knnbuildersetdatasetcls(knnbuilder s, double[,] xy, int npoints, int nvars, int nclasses, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        x_int _d_nvars = new x_int(nvars);
        x_int _d_nclasses = new x_int(nclasses);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_xv2_knnbuildersetdatasetcls(&_s_errormsg, &_d_s, &_d_xy, &_d_npoints, &_d_nvars, &_d_nclasses, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "knnbuildersetdatasetcls");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
        }
        // This function returns no value.
    }
    
    public static void knnbuildersetdatasetcls(knnbuilder s, double[,] xy, int npoints, int nvars, int nclasses)
    {
        _core_knnbuildersetdatasetcls( s,  xy,  npoints,  nvars,  nclasses, 0x0);
    }
    
    public static void knnbuildersetdatasetcls(knnbuilder s, double[,] xy, int npoints, int nvars, int nclasses, alglib.xparams _xparams)
    {
        _core_knnbuildersetdatasetcls( s,  xy,  npoints,  nvars,  nclasses, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_knnbuildersetnorm(knnbuilder s, int nrmtype, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_int _d_nrmtype = new x_int(nrmtype);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_knnbuildersetnorm(&_s_errormsg, &_d_s, &_d_nrmtype, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "knnbuildersetnorm");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void knnbuildersetnorm(knnbuilder s, int nrmtype)
    {
        _core_knnbuildersetnorm( s,  nrmtype, 0x0);
    }
    
    public static void knnbuildersetnorm(knnbuilder s, int nrmtype, alglib.xparams _xparams)
    {
        _core_knnbuildersetnorm( s,  nrmtype, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_knnbuilderbuildknnmodel(knnbuilder s, int k, double eps, out knnmodel model, out knnreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_int _d_k = new x_int(k);
        double _d_eps = eps;
        void *_d_model = null;
        model = null;
        x_knnreport _d_rep = new x_knnreport();
        
        // Pack, call, unpack
        try
        {
            x_knnreport_init(ref _d_rep);
            _error_code = _i_xv2_knnbuilderbuildknnmodel(&_s_errormsg, &_d_s, &_d_k, &_d_eps, &_d_model, &_d_rep, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "knnbuilderbuildknnmodel");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            model = new knnmodel(_d_model);
            rep = null;
            x_knnreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            if( _d_model!=null && model==null)
                _i_x_obj_free_knnmodel(_d_model); // on exception clean up X objects which were not attached to C# objects
            x_knnreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void knnbuilderbuildknnmodel(knnbuilder s, int k, double eps, out knnmodel model, out knnreport rep)
    {
        _core_knnbuilderbuildknnmodel( s,  k,  eps, out  model, out  rep, 0x0);
    }
    
    public static void knnbuilderbuildknnmodel(knnbuilder s, int k, double eps, out knnmodel model, out knnreport rep, alglib.xparams _xparams)
    {
        _core_knnbuilderbuildknnmodel( s,  k,  eps, out  model, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_knnrewritekeps(knnmodel model, int k, double eps, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_model = model.ptr;
        x_int _d_k = new x_int(k);
        double _d_eps = eps;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_knnrewritekeps(&_s_errormsg, &_d_model, &_d_k, &_d_eps, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "knnrewritekeps");
            ap.assert(model.ptr==_d_model, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void knnrewritekeps(knnmodel model, int k, double eps)
    {
        _core_knnrewritekeps( model,  k,  eps, 0x0);
    }
    
    public static void knnrewritekeps(knnmodel model, int k, double eps, alglib.xparams _xparams)
    {
        _core_knnrewritekeps( model,  k,  eps, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_knnprocess(knnmodel model, double[] x, ref double[] y, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_model = model.ptr;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                _error_code = _i_xv2_knnprocess(&_s_errormsg, &_d_model, &_d_x, &_d_y, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "knnprocess");
            ap.assert(model.ptr==_d_model, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_y.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_y, ref y);
            if( y == null )
                y = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
        }
        // This function returns no value.
    }
    
    public static void knnprocess(knnmodel model, double[] x, ref double[] y)
    {
        _core_knnprocess( model,  x, ref  y, 0x0);
    }
    
    public static void knnprocess(knnmodel model, double[] x, ref double[] y, alglib.xparams _xparams)
    {
        _core_knnprocess( model,  x, ref  y, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_knnprocess0(knnmodel model, double[] x, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_model = model.ptr;
        x_vector _d_x = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_xv2_knnprocess0(&_s_errormsg, &_d_result, &_d_model, &_d_x, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "knnprocess0");
            result = _d_result;
            ap.assert(model.ptr==_d_model, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_x);
        }
        return result;
    }
    
    public static double knnprocess0(knnmodel model, double[] x)
    {
        return _core_knnprocess0( model,  x, 0x0);
    }
    
    public static double knnprocess0(knnmodel model, double[] x, alglib.xparams _xparams)
    {
        return _core_knnprocess0( model,  x, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe int _core_knnclassify(knnmodel model, double[] x, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        int result;
        x_int _d_result = new x_int();
        void *_d_model = model.ptr;
        x_vector _d_x = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_xv2_knnclassify(&_s_errormsg, &_d_result, &_d_model, &_d_x, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "knnclassify");
            result = _d_result.intval;
            ap.assert(model.ptr==_d_model, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_x);
        }
        return result;
    }
    
    public static int knnclassify(knnmodel model, double[] x)
    {
        return _core_knnclassify( model,  x, 0x0);
    }
    
    public static int knnclassify(knnmodel model, double[] x, alglib.xparams _xparams)
    {
        return _core_knnclassify( model,  x, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_knnprocessi(knnmodel model, double[] x, out double[] y, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_model = model.ptr;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_create_empty(ref _d_y, DT_REAL);
                y = null;
                _error_code = _i_xv2_knnprocessi(&_s_errormsg, &_d_model, &_d_x, &_d_y, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "knnprocessi");
            ap.assert(model.ptr==_d_model, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_y.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_y, ref y);
            if( y == null )
                y = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
        }
        // This function returns no value.
    }
    
    public static void knnprocessi(knnmodel model, double[] x, out double[] y)
    {
        _core_knnprocessi( model,  x, out  y, 0x0);
    }
    
    public static void knnprocessi(knnmodel model, double[] x, out double[] y, alglib.xparams _xparams)
    {
        _core_knnprocessi( model,  x, out  y, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_knntsprocess(knnmodel model, knnbuffer buf, double[] x, ref double[] y, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_model = model.ptr;
        void *_d_buf = buf.ptr;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                _error_code = _i_xv2_knntsprocess(&_s_errormsg, &_d_model, &_d_buf, &_d_x, &_d_y, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "knntsprocess");
            ap.assert(model.ptr==_d_model, "ALGLIB: internal error (reference changed for non-out X-object)");
            ap.assert(buf.ptr==_d_buf, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_y.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_y, ref y);
            if( y == null )
                y = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
        }
        // This function returns no value.
    }
    
    public static void knntsprocess(knnmodel model, knnbuffer buf, double[] x, ref double[] y)
    {
        _core_knntsprocess( model,  buf,  x, ref  y, 0x0);
    }
    
    public static void knntsprocess(knnmodel model, knnbuffer buf, double[] x, ref double[] y, alglib.xparams _xparams)
    {
        _core_knntsprocess( model,  buf,  x, ref  y, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_knnrelclserror(knnmodel model, double[,] xy, int npoints, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_model = model.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_xv2_knnrelclserror(&_s_errormsg, &_d_result, &_d_model, &_d_xy, &_d_npoints, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "knnrelclserror");
            result = _d_result;
            ap.assert(model.ptr==_d_model, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
        }
        return result;
    }
    
    public static double knnrelclserror(knnmodel model, double[,] xy, int npoints)
    {
        return _core_knnrelclserror( model,  xy,  npoints, 0x0);
    }
    
    public static double knnrelclserror(knnmodel model, double[,] xy, int npoints, alglib.xparams _xparams)
    {
        return _core_knnrelclserror( model,  xy,  npoints, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_knnavgce(knnmodel model, double[,] xy, int npoints, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_model = model.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_xv2_knnavgce(&_s_errormsg, &_d_result, &_d_model, &_d_xy, &_d_npoints, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "knnavgce");
            result = _d_result;
            ap.assert(model.ptr==_d_model, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
        }
        return result;
    }
    
    public static double knnavgce(knnmodel model, double[,] xy, int npoints)
    {
        return _core_knnavgce( model,  xy,  npoints, 0x0);
    }
    
    public static double knnavgce(knnmodel model, double[,] xy, int npoints, alglib.xparams _xparams)
    {
        return _core_knnavgce( model,  xy,  npoints, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_knnrmserror(knnmodel model, double[,] xy, int npoints, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_model = model.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_xv2_knnrmserror(&_s_errormsg, &_d_result, &_d_model, &_d_xy, &_d_npoints, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "knnrmserror");
            result = _d_result;
            ap.assert(model.ptr==_d_model, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
        }
        return result;
    }
    
    public static double knnrmserror(knnmodel model, double[,] xy, int npoints)
    {
        return _core_knnrmserror( model,  xy,  npoints, 0x0);
    }
    
    public static double knnrmserror(knnmodel model, double[,] xy, int npoints, alglib.xparams _xparams)
    {
        return _core_knnrmserror( model,  xy,  npoints, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_knnavgerror(knnmodel model, double[,] xy, int npoints, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_model = model.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_xv2_knnavgerror(&_s_errormsg, &_d_result, &_d_model, &_d_xy, &_d_npoints, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "knnavgerror");
            result = _d_result;
            ap.assert(model.ptr==_d_model, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
        }
        return result;
    }
    
    public static double knnavgerror(knnmodel model, double[,] xy, int npoints)
    {
        return _core_knnavgerror( model,  xy,  npoints, 0x0);
    }
    
    public static double knnavgerror(knnmodel model, double[,] xy, int npoints, alglib.xparams _xparams)
    {
        return _core_knnavgerror( model,  xy,  npoints, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe double _core_knnavgrelerror(knnmodel model, double[,] xy, int npoints, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_model = model.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_xv2_knnavgrelerror(&_s_errormsg, &_d_result, &_d_model, &_d_xy, &_d_npoints, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "knnavgrelerror");
            result = _d_result;
            ap.assert(model.ptr==_d_model, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
        }
        return result;
    }
    
    public static double knnavgrelerror(knnmodel model, double[,] xy, int npoints)
    {
        return _core_knnavgrelerror( model,  xy,  npoints, 0x0);
    }
    
    public static double knnavgrelerror(knnmodel model, double[,] xy, int npoints, alglib.xparams _xparams)
    {
        return _core_knnavgrelerror( model,  xy,  npoints, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_knnallerrors(knnmodel model, double[,] xy, int npoints, out knnreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_model = model.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        x_knnreport _d_rep = new x_knnreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                x_knnreport_init(ref _d_rep);
                _error_code = _i_xv2_knnallerrors(&_s_errormsg, &_d_model, &_d_xy, &_d_npoints, &_d_rep, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "knnallerrors");
            ap.assert(model.ptr==_d_model, "ALGLIB: internal error (reference changed for non-out X-object)");
            rep = null;
            x_knnreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
            x_knnreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void knnallerrors(knnmodel model, double[,] xy, int npoints, out knnreport rep)
    {
        _core_knnallerrors( model,  xy,  npoints, out  rep, 0x0);
    }
    
    public static void knnallerrors(knnmodel model, double[,] xy, int npoints, out knnreport rep, alglib.xparams _xparams)
    {
        _core_knnallerrors( model,  xy,  npoints, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage mlptrain
    //
    

    [StructLayout(LayoutKind.Sequential, Pack=8)]
    private struct x_mlpreport
    {
        public double relclserror;
        public double avgce;
        public double rmserror;
        public double avgerror;
        public double avgrelerror;
        public x_int ngrad;
        public x_int nhess;
        public x_int ncholesky;
    }

    public class mlpreport : alglibobject
    {
        public double relclserror;
        public double avgce;
        public double rmserror;
        public double avgerror;
        public double avgrelerror;
        public int ngrad;
        public int nhess;
        public int ncholesky;
        public override alglib.alglibobject make_copy()
        {
            mlpreport dst = new mlpreport();
            dst.relclserror = relclserror;
            dst.avgce = avgce;
            dst.rmserror = rmserror;
            dst.avgerror = avgerror;
            dst.avgrelerror = avgrelerror;
            dst.ngrad = ngrad;
            dst.nhess = nhess;
            dst.ncholesky = ncholesky;
            return dst;
        }
    }

    // This function initializes X-structure (its previous content is ignored)
    private static void x_mlpreport_init(ref x_mlpreport x)
    {
        x.relclserror = 0;
        x.avgce = 0;
        x.rmserror = 0;
        x.avgerror = 0;
        x.avgrelerror = 0;
        x.ngrad.longval = 0;
        x.nhess.longval = 0;
        x.ncholesky.longval = 0;
    }

    // This function finalizes fields of X-structure (however, memory occupied by structure itself is not freed)
    // After destruction structure becomes unusable and should be re-initialized if you want to use it
    private static void x_mlpreport_clear(ref x_mlpreport x)
    {
    }

    // This function initializes X-structure by appropriate C# instance
    // (previous content of X structure is ignored)
    private static void x_mlpreport_init_from(ref x_mlpreport x, mlpreport v)
    {
        x.relclserror = v.relclserror;
        x.avgce = v.avgce;
        x.rmserror = v.rmserror;
        x.avgerror = v.avgerror;
        x.avgrelerror = v.avgrelerror;
        x.ngrad.longval = v.ngrad;
        x.nhess.longval = v.nhess;
        x.ncholesky.longval = v.ncholesky;
    }

    // This function initializes C# structure by appropriate X instance
    // (previous content of C# structure is ignored).
    // This function may accept null v, in this case v is automatically allocated with new().
    private static void x_mlpreport_to_record(ref x_mlpreport x, ref mlpreport v)
    {
        if( v==null )
            v = new mlpreport();
        v.relclserror = x.relclserror;
        v.avgce = x.avgce;
        v.rmserror = x.rmserror;
        v.avgerror = x.avgerror;
        v.avgrelerror = x.avgrelerror;
        v.ngrad = x.ngrad.intval; // long is silently truncated to int
        v.nhess = x.nhess.intval; // long is silently truncated to int
        v.ncholesky = x.ncholesky.intval; // long is silently truncated to int
    }

    [StructLayout(LayoutKind.Sequential, Pack=8)]
    private struct x_mlpcvreport
    {
        public double relclserror;
        public double avgce;
        public double rmserror;
        public double avgerror;
        public double avgrelerror;
    }

    public class mlpcvreport : alglibobject
    {
        public double relclserror;
        public double avgce;
        public double rmserror;
        public double avgerror;
        public double avgrelerror;
        public override alglib.alglibobject make_copy()
        {
            mlpcvreport dst = new mlpcvreport();
            dst.relclserror = relclserror;
            dst.avgce = avgce;
            dst.rmserror = rmserror;
            dst.avgerror = avgerror;
            dst.avgrelerror = avgrelerror;
            return dst;
        }
    }

    // This function initializes X-structure (its previous content is ignored)
    private static void x_mlpcvreport_init(ref x_mlpcvreport x)
    {
        x.relclserror = 0;
        x.avgce = 0;
        x.rmserror = 0;
        x.avgerror = 0;
        x.avgrelerror = 0;
    }

    // This function finalizes fields of X-structure (however, memory occupied by structure itself is not freed)
    // After destruction structure becomes unusable and should be re-initialized if you want to use it
    private static void x_mlpcvreport_clear(ref x_mlpcvreport x)
    {
    }

    // This function initializes X-structure by appropriate C# instance
    // (previous content of X structure is ignored)
    private static void x_mlpcvreport_init_from(ref x_mlpcvreport x, mlpcvreport v)
    {
        x.relclserror = v.relclserror;
        x.avgce = v.avgce;
        x.rmserror = v.rmserror;
        x.avgerror = v.avgerror;
        x.avgrelerror = v.avgrelerror;
    }

    // This function initializes C# structure by appropriate X instance
    // (previous content of C# structure is ignored).
    // This function may accept null v, in this case v is automatically allocated with new().
    private static void x_mlpcvreport_to_record(ref x_mlpcvreport x, ref mlpcvreport v)
    {
        if( v==null )
            v = new mlpcvreport();
        v.relclserror = x.relclserror;
        v.avgce = x.avgce;
        v.rmserror = x.rmserror;
        v.avgerror = x.avgerror;
        v.avgrelerror = x.avgrelerror;
    }

    public unsafe class mlptrainer : alglibobject
    {
        private void *_ptr;
        public mlptrainer(void *x)
        {
            _ptr = x;
        }
        ~mlptrainer()
        {
            _deallocate();
        }
        public void* ptr { get { return _ptr; } }
        public override alglib.alglibobject make_copy()
        {
            if( _ptr==null )
                return new mlptrainer(null);
            return new mlptrainer(_i_x_obj_copy_mlptrainer(_ptr));
        }
        public override void _deallocate()
        {
            if( _ptr!=null )
                _i_x_obj_free_mlptrainer(_ptr);
            _ptr = null;
            System.GC.SuppressFinalize(this);
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_mlptrainer(void *x);
    private static _d_x_obj_copy_mlptrainer _i_x_obj_copy_mlptrainer = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_obj_free_mlptrainer(void *x);
    private static _d_x_obj_free_mlptrainer _i_x_obj_free_mlptrainer = null;
    
    private static unsafe void _core_mlptrainlm(multilayerperceptron network, double[,] xy, int npoints, double decay, int restarts, out int info, out mlpreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_network = network.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        double _d_decay = decay;
        x_int _d_restarts = new x_int(restarts);
        x_int _d_info = new x_int();
        x_mlpreport _d_rep = new x_mlpreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                x_mlpreport_init(ref _d_rep);
                _error_code = _i_xv2_mlptrainlm(&_s_errormsg, &_d_network, &_d_xy, &_d_npoints, &_d_decay, &_d_restarts, &_d_info, &_d_rep, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlptrainlm");
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
            info = _d_info.intval;
            rep = null;
            x_mlpreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
            x_mlpreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void mlptrainlm(multilayerperceptron network, double[,] xy, int npoints, double decay, int restarts, out int info, out mlpreport rep)
    {
        _core_mlptrainlm( network,  xy,  npoints,  decay,  restarts, out  info, out  rep, 0x0);
    }
    
    public static void mlptrainlm(multilayerperceptron network, double[,] xy, int npoints, double decay, int restarts, out int info, out mlpreport rep, alglib.xparams _xparams)
    {
        _core_mlptrainlm( network,  xy,  npoints,  decay,  restarts, out  info, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mlptrainlbfgs(multilayerperceptron network, double[,] xy, int npoints, double decay, int restarts, double wstep, int maxits, out int info, out mlpreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_network = network.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        double _d_decay = decay;
        x_int _d_restarts = new x_int(restarts);
        double _d_wstep = wstep;
        x_int _d_maxits = new x_int(maxits);
        x_int _d_info = new x_int();
        x_mlpreport _d_rep = new x_mlpreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                x_mlpreport_init(ref _d_rep);
                _error_code = _i_xv2_mlptrainlbfgs(&_s_errormsg, &_d_network, &_d_xy, &_d_npoints, &_d_decay, &_d_restarts, &_d_wstep, &_d_maxits, &_d_info, &_d_rep, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlptrainlbfgs");
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
            info = _d_info.intval;
            rep = null;
            x_mlpreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
            x_mlpreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void mlptrainlbfgs(multilayerperceptron network, double[,] xy, int npoints, double decay, int restarts, double wstep, int maxits, out int info, out mlpreport rep)
    {
        _core_mlptrainlbfgs( network,  xy,  npoints,  decay,  restarts,  wstep,  maxits, out  info, out  rep, 0x0);
    }
    
    public static void mlptrainlbfgs(multilayerperceptron network, double[,] xy, int npoints, double decay, int restarts, double wstep, int maxits, out int info, out mlpreport rep, alglib.xparams _xparams)
    {
        _core_mlptrainlbfgs( network,  xy,  npoints,  decay,  restarts,  wstep,  maxits, out  info, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mlptraines(multilayerperceptron network, double[,] trnxy, int trnsize, double[,] valxy, int valsize, double decay, int restarts, out int info, out mlpreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_network = network.ptr;
        x_matrix _d_trnxy = new x_matrix();
        x_int _d_trnsize = new x_int(trnsize);
        x_matrix _d_valxy = new x_matrix();
        x_int _d_valsize = new x_int(valsize);
        double _d_decay = decay;
        x_int _d_restarts = new x_int(restarts);
        x_int _d_info = new x_int();
        x_mlpreport _d_rep = new x_mlpreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_trnxy = trnxy, _fp_valxy = valxy){
                x_matrix_attach_to_array(ref _d_trnxy, _fp_trnxy, ap.rows(trnxy), ap.cols(trnxy));
                x_matrix_attach_to_array(ref _d_valxy, _fp_valxy, ap.rows(valxy), ap.cols(valxy));
                x_mlpreport_init(ref _d_rep);
                _error_code = _i_xv2_mlptraines(&_s_errormsg, &_d_network, &_d_trnxy, &_d_trnsize, &_d_valxy, &_d_valsize, &_d_decay, &_d_restarts, &_d_info, &_d_rep, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlptraines");
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
            info = _d_info.intval;
            rep = null;
            x_mlpreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_matrix_clear(ref _d_trnxy);
            x_matrix_clear(ref _d_valxy);
            x_mlpreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void mlptraines(multilayerperceptron network, double[,] trnxy, int trnsize, double[,] valxy, int valsize, double decay, int restarts, out int info, out mlpreport rep)
    {
        _core_mlptraines( network,  trnxy,  trnsize,  valxy,  valsize,  decay,  restarts, out  info, out  rep, 0x0);
    }
    
    public static void mlptraines(multilayerperceptron network, double[,] trnxy, int trnsize, double[,] valxy, int valsize, double decay, int restarts, out int info, out mlpreport rep, alglib.xparams _xparams)
    {
        _core_mlptraines( network,  trnxy,  trnsize,  valxy,  valsize,  decay,  restarts, out  info, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mlpkfoldcvlbfgs(multilayerperceptron network, double[,] xy, int npoints, double decay, int restarts, double wstep, int maxits, int foldscount, out int info, out mlpreport rep, out mlpcvreport cvrep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_network = network.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        double _d_decay = decay;
        x_int _d_restarts = new x_int(restarts);
        double _d_wstep = wstep;
        x_int _d_maxits = new x_int(maxits);
        x_int _d_foldscount = new x_int(foldscount);
        x_int _d_info = new x_int();
        x_mlpreport _d_rep = new x_mlpreport();
        x_mlpcvreport _d_cvrep = new x_mlpcvreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                x_mlpreport_init(ref _d_rep);
                x_mlpcvreport_init(ref _d_cvrep);
                _error_code = _i_xv2_mlpkfoldcvlbfgs(&_s_errormsg, &_d_network, &_d_xy, &_d_npoints, &_d_decay, &_d_restarts, &_d_wstep, &_d_maxits, &_d_foldscount, &_d_info, &_d_rep, &_d_cvrep, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpkfoldcvlbfgs");
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
            info = _d_info.intval;
            rep = null;
            x_mlpreport_to_record(ref _d_rep, ref rep);
            cvrep = null;
            x_mlpcvreport_to_record(ref _d_cvrep, ref cvrep);
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
            x_mlpreport_clear(ref _d_rep);
            x_mlpcvreport_clear(ref _d_cvrep);
        }
        // This function returns no value.
    }
    
    public static void mlpkfoldcvlbfgs(multilayerperceptron network, double[,] xy, int npoints, double decay, int restarts, double wstep, int maxits, int foldscount, out int info, out mlpreport rep, out mlpcvreport cvrep)
    {
        _core_mlpkfoldcvlbfgs( network,  xy,  npoints,  decay,  restarts,  wstep,  maxits,  foldscount, out  info, out  rep, out  cvrep, 0x0);
    }
    
    public static void mlpkfoldcvlbfgs(multilayerperceptron network, double[,] xy, int npoints, double decay, int restarts, double wstep, int maxits, int foldscount, out int info, out mlpreport rep, out mlpcvreport cvrep, alglib.xparams _xparams)
    {
        _core_mlpkfoldcvlbfgs( network,  xy,  npoints,  decay,  restarts,  wstep,  maxits,  foldscount, out  info, out  rep, out  cvrep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mlpkfoldcvlm(multilayerperceptron network, double[,] xy, int npoints, double decay, int restarts, int foldscount, out int info, out mlpreport rep, out mlpcvreport cvrep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_network = network.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        double _d_decay = decay;
        x_int _d_restarts = new x_int(restarts);
        x_int _d_foldscount = new x_int(foldscount);
        x_int _d_info = new x_int();
        x_mlpreport _d_rep = new x_mlpreport();
        x_mlpcvreport _d_cvrep = new x_mlpcvreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                x_mlpreport_init(ref _d_rep);
                x_mlpcvreport_init(ref _d_cvrep);
                _error_code = _i_xv2_mlpkfoldcvlm(&_s_errormsg, &_d_network, &_d_xy, &_d_npoints, &_d_decay, &_d_restarts, &_d_foldscount, &_d_info, &_d_rep, &_d_cvrep, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpkfoldcvlm");
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
            info = _d_info.intval;
            rep = null;
            x_mlpreport_to_record(ref _d_rep, ref rep);
            cvrep = null;
            x_mlpcvreport_to_record(ref _d_cvrep, ref cvrep);
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
            x_mlpreport_clear(ref _d_rep);
            x_mlpcvreport_clear(ref _d_cvrep);
        }
        // This function returns no value.
    }
    
    public static void mlpkfoldcvlm(multilayerperceptron network, double[,] xy, int npoints, double decay, int restarts, int foldscount, out int info, out mlpreport rep, out mlpcvreport cvrep)
    {
        _core_mlpkfoldcvlm( network,  xy,  npoints,  decay,  restarts,  foldscount, out  info, out  rep, out  cvrep, 0x0);
    }
    
    public static void mlpkfoldcvlm(multilayerperceptron network, double[,] xy, int npoints, double decay, int restarts, int foldscount, out int info, out mlpreport rep, out mlpcvreport cvrep, alglib.xparams _xparams)
    {
        _core_mlpkfoldcvlm( network,  xy,  npoints,  decay,  restarts,  foldscount, out  info, out  rep, out  cvrep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mlpkfoldcv(mlptrainer s, multilayerperceptron network, int nrestarts, int foldscount, out mlpreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        void *_d_network = network.ptr;
        x_int _d_nrestarts = new x_int(nrestarts);
        x_int _d_foldscount = new x_int(foldscount);
        x_mlpreport _d_rep = new x_mlpreport();
        
        // Pack, call, unpack
        try
        {
            x_mlpreport_init(ref _d_rep);
            _error_code = _i_xv2_mlpkfoldcv(&_s_errormsg, &_d_s, &_d_network, &_d_nrestarts, &_d_foldscount, &_d_rep, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpkfoldcv");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
            rep = null;
            x_mlpreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_mlpreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void mlpkfoldcv(mlptrainer s, multilayerperceptron network, int nrestarts, int foldscount, out mlpreport rep)
    {
        _core_mlpkfoldcv( s,  network,  nrestarts,  foldscount, out  rep, 0x0);
    }
    
    public static void mlpkfoldcv(mlptrainer s, multilayerperceptron network, int nrestarts, int foldscount, out mlpreport rep, alglib.xparams _xparams)
    {
        _core_mlpkfoldcv( s,  network,  nrestarts,  foldscount, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mlpcreatetrainer(int nin, int nout, out mlptrainer s, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_nin = new x_int(nin);
        x_int _d_nout = new x_int(nout);
        void *_d_s = null;
        s = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_mlpcreatetrainer(&_s_errormsg, &_d_nin, &_d_nout, &_d_s, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpcreatetrainer");
            s = new mlptrainer(_d_s);
        }
        finally
        {
            if( _d_s!=null && s==null)
                _i_x_obj_free_mlptrainer(_d_s); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void mlpcreatetrainer(int nin, int nout, out mlptrainer s)
    {
        _core_mlpcreatetrainer( nin,  nout, out  s, 0x0);
    }
    
    public static void mlpcreatetrainer(int nin, int nout, out mlptrainer s, alglib.xparams _xparams)
    {
        _core_mlpcreatetrainer( nin,  nout, out  s, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mlpcreatetrainercls(int nin, int nclasses, out mlptrainer s, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_nin = new x_int(nin);
        x_int _d_nclasses = new x_int(nclasses);
        void *_d_s = null;
        s = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_mlpcreatetrainercls(&_s_errormsg, &_d_nin, &_d_nclasses, &_d_s, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpcreatetrainercls");
            s = new mlptrainer(_d_s);
        }
        finally
        {
            if( _d_s!=null && s==null)
                _i_x_obj_free_mlptrainer(_d_s); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    
    public static void mlpcreatetrainercls(int nin, int nclasses, out mlptrainer s)
    {
        _core_mlpcreatetrainercls( nin,  nclasses, out  s, 0x0);
    }
    
    public static void mlpcreatetrainercls(int nin, int nclasses, out mlptrainer s, alglib.xparams _xparams)
    {
        _core_mlpcreatetrainercls( nin,  nclasses, out  s, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mlpsetdataset(mlptrainer s, double[,] xy, int npoints, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_xv2_mlpsetdataset(&_s_errormsg, &_d_s, &_d_xy, &_d_npoints, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpsetdataset");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
        }
        // This function returns no value.
    }
    
    public static void mlpsetdataset(mlptrainer s, double[,] xy, int npoints)
    {
        _core_mlpsetdataset( s,  xy,  npoints, 0x0);
    }
    
    public static void mlpsetdataset(mlptrainer s, double[,] xy, int npoints, alglib.xparams _xparams)
    {
        _core_mlpsetdataset( s,  xy,  npoints, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mlpsetsparsedataset(mlptrainer s, sparsematrix xy, int npoints, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        void *_d_xy = xy.ptr;
        x_int _d_npoints = new x_int(npoints);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_mlpsetsparsedataset(&_s_errormsg, &_d_s, &_d_xy, &_d_npoints, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpsetsparsedataset");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            ap.assert(xy.ptr==_d_xy, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void mlpsetsparsedataset(mlptrainer s, sparsematrix xy, int npoints)
    {
        _core_mlpsetsparsedataset( s,  xy,  npoints, 0x0);
    }
    
    public static void mlpsetsparsedataset(mlptrainer s, sparsematrix xy, int npoints, alglib.xparams _xparams)
    {
        _core_mlpsetsparsedataset( s,  xy,  npoints, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mlpsetdecay(mlptrainer s, double decay, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        double _d_decay = decay;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_mlpsetdecay(&_s_errormsg, &_d_s, &_d_decay, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpsetdecay");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void mlpsetdecay(mlptrainer s, double decay)
    {
        _core_mlpsetdecay( s,  decay, 0x0);
    }
    
    public static void mlpsetdecay(mlptrainer s, double decay, alglib.xparams _xparams)
    {
        _core_mlpsetdecay( s,  decay, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mlpsetcond(mlptrainer s, double wstep, int maxits, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        double _d_wstep = wstep;
        x_int _d_maxits = new x_int(maxits);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_mlpsetcond(&_s_errormsg, &_d_s, &_d_wstep, &_d_maxits, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpsetcond");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void mlpsetcond(mlptrainer s, double wstep, int maxits)
    {
        _core_mlpsetcond( s,  wstep,  maxits, 0x0);
    }
    
    public static void mlpsetcond(mlptrainer s, double wstep, int maxits, alglib.xparams _xparams)
    {
        _core_mlpsetcond( s,  wstep,  maxits, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mlpsetalgobatch(mlptrainer s, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_mlpsetalgobatch(&_s_errormsg, &_d_s, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpsetalgobatch");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void mlpsetalgobatch(mlptrainer s)
    {
        _core_mlpsetalgobatch( s, 0x0);
    }
    
    public static void mlpsetalgobatch(mlptrainer s, alglib.xparams _xparams)
    {
        _core_mlpsetalgobatch( s, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mlptrainnetwork(mlptrainer s, multilayerperceptron network, int nrestarts, out mlpreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        void *_d_network = network.ptr;
        x_int _d_nrestarts = new x_int(nrestarts);
        x_mlpreport _d_rep = new x_mlpreport();
        
        // Pack, call, unpack
        try
        {
            x_mlpreport_init(ref _d_rep);
            _error_code = _i_xv2_mlptrainnetwork(&_s_errormsg, &_d_s, &_d_network, &_d_nrestarts, &_d_rep, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlptrainnetwork");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
            rep = null;
            x_mlpreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_mlpreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void mlptrainnetwork(mlptrainer s, multilayerperceptron network, int nrestarts, out mlpreport rep)
    {
        _core_mlptrainnetwork( s,  network,  nrestarts, out  rep, 0x0);
    }
    
    public static void mlptrainnetwork(mlptrainer s, multilayerperceptron network, int nrestarts, out mlpreport rep, alglib.xparams _xparams)
    {
        _core_mlptrainnetwork( s,  network,  nrestarts, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mlpstarttraining(mlptrainer s, multilayerperceptron network, bool randomstart, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        void *_d_network = network.ptr;
        byte _d_randomstart = (byte)(randomstart ? 1 : 0);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_mlpstarttraining(&_s_errormsg, &_d_s, &_d_network, &_d_randomstart, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpstarttraining");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    
    public static void mlpstarttraining(mlptrainer s, multilayerperceptron network, bool randomstart)
    {
        _core_mlpstarttraining( s,  network,  randomstart, 0x0);
    }
    
    public static void mlpstarttraining(mlptrainer s, multilayerperceptron network, bool randomstart, alglib.xparams _xparams)
    {
        _core_mlpstarttraining( s,  network,  randomstart, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe bool _core_mlpcontinuetraining(mlptrainer s, multilayerperceptron network, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        bool result;
        byte _d_result = (byte)0;
        void *_d_s = s.ptr;
        void *_d_network = network.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_xv2_mlpcontinuetraining(&_s_errormsg, &_d_result, &_d_s, &_d_network, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpcontinuetraining");
            result = _d_result!=0;
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    
    public static bool mlpcontinuetraining(mlptrainer s, multilayerperceptron network)
    {
        return _core_mlpcontinuetraining( s,  network, 0x0);
    }
    
    public static bool mlpcontinuetraining(mlptrainer s, multilayerperceptron network, alglib.xparams _xparams)
    {
        return _core_mlpcontinuetraining( s,  network, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mlpebagginglm(mlpensemble ensemble, double[,] xy, int npoints, double decay, int restarts, out int info, out mlpreport rep, out mlpcvreport ooberrors, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_ensemble = ensemble.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        double _d_decay = decay;
        x_int _d_restarts = new x_int(restarts);
        x_int _d_info = new x_int();
        x_mlpreport _d_rep = new x_mlpreport();
        x_mlpcvreport _d_ooberrors = new x_mlpcvreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                x_mlpreport_init(ref _d_rep);
                x_mlpcvreport_init(ref _d_ooberrors);
                _error_code = _i_xv2_mlpebagginglm(&_s_errormsg, &_d_ensemble, &_d_xy, &_d_npoints, &_d_decay, &_d_restarts, &_d_info, &_d_rep, &_d_ooberrors, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpebagginglm");
            ap.assert(ensemble.ptr==_d_ensemble, "ALGLIB: internal error (reference changed for non-out X-object)");
            info = _d_info.intval;
            rep = null;
            x_mlpreport_to_record(ref _d_rep, ref rep);
            ooberrors = null;
            x_mlpcvreport_to_record(ref _d_ooberrors, ref ooberrors);
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
            x_mlpreport_clear(ref _d_rep);
            x_mlpcvreport_clear(ref _d_ooberrors);
        }
        // This function returns no value.
    }
    
    public static void mlpebagginglm(mlpensemble ensemble, double[,] xy, int npoints, double decay, int restarts, out int info, out mlpreport rep, out mlpcvreport ooberrors)
    {
        _core_mlpebagginglm( ensemble,  xy,  npoints,  decay,  restarts, out  info, out  rep, out  ooberrors, 0x0);
    }
    
    public static void mlpebagginglm(mlpensemble ensemble, double[,] xy, int npoints, double decay, int restarts, out int info, out mlpreport rep, out mlpcvreport ooberrors, alglib.xparams _xparams)
    {
        _core_mlpebagginglm( ensemble,  xy,  npoints,  decay,  restarts, out  info, out  rep, out  ooberrors, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mlpebagginglbfgs(mlpensemble ensemble, double[,] xy, int npoints, double decay, int restarts, double wstep, int maxits, out int info, out mlpreport rep, out mlpcvreport ooberrors, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_ensemble = ensemble.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        double _d_decay = decay;
        x_int _d_restarts = new x_int(restarts);
        double _d_wstep = wstep;
        x_int _d_maxits = new x_int(maxits);
        x_int _d_info = new x_int();
        x_mlpreport _d_rep = new x_mlpreport();
        x_mlpcvreport _d_ooberrors = new x_mlpcvreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                x_mlpreport_init(ref _d_rep);
                x_mlpcvreport_init(ref _d_ooberrors);
                _error_code = _i_xv2_mlpebagginglbfgs(&_s_errormsg, &_d_ensemble, &_d_xy, &_d_npoints, &_d_decay, &_d_restarts, &_d_wstep, &_d_maxits, &_d_info, &_d_rep, &_d_ooberrors, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpebagginglbfgs");
            ap.assert(ensemble.ptr==_d_ensemble, "ALGLIB: internal error (reference changed for non-out X-object)");
            info = _d_info.intval;
            rep = null;
            x_mlpreport_to_record(ref _d_rep, ref rep);
            ooberrors = null;
            x_mlpcvreport_to_record(ref _d_ooberrors, ref ooberrors);
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
            x_mlpreport_clear(ref _d_rep);
            x_mlpcvreport_clear(ref _d_ooberrors);
        }
        // This function returns no value.
    }
    
    public static void mlpebagginglbfgs(mlpensemble ensemble, double[,] xy, int npoints, double decay, int restarts, double wstep, int maxits, out int info, out mlpreport rep, out mlpcvreport ooberrors)
    {
        _core_mlpebagginglbfgs( ensemble,  xy,  npoints,  decay,  restarts,  wstep,  maxits, out  info, out  rep, out  ooberrors, 0x0);
    }
    
    public static void mlpebagginglbfgs(mlpensemble ensemble, double[,] xy, int npoints, double decay, int restarts, double wstep, int maxits, out int info, out mlpreport rep, out mlpcvreport ooberrors, alglib.xparams _xparams)
    {
        _core_mlpebagginglbfgs( ensemble,  xy,  npoints,  decay,  restarts,  wstep,  maxits, out  info, out  rep, out  ooberrors, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mlpetraines(mlpensemble ensemble, double[,] xy, int npoints, double decay, int restarts, out int info, out mlpreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_ensemble = ensemble.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        double _d_decay = decay;
        x_int _d_restarts = new x_int(restarts);
        x_int _d_info = new x_int();
        x_mlpreport _d_rep = new x_mlpreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                x_mlpreport_init(ref _d_rep);
                _error_code = _i_xv2_mlpetraines(&_s_errormsg, &_d_ensemble, &_d_xy, &_d_npoints, &_d_decay, &_d_restarts, &_d_info, &_d_rep, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlpetraines");
            ap.assert(ensemble.ptr==_d_ensemble, "ALGLIB: internal error (reference changed for non-out X-object)");
            info = _d_info.intval;
            rep = null;
            x_mlpreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
            x_mlpreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void mlpetraines(mlpensemble ensemble, double[,] xy, int npoints, double decay, int restarts, out int info, out mlpreport rep)
    {
        _core_mlpetraines( ensemble,  xy,  npoints,  decay,  restarts, out  info, out  rep, 0x0);
    }
    
    public static void mlpetraines(mlpensemble ensemble, double[,] xy, int npoints, double decay, int restarts, out int info, out mlpreport rep, alglib.xparams _xparams)
    {
        _core_mlpetraines( ensemble,  xy,  npoints,  decay,  restarts, out  info, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    private static unsafe void _core_mlptrainensemblees(mlptrainer s, mlpensemble ensemble, int nrestarts, out mlpreport rep, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        void *_d_ensemble = ensemble.ptr;
        x_int _d_nrestarts = new x_int(nrestarts);
        x_mlpreport _d_rep = new x_mlpreport();
        
        // Pack, call, unpack
        try
        {
            x_mlpreport_init(ref _d_rep);
            _error_code = _i_xv2_mlptrainensemblees(&_s_errormsg, &_d_s, &_d_ensemble, &_d_nrestarts, &_d_rep, _xparams);
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "mlptrainensemblees");
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            ap.assert(ensemble.ptr==_d_ensemble, "ALGLIB: internal error (reference changed for non-out X-object)");
            rep = null;
            x_mlpreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_mlpreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    
    public static void mlptrainensemblees(mlptrainer s, mlpensemble ensemble, int nrestarts, out mlpreport rep)
    {
        _core_mlptrainensemblees( s,  ensemble,  nrestarts, out  rep, 0x0);
    }
    
    public static void mlptrainensemblees(mlptrainer s, mlpensemble ensemble, int nrestarts, out mlpreport rep, alglib.xparams _xparams)
    {
        _core_mlptrainensemblees( s,  ensemble,  nrestarts, out  rep, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage datacomp
    //
    
    
    private static unsafe void _core_kmeansgenerate(double[,] xy, int npoints, int nvars, int k, int restarts, out int info, out double[,] c, out int[] xyc, ulong _xparams)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        x_int _d_nvars = new x_int(nvars);
        x_int _d_k = new x_int(k);
        x_int _d_restarts = new x_int(restarts);
        x_int _d_info = new x_int();
        x_matrix _d_c = new x_matrix();
        x_vector _d_xyc = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                x_matrix_create_empty(ref _d_c, DT_REAL);
                c = null;
                x_vector_create_empty(ref _d_xyc, DT_INT);
                xyc = null;
                _error_code = _i_xv2_kmeansgenerate(&_s_errormsg, &_d_xy, &_d_npoints, &_d_nvars, &_d_k, &_d_restarts, &_d_info, &_d_c, &_d_xyc, _xparams);
            }
            if( _error_code!=X_OK )
                handle_exception(_error_code, _s_errormsg, "kmeansgenerate");
            info = _d_info.intval;
            if( _d_c.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_c, ref c);
            if( c == null )
                c = new double[0,0];
            x_vector_to_array(ref _d_xyc, ref xyc);
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
            x_matrix_clear(ref _d_c);
            x_vector_clear(ref _d_xyc);
        }
        // This function returns no value.
    }
    
    public static void kmeansgenerate(double[,] xy, int npoints, int nvars, int k, int restarts, out int info, out double[,] c, out int[] xyc)
    {
        _core_kmeansgenerate( xy,  npoints,  nvars,  k,  restarts, out  info, out  c, out  xyc, 0x0);
    }
    
    public static void kmeansgenerate(double[,] xy, int npoints, int nvars, int k, int restarts, out int info, out double[,] c, out int[] xyc, alglib.xparams _xparams)
    {
        _core_kmeansgenerate( xy,  npoints,  nvars,  k,  restarts, out  info, out  c, out  xyc, _xparams==null ? 0x0 : _xparams.flags);
    }
    
    
    //
    // Subpackage alglibbasics
    //
    
    
    //
    // This section holds pointers to ALGLIB functions and declarations
    // of appropriate types.
    //
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void _d_x_activate_core();
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_malloc(out IntPtr p, long size);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_free(IntPtr p);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate byte _d_x_setnworkers(long nworkers);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public  unsafe delegate long _d_x_alloc_counter();
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public  unsafe delegate void _d_x_alloc_counter_activate();
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public  unsafe delegate void _d_x_free_disposed_items();
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public  unsafe delegate void _d_x_trace_file(string tags, string filename);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public  unsafe delegate void _d_x_trace_disable();
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public  unsafe delegate void _d_x_set_dbg_flag(long flag_id, long flag_val);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public  unsafe delegate long _d_x_get_dbg_value(long id);
    private static _d_x_activate_core           x_activate_core = null;
    private static _d_x_malloc                  x_malloc        = null;
    private static _d_x_free                    x_free          = null;
    private static _d_x_setnworkers             x_setnworkers   = null;
    public  static _d_x_alloc_counter           x_alloc_counter = null;
    public  static _d_x_alloc_counter_activate  x_alloc_counter_activate = null;
    public  static _d_x_set_dbg_flag            x_set_dbg_flag  = null;
    public  static _d_x_get_dbg_value           x_get_dbg_value = null;
    public  static _d_x_free_disposed_items     x_free_disposed_items    = null;
    public  static _d_x_trace_file              x_trace_file             = null;
    public  static _d_x_trace_disable           x_trace_disable          = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_hqrndrandomize(byte **error_msg, void **state, ulong _xparams);
        private static _dxv2_hqrndrandomize _i_xv2_hqrndrandomize = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_hqrndseed(byte **error_msg, x_int *s1, x_int *s2, void **state, ulong _xparams);
        private static _dxv2_hqrndseed _i_xv2_hqrndseed = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_hqrnduniformr(byte **error_msg, double *result, void **state, ulong _xparams);
        private static _dxv2_hqrnduniformr _i_xv2_hqrnduniformr = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_hqrnduniformi(byte **error_msg, x_int *result, void **state, x_int *n, ulong _xparams);
        private static _dxv2_hqrnduniformi _i_xv2_hqrnduniformi = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_hqrndnormal(byte **error_msg, double *result, void **state, ulong _xparams);
        private static _dxv2_hqrndnormal _i_xv2_hqrndnormal = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_hqrndnormalv(byte **error_msg, void **state, x_int *n, x_vector *x, ulong _xparams);
        private static _dxv2_hqrndnormalv _i_xv2_hqrndnormalv = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_hqrndnormalm(byte **error_msg, void **state, x_int *m, x_int *n, x_matrix *x, ulong _xparams);
        private static _dxv2_hqrndnormalm _i_xv2_hqrndnormalm = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_hqrndunit2(byte **error_msg, void **state, double *x, double *y, ulong _xparams);
        private static _dxv2_hqrndunit2 _i_xv2_hqrndunit2 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_hqrndnormal2(byte **error_msg, void **state, double *x1, double *x2, ulong _xparams);
        private static _dxv2_hqrndnormal2 _i_xv2_hqrndnormal2 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_hqrndexponential(byte **error_msg, double *result, void **state, double *lambdav, ulong _xparams);
        private static _dxv2_hqrndexponential _i_xv2_hqrndexponential = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_hqrnddiscrete(byte **error_msg, double *result, void **state, x_vector *x, x_int *n, ulong _xparams);
        private static _dxv2_hqrnddiscrete _i_xv2_hqrnddiscrete = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_hqrndcontinuous(byte **error_msg, double *result, void **state, x_vector *x, x_int *n, ulong _xparams);
        private static _dxv2_hqrndcontinuous _i_xv2_hqrndcontinuous = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_cmatrixtranspose(byte **error_msg, x_int *m, x_int *n, x_matrix *a, x_int *ia, x_int *ja, x_matrix *b, x_int *ib, x_int *jb, ulong _xparams);
        private static _dxv2_cmatrixtranspose _i_xv2_cmatrixtranspose = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rmatrixtranspose(byte **error_msg, x_int *m, x_int *n, x_matrix *a, x_int *ia, x_int *ja, x_matrix *b, x_int *ib, x_int *jb, ulong _xparams);
        private static _dxv2_rmatrixtranspose _i_xv2_rmatrixtranspose = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rmatrixenforcesymmetricity(byte **error_msg, x_matrix *a, x_int *n, byte *isupper, ulong _xparams);
        private static _dxv2_rmatrixenforcesymmetricity _i_xv2_rmatrixenforcesymmetricity = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_cmatrixcopy(byte **error_msg, x_int *m, x_int *n, x_matrix *a, x_int *ia, x_int *ja, x_matrix *b, x_int *ib, x_int *jb, ulong _xparams);
        private static _dxv2_cmatrixcopy _i_xv2_cmatrixcopy = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rvectorcopy(byte **error_msg, x_int *n, x_vector *a, x_int *ia, x_vector *b, x_int *ib, ulong _xparams);
        private static _dxv2_rvectorcopy _i_xv2_rvectorcopy = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rmatrixcopy(byte **error_msg, x_int *m, x_int *n, x_matrix *a, x_int *ia, x_int *ja, x_matrix *b, x_int *ib, x_int *jb, ulong _xparams);
        private static _dxv2_rmatrixcopy _i_xv2_rmatrixcopy = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rmatrixgencopy(byte **error_msg, x_int *m, x_int *n, double *alpha, x_matrix *a, x_int *ia, x_int *ja, double *beta, x_matrix *b, x_int *ib, x_int *jb, ulong _xparams);
        private static _dxv2_rmatrixgencopy _i_xv2_rmatrixgencopy = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rmatrixger(byte **error_msg, x_int *m, x_int *n, x_matrix *a, x_int *ia, x_int *ja, double *alpha, x_vector *u, x_int *iu, x_vector *v, x_int *iv, ulong _xparams);
        private static _dxv2_rmatrixger _i_xv2_rmatrixger = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_cmatrixrank1(byte **error_msg, x_int *m, x_int *n, x_matrix *a, x_int *ia, x_int *ja, x_vector *u, x_int *iu, x_vector *v, x_int *iv, ulong _xparams);
        private static _dxv2_cmatrixrank1 _i_xv2_cmatrixrank1 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rmatrixrank1(byte **error_msg, x_int *m, x_int *n, x_matrix *a, x_int *ia, x_int *ja, x_vector *u, x_int *iu, x_vector *v, x_int *iv, ulong _xparams);
        private static _dxv2_rmatrixrank1 _i_xv2_rmatrixrank1 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rmatrixgemv(byte **error_msg, x_int *m, x_int *n, double *alpha, x_matrix *a, x_int *ia, x_int *ja, x_int *opa, x_vector *x, x_int *ix, double *beta, x_vector *y, x_int *iy, ulong _xparams);
        private static _dxv2_rmatrixgemv _i_xv2_rmatrixgemv = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_cmatrixmv(byte **error_msg, x_int *m, x_int *n, x_matrix *a, x_int *ia, x_int *ja, x_int *opa, x_vector *x, x_int *ix, x_vector *y, x_int *iy, ulong _xparams);
        private static _dxv2_cmatrixmv _i_xv2_cmatrixmv = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rmatrixmv(byte **error_msg, x_int *m, x_int *n, x_matrix *a, x_int *ia, x_int *ja, x_int *opa, x_vector *x, x_int *ix, x_vector *y, x_int *iy, ulong _xparams);
        private static _dxv2_rmatrixmv _i_xv2_rmatrixmv = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rmatrixsymv(byte **error_msg, x_int *n, double *alpha, x_matrix *a, x_int *ia, x_int *ja, byte *isupper, x_vector *x, x_int *ix, double *beta, x_vector *y, x_int *iy, ulong _xparams);
        private static _dxv2_rmatrixsymv _i_xv2_rmatrixsymv = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rmatrixsyvmv(byte **error_msg, double *result, x_int *n, x_matrix *a, x_int *ia, x_int *ja, byte *isupper, x_vector *x, x_int *ix, x_vector *tmp, ulong _xparams);
        private static _dxv2_rmatrixsyvmv _i_xv2_rmatrixsyvmv = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rmatrixtrsv(byte **error_msg, x_int *n, x_matrix *a, x_int *ia, x_int *ja, byte *isupper, byte *isunit, x_int *optype, x_vector *x, x_int *ix, ulong _xparams);
        private static _dxv2_rmatrixtrsv _i_xv2_rmatrixtrsv = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_cmatrixrighttrsm(byte **error_msg, x_int *m, x_int *n, x_matrix *a, x_int *i1, x_int *j1, byte *isupper, byte *isunit, x_int *optype, x_matrix *x, x_int *i2, x_int *j2, ulong _xparams);
        private static _dxv2_cmatrixrighttrsm _i_xv2_cmatrixrighttrsm = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_cmatrixlefttrsm(byte **error_msg, x_int *m, x_int *n, x_matrix *a, x_int *i1, x_int *j1, byte *isupper, byte *isunit, x_int *optype, x_matrix *x, x_int *i2, x_int *j2, ulong _xparams);
        private static _dxv2_cmatrixlefttrsm _i_xv2_cmatrixlefttrsm = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rmatrixrighttrsm(byte **error_msg, x_int *m, x_int *n, x_matrix *a, x_int *i1, x_int *j1, byte *isupper, byte *isunit, x_int *optype, x_matrix *x, x_int *i2, x_int *j2, ulong _xparams);
        private static _dxv2_rmatrixrighttrsm _i_xv2_rmatrixrighttrsm = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rmatrixlefttrsm(byte **error_msg, x_int *m, x_int *n, x_matrix *a, x_int *i1, x_int *j1, byte *isupper, byte *isunit, x_int *optype, x_matrix *x, x_int *i2, x_int *j2, ulong _xparams);
        private static _dxv2_rmatrixlefttrsm _i_xv2_rmatrixlefttrsm = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_cmatrixherk(byte **error_msg, x_int *n, x_int *k, double *alpha, x_matrix *a, x_int *ia, x_int *ja, x_int *optypea, double *beta, x_matrix *c, x_int *ic, x_int *jc, byte *isupper, ulong _xparams);
        private static _dxv2_cmatrixherk _i_xv2_cmatrixherk = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rmatrixsyrk(byte **error_msg, x_int *n, x_int *k, double *alpha, x_matrix *a, x_int *ia, x_int *ja, x_int *optypea, double *beta, x_matrix *c, x_int *ic, x_int *jc, byte *isupper, ulong _xparams);
        private static _dxv2_rmatrixsyrk _i_xv2_rmatrixsyrk = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_cmatrixgemm(byte **error_msg, x_int *m, x_int *n, x_int *k, alglib.complex *alpha, x_matrix *a, x_int *ia, x_int *ja, x_int *optypea, x_matrix *b, x_int *ib, x_int *jb, x_int *optypeb, alglib.complex *beta, x_matrix *c, x_int *ic, x_int *jc, ulong _xparams);
        private static _dxv2_cmatrixgemm _i_xv2_cmatrixgemm = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rmatrixgemm(byte **error_msg, x_int *m, x_int *n, x_int *k, double *alpha, x_matrix *a, x_int *ia, x_int *ja, x_int *optypea, x_matrix *b, x_int *ib, x_int *jb, x_int *optypeb, double *beta, x_matrix *c, x_int *ic, x_int *jc, ulong _xparams);
        private static _dxv2_rmatrixgemm _i_xv2_rmatrixgemm = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_cmatrixsyrk(byte **error_msg, x_int *n, x_int *k, double *alpha, x_matrix *a, x_int *ia, x_int *ja, x_int *optypea, double *beta, x_matrix *c, x_int *ic, x_int *jc, byte *isupper, ulong _xparams);
        private static _dxv2_cmatrixsyrk _i_xv2_cmatrixsyrk = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rmatrixqr(byte **error_msg, x_matrix *a, x_int *m, x_int *n, x_vector *tau, ulong _xparams);
        private static _dxv2_rmatrixqr _i_xv2_rmatrixqr = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rmatrixlq(byte **error_msg, x_matrix *a, x_int *m, x_int *n, x_vector *tau, ulong _xparams);
        private static _dxv2_rmatrixlq _i_xv2_rmatrixlq = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_cmatrixqr(byte **error_msg, x_matrix *a, x_int *m, x_int *n, x_vector *tau, ulong _xparams);
        private static _dxv2_cmatrixqr _i_xv2_cmatrixqr = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_cmatrixlq(byte **error_msg, x_matrix *a, x_int *m, x_int *n, x_vector *tau, ulong _xparams);
        private static _dxv2_cmatrixlq _i_xv2_cmatrixlq = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rmatrixqrunpackq(byte **error_msg, x_matrix *a, x_int *m, x_int *n, x_vector *tau, x_int *qcolumns, x_matrix *q, ulong _xparams);
        private static _dxv2_rmatrixqrunpackq _i_xv2_rmatrixqrunpackq = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rmatrixqrunpackr(byte **error_msg, x_matrix *a, x_int *m, x_int *n, x_matrix *r, ulong _xparams);
        private static _dxv2_rmatrixqrunpackr _i_xv2_rmatrixqrunpackr = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rmatrixlqunpackq(byte **error_msg, x_matrix *a, x_int *m, x_int *n, x_vector *tau, x_int *qrows, x_matrix *q, ulong _xparams);
        private static _dxv2_rmatrixlqunpackq _i_xv2_rmatrixlqunpackq = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rmatrixlqunpackl(byte **error_msg, x_matrix *a, x_int *m, x_int *n, x_matrix *l, ulong _xparams);
        private static _dxv2_rmatrixlqunpackl _i_xv2_rmatrixlqunpackl = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_cmatrixqrunpackq(byte **error_msg, x_matrix *a, x_int *m, x_int *n, x_vector *tau, x_int *qcolumns, x_matrix *q, ulong _xparams);
        private static _dxv2_cmatrixqrunpackq _i_xv2_cmatrixqrunpackq = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_cmatrixqrunpackr(byte **error_msg, x_matrix *a, x_int *m, x_int *n, x_matrix *r, ulong _xparams);
        private static _dxv2_cmatrixqrunpackr _i_xv2_cmatrixqrunpackr = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_cmatrixlqunpackq(byte **error_msg, x_matrix *a, x_int *m, x_int *n, x_vector *tau, x_int *qrows, x_matrix *q, ulong _xparams);
        private static _dxv2_cmatrixlqunpackq _i_xv2_cmatrixlqunpackq = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_cmatrixlqunpackl(byte **error_msg, x_matrix *a, x_int *m, x_int *n, x_matrix *l, ulong _xparams);
        private static _dxv2_cmatrixlqunpackl _i_xv2_cmatrixlqunpackl = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rmatrixbd(byte **error_msg, x_matrix *a, x_int *m, x_int *n, x_vector *tauq, x_vector *taup, ulong _xparams);
        private static _dxv2_rmatrixbd _i_xv2_rmatrixbd = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rmatrixbdunpackq(byte **error_msg, x_matrix *qp, x_int *m, x_int *n, x_vector *tauq, x_int *qcolumns, x_matrix *q, ulong _xparams);
        private static _dxv2_rmatrixbdunpackq _i_xv2_rmatrixbdunpackq = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rmatrixbdmultiplybyq(byte **error_msg, x_matrix *qp, x_int *m, x_int *n, x_vector *tauq, x_matrix *z, x_int *zrows, x_int *zcolumns, byte *fromtheright, byte *dotranspose, ulong _xparams);
        private static _dxv2_rmatrixbdmultiplybyq _i_xv2_rmatrixbdmultiplybyq = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rmatrixbdunpackpt(byte **error_msg, x_matrix *qp, x_int *m, x_int *n, x_vector *taup, x_int *ptrows, x_matrix *pt, ulong _xparams);
        private static _dxv2_rmatrixbdunpackpt _i_xv2_rmatrixbdunpackpt = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rmatrixbdmultiplybyp(byte **error_msg, x_matrix *qp, x_int *m, x_int *n, x_vector *taup, x_matrix *z, x_int *zrows, x_int *zcolumns, byte *fromtheright, byte *dotranspose, ulong _xparams);
        private static _dxv2_rmatrixbdmultiplybyp _i_xv2_rmatrixbdmultiplybyp = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rmatrixbdunpackdiagonals(byte **error_msg, x_matrix *b, x_int *m, x_int *n, byte *isupper, x_vector *d, x_vector *e, ulong _xparams);
        private static _dxv2_rmatrixbdunpackdiagonals _i_xv2_rmatrixbdunpackdiagonals = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rmatrixhessenberg(byte **error_msg, x_matrix *a, x_int *n, x_vector *tau, ulong _xparams);
        private static _dxv2_rmatrixhessenberg _i_xv2_rmatrixhessenberg = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rmatrixhessenbergunpackq(byte **error_msg, x_matrix *a, x_int *n, x_vector *tau, x_matrix *q, ulong _xparams);
        private static _dxv2_rmatrixhessenbergunpackq _i_xv2_rmatrixhessenbergunpackq = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rmatrixhessenbergunpackh(byte **error_msg, x_matrix *a, x_int *n, x_matrix *h, ulong _xparams);
        private static _dxv2_rmatrixhessenbergunpackh _i_xv2_rmatrixhessenbergunpackh = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_smatrixtd(byte **error_msg, x_matrix *a, x_int *n, byte *isupper, x_vector *tau, x_vector *d, x_vector *e, ulong _xparams);
        private static _dxv2_smatrixtd _i_xv2_smatrixtd = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_smatrixtdunpackq(byte **error_msg, x_matrix *a, x_int *n, byte *isupper, x_vector *tau, x_matrix *q, ulong _xparams);
        private static _dxv2_smatrixtdunpackq _i_xv2_smatrixtdunpackq = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_hmatrixtd(byte **error_msg, x_matrix *a, x_int *n, byte *isupper, x_vector *tau, x_vector *d, x_vector *e, ulong _xparams);
        private static _dxv2_hmatrixtd _i_xv2_hmatrixtd = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_hmatrixtdunpackq(byte **error_msg, x_matrix *a, x_int *n, byte *isupper, x_vector *tau, x_matrix *q, ulong _xparams);
        private static _dxv2_hmatrixtdunpackq _i_xv2_hmatrixtdunpackq = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rmatrixrndorthogonal(byte **error_msg, x_int *n, x_matrix *a, ulong _xparams);
        private static _dxv2_rmatrixrndorthogonal _i_xv2_rmatrixrndorthogonal = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rmatrixrndcond(byte **error_msg, x_int *n, double *c, x_matrix *a, ulong _xparams);
        private static _dxv2_rmatrixrndcond _i_xv2_rmatrixrndcond = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_cmatrixrndorthogonal(byte **error_msg, x_int *n, x_matrix *a, ulong _xparams);
        private static _dxv2_cmatrixrndorthogonal _i_xv2_cmatrixrndorthogonal = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_cmatrixrndcond(byte **error_msg, x_int *n, double *c, x_matrix *a, ulong _xparams);
        private static _dxv2_cmatrixrndcond _i_xv2_cmatrixrndcond = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_smatrixrndcond(byte **error_msg, x_int *n, double *c, x_matrix *a, ulong _xparams);
        private static _dxv2_smatrixrndcond _i_xv2_smatrixrndcond = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spdmatrixrndcond(byte **error_msg, x_int *n, double *c, x_matrix *a, ulong _xparams);
        private static _dxv2_spdmatrixrndcond _i_xv2_spdmatrixrndcond = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_hmatrixrndcond(byte **error_msg, x_int *n, double *c, x_matrix *a, ulong _xparams);
        private static _dxv2_hmatrixrndcond _i_xv2_hmatrixrndcond = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_hpdmatrixrndcond(byte **error_msg, x_int *n, double *c, x_matrix *a, ulong _xparams);
        private static _dxv2_hpdmatrixrndcond _i_xv2_hpdmatrixrndcond = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rmatrixrndorthogonalfromtheright(byte **error_msg, x_matrix *a, x_int *m, x_int *n, ulong _xparams);
        private static _dxv2_rmatrixrndorthogonalfromtheright _i_xv2_rmatrixrndorthogonalfromtheright = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rmatrixrndorthogonalfromtheleft(byte **error_msg, x_matrix *a, x_int *m, x_int *n, ulong _xparams);
        private static _dxv2_rmatrixrndorthogonalfromtheleft _i_xv2_rmatrixrndorthogonalfromtheleft = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_cmatrixrndorthogonalfromtheright(byte **error_msg, x_matrix *a, x_int *m, x_int *n, ulong _xparams);
        private static _dxv2_cmatrixrndorthogonalfromtheright _i_xv2_cmatrixrndorthogonalfromtheright = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_cmatrixrndorthogonalfromtheleft(byte **error_msg, x_matrix *a, x_int *m, x_int *n, ulong _xparams);
        private static _dxv2_cmatrixrndorthogonalfromtheleft _i_xv2_cmatrixrndorthogonalfromtheleft = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_smatrixrndmultiply(byte **error_msg, x_matrix *a, x_int *n, ulong _xparams);
        private static _dxv2_smatrixrndmultiply _i_xv2_smatrixrndmultiply = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_hmatrixrndmultiply(byte **error_msg, x_matrix *a, x_int *n, ulong _xparams);
        private static _dxv2_hmatrixrndmultiply _i_xv2_hmatrixrndmultiply = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_x_sparseserialize(byte **error_msg, void **x, byte **dst);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_x_sparseunserialize(byte **error_msg, byte **src, void **x);
        private static _d_x_sparseserialize   _i_x_sparseserialize   = null;
        private static _d_x_sparseunserialize _i_x_sparseunserialize = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_x_sparseserialize_stream(byte **error_msg, void **x, native_stream_adapter.writer_delegate writer, IntPtr aux);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_x_sparseunserialize_stream(byte **error_msg, native_stream_adapter.reader_delegate reader, IntPtr aux, void **x);
        private static _d_x_sparseserialize_stream   _i_x_sparseserialize_stream   = null;
        private static _d_x_sparseunserialize_stream _i_x_sparseunserialize_stream = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparsecreate(byte **error_msg, x_int *m, x_int *n, x_int *k, void **s, ulong _xparams);
        private static _dxv2_sparsecreate _i_xv2_sparsecreate = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparsecreatebuf(byte **error_msg, x_int *m, x_int *n, x_int *k, void **s, ulong _xparams);
        private static _dxv2_sparsecreatebuf _i_xv2_sparsecreatebuf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparsecreatecrs(byte **error_msg, x_int *m, x_int *n, x_vector *ner, void **s, ulong _xparams);
        private static _dxv2_sparsecreatecrs _i_xv2_sparsecreatecrs = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparsecreatecrsbuf(byte **error_msg, x_int *m, x_int *n, x_vector *ner, void **s, ulong _xparams);
        private static _dxv2_sparsecreatecrsbuf _i_xv2_sparsecreatecrsbuf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparsecreatesks(byte **error_msg, x_int *m, x_int *n, x_vector *d, x_vector *u, void **s, ulong _xparams);
        private static _dxv2_sparsecreatesks _i_xv2_sparsecreatesks = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparsecreatesksbuf(byte **error_msg, x_int *m, x_int *n, x_vector *d, x_vector *u, void **s, ulong _xparams);
        private static _dxv2_sparsecreatesksbuf _i_xv2_sparsecreatesksbuf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparsecreatesksband(byte **error_msg, x_int *m, x_int *n, x_int *bw, void **s, ulong _xparams);
        private static _dxv2_sparsecreatesksband _i_xv2_sparsecreatesksband = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparsecreatesksbandbuf(byte **error_msg, x_int *m, x_int *n, x_int *bw, void **s, ulong _xparams);
        private static _dxv2_sparsecreatesksbandbuf _i_xv2_sparsecreatesksbandbuf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparsecopy(byte **error_msg, void **s0, void **s1, ulong _xparams);
        private static _dxv2_sparsecopy _i_xv2_sparsecopy = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparsecopybuf(byte **error_msg, void **s0, void **s1, ulong _xparams);
        private static _dxv2_sparsecopybuf _i_xv2_sparsecopybuf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparseswap(byte **error_msg, void **s0, void **s1, ulong _xparams);
        private static _dxv2_sparseswap _i_xv2_sparseswap = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparseadd(byte **error_msg, void **s, x_int *i, x_int *j, double *v, ulong _xparams);
        private static _dxv2_sparseadd _i_xv2_sparseadd = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparseset(byte **error_msg, void **s, x_int *i, x_int *j, double *v, ulong _xparams);
        private static _dxv2_sparseset _i_xv2_sparseset = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparseget(byte **error_msg, double *result, void **s, x_int *i, x_int *j, ulong _xparams);
        private static _dxv2_sparseget _i_xv2_sparseget = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparseexists(byte **error_msg, byte *result, void **s, x_int *i, x_int *j, ulong _xparams);
        private static _dxv2_sparseexists _i_xv2_sparseexists = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparsegetdiagonal(byte **error_msg, double *result, void **s, x_int *i, ulong _xparams);
        private static _dxv2_sparsegetdiagonal _i_xv2_sparsegetdiagonal = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparsemv(byte **error_msg, void **s, x_vector *x, x_vector *y, ulong _xparams);
        private static _dxv2_sparsemv _i_xv2_sparsemv = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparsemtv(byte **error_msg, void **s, x_vector *x, x_vector *y, ulong _xparams);
        private static _dxv2_sparsemtv _i_xv2_sparsemtv = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparsegemv(byte **error_msg, void **s, double *alpha, x_int *ops, x_vector *x, x_int *ix, double *beta, x_vector *y, x_int *iy, ulong _xparams);
        private static _dxv2_sparsegemv _i_xv2_sparsegemv = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparsemv2(byte **error_msg, void **s, x_vector *x, x_vector *y0, x_vector *y1, ulong _xparams);
        private static _dxv2_sparsemv2 _i_xv2_sparsemv2 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparsesmv(byte **error_msg, void **s, byte *isupper, x_vector *x, x_vector *y, ulong _xparams);
        private static _dxv2_sparsesmv _i_xv2_sparsesmv = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparsevsmv(byte **error_msg, double *result, void **s, byte *isupper, x_vector *x, ulong _xparams);
        private static _dxv2_sparsevsmv _i_xv2_sparsevsmv = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparsemm(byte **error_msg, void **s, x_matrix *a, x_int *k, x_matrix *b, ulong _xparams);
        private static _dxv2_sparsemm _i_xv2_sparsemm = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparsemtm(byte **error_msg, void **s, x_matrix *a, x_int *k, x_matrix *b, ulong _xparams);
        private static _dxv2_sparsemtm _i_xv2_sparsemtm = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparsemm2(byte **error_msg, void **s, x_matrix *a, x_int *k, x_matrix *b0, x_matrix *b1, ulong _xparams);
        private static _dxv2_sparsemm2 _i_xv2_sparsemm2 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparsesmm(byte **error_msg, void **s, byte *isupper, x_matrix *a, x_int *k, x_matrix *b, ulong _xparams);
        private static _dxv2_sparsesmm _i_xv2_sparsesmm = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparsetrmv(byte **error_msg, void **s, byte *isupper, byte *isunit, x_int *optype, x_vector *x, x_vector *y, ulong _xparams);
        private static _dxv2_sparsetrmv _i_xv2_sparsetrmv = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparsetrsv(byte **error_msg, void **s, byte *isupper, byte *isunit, x_int *optype, x_vector *x, ulong _xparams);
        private static _dxv2_sparsetrsv _i_xv2_sparsetrsv = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparsesymmpermtbl(byte **error_msg, void **a, byte *isupper, x_vector *p, void **b, ulong _xparams);
        private static _dxv2_sparsesymmpermtbl _i_xv2_sparsesymmpermtbl = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparsesymmpermtblbuf(byte **error_msg, void **a, byte *isupper, x_vector *p, void **b, ulong _xparams);
        private static _dxv2_sparsesymmpermtblbuf _i_xv2_sparsesymmpermtblbuf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparseresizematrix(byte **error_msg, void **s, ulong _xparams);
        private static _dxv2_sparseresizematrix _i_xv2_sparseresizematrix = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparseenumerate(byte **error_msg, byte *result, void **s, x_int *t0, x_int *t1, x_int *i, x_int *j, double *v, ulong _xparams);
        private static _dxv2_sparseenumerate _i_xv2_sparseenumerate = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparserewriteexisting(byte **error_msg, byte *result, void **s, x_int *i, x_int *j, double *v, ulong _xparams);
        private static _dxv2_sparserewriteexisting _i_xv2_sparserewriteexisting = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparsegetrow(byte **error_msg, void **s, x_int *i, x_vector *irow, ulong _xparams);
        private static _dxv2_sparsegetrow _i_xv2_sparsegetrow = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparsegetcompressedrow(byte **error_msg, void **s, x_int *i, x_vector *colidx, x_vector *vals, x_int *nzcnt, ulong _xparams);
        private static _dxv2_sparsegetcompressedrow _i_xv2_sparsegetcompressedrow = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparsetransposesks(byte **error_msg, void **s, ulong _xparams);
        private static _dxv2_sparsetransposesks _i_xv2_sparsetransposesks = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparsetransposecrs(byte **error_msg, void **s, ulong _xparams);
        private static _dxv2_sparsetransposecrs _i_xv2_sparsetransposecrs = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparsecopytransposecrs(byte **error_msg, void **s0, void **s1, ulong _xparams);
        private static _dxv2_sparsecopytransposecrs _i_xv2_sparsecopytransposecrs = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparsecopytransposecrsbuf(byte **error_msg, void **s0, void **s1, ulong _xparams);
        private static _dxv2_sparsecopytransposecrsbuf _i_xv2_sparsecopytransposecrsbuf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparseconvertto(byte **error_msg, void **s0, x_int *fmt, ulong _xparams);
        private static _dxv2_sparseconvertto _i_xv2_sparseconvertto = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparsecopytobuf(byte **error_msg, void **s0, x_int *fmt, void **s1, ulong _xparams);
        private static _dxv2_sparsecopytobuf _i_xv2_sparsecopytobuf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparseconverttohash(byte **error_msg, void **s, ulong _xparams);
        private static _dxv2_sparseconverttohash _i_xv2_sparseconverttohash = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparsecopytohash(byte **error_msg, void **s0, void **s1, ulong _xparams);
        private static _dxv2_sparsecopytohash _i_xv2_sparsecopytohash = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparsecopytohashbuf(byte **error_msg, void **s0, void **s1, ulong _xparams);
        private static _dxv2_sparsecopytohashbuf _i_xv2_sparsecopytohashbuf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparseconverttocrs(byte **error_msg, void **s, ulong _xparams);
        private static _dxv2_sparseconverttocrs _i_xv2_sparseconverttocrs = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparsecopytocrs(byte **error_msg, void **s0, void **s1, ulong _xparams);
        private static _dxv2_sparsecopytocrs _i_xv2_sparsecopytocrs = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparsecopytocrsbuf(byte **error_msg, void **s0, void **s1, ulong _xparams);
        private static _dxv2_sparsecopytocrsbuf _i_xv2_sparsecopytocrsbuf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparseconverttosks(byte **error_msg, void **s, ulong _xparams);
        private static _dxv2_sparseconverttosks _i_xv2_sparseconverttosks = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparsecopytosks(byte **error_msg, void **s0, void **s1, ulong _xparams);
        private static _dxv2_sparsecopytosks _i_xv2_sparsecopytosks = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparsecopytosksbuf(byte **error_msg, void **s0, void **s1, ulong _xparams);
        private static _dxv2_sparsecopytosksbuf _i_xv2_sparsecopytosksbuf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparsegetmatrixtype(byte **error_msg, x_int *result, void **s, ulong _xparams);
        private static _dxv2_sparsegetmatrixtype _i_xv2_sparsegetmatrixtype = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparseishash(byte **error_msg, byte *result, void **s, ulong _xparams);
        private static _dxv2_sparseishash _i_xv2_sparseishash = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparseiscrs(byte **error_msg, byte *result, void **s, ulong _xparams);
        private static _dxv2_sparseiscrs _i_xv2_sparseiscrs = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparseissks(byte **error_msg, byte *result, void **s, ulong _xparams);
        private static _dxv2_sparseissks _i_xv2_sparseissks = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparsefree(byte **error_msg, void **s, ulong _xparams);
        private static _dxv2_sparsefree _i_xv2_sparsefree = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparsegetnrows(byte **error_msg, x_int *result, void **s, ulong _xparams);
        private static _dxv2_sparsegetnrows _i_xv2_sparsegetnrows = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparsegetncols(byte **error_msg, x_int *result, void **s, ulong _xparams);
        private static _dxv2_sparsegetncols _i_xv2_sparsegetncols = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparsegetuppercount(byte **error_msg, x_int *result, void **s, ulong _xparams);
        private static _dxv2_sparsegetuppercount _i_xv2_sparsegetuppercount = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparsegetlowercount(byte **error_msg, x_int *result, void **s, ulong _xparams);
        private static _dxv2_sparsegetlowercount _i_xv2_sparsegetlowercount = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_eigsubspacecreate(byte **error_msg, x_int *n, x_int *k, void **state, ulong _xparams);
        private static _dxv2_eigsubspacecreate _i_xv2_eigsubspacecreate = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_eigsubspacecreatebuf(byte **error_msg, x_int *n, x_int *k, void **state, ulong _xparams);
        private static _dxv2_eigsubspacecreatebuf _i_xv2_eigsubspacecreatebuf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_eigsubspacesetcond(byte **error_msg, void **state, double *eps, x_int *maxits, ulong _xparams);
        private static _dxv2_eigsubspacesetcond _i_xv2_eigsubspacesetcond = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_eigsubspacesetwarmstart(byte **error_msg, void **state, byte *usewarmstart, ulong _xparams);
        private static _dxv2_eigsubspacesetwarmstart _i_xv2_eigsubspacesetwarmstart = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_eigsubspaceoocstart(byte **error_msg, void **state, x_int *mtype, ulong _xparams);
        private static _dxv2_eigsubspaceoocstart _i_xv2_eigsubspaceoocstart = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_eigsubspaceooccontinue(byte **error_msg, byte *result, void **state, ulong _xparams);
        private static _dxv2_eigsubspaceooccontinue _i_xv2_eigsubspaceooccontinue = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_eigsubspaceoocgetrequestinfo(byte **error_msg, void **state, x_int *requesttype, x_int *requestsize, ulong _xparams);
        private static _dxv2_eigsubspaceoocgetrequestinfo _i_xv2_eigsubspaceoocgetrequestinfo = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_eigsubspaceoocgetrequestdata(byte **error_msg, void **state, x_matrix *x, ulong _xparams);
        private static _dxv2_eigsubspaceoocgetrequestdata _i_xv2_eigsubspaceoocgetrequestdata = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_eigsubspaceoocsendresult(byte **error_msg, void **state, x_matrix *ax, ulong _xparams);
        private static _dxv2_eigsubspaceoocsendresult _i_xv2_eigsubspaceoocsendresult = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_eigsubspaceoocstop(byte **error_msg, void **state, x_vector *w, x_matrix *z, x_eigsubspacereport *rep, ulong _xparams);
        private static _dxv2_eigsubspaceoocstop _i_xv2_eigsubspaceoocstop = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_eigsubspacesolvedenses(byte **error_msg, void **state, x_matrix *a, byte *isupper, x_vector *w, x_matrix *z, x_eigsubspacereport *rep, ulong _xparams);
        private static _dxv2_eigsubspacesolvedenses _i_xv2_eigsubspacesolvedenses = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_eigsubspacesolvesparses(byte **error_msg, void **state, void **a, byte *isupper, x_vector *w, x_matrix *z, x_eigsubspacereport *rep, ulong _xparams);
        private static _dxv2_eigsubspacesolvesparses _i_xv2_eigsubspacesolvesparses = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_smatrixevd(byte **error_msg, byte *result, x_matrix *a, x_int *n, x_int *zneeded, byte *isupper, x_vector *d, x_matrix *z, ulong _xparams);
        private static _dxv2_smatrixevd _i_xv2_smatrixevd = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_smatrixevdr(byte **error_msg, byte *result, x_matrix *a, x_int *n, x_int *zneeded, byte *isupper, double *b1, double *b2, x_int *m, x_vector *w, x_matrix *z, ulong _xparams);
        private static _dxv2_smatrixevdr _i_xv2_smatrixevdr = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_smatrixevdi(byte **error_msg, byte *result, x_matrix *a, x_int *n, x_int *zneeded, byte *isupper, x_int *i1, x_int *i2, x_vector *w, x_matrix *z, ulong _xparams);
        private static _dxv2_smatrixevdi _i_xv2_smatrixevdi = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_hmatrixevd(byte **error_msg, byte *result, x_matrix *a, x_int *n, x_int *zneeded, byte *isupper, x_vector *d, x_matrix *z, ulong _xparams);
        private static _dxv2_hmatrixevd _i_xv2_hmatrixevd = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_hmatrixevdr(byte **error_msg, byte *result, x_matrix *a, x_int *n, x_int *zneeded, byte *isupper, double *b1, double *b2, x_int *m, x_vector *w, x_matrix *z, ulong _xparams);
        private static _dxv2_hmatrixevdr _i_xv2_hmatrixevdr = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_hmatrixevdi(byte **error_msg, byte *result, x_matrix *a, x_int *n, x_int *zneeded, byte *isupper, x_int *i1, x_int *i2, x_vector *w, x_matrix *z, ulong _xparams);
        private static _dxv2_hmatrixevdi _i_xv2_hmatrixevdi = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_smatrixtdevd(byte **error_msg, byte *result, x_vector *d, x_vector *e, x_int *n, x_int *zneeded, x_matrix *z, ulong _xparams);
        private static _dxv2_smatrixtdevd _i_xv2_smatrixtdevd = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_smatrixtdevdr(byte **error_msg, byte *result, x_vector *d, x_vector *e, x_int *n, x_int *zneeded, double *a, double *b, x_int *m, x_matrix *z, ulong _xparams);
        private static _dxv2_smatrixtdevdr _i_xv2_smatrixtdevdr = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_smatrixtdevdi(byte **error_msg, byte *result, x_vector *d, x_vector *e, x_int *n, x_int *zneeded, x_int *i1, x_int *i2, x_matrix *z, ulong _xparams);
        private static _dxv2_smatrixtdevdi _i_xv2_smatrixtdevdi = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rmatrixevd(byte **error_msg, byte *result, x_matrix *a, x_int *n, x_int *vneeded, x_vector *wr, x_vector *wi, x_matrix *vl, x_matrix *vr, ulong _xparams);
        private static _dxv2_rmatrixevd _i_xv2_rmatrixevd = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rmatrixlu(byte **error_msg, x_matrix *a, x_int *m, x_int *n, x_vector *pivots, ulong _xparams);
        private static _dxv2_rmatrixlu _i_xv2_rmatrixlu = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_cmatrixlu(byte **error_msg, x_matrix *a, x_int *m, x_int *n, x_vector *pivots, ulong _xparams);
        private static _dxv2_cmatrixlu _i_xv2_cmatrixlu = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_hpdmatrixcholesky(byte **error_msg, byte *result, x_matrix *a, x_int *n, byte *isupper, ulong _xparams);
        private static _dxv2_hpdmatrixcholesky _i_xv2_hpdmatrixcholesky = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spdmatrixcholesky(byte **error_msg, byte *result, x_matrix *a, x_int *n, byte *isupper, ulong _xparams);
        private static _dxv2_spdmatrixcholesky _i_xv2_spdmatrixcholesky = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spdmatrixcholeskyupdateadd1(byte **error_msg, x_matrix *a, x_int *n, byte *isupper, x_vector *u, ulong _xparams);
        private static _dxv2_spdmatrixcholeskyupdateadd1 _i_xv2_spdmatrixcholeskyupdateadd1 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spdmatrixcholeskyupdatefix(byte **error_msg, x_matrix *a, x_int *n, byte *isupper, x_vector *fix, ulong _xparams);
        private static _dxv2_spdmatrixcholeskyupdatefix _i_xv2_spdmatrixcholeskyupdatefix = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spdmatrixcholeskyupdateadd1buf(byte **error_msg, x_matrix *a, x_int *n, byte *isupper, x_vector *u, x_vector *bufr, ulong _xparams);
        private static _dxv2_spdmatrixcholeskyupdateadd1buf _i_xv2_spdmatrixcholeskyupdateadd1buf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spdmatrixcholeskyupdatefixbuf(byte **error_msg, x_matrix *a, x_int *n, byte *isupper, x_vector *fix, x_vector *bufr, ulong _xparams);
        private static _dxv2_spdmatrixcholeskyupdatefixbuf _i_xv2_spdmatrixcholeskyupdatefixbuf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparselu(byte **error_msg, byte *result, void **a, x_int *pivottype, x_vector *p, x_vector *q, ulong _xparams);
        private static _dxv2_sparselu _i_xv2_sparselu = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparsecholeskyskyline(byte **error_msg, byte *result, void **a, x_int *n, byte *isupper, ulong _xparams);
        private static _dxv2_sparsecholeskyskyline _i_xv2_sparsecholeskyskyline = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparsecholesky(byte **error_msg, byte *result, void **a, byte *isupper, ulong _xparams);
        private static _dxv2_sparsecholesky _i_xv2_sparsecholesky = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparsecholeskyp(byte **error_msg, byte *result, void **a, byte *isupper, x_vector *p, ulong _xparams);
        private static _dxv2_sparsecholeskyp _i_xv2_sparsecholeskyp = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparsecholeskyanalyze(byte **error_msg, byte *result, void **a, byte *isupper, x_int *facttype, x_int *permtype, void **analysis, ulong _xparams);
        private static _dxv2_sparsecholeskyanalyze _i_xv2_sparsecholeskyanalyze = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparsecholeskyfactorize(byte **error_msg, byte *result, void **analysis, byte *needupper, void **a, x_vector *d, x_vector *p, ulong _xparams);
        private static _dxv2_sparsecholeskyfactorize _i_xv2_sparsecholeskyfactorize = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparsecholeskyreload(byte **error_msg, void **analysis, void **a, byte *isupper, ulong _xparams);
        private static _dxv2_sparsecholeskyreload _i_xv2_sparsecholeskyreload = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_polynomialsolve(byte **error_msg, x_vector *a, x_int *n, x_vector *x, x_polynomialsolverreport *rep, ulong _xparams);
        private static _dxv2_polynomialsolve _i_xv2_polynomialsolve = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rmatrixbdsvd(byte **error_msg, byte *result, x_vector *d, x_vector *e, x_int *n, byte *isupper, byte *isfractionalaccuracyrequired, x_matrix *u, x_int *nru, x_matrix *c, x_int *ncc, x_matrix *vt, x_int *ncvt, ulong _xparams);
        private static _dxv2_rmatrixbdsvd _i_xv2_rmatrixbdsvd = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rmatrixsvd(byte **error_msg, byte *result, x_matrix *a, x_int *m, x_int *n, x_int *uneeded, x_int *vtneeded, x_int *additionalmemory, x_vector *w, x_matrix *u, x_matrix *vt, ulong _xparams);
        private static _dxv2_rmatrixsvd _i_xv2_rmatrixsvd = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rmatrixrcond1(byte **error_msg, double *result, x_matrix *a, x_int *n, ulong _xparams);
        private static _dxv2_rmatrixrcond1 _i_xv2_rmatrixrcond1 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rmatrixrcondinf(byte **error_msg, double *result, x_matrix *a, x_int *n, ulong _xparams);
        private static _dxv2_rmatrixrcondinf _i_xv2_rmatrixrcondinf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spdmatrixrcond(byte **error_msg, double *result, x_matrix *a, x_int *n, byte *isupper, ulong _xparams);
        private static _dxv2_spdmatrixrcond _i_xv2_spdmatrixrcond = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rmatrixtrrcond1(byte **error_msg, double *result, x_matrix *a, x_int *n, byte *isupper, byte *isunit, ulong _xparams);
        private static _dxv2_rmatrixtrrcond1 _i_xv2_rmatrixtrrcond1 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rmatrixtrrcondinf(byte **error_msg, double *result, x_matrix *a, x_int *n, byte *isupper, byte *isunit, ulong _xparams);
        private static _dxv2_rmatrixtrrcondinf _i_xv2_rmatrixtrrcondinf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_hpdmatrixrcond(byte **error_msg, double *result, x_matrix *a, x_int *n, byte *isupper, ulong _xparams);
        private static _dxv2_hpdmatrixrcond _i_xv2_hpdmatrixrcond = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_cmatrixrcond1(byte **error_msg, double *result, x_matrix *a, x_int *n, ulong _xparams);
        private static _dxv2_cmatrixrcond1 _i_xv2_cmatrixrcond1 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_cmatrixrcondinf(byte **error_msg, double *result, x_matrix *a, x_int *n, ulong _xparams);
        private static _dxv2_cmatrixrcondinf _i_xv2_cmatrixrcondinf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rmatrixlurcond1(byte **error_msg, double *result, x_matrix *lua, x_int *n, ulong _xparams);
        private static _dxv2_rmatrixlurcond1 _i_xv2_rmatrixlurcond1 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rmatrixlurcondinf(byte **error_msg, double *result, x_matrix *lua, x_int *n, ulong _xparams);
        private static _dxv2_rmatrixlurcondinf _i_xv2_rmatrixlurcondinf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spdmatrixcholeskyrcond(byte **error_msg, double *result, x_matrix *a, x_int *n, byte *isupper, ulong _xparams);
        private static _dxv2_spdmatrixcholeskyrcond _i_xv2_spdmatrixcholeskyrcond = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_hpdmatrixcholeskyrcond(byte **error_msg, double *result, x_matrix *a, x_int *n, byte *isupper, ulong _xparams);
        private static _dxv2_hpdmatrixcholeskyrcond _i_xv2_hpdmatrixcholeskyrcond = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_cmatrixlurcond1(byte **error_msg, double *result, x_matrix *lua, x_int *n, ulong _xparams);
        private static _dxv2_cmatrixlurcond1 _i_xv2_cmatrixlurcond1 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_cmatrixlurcondinf(byte **error_msg, double *result, x_matrix *lua, x_int *n, ulong _xparams);
        private static _dxv2_cmatrixlurcondinf _i_xv2_cmatrixlurcondinf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_cmatrixtrrcond1(byte **error_msg, double *result, x_matrix *a, x_int *n, byte *isupper, byte *isunit, ulong _xparams);
        private static _dxv2_cmatrixtrrcond1 _i_xv2_cmatrixtrrcond1 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_cmatrixtrrcondinf(byte **error_msg, double *result, x_matrix *a, x_int *n, byte *isupper, byte *isunit, ulong _xparams);
        private static _dxv2_cmatrixtrrcondinf _i_xv2_cmatrixtrrcondinf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rmatrixsolve(byte **error_msg, x_matrix *a, x_int *n, x_vector *b, x_int *info, x_densesolverreport *rep, x_vector *x, ulong _xparams);
        private static _dxv2_rmatrixsolve _i_xv2_rmatrixsolve = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rmatrixsolvefast(byte **error_msg, x_matrix *a, x_int *n, x_vector *b, x_int *info, ulong _xparams);
        private static _dxv2_rmatrixsolvefast _i_xv2_rmatrixsolvefast = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rmatrixsolvem(byte **error_msg, x_matrix *a, x_int *n, x_matrix *b, x_int *m, byte *rfs, x_int *info, x_densesolverreport *rep, x_matrix *x, ulong _xparams);
        private static _dxv2_rmatrixsolvem _i_xv2_rmatrixsolvem = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rmatrixsolvemfast(byte **error_msg, x_matrix *a, x_int *n, x_matrix *b, x_int *m, x_int *info, ulong _xparams);
        private static _dxv2_rmatrixsolvemfast _i_xv2_rmatrixsolvemfast = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rmatrixlusolve(byte **error_msg, x_matrix *lua, x_vector *p, x_int *n, x_vector *b, x_int *info, x_densesolverreport *rep, x_vector *x, ulong _xparams);
        private static _dxv2_rmatrixlusolve _i_xv2_rmatrixlusolve = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rmatrixlusolvefast(byte **error_msg, x_matrix *lua, x_vector *p, x_int *n, x_vector *b, x_int *info, ulong _xparams);
        private static _dxv2_rmatrixlusolvefast _i_xv2_rmatrixlusolvefast = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rmatrixlusolvem(byte **error_msg, x_matrix *lua, x_vector *p, x_int *n, x_matrix *b, x_int *m, x_int *info, x_densesolverreport *rep, x_matrix *x, ulong _xparams);
        private static _dxv2_rmatrixlusolvem _i_xv2_rmatrixlusolvem = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rmatrixlusolvemfast(byte **error_msg, x_matrix *lua, x_vector *p, x_int *n, x_matrix *b, x_int *m, x_int *info, ulong _xparams);
        private static _dxv2_rmatrixlusolvemfast _i_xv2_rmatrixlusolvemfast = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rmatrixmixedsolve(byte **error_msg, x_matrix *a, x_matrix *lua, x_vector *p, x_int *n, x_vector *b, x_int *info, x_densesolverreport *rep, x_vector *x, ulong _xparams);
        private static _dxv2_rmatrixmixedsolve _i_xv2_rmatrixmixedsolve = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rmatrixmixedsolvem(byte **error_msg, x_matrix *a, x_matrix *lua, x_vector *p, x_int *n, x_matrix *b, x_int *m, x_int *info, x_densesolverreport *rep, x_matrix *x, ulong _xparams);
        private static _dxv2_rmatrixmixedsolvem _i_xv2_rmatrixmixedsolvem = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_cmatrixsolvem(byte **error_msg, x_matrix *a, x_int *n, x_matrix *b, x_int *m, byte *rfs, x_int *info, x_densesolverreport *rep, x_matrix *x, ulong _xparams);
        private static _dxv2_cmatrixsolvem _i_xv2_cmatrixsolvem = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_cmatrixsolvemfast(byte **error_msg, x_matrix *a, x_int *n, x_matrix *b, x_int *m, x_int *info, ulong _xparams);
        private static _dxv2_cmatrixsolvemfast _i_xv2_cmatrixsolvemfast = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_cmatrixsolve(byte **error_msg, x_matrix *a, x_int *n, x_vector *b, x_int *info, x_densesolverreport *rep, x_vector *x, ulong _xparams);
        private static _dxv2_cmatrixsolve _i_xv2_cmatrixsolve = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_cmatrixsolvefast(byte **error_msg, x_matrix *a, x_int *n, x_vector *b, x_int *info, ulong _xparams);
        private static _dxv2_cmatrixsolvefast _i_xv2_cmatrixsolvefast = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_cmatrixlusolvem(byte **error_msg, x_matrix *lua, x_vector *p, x_int *n, x_matrix *b, x_int *m, x_int *info, x_densesolverreport *rep, x_matrix *x, ulong _xparams);
        private static _dxv2_cmatrixlusolvem _i_xv2_cmatrixlusolvem = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_cmatrixlusolvemfast(byte **error_msg, x_matrix *lua, x_vector *p, x_int *n, x_matrix *b, x_int *m, x_int *info, ulong _xparams);
        private static _dxv2_cmatrixlusolvemfast _i_xv2_cmatrixlusolvemfast = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_cmatrixlusolve(byte **error_msg, x_matrix *lua, x_vector *p, x_int *n, x_vector *b, x_int *info, x_densesolverreport *rep, x_vector *x, ulong _xparams);
        private static _dxv2_cmatrixlusolve _i_xv2_cmatrixlusolve = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_cmatrixlusolvefast(byte **error_msg, x_matrix *lua, x_vector *p, x_int *n, x_vector *b, x_int *info, ulong _xparams);
        private static _dxv2_cmatrixlusolvefast _i_xv2_cmatrixlusolvefast = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_cmatrixmixedsolvem(byte **error_msg, x_matrix *a, x_matrix *lua, x_vector *p, x_int *n, x_matrix *b, x_int *m, x_int *info, x_densesolverreport *rep, x_matrix *x, ulong _xparams);
        private static _dxv2_cmatrixmixedsolvem _i_xv2_cmatrixmixedsolvem = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_cmatrixmixedsolve(byte **error_msg, x_matrix *a, x_matrix *lua, x_vector *p, x_int *n, x_vector *b, x_int *info, x_densesolverreport *rep, x_vector *x, ulong _xparams);
        private static _dxv2_cmatrixmixedsolve _i_xv2_cmatrixmixedsolve = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spdmatrixsolvem(byte **error_msg, x_matrix *a, x_int *n, byte *isupper, x_matrix *b, x_int *m, x_int *info, x_densesolverreport *rep, x_matrix *x, ulong _xparams);
        private static _dxv2_spdmatrixsolvem _i_xv2_spdmatrixsolvem = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spdmatrixsolvemfast(byte **error_msg, x_matrix *a, x_int *n, byte *isupper, x_matrix *b, x_int *m, x_int *info, ulong _xparams);
        private static _dxv2_spdmatrixsolvemfast _i_xv2_spdmatrixsolvemfast = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spdmatrixsolve(byte **error_msg, x_matrix *a, x_int *n, byte *isupper, x_vector *b, x_int *info, x_densesolverreport *rep, x_vector *x, ulong _xparams);
        private static _dxv2_spdmatrixsolve _i_xv2_spdmatrixsolve = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spdmatrixsolvefast(byte **error_msg, x_matrix *a, x_int *n, byte *isupper, x_vector *b, x_int *info, ulong _xparams);
        private static _dxv2_spdmatrixsolvefast _i_xv2_spdmatrixsolvefast = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spdmatrixcholeskysolvem(byte **error_msg, x_matrix *cha, x_int *n, byte *isupper, x_matrix *b, x_int *m, x_int *info, x_densesolverreport *rep, x_matrix *x, ulong _xparams);
        private static _dxv2_spdmatrixcholeskysolvem _i_xv2_spdmatrixcholeskysolvem = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spdmatrixcholeskysolvemfast(byte **error_msg, x_matrix *cha, x_int *n, byte *isupper, x_matrix *b, x_int *m, x_int *info, ulong _xparams);
        private static _dxv2_spdmatrixcholeskysolvemfast _i_xv2_spdmatrixcholeskysolvemfast = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spdmatrixcholeskysolve(byte **error_msg, x_matrix *cha, x_int *n, byte *isupper, x_vector *b, x_int *info, x_densesolverreport *rep, x_vector *x, ulong _xparams);
        private static _dxv2_spdmatrixcholeskysolve _i_xv2_spdmatrixcholeskysolve = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spdmatrixcholeskysolvefast(byte **error_msg, x_matrix *cha, x_int *n, byte *isupper, x_vector *b, x_int *info, ulong _xparams);
        private static _dxv2_spdmatrixcholeskysolvefast _i_xv2_spdmatrixcholeskysolvefast = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_hpdmatrixsolvem(byte **error_msg, x_matrix *a, x_int *n, byte *isupper, x_matrix *b, x_int *m, x_int *info, x_densesolverreport *rep, x_matrix *x, ulong _xparams);
        private static _dxv2_hpdmatrixsolvem _i_xv2_hpdmatrixsolvem = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_hpdmatrixsolvemfast(byte **error_msg, x_matrix *a, x_int *n, byte *isupper, x_matrix *b, x_int *m, x_int *info, ulong _xparams);
        private static _dxv2_hpdmatrixsolvemfast _i_xv2_hpdmatrixsolvemfast = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_hpdmatrixsolve(byte **error_msg, x_matrix *a, x_int *n, byte *isupper, x_vector *b, x_int *info, x_densesolverreport *rep, x_vector *x, ulong _xparams);
        private static _dxv2_hpdmatrixsolve _i_xv2_hpdmatrixsolve = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_hpdmatrixsolvefast(byte **error_msg, x_matrix *a, x_int *n, byte *isupper, x_vector *b, x_int *info, ulong _xparams);
        private static _dxv2_hpdmatrixsolvefast _i_xv2_hpdmatrixsolvefast = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_hpdmatrixcholeskysolvem(byte **error_msg, x_matrix *cha, x_int *n, byte *isupper, x_matrix *b, x_int *m, x_int *info, x_densesolverreport *rep, x_matrix *x, ulong _xparams);
        private static _dxv2_hpdmatrixcholeskysolvem _i_xv2_hpdmatrixcholeskysolvem = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_hpdmatrixcholeskysolvemfast(byte **error_msg, x_matrix *cha, x_int *n, byte *isupper, x_matrix *b, x_int *m, x_int *info, ulong _xparams);
        private static _dxv2_hpdmatrixcholeskysolvemfast _i_xv2_hpdmatrixcholeskysolvemfast = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_hpdmatrixcholeskysolve(byte **error_msg, x_matrix *cha, x_int *n, byte *isupper, x_vector *b, x_int *info, x_densesolverreport *rep, x_vector *x, ulong _xparams);
        private static _dxv2_hpdmatrixcholeskysolve _i_xv2_hpdmatrixcholeskysolve = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_hpdmatrixcholeskysolvefast(byte **error_msg, x_matrix *cha, x_int *n, byte *isupper, x_vector *b, x_int *info, ulong _xparams);
        private static _dxv2_hpdmatrixcholeskysolvefast _i_xv2_hpdmatrixcholeskysolvefast = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rmatrixsolvels(byte **error_msg, x_matrix *a, x_int *nrows, x_int *ncols, x_vector *b, double *threshold, x_int *info, x_densesolverlsreport *rep, x_vector *x, ulong _xparams);
        private static _dxv2_rmatrixsolvels _i_xv2_rmatrixsolvels = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparsespdsolvesks(byte **error_msg, void **a, byte *isupper, x_vector *b, x_vector *x, x_sparsesolverreport *rep, ulong _xparams);
        private static _dxv2_sparsespdsolvesks _i_xv2_sparsespdsolvesks = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparsespdsolve(byte **error_msg, void **a, byte *isupper, x_vector *b, x_vector *x, x_sparsesolverreport *rep, ulong _xparams);
        private static _dxv2_sparsespdsolve _i_xv2_sparsespdsolve = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparsespdcholeskysolve(byte **error_msg, void **a, byte *isupper, x_vector *b, x_vector *x, x_sparsesolverreport *rep, ulong _xparams);
        private static _dxv2_sparsespdcholeskysolve _i_xv2_sparsespdcholeskysolve = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparsesolve(byte **error_msg, void **a, x_vector *b, x_vector *x, x_sparsesolverreport *rep, ulong _xparams);
        private static _dxv2_sparsesolve _i_xv2_sparsesolve = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparselusolve(byte **error_msg, void **a, x_vector *p, x_vector *q, x_vector *b, x_vector *x, x_sparsesolverreport *rep, ulong _xparams);
        private static _dxv2_sparselusolve _i_xv2_sparselusolve = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparsesolvesymmetricgmres(byte **error_msg, void **a, byte *isupper, x_vector *b, x_int *k, double *epsf, x_int *maxits, x_vector *x, x_sparsesolverreport *rep, ulong _xparams);
        private static _dxv2_sparsesolvesymmetricgmres _i_xv2_sparsesolvesymmetricgmres = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparsesolvegmres(byte **error_msg, void **a, x_vector *b, x_int *k, double *epsf, x_int *maxits, x_vector *x, x_sparsesolverreport *rep, ulong _xparams);
        private static _dxv2_sparsesolvegmres _i_xv2_sparsesolvegmres = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparsesolvercreate(byte **error_msg, x_int *n, void **state, ulong _xparams);
        private static _dxv2_sparsesolvercreate _i_xv2_sparsesolvercreate = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparsesolversetalgogmres(byte **error_msg, void **state, x_int *k, ulong _xparams);
        private static _dxv2_sparsesolversetalgogmres _i_xv2_sparsesolversetalgogmres = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparsesolversetstartingpoint(byte **error_msg, void **state, x_vector *x, ulong _xparams);
        private static _dxv2_sparsesolversetstartingpoint _i_xv2_sparsesolversetstartingpoint = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparsesolversetcond(byte **error_msg, void **state, double *epsf, x_int *maxits, ulong _xparams);
        private static _dxv2_sparsesolversetcond _i_xv2_sparsesolversetcond = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparsesolversolvesymmetric(byte **error_msg, void **state, void **a, byte *isupper, x_vector *b, ulong _xparams);
        private static _dxv2_sparsesolversolvesymmetric _i_xv2_sparsesolversolvesymmetric = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparsesolversolve(byte **error_msg, void **state, void **a, x_vector *b, ulong _xparams);
        private static _dxv2_sparsesolversolve _i_xv2_sparsesolversolve = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparsesolverresults(byte **error_msg, void **state, x_vector *x, x_sparsesolverreport *rep, ulong _xparams);
        private static _dxv2_sparsesolverresults _i_xv2_sparsesolverresults = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparsesolversetxrep(byte **error_msg, void **state, byte *needxrep, ulong _xparams);
        private static _dxv2_sparsesolversetxrep _i_xv2_sparsesolversetxrep = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparsesolveroocstart(byte **error_msg, void **state, x_vector *b, ulong _xparams);
        private static _dxv2_sparsesolveroocstart _i_xv2_sparsesolveroocstart = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparsesolverooccontinue(byte **error_msg, byte *result, void **state, ulong _xparams);
        private static _dxv2_sparsesolverooccontinue _i_xv2_sparsesolverooccontinue = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparsesolveroocgetrequestinfo(byte **error_msg, void **state, x_int *requesttype, ulong _xparams);
        private static _dxv2_sparsesolveroocgetrequestinfo _i_xv2_sparsesolveroocgetrequestinfo = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparsesolveroocgetrequestdata(byte **error_msg, void **state, x_vector *x, ulong _xparams);
        private static _dxv2_sparsesolveroocgetrequestdata _i_xv2_sparsesolveroocgetrequestdata = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparsesolveroocgetrequestdata1(byte **error_msg, void **state, double *v, ulong _xparams);
        private static _dxv2_sparsesolveroocgetrequestdata1 _i_xv2_sparsesolveroocgetrequestdata1 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparsesolveroocsendresult(byte **error_msg, void **state, x_vector *ax, ulong _xparams);
        private static _dxv2_sparsesolveroocsendresult _i_xv2_sparsesolveroocsendresult = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparsesolveroocstop(byte **error_msg, void **state, x_vector *x, x_sparsesolverreport *rep, ulong _xparams);
        private static _dxv2_sparsesolveroocstop _i_xv2_sparsesolveroocstop = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sparsesolverrequesttermination(byte **error_msg, void **state, ulong _xparams);
        private static _dxv2_sparsesolverrequesttermination _i_xv2_sparsesolverrequesttermination = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_lincgcreate(byte **error_msg, x_int *n, void **state, ulong _xparams);
        private static _dxv2_lincgcreate _i_xv2_lincgcreate = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_lincgsetstartingpoint(byte **error_msg, void **state, x_vector *x, ulong _xparams);
        private static _dxv2_lincgsetstartingpoint _i_xv2_lincgsetstartingpoint = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_lincgsetprecunit(byte **error_msg, void **state, ulong _xparams);
        private static _dxv2_lincgsetprecunit _i_xv2_lincgsetprecunit = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_lincgsetprecdiag(byte **error_msg, void **state, ulong _xparams);
        private static _dxv2_lincgsetprecdiag _i_xv2_lincgsetprecdiag = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_lincgsetcond(byte **error_msg, void **state, double *epsf, x_int *maxits, ulong _xparams);
        private static _dxv2_lincgsetcond _i_xv2_lincgsetcond = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_lincgsolvesparse(byte **error_msg, void **state, void **a, byte *isupper, x_vector *b, ulong _xparams);
        private static _dxv2_lincgsolvesparse _i_xv2_lincgsolvesparse = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_lincgresults(byte **error_msg, void **state, x_vector *x, x_lincgreport *rep, ulong _xparams);
        private static _dxv2_lincgresults _i_xv2_lincgresults = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_lincgsetrestartfreq(byte **error_msg, void **state, x_int *srf, ulong _xparams);
        private static _dxv2_lincgsetrestartfreq _i_xv2_lincgsetrestartfreq = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_lincgsetrupdatefreq(byte **error_msg, void **state, x_int *freq, ulong _xparams);
        private static _dxv2_lincgsetrupdatefreq _i_xv2_lincgsetrupdatefreq = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_lincgsetxrep(byte **error_msg, void **state, byte *needxrep, ulong _xparams);
        private static _dxv2_lincgsetxrep _i_xv2_lincgsetxrep = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_normestimatorcreate(byte **error_msg, x_int *m, x_int *n, x_int *nstart, x_int *nits, void **state, ulong _xparams);
        private static _dxv2_normestimatorcreate _i_xv2_normestimatorcreate = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_normestimatorsetseed(byte **error_msg, void **state, x_int *seedval, ulong _xparams);
        private static _dxv2_normestimatorsetseed _i_xv2_normestimatorsetseed = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_normestimatorestimatesparse(byte **error_msg, void **state, void **a, ulong _xparams);
        private static _dxv2_normestimatorestimatesparse _i_xv2_normestimatorestimatesparse = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_normestimatorresults(byte **error_msg, void **state, double *nrm, ulong _xparams);
        private static _dxv2_normestimatorresults _i_xv2_normestimatorresults = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_linlsqrcreate(byte **error_msg, x_int *m, x_int *n, void **state, ulong _xparams);
        private static _dxv2_linlsqrcreate _i_xv2_linlsqrcreate = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_linlsqrcreatebuf(byte **error_msg, x_int *m, x_int *n, void **state, ulong _xparams);
        private static _dxv2_linlsqrcreatebuf _i_xv2_linlsqrcreatebuf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_linlsqrsetprecunit(byte **error_msg, void **state, ulong _xparams);
        private static _dxv2_linlsqrsetprecunit _i_xv2_linlsqrsetprecunit = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_linlsqrsetprecdiag(byte **error_msg, void **state, ulong _xparams);
        private static _dxv2_linlsqrsetprecdiag _i_xv2_linlsqrsetprecdiag = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_linlsqrsetlambdai(byte **error_msg, void **state, double *lambdai, ulong _xparams);
        private static _dxv2_linlsqrsetlambdai _i_xv2_linlsqrsetlambdai = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_linlsqrsolvesparse(byte **error_msg, void **state, void **a, x_vector *b, ulong _xparams);
        private static _dxv2_linlsqrsolvesparse _i_xv2_linlsqrsolvesparse = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_linlsqrsetcond(byte **error_msg, void **state, double *epsa, double *epsb, x_int *maxits, ulong _xparams);
        private static _dxv2_linlsqrsetcond _i_xv2_linlsqrsetcond = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_linlsqrresults(byte **error_msg, void **state, x_vector *x, x_linlsqrreport *rep, ulong _xparams);
        private static _dxv2_linlsqrresults _i_xv2_linlsqrresults = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_linlsqrsetxrep(byte **error_msg, void **state, byte *needxrep, ulong _xparams);
        private static _dxv2_linlsqrsetxrep _i_xv2_linlsqrsetxrep = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_linlsqrpeekiterationscount(byte **error_msg, x_int *result, void **s, ulong _xparams);
        private static _dxv2_linlsqrpeekiterationscount _i_xv2_linlsqrpeekiterationscount = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_linlsqrrequesttermination(byte **error_msg, void **state, ulong _xparams);
        private static _dxv2_linlsqrrequesttermination _i_xv2_linlsqrrequesttermination = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_nleqcreatelm(byte **error_msg, x_int *n, x_int *m, x_vector *x, void **state, ulong _xparams);
        private static _dxv2_nleqcreatelm _i_xv2_nleqcreatelm = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_nleqsetcond(byte **error_msg, void **state, double *epsf, x_int *maxits, ulong _xparams);
        private static _dxv2_nleqsetcond _i_xv2_nleqsetcond = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_nleqsetxrep(byte **error_msg, void **state, byte *needxrep, ulong _xparams);
        private static _dxv2_nleqsetxrep _i_xv2_nleqsetxrep = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_nleqsetstpmax(byte **error_msg, void **state, double *stpmax, ulong _xparams);
        private static _dxv2_nleqsetstpmax _i_xv2_nleqsetstpmax = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_nleqiteration(byte **error_msg, byte *result, void **state, ulong _xparams);
        private static _dxv2_nleqiteration _i_xv2_nleqiteration = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_nleqresults(byte **error_msg, void **state, x_vector *x, x_nleqreport *rep, ulong _xparams);
        private static _dxv2_nleqresults _i_xv2_nleqresults = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_nleqresultsbuf(byte **error_msg, void **state, x_vector *x, x_nleqreport *rep, ulong _xparams);
        private static _dxv2_nleqresultsbuf _i_xv2_nleqresultsbuf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_nleqrestartfrom(byte **error_msg, void **state, x_vector *x, ulong _xparams);
        private static _dxv2_nleqrestartfrom _i_xv2_nleqrestartfrom = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rmatrixluinverse(byte **error_msg, x_matrix *a, x_vector *pivots, x_int *n, x_int *info, x_matinvreport *rep, ulong _xparams);
        private static _dxv2_rmatrixluinverse _i_xv2_rmatrixluinverse = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rmatrixinverse(byte **error_msg, x_matrix *a, x_int *n, x_int *info, x_matinvreport *rep, ulong _xparams);
        private static _dxv2_rmatrixinverse _i_xv2_rmatrixinverse = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_cmatrixluinverse(byte **error_msg, x_matrix *a, x_vector *pivots, x_int *n, x_int *info, x_matinvreport *rep, ulong _xparams);
        private static _dxv2_cmatrixluinverse _i_xv2_cmatrixluinverse = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_cmatrixinverse(byte **error_msg, x_matrix *a, x_int *n, x_int *info, x_matinvreport *rep, ulong _xparams);
        private static _dxv2_cmatrixinverse _i_xv2_cmatrixinverse = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spdmatrixcholeskyinverse(byte **error_msg, x_matrix *a, x_int *n, byte *isupper, x_int *info, x_matinvreport *rep, ulong _xparams);
        private static _dxv2_spdmatrixcholeskyinverse _i_xv2_spdmatrixcholeskyinverse = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spdmatrixinverse(byte **error_msg, x_matrix *a, x_int *n, byte *isupper, x_int *info, x_matinvreport *rep, ulong _xparams);
        private static _dxv2_spdmatrixinverse _i_xv2_spdmatrixinverse = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_hpdmatrixcholeskyinverse(byte **error_msg, x_matrix *a, x_int *n, byte *isupper, x_int *info, x_matinvreport *rep, ulong _xparams);
        private static _dxv2_hpdmatrixcholeskyinverse _i_xv2_hpdmatrixcholeskyinverse = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_hpdmatrixinverse(byte **error_msg, x_matrix *a, x_int *n, byte *isupper, x_int *info, x_matinvreport *rep, ulong _xparams);
        private static _dxv2_hpdmatrixinverse _i_xv2_hpdmatrixinverse = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rmatrixtrinverse(byte **error_msg, x_matrix *a, x_int *n, byte *isupper, byte *isunit, x_int *info, x_matinvreport *rep, ulong _xparams);
        private static _dxv2_rmatrixtrinverse _i_xv2_rmatrixtrinverse = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_cmatrixtrinverse(byte **error_msg, x_matrix *a, x_int *n, byte *isupper, byte *isunit, x_int *info, x_matinvreport *rep, ulong _xparams);
        private static _dxv2_cmatrixtrinverse _i_xv2_cmatrixtrinverse = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minlbfgscreate(byte **error_msg, x_int *n, x_int *m, x_vector *x, void **state, ulong _xparams);
        private static _dxv2_minlbfgscreate _i_xv2_minlbfgscreate = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minlbfgscreatef(byte **error_msg, x_int *n, x_int *m, x_vector *x, double *diffstep, void **state, ulong _xparams);
        private static _dxv2_minlbfgscreatef _i_xv2_minlbfgscreatef = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minlbfgssetcond(byte **error_msg, void **state, double *epsg, double *epsf, double *epsx, x_int *maxits, ulong _xparams);
        private static _dxv2_minlbfgssetcond _i_xv2_minlbfgssetcond = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minlbfgssetxrep(byte **error_msg, void **state, byte *needxrep, ulong _xparams);
        private static _dxv2_minlbfgssetxrep _i_xv2_minlbfgssetxrep = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minlbfgssetstpmax(byte **error_msg, void **state, double *stpmax, ulong _xparams);
        private static _dxv2_minlbfgssetstpmax _i_xv2_minlbfgssetstpmax = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minlbfgssetscale(byte **error_msg, void **state, x_vector *s, ulong _xparams);
        private static _dxv2_minlbfgssetscale _i_xv2_minlbfgssetscale = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minlbfgssetprecdefault(byte **error_msg, void **state, ulong _xparams);
        private static _dxv2_minlbfgssetprecdefault _i_xv2_minlbfgssetprecdefault = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minlbfgssetpreccholesky(byte **error_msg, void **state, x_matrix *p, byte *isupper, ulong _xparams);
        private static _dxv2_minlbfgssetpreccholesky _i_xv2_minlbfgssetpreccholesky = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minlbfgssetprecdiag(byte **error_msg, void **state, x_vector *d, ulong _xparams);
        private static _dxv2_minlbfgssetprecdiag _i_xv2_minlbfgssetprecdiag = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minlbfgssetprecscale(byte **error_msg, void **state, ulong _xparams);
        private static _dxv2_minlbfgssetprecscale _i_xv2_minlbfgssetprecscale = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minlbfgsiteration(byte **error_msg, byte *result, void **state, ulong _xparams);
        private static _dxv2_minlbfgsiteration _i_xv2_minlbfgsiteration = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minlbfgsoptguardgradient(byte **error_msg, void **state, double *teststep, ulong _xparams);
        private static _dxv2_minlbfgsoptguardgradient _i_xv2_minlbfgsoptguardgradient = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minlbfgsoptguardsmoothness(byte **error_msg, void **state, x_int *level, ulong _xparams);
        private static _dxv2_minlbfgsoptguardsmoothness _i_xv2_minlbfgsoptguardsmoothness = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minlbfgsoptguardresults(byte **error_msg, void **state, x_optguardreport *rep, ulong _xparams);
        private static _dxv2_minlbfgsoptguardresults _i_xv2_minlbfgsoptguardresults = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minlbfgsoptguardnonc1test0results(byte **error_msg, void **state, x_optguardnonc1test0report *strrep, x_optguardnonc1test0report *lngrep, ulong _xparams);
        private static _dxv2_minlbfgsoptguardnonc1test0results _i_xv2_minlbfgsoptguardnonc1test0results = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minlbfgsoptguardnonc1test1results(byte **error_msg, void **state, x_optguardnonc1test1report *strrep, x_optguardnonc1test1report *lngrep, ulong _xparams);
        private static _dxv2_minlbfgsoptguardnonc1test1results _i_xv2_minlbfgsoptguardnonc1test1results = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minlbfgsresults(byte **error_msg, void **state, x_vector *x, x_minlbfgsreport *rep, ulong _xparams);
        private static _dxv2_minlbfgsresults _i_xv2_minlbfgsresults = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minlbfgsresultsbuf(byte **error_msg, void **state, x_vector *x, x_minlbfgsreport *rep, ulong _xparams);
        private static _dxv2_minlbfgsresultsbuf _i_xv2_minlbfgsresultsbuf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minlbfgsrestartfrom(byte **error_msg, void **state, x_vector *x, ulong _xparams);
        private static _dxv2_minlbfgsrestartfrom _i_xv2_minlbfgsrestartfrom = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minlbfgsrequesttermination(byte **error_msg, void **state, ulong _xparams);
        private static _dxv2_minlbfgsrequesttermination _i_xv2_minlbfgsrequesttermination = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minbleiccreate(byte **error_msg, x_int *n, x_vector *x, void **state, ulong _xparams);
        private static _dxv2_minbleiccreate _i_xv2_minbleiccreate = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minbleiccreatef(byte **error_msg, x_int *n, x_vector *x, double *diffstep, void **state, ulong _xparams);
        private static _dxv2_minbleiccreatef _i_xv2_minbleiccreatef = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minbleicsetbc(byte **error_msg, void **state, x_vector *bndl, x_vector *bndu, ulong _xparams);
        private static _dxv2_minbleicsetbc _i_xv2_minbleicsetbc = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minbleicsetlc(byte **error_msg, void **state, x_matrix *c, x_vector *ct, x_int *k, ulong _xparams);
        private static _dxv2_minbleicsetlc _i_xv2_minbleicsetlc = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minbleicsetcond(byte **error_msg, void **state, double *epsg, double *epsf, double *epsx, x_int *maxits, ulong _xparams);
        private static _dxv2_minbleicsetcond _i_xv2_minbleicsetcond = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minbleicsetscale(byte **error_msg, void **state, x_vector *s, ulong _xparams);
        private static _dxv2_minbleicsetscale _i_xv2_minbleicsetscale = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minbleicsetprecdefault(byte **error_msg, void **state, ulong _xparams);
        private static _dxv2_minbleicsetprecdefault _i_xv2_minbleicsetprecdefault = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minbleicsetprecdiag(byte **error_msg, void **state, x_vector *d, ulong _xparams);
        private static _dxv2_minbleicsetprecdiag _i_xv2_minbleicsetprecdiag = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minbleicsetprecscale(byte **error_msg, void **state, ulong _xparams);
        private static _dxv2_minbleicsetprecscale _i_xv2_minbleicsetprecscale = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minbleicsetxrep(byte **error_msg, void **state, byte *needxrep, ulong _xparams);
        private static _dxv2_minbleicsetxrep _i_xv2_minbleicsetxrep = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minbleicsetstpmax(byte **error_msg, void **state, double *stpmax, ulong _xparams);
        private static _dxv2_minbleicsetstpmax _i_xv2_minbleicsetstpmax = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minbleiciteration(byte **error_msg, byte *result, void **state, ulong _xparams);
        private static _dxv2_minbleiciteration _i_xv2_minbleiciteration = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minbleicoptguardgradient(byte **error_msg, void **state, double *teststep, ulong _xparams);
        private static _dxv2_minbleicoptguardgradient _i_xv2_minbleicoptguardgradient = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minbleicoptguardsmoothness(byte **error_msg, void **state, x_int *level, ulong _xparams);
        private static _dxv2_minbleicoptguardsmoothness _i_xv2_minbleicoptguardsmoothness = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minbleicoptguardresults(byte **error_msg, void **state, x_optguardreport *rep, ulong _xparams);
        private static _dxv2_minbleicoptguardresults _i_xv2_minbleicoptguardresults = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minbleicoptguardnonc1test0results(byte **error_msg, void **state, x_optguardnonc1test0report *strrep, x_optguardnonc1test0report *lngrep, ulong _xparams);
        private static _dxv2_minbleicoptguardnonc1test0results _i_xv2_minbleicoptguardnonc1test0results = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minbleicoptguardnonc1test1results(byte **error_msg, void **state, x_optguardnonc1test1report *strrep, x_optguardnonc1test1report *lngrep, ulong _xparams);
        private static _dxv2_minbleicoptguardnonc1test1results _i_xv2_minbleicoptguardnonc1test1results = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minbleicresults(byte **error_msg, void **state, x_vector *x, x_minbleicreport *rep, ulong _xparams);
        private static _dxv2_minbleicresults _i_xv2_minbleicresults = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minbleicresultsbuf(byte **error_msg, void **state, x_vector *x, x_minbleicreport *rep, ulong _xparams);
        private static _dxv2_minbleicresultsbuf _i_xv2_minbleicresultsbuf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minbleicrestartfrom(byte **error_msg, void **state, x_vector *x, ulong _xparams);
        private static _dxv2_minbleicrestartfrom _i_xv2_minbleicrestartfrom = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minbleicrequesttermination(byte **error_msg, void **state, ulong _xparams);
        private static _dxv2_minbleicrequesttermination _i_xv2_minbleicrequesttermination = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minqpcreate(byte **error_msg, x_int *n, void **state, ulong _xparams);
        private static _dxv2_minqpcreate _i_xv2_minqpcreate = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minqpsetlinearterm(byte **error_msg, void **state, x_vector *b, ulong _xparams);
        private static _dxv2_minqpsetlinearterm _i_xv2_minqpsetlinearterm = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minqpsetquadraticterm(byte **error_msg, void **state, x_matrix *a, byte *isupper, ulong _xparams);
        private static _dxv2_minqpsetquadraticterm _i_xv2_minqpsetquadraticterm = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minqpsetquadratictermsparse(byte **error_msg, void **state, void **a, byte *isupper, ulong _xparams);
        private static _dxv2_minqpsetquadratictermsparse _i_xv2_minqpsetquadratictermsparse = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minqpsetstartingpoint(byte **error_msg, void **state, x_vector *x, ulong _xparams);
        private static _dxv2_minqpsetstartingpoint _i_xv2_minqpsetstartingpoint = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minqpsetorigin(byte **error_msg, void **state, x_vector *xorigin, ulong _xparams);
        private static _dxv2_minqpsetorigin _i_xv2_minqpsetorigin = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minqpsetscale(byte **error_msg, void **state, x_vector *s, ulong _xparams);
        private static _dxv2_minqpsetscale _i_xv2_minqpsetscale = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minqpsetscaleautodiag(byte **error_msg, void **state, ulong _xparams);
        private static _dxv2_minqpsetscaleautodiag _i_xv2_minqpsetscaleautodiag = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minqpsetalgobleic(byte **error_msg, void **state, double *epsg, double *epsf, double *epsx, x_int *maxits, ulong _xparams);
        private static _dxv2_minqpsetalgobleic _i_xv2_minqpsetalgobleic = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minqpsetalgodenseaul(byte **error_msg, void **state, double *epsx, double *rho, x_int *itscnt, ulong _xparams);
        private static _dxv2_minqpsetalgodenseaul _i_xv2_minqpsetalgodenseaul = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minqpsetalgodenseipm(byte **error_msg, void **state, double *eps, ulong _xparams);
        private static _dxv2_minqpsetalgodenseipm _i_xv2_minqpsetalgodenseipm = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minqpsetalgosparseipm(byte **error_msg, void **state, double *eps, ulong _xparams);
        private static _dxv2_minqpsetalgosparseipm _i_xv2_minqpsetalgosparseipm = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minqpsetalgoquickqp(byte **error_msg, void **state, double *epsg, double *epsf, double *epsx, x_int *maxouterits, byte *usenewton, ulong _xparams);
        private static _dxv2_minqpsetalgoquickqp _i_xv2_minqpsetalgoquickqp = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minqpsetbc(byte **error_msg, void **state, x_vector *bndl, x_vector *bndu, ulong _xparams);
        private static _dxv2_minqpsetbc _i_xv2_minqpsetbc = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minqpsetbcall(byte **error_msg, void **state, double *bndl, double *bndu, ulong _xparams);
        private static _dxv2_minqpsetbcall _i_xv2_minqpsetbcall = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minqpsetbci(byte **error_msg, void **state, x_int *i, double *bndl, double *bndu, ulong _xparams);
        private static _dxv2_minqpsetbci _i_xv2_minqpsetbci = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minqpsetlc(byte **error_msg, void **state, x_matrix *c, x_vector *ct, x_int *k, ulong _xparams);
        private static _dxv2_minqpsetlc _i_xv2_minqpsetlc = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minqpsetlcsparse(byte **error_msg, void **state, void **c, x_vector *ct, x_int *k, ulong _xparams);
        private static _dxv2_minqpsetlcsparse _i_xv2_minqpsetlcsparse = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minqpsetlcmixed(byte **error_msg, void **state, void **sparsec, x_vector *sparsect, x_int *sparsek, x_matrix *densec, x_vector *densect, x_int *densek, ulong _xparams);
        private static _dxv2_minqpsetlcmixed _i_xv2_minqpsetlcmixed = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minqpsetlcmixedlegacy(byte **error_msg, void **state, x_matrix *densec, x_vector *densect, x_int *densek, void **sparsec, x_vector *sparsect, x_int *sparsek, ulong _xparams);
        private static _dxv2_minqpsetlcmixedlegacy _i_xv2_minqpsetlcmixedlegacy = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minqpsetlc2dense(byte **error_msg, void **state, x_matrix *a, x_vector *al, x_vector *au, x_int *k, ulong _xparams);
        private static _dxv2_minqpsetlc2dense _i_xv2_minqpsetlc2dense = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minqpsetlc2(byte **error_msg, void **state, void **a, x_vector *al, x_vector *au, x_int *k, ulong _xparams);
        private static _dxv2_minqpsetlc2 _i_xv2_minqpsetlc2 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minqpsetlc2mixed(byte **error_msg, void **state, void **sparsea, x_int *ksparse, x_matrix *densea, x_int *kdense, x_vector *al, x_vector *au, ulong _xparams);
        private static _dxv2_minqpsetlc2mixed _i_xv2_minqpsetlc2mixed = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minqpaddlc2dense(byte **error_msg, void **state, x_vector *a, double *al, double *au, ulong _xparams);
        private static _dxv2_minqpaddlc2dense _i_xv2_minqpaddlc2dense = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minqpaddlc2(byte **error_msg, void **state, x_vector *idxa, x_vector *vala, x_int *nnz, double *al, double *au, ulong _xparams);
        private static _dxv2_minqpaddlc2 _i_xv2_minqpaddlc2 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minqpaddlc2sparsefromdense(byte **error_msg, void **state, x_vector *da, double *al, double *au, ulong _xparams);
        private static _dxv2_minqpaddlc2sparsefromdense _i_xv2_minqpaddlc2sparsefromdense = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minqpoptimize(byte **error_msg, void **state, ulong _xparams);
        private static _dxv2_minqpoptimize _i_xv2_minqpoptimize = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minqpresults(byte **error_msg, void **state, x_vector *x, x_minqpreport *rep, ulong _xparams);
        private static _dxv2_minqpresults _i_xv2_minqpresults = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minqpresultsbuf(byte **error_msg, void **state, x_vector *x, x_minqpreport *rep, ulong _xparams);
        private static _dxv2_minqpresultsbuf _i_xv2_minqpresultsbuf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minlmcreatevj(byte **error_msg, x_int *n, x_int *m, x_vector *x, void **state, ulong _xparams);
        private static _dxv2_minlmcreatevj _i_xv2_minlmcreatevj = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minlmcreatev(byte **error_msg, x_int *n, x_int *m, x_vector *x, double *diffstep, void **state, ulong _xparams);
        private static _dxv2_minlmcreatev _i_xv2_minlmcreatev = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minlmcreatefgh(byte **error_msg, x_int *n, x_vector *x, void **state, ulong _xparams);
        private static _dxv2_minlmcreatefgh _i_xv2_minlmcreatefgh = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minlmsetcond(byte **error_msg, void **state, double *epsx, x_int *maxits, ulong _xparams);
        private static _dxv2_minlmsetcond _i_xv2_minlmsetcond = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minlmsetxrep(byte **error_msg, void **state, byte *needxrep, ulong _xparams);
        private static _dxv2_minlmsetxrep _i_xv2_minlmsetxrep = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minlmsetstpmax(byte **error_msg, void **state, double *stpmax, ulong _xparams);
        private static _dxv2_minlmsetstpmax _i_xv2_minlmsetstpmax = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minlmsetscale(byte **error_msg, void **state, x_vector *s, ulong _xparams);
        private static _dxv2_minlmsetscale _i_xv2_minlmsetscale = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minlmsetbc(byte **error_msg, void **state, x_vector *bndl, x_vector *bndu, ulong _xparams);
        private static _dxv2_minlmsetbc _i_xv2_minlmsetbc = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minlmsetlc(byte **error_msg, void **state, x_matrix *c, x_vector *ct, x_int *k, ulong _xparams);
        private static _dxv2_minlmsetlc _i_xv2_minlmsetlc = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minlmsetacctype(byte **error_msg, void **state, x_int *acctype, ulong _xparams);
        private static _dxv2_minlmsetacctype _i_xv2_minlmsetacctype = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minlmiteration(byte **error_msg, byte *result, void **state, ulong _xparams);
        private static _dxv2_minlmiteration _i_xv2_minlmiteration = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minlmoptguardgradient(byte **error_msg, void **state, double *teststep, ulong _xparams);
        private static _dxv2_minlmoptguardgradient _i_xv2_minlmoptguardgradient = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minlmoptguardresults(byte **error_msg, void **state, x_optguardreport *rep, ulong _xparams);
        private static _dxv2_minlmoptguardresults _i_xv2_minlmoptguardresults = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minlmresults(byte **error_msg, void **state, x_vector *x, x_minlmreport *rep, ulong _xparams);
        private static _dxv2_minlmresults _i_xv2_minlmresults = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minlmresultsbuf(byte **error_msg, void **state, x_vector *x, x_minlmreport *rep, ulong _xparams);
        private static _dxv2_minlmresultsbuf _i_xv2_minlmresultsbuf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minlmrestartfrom(byte **error_msg, void **state, x_vector *x, ulong _xparams);
        private static _dxv2_minlmrestartfrom _i_xv2_minlmrestartfrom = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minlmrequesttermination(byte **error_msg, void **state, ulong _xparams);
        private static _dxv2_minlmrequesttermination _i_xv2_minlmrequesttermination = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minlmcreatevgj(byte **error_msg, x_int *n, x_int *m, x_vector *x, void **state, ulong _xparams);
        private static _dxv2_minlmcreatevgj _i_xv2_minlmcreatevgj = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minlmcreatefgj(byte **error_msg, x_int *n, x_int *m, x_vector *x, void **state, ulong _xparams);
        private static _dxv2_minlmcreatefgj _i_xv2_minlmcreatefgj = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minlmcreatefj(byte **error_msg, x_int *n, x_int *m, x_vector *x, void **state, ulong _xparams);
        private static _dxv2_minlmcreatefj _i_xv2_minlmcreatefj = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mincgcreate(byte **error_msg, x_int *n, x_vector *x, void **state, ulong _xparams);
        private static _dxv2_mincgcreate _i_xv2_mincgcreate = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mincgcreatef(byte **error_msg, x_int *n, x_vector *x, double *diffstep, void **state, ulong _xparams);
        private static _dxv2_mincgcreatef _i_xv2_mincgcreatef = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mincgsetcond(byte **error_msg, void **state, double *epsg, double *epsf, double *epsx, x_int *maxits, ulong _xparams);
        private static _dxv2_mincgsetcond _i_xv2_mincgsetcond = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mincgsetscale(byte **error_msg, void **state, x_vector *s, ulong _xparams);
        private static _dxv2_mincgsetscale _i_xv2_mincgsetscale = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mincgsetxrep(byte **error_msg, void **state, byte *needxrep, ulong _xparams);
        private static _dxv2_mincgsetxrep _i_xv2_mincgsetxrep = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mincgsetcgtype(byte **error_msg, void **state, x_int *cgtype, ulong _xparams);
        private static _dxv2_mincgsetcgtype _i_xv2_mincgsetcgtype = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mincgsetstpmax(byte **error_msg, void **state, double *stpmax, ulong _xparams);
        private static _dxv2_mincgsetstpmax _i_xv2_mincgsetstpmax = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mincgsuggeststep(byte **error_msg, void **state, double *stp, ulong _xparams);
        private static _dxv2_mincgsuggeststep _i_xv2_mincgsuggeststep = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mincgsetprecdefault(byte **error_msg, void **state, ulong _xparams);
        private static _dxv2_mincgsetprecdefault _i_xv2_mincgsetprecdefault = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mincgsetprecdiag(byte **error_msg, void **state, x_vector *d, ulong _xparams);
        private static _dxv2_mincgsetprecdiag _i_xv2_mincgsetprecdiag = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mincgsetprecscale(byte **error_msg, void **state, ulong _xparams);
        private static _dxv2_mincgsetprecscale _i_xv2_mincgsetprecscale = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mincgiteration(byte **error_msg, byte *result, void **state, ulong _xparams);
        private static _dxv2_mincgiteration _i_xv2_mincgiteration = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mincgoptguardgradient(byte **error_msg, void **state, double *teststep, ulong _xparams);
        private static _dxv2_mincgoptguardgradient _i_xv2_mincgoptguardgradient = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mincgoptguardsmoothness(byte **error_msg, void **state, x_int *level, ulong _xparams);
        private static _dxv2_mincgoptguardsmoothness _i_xv2_mincgoptguardsmoothness = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mincgoptguardresults(byte **error_msg, void **state, x_optguardreport *rep, ulong _xparams);
        private static _dxv2_mincgoptguardresults _i_xv2_mincgoptguardresults = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mincgoptguardnonc1test0results(byte **error_msg, void **state, x_optguardnonc1test0report *strrep, x_optguardnonc1test0report *lngrep, ulong _xparams);
        private static _dxv2_mincgoptguardnonc1test0results _i_xv2_mincgoptguardnonc1test0results = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mincgoptguardnonc1test1results(byte **error_msg, void **state, x_optguardnonc1test1report *strrep, x_optguardnonc1test1report *lngrep, ulong _xparams);
        private static _dxv2_mincgoptguardnonc1test1results _i_xv2_mincgoptguardnonc1test1results = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mincgresults(byte **error_msg, void **state, x_vector *x, x_mincgreport *rep, ulong _xparams);
        private static _dxv2_mincgresults _i_xv2_mincgresults = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mincgresultsbuf(byte **error_msg, void **state, x_vector *x, x_mincgreport *rep, ulong _xparams);
        private static _dxv2_mincgresultsbuf _i_xv2_mincgresultsbuf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mincgrestartfrom(byte **error_msg, void **state, x_vector *x, ulong _xparams);
        private static _dxv2_mincgrestartfrom _i_xv2_mincgrestartfrom = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mincgrequesttermination(byte **error_msg, void **state, ulong _xparams);
        private static _dxv2_mincgrequesttermination _i_xv2_mincgrequesttermination = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minlpcreate(byte **error_msg, x_int *n, void **state, ulong _xparams);
        private static _dxv2_minlpcreate _i_xv2_minlpcreate = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minlpsetalgodss(byte **error_msg, void **state, double *eps, ulong _xparams);
        private static _dxv2_minlpsetalgodss _i_xv2_minlpsetalgodss = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minlpsetalgoipm(byte **error_msg, void **state, double *eps, ulong _xparams);
        private static _dxv2_minlpsetalgoipm _i_xv2_minlpsetalgoipm = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minlpsetcost(byte **error_msg, void **state, x_vector *c, ulong _xparams);
        private static _dxv2_minlpsetcost _i_xv2_minlpsetcost = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minlpsetscale(byte **error_msg, void **state, x_vector *s, ulong _xparams);
        private static _dxv2_minlpsetscale _i_xv2_minlpsetscale = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minlpsetbc(byte **error_msg, void **state, x_vector *bndl, x_vector *bndu, ulong _xparams);
        private static _dxv2_minlpsetbc _i_xv2_minlpsetbc = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minlpsetbcall(byte **error_msg, void **state, double *bndl, double *bndu, ulong _xparams);
        private static _dxv2_minlpsetbcall _i_xv2_minlpsetbcall = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minlpsetbci(byte **error_msg, void **state, x_int *i, double *bndl, double *bndu, ulong _xparams);
        private static _dxv2_minlpsetbci _i_xv2_minlpsetbci = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minlpsetlc(byte **error_msg, void **state, x_matrix *a, x_vector *ct, x_int *k, ulong _xparams);
        private static _dxv2_minlpsetlc _i_xv2_minlpsetlc = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minlpsetlc2dense(byte **error_msg, void **state, x_matrix *a, x_vector *al, x_vector *au, x_int *k, ulong _xparams);
        private static _dxv2_minlpsetlc2dense _i_xv2_minlpsetlc2dense = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minlpsetlc2(byte **error_msg, void **state, void **a, x_vector *al, x_vector *au, x_int *k, ulong _xparams);
        private static _dxv2_minlpsetlc2 _i_xv2_minlpsetlc2 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minlpaddlc2dense(byte **error_msg, void **state, x_vector *a, double *al, double *au, ulong _xparams);
        private static _dxv2_minlpaddlc2dense _i_xv2_minlpaddlc2dense = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minlpaddlc2(byte **error_msg, void **state, x_vector *idxa, x_vector *vala, x_int *nnz, double *al, double *au, ulong _xparams);
        private static _dxv2_minlpaddlc2 _i_xv2_minlpaddlc2 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minlpoptimize(byte **error_msg, void **state, ulong _xparams);
        private static _dxv2_minlpoptimize _i_xv2_minlpoptimize = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minlpresults(byte **error_msg, void **state, x_vector *x, x_minlpreport *rep, ulong _xparams);
        private static _dxv2_minlpresults _i_xv2_minlpresults = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minlpresultsbuf(byte **error_msg, void **state, x_vector *x, x_minlpreport *rep, ulong _xparams);
        private static _dxv2_minlpresultsbuf _i_xv2_minlpresultsbuf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minnlccreate(byte **error_msg, x_int *n, x_vector *x, void **state, ulong _xparams);
        private static _dxv2_minnlccreate _i_xv2_minnlccreate = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minnlccreatef(byte **error_msg, x_int *n, x_vector *x, double *diffstep, void **state, ulong _xparams);
        private static _dxv2_minnlccreatef _i_xv2_minnlccreatef = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minnlcsetbc(byte **error_msg, void **state, x_vector *bndl, x_vector *bndu, ulong _xparams);
        private static _dxv2_minnlcsetbc _i_xv2_minnlcsetbc = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minnlcsetlc(byte **error_msg, void **state, x_matrix *c, x_vector *ct, x_int *k, ulong _xparams);
        private static _dxv2_minnlcsetlc _i_xv2_minnlcsetlc = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minnlcsetnlc(byte **error_msg, void **state, x_int *nlec, x_int *nlic, ulong _xparams);
        private static _dxv2_minnlcsetnlc _i_xv2_minnlcsetnlc = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minnlcsetcond(byte **error_msg, void **state, double *epsx, x_int *maxits, ulong _xparams);
        private static _dxv2_minnlcsetcond _i_xv2_minnlcsetcond = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minnlcsetscale(byte **error_msg, void **state, x_vector *s, ulong _xparams);
        private static _dxv2_minnlcsetscale _i_xv2_minnlcsetscale = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minnlcsetprecinexact(byte **error_msg, void **state, ulong _xparams);
        private static _dxv2_minnlcsetprecinexact _i_xv2_minnlcsetprecinexact = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minnlcsetprecexactlowrank(byte **error_msg, void **state, x_int *updatefreq, ulong _xparams);
        private static _dxv2_minnlcsetprecexactlowrank _i_xv2_minnlcsetprecexactlowrank = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minnlcsetprecexactrobust(byte **error_msg, void **state, x_int *updatefreq, ulong _xparams);
        private static _dxv2_minnlcsetprecexactrobust _i_xv2_minnlcsetprecexactrobust = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minnlcsetprecnone(byte **error_msg, void **state, ulong _xparams);
        private static _dxv2_minnlcsetprecnone _i_xv2_minnlcsetprecnone = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minnlcsetstpmax(byte **error_msg, void **state, double *stpmax, ulong _xparams);
        private static _dxv2_minnlcsetstpmax _i_xv2_minnlcsetstpmax = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minnlcsetalgoaul(byte **error_msg, void **state, double *rho, x_int *itscnt, ulong _xparams);
        private static _dxv2_minnlcsetalgoaul _i_xv2_minnlcsetalgoaul = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minnlcsetalgoslp(byte **error_msg, void **state, ulong _xparams);
        private static _dxv2_minnlcsetalgoslp _i_xv2_minnlcsetalgoslp = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minnlcsetalgosqp(byte **error_msg, void **state, ulong _xparams);
        private static _dxv2_minnlcsetalgosqp _i_xv2_minnlcsetalgosqp = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minnlcsetxrep(byte **error_msg, void **state, byte *needxrep, ulong _xparams);
        private static _dxv2_minnlcsetxrep _i_xv2_minnlcsetxrep = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minnlciteration(byte **error_msg, byte *result, void **state, ulong _xparams);
        private static _dxv2_minnlciteration _i_xv2_minnlciteration = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minnlcoptguardgradient(byte **error_msg, void **state, double *teststep, ulong _xparams);
        private static _dxv2_minnlcoptguardgradient _i_xv2_minnlcoptguardgradient = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minnlcoptguardsmoothness(byte **error_msg, void **state, x_int *level, ulong _xparams);
        private static _dxv2_minnlcoptguardsmoothness _i_xv2_minnlcoptguardsmoothness = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minnlcoptguardresults(byte **error_msg, void **state, x_optguardreport *rep, ulong _xparams);
        private static _dxv2_minnlcoptguardresults _i_xv2_minnlcoptguardresults = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minnlcoptguardnonc1test0results(byte **error_msg, void **state, x_optguardnonc1test0report *strrep, x_optguardnonc1test0report *lngrep, ulong _xparams);
        private static _dxv2_minnlcoptguardnonc1test0results _i_xv2_minnlcoptguardnonc1test0results = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minnlcoptguardnonc1test1results(byte **error_msg, void **state, x_optguardnonc1test1report *strrep, x_optguardnonc1test1report *lngrep, ulong _xparams);
        private static _dxv2_minnlcoptguardnonc1test1results _i_xv2_minnlcoptguardnonc1test1results = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minnlcresults(byte **error_msg, void **state, x_vector *x, x_minnlcreport *rep, ulong _xparams);
        private static _dxv2_minnlcresults _i_xv2_minnlcresults = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minnlcresultsbuf(byte **error_msg, void **state, x_vector *x, x_minnlcreport *rep, ulong _xparams);
        private static _dxv2_minnlcresultsbuf _i_xv2_minnlcresultsbuf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minnlcrequesttermination(byte **error_msg, void **state, ulong _xparams);
        private static _dxv2_minnlcrequesttermination _i_xv2_minnlcrequesttermination = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minnlcrestartfrom(byte **error_msg, void **state, x_vector *x, ulong _xparams);
        private static _dxv2_minnlcrestartfrom _i_xv2_minnlcrestartfrom = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minnscreate(byte **error_msg, x_int *n, x_vector *x, void **state, ulong _xparams);
        private static _dxv2_minnscreate _i_xv2_minnscreate = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minnscreatef(byte **error_msg, x_int *n, x_vector *x, double *diffstep, void **state, ulong _xparams);
        private static _dxv2_minnscreatef _i_xv2_minnscreatef = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minnssetbc(byte **error_msg, void **state, x_vector *bndl, x_vector *bndu, ulong _xparams);
        private static _dxv2_minnssetbc _i_xv2_minnssetbc = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minnssetlc(byte **error_msg, void **state, x_matrix *c, x_vector *ct, x_int *k, ulong _xparams);
        private static _dxv2_minnssetlc _i_xv2_minnssetlc = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minnssetnlc(byte **error_msg, void **state, x_int *nlec, x_int *nlic, ulong _xparams);
        private static _dxv2_minnssetnlc _i_xv2_minnssetnlc = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minnssetcond(byte **error_msg, void **state, double *epsx, x_int *maxits, ulong _xparams);
        private static _dxv2_minnssetcond _i_xv2_minnssetcond = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minnssetscale(byte **error_msg, void **state, x_vector *s, ulong _xparams);
        private static _dxv2_minnssetscale _i_xv2_minnssetscale = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minnssetalgoags(byte **error_msg, void **state, double *radius, double *penalty, ulong _xparams);
        private static _dxv2_minnssetalgoags _i_xv2_minnssetalgoags = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minnssetxrep(byte **error_msg, void **state, byte *needxrep, ulong _xparams);
        private static _dxv2_minnssetxrep _i_xv2_minnssetxrep = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minnsrequesttermination(byte **error_msg, void **state, ulong _xparams);
        private static _dxv2_minnsrequesttermination _i_xv2_minnsrequesttermination = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minnsiteration(byte **error_msg, byte *result, void **state, ulong _xparams);
        private static _dxv2_minnsiteration _i_xv2_minnsiteration = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minnsresults(byte **error_msg, void **state, x_vector *x, x_minnsreport *rep, ulong _xparams);
        private static _dxv2_minnsresults _i_xv2_minnsresults = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minnsresultsbuf(byte **error_msg, void **state, x_vector *x, x_minnsreport *rep, ulong _xparams);
        private static _dxv2_minnsresultsbuf _i_xv2_minnsresultsbuf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minnsrestartfrom(byte **error_msg, void **state, x_vector *x, ulong _xparams);
        private static _dxv2_minnsrestartfrom _i_xv2_minnsrestartfrom = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minlbfgssetdefaultpreconditioner(byte **error_msg, void **state, ulong _xparams);
        private static _dxv2_minlbfgssetdefaultpreconditioner _i_xv2_minlbfgssetdefaultpreconditioner = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minlbfgssetcholeskypreconditioner(byte **error_msg, void **state, x_matrix *p, byte *isupper, ulong _xparams);
        private static _dxv2_minlbfgssetcholeskypreconditioner _i_xv2_minlbfgssetcholeskypreconditioner = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minbleicsetbarrierwidth(byte **error_msg, void **state, double *mu, ulong _xparams);
        private static _dxv2_minbleicsetbarrierwidth _i_xv2_minbleicsetbarrierwidth = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minbleicsetbarrierdecay(byte **error_msg, void **state, double *mudecay, ulong _xparams);
        private static _dxv2_minbleicsetbarrierdecay _i_xv2_minbleicsetbarrierdecay = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minasacreate(byte **error_msg, x_int *n, x_vector *x, x_vector *bndl, x_vector *bndu, void **state, ulong _xparams);
        private static _dxv2_minasacreate _i_xv2_minasacreate = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minasasetcond(byte **error_msg, void **state, double *epsg, double *epsf, double *epsx, x_int *maxits, ulong _xparams);
        private static _dxv2_minasasetcond _i_xv2_minasasetcond = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minasasetxrep(byte **error_msg, void **state, byte *needxrep, ulong _xparams);
        private static _dxv2_minasasetxrep _i_xv2_minasasetxrep = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minasasetalgorithm(byte **error_msg, void **state, x_int *algotype, ulong _xparams);
        private static _dxv2_minasasetalgorithm _i_xv2_minasasetalgorithm = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minasasetstpmax(byte **error_msg, void **state, double *stpmax, ulong _xparams);
        private static _dxv2_minasasetstpmax _i_xv2_minasasetstpmax = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minasaiteration(byte **error_msg, byte *result, void **state, ulong _xparams);
        private static _dxv2_minasaiteration _i_xv2_minasaiteration = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minasaresults(byte **error_msg, void **state, x_vector *x, x_minasareport *rep, ulong _xparams);
        private static _dxv2_minasaresults _i_xv2_minasaresults = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minasaresultsbuf(byte **error_msg, void **state, x_vector *x, x_minasareport *rep, ulong _xparams);
        private static _dxv2_minasaresultsbuf _i_xv2_minasaresultsbuf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minasarestartfrom(byte **error_msg, void **state, x_vector *x, x_vector *bndl, x_vector *bndu, ulong _xparams);
        private static _dxv2_minasarestartfrom _i_xv2_minasarestartfrom = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minbccreate(byte **error_msg, x_int *n, x_vector *x, void **state, ulong _xparams);
        private static _dxv2_minbccreate _i_xv2_minbccreate = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minbccreatef(byte **error_msg, x_int *n, x_vector *x, double *diffstep, void **state, ulong _xparams);
        private static _dxv2_minbccreatef _i_xv2_minbccreatef = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minbcsetbc(byte **error_msg, void **state, x_vector *bndl, x_vector *bndu, ulong _xparams);
        private static _dxv2_minbcsetbc _i_xv2_minbcsetbc = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minbcsetcond(byte **error_msg, void **state, double *epsg, double *epsf, double *epsx, x_int *maxits, ulong _xparams);
        private static _dxv2_minbcsetcond _i_xv2_minbcsetcond = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minbcsetscale(byte **error_msg, void **state, x_vector *s, ulong _xparams);
        private static _dxv2_minbcsetscale _i_xv2_minbcsetscale = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minbcsetprecdefault(byte **error_msg, void **state, ulong _xparams);
        private static _dxv2_minbcsetprecdefault _i_xv2_minbcsetprecdefault = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minbcsetprecdiag(byte **error_msg, void **state, x_vector *d, ulong _xparams);
        private static _dxv2_minbcsetprecdiag _i_xv2_minbcsetprecdiag = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minbcsetprecscale(byte **error_msg, void **state, ulong _xparams);
        private static _dxv2_minbcsetprecscale _i_xv2_minbcsetprecscale = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minbcsetxrep(byte **error_msg, void **state, byte *needxrep, ulong _xparams);
        private static _dxv2_minbcsetxrep _i_xv2_minbcsetxrep = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minbcsetstpmax(byte **error_msg, void **state, double *stpmax, ulong _xparams);
        private static _dxv2_minbcsetstpmax _i_xv2_minbcsetstpmax = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minbciteration(byte **error_msg, byte *result, void **state, ulong _xparams);
        private static _dxv2_minbciteration _i_xv2_minbciteration = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minbcoptguardgradient(byte **error_msg, void **state, double *teststep, ulong _xparams);
        private static _dxv2_minbcoptguardgradient _i_xv2_minbcoptguardgradient = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minbcoptguardsmoothness(byte **error_msg, void **state, x_int *level, ulong _xparams);
        private static _dxv2_minbcoptguardsmoothness _i_xv2_minbcoptguardsmoothness = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minbcoptguardresults(byte **error_msg, void **state, x_optguardreport *rep, ulong _xparams);
        private static _dxv2_minbcoptguardresults _i_xv2_minbcoptguardresults = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minbcoptguardnonc1test0results(byte **error_msg, void **state, x_optguardnonc1test0report *strrep, x_optguardnonc1test0report *lngrep, ulong _xparams);
        private static _dxv2_minbcoptguardnonc1test0results _i_xv2_minbcoptguardnonc1test0results = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minbcoptguardnonc1test1results(byte **error_msg, void **state, x_optguardnonc1test1report *strrep, x_optguardnonc1test1report *lngrep, ulong _xparams);
        private static _dxv2_minbcoptguardnonc1test1results _i_xv2_minbcoptguardnonc1test1results = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minbcresults(byte **error_msg, void **state, x_vector *x, x_minbcreport *rep, ulong _xparams);
        private static _dxv2_minbcresults _i_xv2_minbcresults = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minbcresultsbuf(byte **error_msg, void **state, x_vector *x, x_minbcreport *rep, ulong _xparams);
        private static _dxv2_minbcresultsbuf _i_xv2_minbcresultsbuf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minbcrestartfrom(byte **error_msg, void **state, x_vector *x, ulong _xparams);
        private static _dxv2_minbcrestartfrom _i_xv2_minbcrestartfrom = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_minbcrequesttermination(byte **error_msg, void **state, ulong _xparams);
        private static _dxv2_minbcrequesttermination _i_xv2_minbcrequesttermination = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_x_lptestproblemserialize(byte **error_msg, void **x, byte **dst);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_x_lptestproblemunserialize(byte **error_msg, byte **src, void **x);
        private static _d_x_lptestproblemserialize   _i_x_lptestproblemserialize   = null;
        private static _d_x_lptestproblemunserialize _i_x_lptestproblemunserialize = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_x_lptestproblemserialize_stream(byte **error_msg, void **x, native_stream_adapter.writer_delegate writer, IntPtr aux);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_x_lptestproblemunserialize_stream(byte **error_msg, native_stream_adapter.reader_delegate reader, IntPtr aux, void **x);
        private static _d_x_lptestproblemserialize_stream   _i_x_lptestproblemserialize_stream   = null;
        private static _d_x_lptestproblemunserialize_stream _i_x_lptestproblemunserialize_stream = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_lptestproblemcreate(byte **error_msg, x_int *n, byte *hasknowntarget, double *targetf, void **p, ulong _xparams);
        private static _dxv2_lptestproblemcreate _i_xv2_lptestproblemcreate = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_lptestproblemhasknowntarget(byte **error_msg, byte *result, void **p, ulong _xparams);
        private static _dxv2_lptestproblemhasknowntarget _i_xv2_lptestproblemhasknowntarget = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_lptestproblemgettargetf(byte **error_msg, double *result, void **p, ulong _xparams);
        private static _dxv2_lptestproblemgettargetf _i_xv2_lptestproblemgettargetf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_lptestproblemgetn(byte **error_msg, x_int *result, void **p, ulong _xparams);
        private static _dxv2_lptestproblemgetn _i_xv2_lptestproblemgetn = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_lptestproblemgetm(byte **error_msg, x_int *result, void **p, ulong _xparams);
        private static _dxv2_lptestproblemgetm _i_xv2_lptestproblemgetm = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_lptestproblemsetscale(byte **error_msg, void **p, x_vector *s, ulong _xparams);
        private static _dxv2_lptestproblemsetscale _i_xv2_lptestproblemsetscale = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_lptestproblemsetcost(byte **error_msg, void **p, x_vector *c, ulong _xparams);
        private static _dxv2_lptestproblemsetcost _i_xv2_lptestproblemsetcost = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_lptestproblemsetbc(byte **error_msg, void **p, x_vector *bndl, x_vector *bndu, ulong _xparams);
        private static _dxv2_lptestproblemsetbc _i_xv2_lptestproblemsetbc = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_lptestproblemsetlc2(byte **error_msg, void **p, void **a, x_vector *al, x_vector *au, x_int *m, ulong _xparams);
        private static _dxv2_lptestproblemsetlc2 _i_xv2_lptestproblemsetlc2 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_xdbgminlpcreatefromtestproblem(byte **error_msg, void **p, void **state, ulong _xparams);
        private static _dxv2_xdbgminlpcreatefromtestproblem _i_xv2_xdbgminlpcreatefromtestproblem = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_xdebuginitrecord1(byte **error_msg, x_xdebugrecord1 *rec1, ulong _xparams);
        private static _dxv2_xdebuginitrecord1 _i_xv2_xdebuginitrecord1 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_xdebugb1count(byte **error_msg, x_int *result, x_vector *a, ulong _xparams);
        private static _dxv2_xdebugb1count _i_xv2_xdebugb1count = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_xdebugb1not(byte **error_msg, x_vector *a, ulong _xparams);
        private static _dxv2_xdebugb1not _i_xv2_xdebugb1not = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_xdebugb1appendcopy(byte **error_msg, x_vector *a, ulong _xparams);
        private static _dxv2_xdebugb1appendcopy _i_xv2_xdebugb1appendcopy = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_xdebugb1outeven(byte **error_msg, x_int *n, x_vector *a, ulong _xparams);
        private static _dxv2_xdebugb1outeven _i_xv2_xdebugb1outeven = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_xdebugi1sum(byte **error_msg, x_int *result, x_vector *a, ulong _xparams);
        private static _dxv2_xdebugi1sum _i_xv2_xdebugi1sum = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_xdebugi1neg(byte **error_msg, x_vector *a, ulong _xparams);
        private static _dxv2_xdebugi1neg _i_xv2_xdebugi1neg = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_xdebugi1appendcopy(byte **error_msg, x_vector *a, ulong _xparams);
        private static _dxv2_xdebugi1appendcopy _i_xv2_xdebugi1appendcopy = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_xdebugi1outeven(byte **error_msg, x_int *n, x_vector *a, ulong _xparams);
        private static _dxv2_xdebugi1outeven _i_xv2_xdebugi1outeven = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_xdebugr1sum(byte **error_msg, double *result, x_vector *a, ulong _xparams);
        private static _dxv2_xdebugr1sum _i_xv2_xdebugr1sum = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_xdebugr1neg(byte **error_msg, x_vector *a, ulong _xparams);
        private static _dxv2_xdebugr1neg _i_xv2_xdebugr1neg = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_xdebugr1appendcopy(byte **error_msg, x_vector *a, ulong _xparams);
        private static _dxv2_xdebugr1appendcopy _i_xv2_xdebugr1appendcopy = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_xdebugr1outeven(byte **error_msg, x_int *n, x_vector *a, ulong _xparams);
        private static _dxv2_xdebugr1outeven _i_xv2_xdebugr1outeven = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_xdebugc1sum(byte **error_msg, alglib.complex *result, x_vector *a, ulong _xparams);
        private static _dxv2_xdebugc1sum _i_xv2_xdebugc1sum = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_xdebugc1neg(byte **error_msg, x_vector *a, ulong _xparams);
        private static _dxv2_xdebugc1neg _i_xv2_xdebugc1neg = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_xdebugc1appendcopy(byte **error_msg, x_vector *a, ulong _xparams);
        private static _dxv2_xdebugc1appendcopy _i_xv2_xdebugc1appendcopy = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_xdebugc1outeven(byte **error_msg, x_int *n, x_vector *a, ulong _xparams);
        private static _dxv2_xdebugc1outeven _i_xv2_xdebugc1outeven = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_xdebugb2count(byte **error_msg, x_int *result, x_matrix *a, ulong _xparams);
        private static _dxv2_xdebugb2count _i_xv2_xdebugb2count = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_xdebugb2not(byte **error_msg, x_matrix *a, ulong _xparams);
        private static _dxv2_xdebugb2not _i_xv2_xdebugb2not = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_xdebugb2transpose(byte **error_msg, x_matrix *a, ulong _xparams);
        private static _dxv2_xdebugb2transpose _i_xv2_xdebugb2transpose = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_xdebugb2outsin(byte **error_msg, x_int *m, x_int *n, x_matrix *a, ulong _xparams);
        private static _dxv2_xdebugb2outsin _i_xv2_xdebugb2outsin = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_xdebugi2sum(byte **error_msg, x_int *result, x_matrix *a, ulong _xparams);
        private static _dxv2_xdebugi2sum _i_xv2_xdebugi2sum = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_xdebugi2neg(byte **error_msg, x_matrix *a, ulong _xparams);
        private static _dxv2_xdebugi2neg _i_xv2_xdebugi2neg = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_xdebugi2transpose(byte **error_msg, x_matrix *a, ulong _xparams);
        private static _dxv2_xdebugi2transpose _i_xv2_xdebugi2transpose = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_xdebugi2outsin(byte **error_msg, x_int *m, x_int *n, x_matrix *a, ulong _xparams);
        private static _dxv2_xdebugi2outsin _i_xv2_xdebugi2outsin = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_xdebugr2sum(byte **error_msg, double *result, x_matrix *a, ulong _xparams);
        private static _dxv2_xdebugr2sum _i_xv2_xdebugr2sum = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_xdebugr2neg(byte **error_msg, x_matrix *a, ulong _xparams);
        private static _dxv2_xdebugr2neg _i_xv2_xdebugr2neg = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_xdebugr2transpose(byte **error_msg, x_matrix *a, ulong _xparams);
        private static _dxv2_xdebugr2transpose _i_xv2_xdebugr2transpose = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_xdebugr2outsin(byte **error_msg, x_int *m, x_int *n, x_matrix *a, ulong _xparams);
        private static _dxv2_xdebugr2outsin _i_xv2_xdebugr2outsin = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_xdebugc2sum(byte **error_msg, alglib.complex *result, x_matrix *a, ulong _xparams);
        private static _dxv2_xdebugc2sum _i_xv2_xdebugc2sum = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_xdebugc2neg(byte **error_msg, x_matrix *a, ulong _xparams);
        private static _dxv2_xdebugc2neg _i_xv2_xdebugc2neg = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_xdebugc2transpose(byte **error_msg, x_matrix *a, ulong _xparams);
        private static _dxv2_xdebugc2transpose _i_xv2_xdebugc2transpose = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_xdebugc2outsincos(byte **error_msg, x_int *m, x_int *n, x_matrix *a, ulong _xparams);
        private static _dxv2_xdebugc2outsincos _i_xv2_xdebugc2outsincos = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_xdebugmaskedbiasedproductsum(byte **error_msg, double *result, x_int *m, x_int *n, x_matrix *a, x_matrix *b, x_matrix *c, ulong _xparams);
        private static _dxv2_xdebugmaskedbiasedproductsum _i_xv2_xdebugmaskedbiasedproductsum = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_x_kdtreeserialize(byte **error_msg, void **x, byte **dst);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_x_kdtreeunserialize(byte **error_msg, byte **src, void **x);
        private static _d_x_kdtreeserialize   _i_x_kdtreeserialize   = null;
        private static _d_x_kdtreeunserialize _i_x_kdtreeunserialize = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_x_kdtreeserialize_stream(byte **error_msg, void **x, native_stream_adapter.writer_delegate writer, IntPtr aux);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_x_kdtreeunserialize_stream(byte **error_msg, native_stream_adapter.reader_delegate reader, IntPtr aux, void **x);
        private static _d_x_kdtreeserialize_stream   _i_x_kdtreeserialize_stream   = null;
        private static _d_x_kdtreeunserialize_stream _i_x_kdtreeunserialize_stream = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_kdtreebuild(byte **error_msg, x_matrix *xy, x_int *n, x_int *nx, x_int *ny, x_int *normtype, void **kdt, ulong _xparams);
        private static _dxv2_kdtreebuild _i_xv2_kdtreebuild = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_kdtreebuildtagged(byte **error_msg, x_matrix *xy, x_vector *tags, x_int *n, x_int *nx, x_int *ny, x_int *normtype, void **kdt, ulong _xparams);
        private static _dxv2_kdtreebuildtagged _i_xv2_kdtreebuildtagged = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_kdtreecreaterequestbuffer(byte **error_msg, void **kdt, void **buf, ulong _xparams);
        private static _dxv2_kdtreecreaterequestbuffer _i_xv2_kdtreecreaterequestbuffer = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_kdtreequeryknn(byte **error_msg, x_int *result, void **kdt, x_vector *x, x_int *k, byte *selfmatch, ulong _xparams);
        private static _dxv2_kdtreequeryknn _i_xv2_kdtreequeryknn = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_kdtreetsqueryknn(byte **error_msg, x_int *result, void **kdt, void **buf, x_vector *x, x_int *k, byte *selfmatch, ulong _xparams);
        private static _dxv2_kdtreetsqueryknn _i_xv2_kdtreetsqueryknn = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_kdtreequeryrnn(byte **error_msg, x_int *result, void **kdt, x_vector *x, double *r, byte *selfmatch, ulong _xparams);
        private static _dxv2_kdtreequeryrnn _i_xv2_kdtreequeryrnn = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_kdtreequeryrnnu(byte **error_msg, x_int *result, void **kdt, x_vector *x, double *r, byte *selfmatch, ulong _xparams);
        private static _dxv2_kdtreequeryrnnu _i_xv2_kdtreequeryrnnu = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_kdtreetsqueryrnn(byte **error_msg, x_int *result, void **kdt, void **buf, x_vector *x, double *r, byte *selfmatch, ulong _xparams);
        private static _dxv2_kdtreetsqueryrnn _i_xv2_kdtreetsqueryrnn = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_kdtreetsqueryrnnu(byte **error_msg, x_int *result, void **kdt, void **buf, x_vector *x, double *r, byte *selfmatch, ulong _xparams);
        private static _dxv2_kdtreetsqueryrnnu _i_xv2_kdtreetsqueryrnnu = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_kdtreequeryaknn(byte **error_msg, x_int *result, void **kdt, x_vector *x, x_int *k, byte *selfmatch, double *eps, ulong _xparams);
        private static _dxv2_kdtreequeryaknn _i_xv2_kdtreequeryaknn = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_kdtreetsqueryaknn(byte **error_msg, x_int *result, void **kdt, void **buf, x_vector *x, x_int *k, byte *selfmatch, double *eps, ulong _xparams);
        private static _dxv2_kdtreetsqueryaknn _i_xv2_kdtreetsqueryaknn = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_kdtreequerybox(byte **error_msg, x_int *result, void **kdt, x_vector *boxmin, x_vector *boxmax, ulong _xparams);
        private static _dxv2_kdtreequerybox _i_xv2_kdtreequerybox = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_kdtreetsquerybox(byte **error_msg, x_int *result, void **kdt, void **buf, x_vector *boxmin, x_vector *boxmax, ulong _xparams);
        private static _dxv2_kdtreetsquerybox _i_xv2_kdtreetsquerybox = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_kdtreequeryresultsx(byte **error_msg, void **kdt, x_matrix *x, ulong _xparams);
        private static _dxv2_kdtreequeryresultsx _i_xv2_kdtreequeryresultsx = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_kdtreequeryresultsxy(byte **error_msg, void **kdt, x_matrix *xy, ulong _xparams);
        private static _dxv2_kdtreequeryresultsxy _i_xv2_kdtreequeryresultsxy = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_kdtreequeryresultstags(byte **error_msg, void **kdt, x_vector *tags, ulong _xparams);
        private static _dxv2_kdtreequeryresultstags _i_xv2_kdtreequeryresultstags = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_kdtreequeryresultsdistances(byte **error_msg, void **kdt, x_vector *r, ulong _xparams);
        private static _dxv2_kdtreequeryresultsdistances _i_xv2_kdtreequeryresultsdistances = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_kdtreetsqueryresultsx(byte **error_msg, void **kdt, void **buf, x_matrix *x, ulong _xparams);
        private static _dxv2_kdtreetsqueryresultsx _i_xv2_kdtreetsqueryresultsx = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_kdtreetsqueryresultsxy(byte **error_msg, void **kdt, void **buf, x_matrix *xy, ulong _xparams);
        private static _dxv2_kdtreetsqueryresultsxy _i_xv2_kdtreetsqueryresultsxy = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_kdtreetsqueryresultstags(byte **error_msg, void **kdt, void **buf, x_vector *tags, ulong _xparams);
        private static _dxv2_kdtreetsqueryresultstags _i_xv2_kdtreetsqueryresultstags = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_kdtreetsqueryresultsdistances(byte **error_msg, void **kdt, void **buf, x_vector *r, ulong _xparams);
        private static _dxv2_kdtreetsqueryresultsdistances _i_xv2_kdtreetsqueryresultsdistances = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_kdtreequeryresultsxi(byte **error_msg, void **kdt, x_matrix *x, ulong _xparams);
        private static _dxv2_kdtreequeryresultsxi _i_xv2_kdtreequeryresultsxi = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_kdtreequeryresultsxyi(byte **error_msg, void **kdt, x_matrix *xy, ulong _xparams);
        private static _dxv2_kdtreequeryresultsxyi _i_xv2_kdtreequeryresultsxyi = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_kdtreequeryresultstagsi(byte **error_msg, void **kdt, x_vector *tags, ulong _xparams);
        private static _dxv2_kdtreequeryresultstagsi _i_xv2_kdtreequeryresultstagsi = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_kdtreequeryresultsdistancesi(byte **error_msg, void **kdt, x_vector *r, ulong _xparams);
        private static _dxv2_kdtreequeryresultsdistancesi _i_xv2_kdtreequeryresultsdistancesi = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_odesolverrkck(byte **error_msg, x_vector *y, x_int *n, x_vector *x, x_int *m, double *eps, double *h, void **state, ulong _xparams);
        private static _dxv2_odesolverrkck _i_xv2_odesolverrkck = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_odesolveriteration(byte **error_msg, byte *result, void **state, ulong _xparams);
        private static _dxv2_odesolveriteration _i_xv2_odesolveriteration = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_odesolverresults(byte **error_msg, void **state, x_int *m, x_vector *xtbl, x_matrix *ytbl, x_odesolverreport *rep, ulong _xparams);
        private static _dxv2_odesolverresults _i_xv2_odesolverresults = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rmatrixinvupdatesimple(byte **error_msg, x_matrix *inva, x_int *n, x_int *updrow, x_int *updcolumn, double *updval, ulong _xparams);
        private static _dxv2_rmatrixinvupdatesimple _i_xv2_rmatrixinvupdatesimple = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rmatrixinvupdaterow(byte **error_msg, x_matrix *inva, x_int *n, x_int *updrow, x_vector *v, ulong _xparams);
        private static _dxv2_rmatrixinvupdaterow _i_xv2_rmatrixinvupdaterow = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rmatrixinvupdatecolumn(byte **error_msg, x_matrix *inva, x_int *n, x_int *updcolumn, x_vector *u, ulong _xparams);
        private static _dxv2_rmatrixinvupdatecolumn _i_xv2_rmatrixinvupdatecolumn = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rmatrixinvupdateuv(byte **error_msg, x_matrix *inva, x_int *n, x_vector *u, x_vector *v, ulong _xparams);
        private static _dxv2_rmatrixinvupdateuv _i_xv2_rmatrixinvupdateuv = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rmatrixschur(byte **error_msg, byte *result, x_matrix *a, x_int *n, x_matrix *s, ulong _xparams);
        private static _dxv2_rmatrixschur _i_xv2_rmatrixschur = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_smatrixgevd(byte **error_msg, byte *result, x_matrix *a, x_int *n, byte *isuppera, x_matrix *b, byte *isupperb, x_int *zneeded, x_int *problemtype, x_vector *d, x_matrix *z, ulong _xparams);
        private static _dxv2_smatrixgevd _i_xv2_smatrixgevd = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_smatrixgevdreduce(byte **error_msg, byte *result, x_matrix *a, x_int *n, byte *isuppera, x_matrix *b, byte *isupperb, x_int *problemtype, x_matrix *r, byte *isupperr, ulong _xparams);
        private static _dxv2_smatrixgevdreduce _i_xv2_smatrixgevdreduce = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rmatrixludet(byte **error_msg, double *result, x_matrix *a, x_vector *pivots, x_int *n, ulong _xparams);
        private static _dxv2_rmatrixludet _i_xv2_rmatrixludet = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rmatrixdet(byte **error_msg, double *result, x_matrix *a, x_int *n, ulong _xparams);
        private static _dxv2_rmatrixdet _i_xv2_rmatrixdet = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_cmatrixludet(byte **error_msg, alglib.complex *result, x_matrix *a, x_vector *pivots, x_int *n, ulong _xparams);
        private static _dxv2_cmatrixludet _i_xv2_cmatrixludet = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_cmatrixdet(byte **error_msg, alglib.complex *result, x_matrix *a, x_int *n, ulong _xparams);
        private static _dxv2_cmatrixdet _i_xv2_cmatrixdet = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spdmatrixcholeskydet(byte **error_msg, double *result, x_matrix *a, x_int *n, ulong _xparams);
        private static _dxv2_spdmatrixcholeskydet _i_xv2_spdmatrixcholeskydet = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spdmatrixdet(byte **error_msg, double *result, x_matrix *a, x_int *n, byte *isupper, ulong _xparams);
        private static _dxv2_spdmatrixdet _i_xv2_spdmatrixdet = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_gammafunction(byte **error_msg, double *result, double *x, ulong _xparams);
        private static _dxv2_gammafunction _i_xv2_gammafunction = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_lngamma(byte **error_msg, double *result, double *x, double *sgngam, ulong _xparams);
        private static _dxv2_lngamma _i_xv2_lngamma = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_gqgeneraterec(byte **error_msg, x_vector *alpha, x_vector *beta, double *mu0, x_int *n, x_int *info, x_vector *x, x_vector *w, ulong _xparams);
        private static _dxv2_gqgeneraterec _i_xv2_gqgeneraterec = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_gqgenerategausslobattorec(byte **error_msg, x_vector *alpha, x_vector *beta, double *mu0, double *a, double *b, x_int *n, x_int *info, x_vector *x, x_vector *w, ulong _xparams);
        private static _dxv2_gqgenerategausslobattorec _i_xv2_gqgenerategausslobattorec = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_gqgenerategaussradaurec(byte **error_msg, x_vector *alpha, x_vector *beta, double *mu0, double *a, x_int *n, x_int *info, x_vector *x, x_vector *w, ulong _xparams);
        private static _dxv2_gqgenerategaussradaurec _i_xv2_gqgenerategaussradaurec = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_gqgenerategausslegendre(byte **error_msg, x_int *n, x_int *info, x_vector *x, x_vector *w, ulong _xparams);
        private static _dxv2_gqgenerategausslegendre _i_xv2_gqgenerategausslegendre = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_gqgenerategaussjacobi(byte **error_msg, x_int *n, double *alpha, double *beta, x_int *info, x_vector *x, x_vector *w, ulong _xparams);
        private static _dxv2_gqgenerategaussjacobi _i_xv2_gqgenerategaussjacobi = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_gqgenerategausslaguerre(byte **error_msg, x_int *n, double *alpha, x_int *info, x_vector *x, x_vector *w, ulong _xparams);
        private static _dxv2_gqgenerategausslaguerre _i_xv2_gqgenerategausslaguerre = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_gqgenerategausshermite(byte **error_msg, x_int *n, x_int *info, x_vector *x, x_vector *w, ulong _xparams);
        private static _dxv2_gqgenerategausshermite _i_xv2_gqgenerategausshermite = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_gkqgeneraterec(byte **error_msg, x_vector *alpha, x_vector *beta, double *mu0, x_int *n, x_int *info, x_vector *x, x_vector *wkronrod, x_vector *wgauss, ulong _xparams);
        private static _dxv2_gkqgeneraterec _i_xv2_gkqgeneraterec = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_gkqgenerategausslegendre(byte **error_msg, x_int *n, x_int *info, x_vector *x, x_vector *wkronrod, x_vector *wgauss, ulong _xparams);
        private static _dxv2_gkqgenerategausslegendre _i_xv2_gkqgenerategausslegendre = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_gkqgenerategaussjacobi(byte **error_msg, x_int *n, double *alpha, double *beta, x_int *info, x_vector *x, x_vector *wkronrod, x_vector *wgauss, ulong _xparams);
        private static _dxv2_gkqgenerategaussjacobi _i_xv2_gkqgenerategaussjacobi = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_gkqlegendrecalc(byte **error_msg, x_int *n, x_int *info, x_vector *x, x_vector *wkronrod, x_vector *wgauss, ulong _xparams);
        private static _dxv2_gkqlegendrecalc _i_xv2_gkqlegendrecalc = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_gkqlegendretbl(byte **error_msg, x_int *n, x_vector *x, x_vector *wkronrod, x_vector *wgauss, double *eps, ulong _xparams);
        private static _dxv2_gkqlegendretbl _i_xv2_gkqlegendretbl = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_autogksmooth(byte **error_msg, double *a, double *b, void **state, ulong _xparams);
        private static _dxv2_autogksmooth _i_xv2_autogksmooth = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_autogksmoothw(byte **error_msg, double *a, double *b, double *xwidth, void **state, ulong _xparams);
        private static _dxv2_autogksmoothw _i_xv2_autogksmoothw = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_autogksingular(byte **error_msg, double *a, double *b, double *alpha, double *beta, void **state, ulong _xparams);
        private static _dxv2_autogksingular _i_xv2_autogksingular = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_autogkiteration(byte **error_msg, byte *result, void **state, ulong _xparams);
        private static _dxv2_autogkiteration _i_xv2_autogkiteration = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_autogkresults(byte **error_msg, void **state, double *v, x_autogkreport *rep, ulong _xparams);
        private static _dxv2_autogkresults _i_xv2_autogkresults = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_errorfunction(byte **error_msg, double *result, double *x, ulong _xparams);
        private static _dxv2_errorfunction _i_xv2_errorfunction = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_errorfunctionc(byte **error_msg, double *result, double *x, ulong _xparams);
        private static _dxv2_errorfunctionc _i_xv2_errorfunctionc = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_normaldistribution(byte **error_msg, double *result, double *x, ulong _xparams);
        private static _dxv2_normaldistribution _i_xv2_normaldistribution = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_normalpdf(byte **error_msg, double *result, double *x, ulong _xparams);
        private static _dxv2_normalpdf _i_xv2_normalpdf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_normalcdf(byte **error_msg, double *result, double *x, ulong _xparams);
        private static _dxv2_normalcdf _i_xv2_normalcdf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_inverf(byte **error_msg, double *result, double *e, ulong _xparams);
        private static _dxv2_inverf _i_xv2_inverf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_invnormaldistribution(byte **error_msg, double *result, double *y0, ulong _xparams);
        private static _dxv2_invnormaldistribution _i_xv2_invnormaldistribution = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_invnormalcdf(byte **error_msg, double *result, double *y0, ulong _xparams);
        private static _dxv2_invnormalcdf _i_xv2_invnormalcdf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_bivariatenormalpdf(byte **error_msg, double *result, double *x, double *y, double *rho, ulong _xparams);
        private static _dxv2_bivariatenormalpdf _i_xv2_bivariatenormalpdf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_bivariatenormalcdf(byte **error_msg, double *result, double *x, double *y, double *rho, ulong _xparams);
        private static _dxv2_bivariatenormalcdf _i_xv2_bivariatenormalcdf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_incompletebeta(byte **error_msg, double *result, double *a, double *b, double *x, ulong _xparams);
        private static _dxv2_incompletebeta _i_xv2_incompletebeta = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_invincompletebeta(byte **error_msg, double *result, double *a, double *b, double *y, ulong _xparams);
        private static _dxv2_invincompletebeta _i_xv2_invincompletebeta = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_studenttdistribution(byte **error_msg, double *result, x_int *k, double *t, ulong _xparams);
        private static _dxv2_studenttdistribution _i_xv2_studenttdistribution = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_invstudenttdistribution(byte **error_msg, double *result, x_int *k, double *p, ulong _xparams);
        private static _dxv2_invstudenttdistribution _i_xv2_invstudenttdistribution = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_samplemoments(byte **error_msg, x_vector *x, x_int *n, double *mean, double *variance, double *skewness, double *kurtosis, ulong _xparams);
        private static _dxv2_samplemoments _i_xv2_samplemoments = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_samplemean(byte **error_msg, double *result, x_vector *x, x_int *n, ulong _xparams);
        private static _dxv2_samplemean _i_xv2_samplemean = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_samplevariance(byte **error_msg, double *result, x_vector *x, x_int *n, ulong _xparams);
        private static _dxv2_samplevariance _i_xv2_samplevariance = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sampleskewness(byte **error_msg, double *result, x_vector *x, x_int *n, ulong _xparams);
        private static _dxv2_sampleskewness _i_xv2_sampleskewness = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_samplekurtosis(byte **error_msg, double *result, x_vector *x, x_int *n, ulong _xparams);
        private static _dxv2_samplekurtosis _i_xv2_samplekurtosis = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sampleadev(byte **error_msg, x_vector *x, x_int *n, double *adev, ulong _xparams);
        private static _dxv2_sampleadev _i_xv2_sampleadev = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_samplemedian(byte **error_msg, x_vector *x, x_int *n, double *median, ulong _xparams);
        private static _dxv2_samplemedian _i_xv2_samplemedian = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_samplepercentile(byte **error_msg, x_vector *x, x_int *n, double *p, double *v, ulong _xparams);
        private static _dxv2_samplepercentile _i_xv2_samplepercentile = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_cov2(byte **error_msg, double *result, x_vector *x, x_vector *y, x_int *n, ulong _xparams);
        private static _dxv2_cov2 _i_xv2_cov2 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_pearsoncorr2(byte **error_msg, double *result, x_vector *x, x_vector *y, x_int *n, ulong _xparams);
        private static _dxv2_pearsoncorr2 _i_xv2_pearsoncorr2 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spearmancorr2(byte **error_msg, double *result, x_vector *x, x_vector *y, x_int *n, ulong _xparams);
        private static _dxv2_spearmancorr2 _i_xv2_spearmancorr2 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_covm(byte **error_msg, x_matrix *x, x_int *n, x_int *m, x_matrix *c, ulong _xparams);
        private static _dxv2_covm _i_xv2_covm = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_pearsoncorrm(byte **error_msg, x_matrix *x, x_int *n, x_int *m, x_matrix *c, ulong _xparams);
        private static _dxv2_pearsoncorrm _i_xv2_pearsoncorrm = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spearmancorrm(byte **error_msg, x_matrix *x, x_int *n, x_int *m, x_matrix *c, ulong _xparams);
        private static _dxv2_spearmancorrm _i_xv2_spearmancorrm = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_covm2(byte **error_msg, x_matrix *x, x_matrix *y, x_int *n, x_int *m1, x_int *m2, x_matrix *c, ulong _xparams);
        private static _dxv2_covm2 _i_xv2_covm2 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_pearsoncorrm2(byte **error_msg, x_matrix *x, x_matrix *y, x_int *n, x_int *m1, x_int *m2, x_matrix *c, ulong _xparams);
        private static _dxv2_pearsoncorrm2 _i_xv2_pearsoncorrm2 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spearmancorrm2(byte **error_msg, x_matrix *x, x_matrix *y, x_int *n, x_int *m1, x_int *m2, x_matrix *c, ulong _xparams);
        private static _dxv2_spearmancorrm2 _i_xv2_spearmancorrm2 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rankdata(byte **error_msg, x_matrix *xy, x_int *npoints, x_int *nfeatures, ulong _xparams);
        private static _dxv2_rankdata _i_xv2_rankdata = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rankdatacentered(byte **error_msg, x_matrix *xy, x_int *npoints, x_int *nfeatures, ulong _xparams);
        private static _dxv2_rankdatacentered _i_xv2_rankdatacentered = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_pearsoncorrelation(byte **error_msg, double *result, x_vector *x, x_vector *y, x_int *n, ulong _xparams);
        private static _dxv2_pearsoncorrelation _i_xv2_pearsoncorrelation = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spearmanrankcorrelation(byte **error_msg, double *result, x_vector *x, x_vector *y, x_int *n, ulong _xparams);
        private static _dxv2_spearmanrankcorrelation _i_xv2_spearmanrankcorrelation = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_pearsoncorrelationsignificance(byte **error_msg, double *r, x_int *n, double *bothtails, double *lefttail, double *righttail, ulong _xparams);
        private static _dxv2_pearsoncorrelationsignificance _i_xv2_pearsoncorrelationsignificance = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spearmanrankcorrelationsignificance(byte **error_msg, double *r, x_int *n, double *bothtails, double *lefttail, double *righttail, ulong _xparams);
        private static _dxv2_spearmanrankcorrelationsignificance _i_xv2_spearmanrankcorrelationsignificance = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_jarqueberatest(byte **error_msg, x_vector *x, x_int *n, double *p, ulong _xparams);
        private static _dxv2_jarqueberatest _i_xv2_jarqueberatest = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_fdistribution(byte **error_msg, double *result, x_int *a, x_int *b, double *x, ulong _xparams);
        private static _dxv2_fdistribution _i_xv2_fdistribution = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_fcdistribution(byte **error_msg, double *result, x_int *a, x_int *b, double *x, ulong _xparams);
        private static _dxv2_fcdistribution _i_xv2_fcdistribution = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_invfdistribution(byte **error_msg, double *result, x_int *a, x_int *b, double *y, ulong _xparams);
        private static _dxv2_invfdistribution _i_xv2_invfdistribution = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_incompletegamma(byte **error_msg, double *result, double *a, double *x, ulong _xparams);
        private static _dxv2_incompletegamma _i_xv2_incompletegamma = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_incompletegammac(byte **error_msg, double *result, double *a, double *x, ulong _xparams);
        private static _dxv2_incompletegammac _i_xv2_incompletegammac = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_invincompletegammac(byte **error_msg, double *result, double *a, double *y0, ulong _xparams);
        private static _dxv2_invincompletegammac _i_xv2_invincompletegammac = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_chisquaredistribution(byte **error_msg, double *result, double *v, double *x, ulong _xparams);
        private static _dxv2_chisquaredistribution _i_xv2_chisquaredistribution = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_chisquarecdistribution(byte **error_msg, double *result, double *v, double *x, ulong _xparams);
        private static _dxv2_chisquarecdistribution _i_xv2_chisquarecdistribution = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_invchisquaredistribution(byte **error_msg, double *result, double *v, double *y, ulong _xparams);
        private static _dxv2_invchisquaredistribution _i_xv2_invchisquaredistribution = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_ftest(byte **error_msg, x_vector *x, x_int *n, x_vector *y, x_int *m, double *bothtails, double *lefttail, double *righttail, ulong _xparams);
        private static _dxv2_ftest _i_xv2_ftest = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_onesamplevariancetest(byte **error_msg, x_vector *x, x_int *n, double *variance, double *bothtails, double *lefttail, double *righttail, ulong _xparams);
        private static _dxv2_onesamplevariancetest _i_xv2_onesamplevariancetest = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_wilcoxonsignedranktest(byte **error_msg, x_vector *x, x_int *n, double *e, double *bothtails, double *lefttail, double *righttail, ulong _xparams);
        private static _dxv2_wilcoxonsignedranktest _i_xv2_wilcoxonsignedranktest = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mannwhitneyutest(byte **error_msg, x_vector *x, x_int *n, x_vector *y, x_int *m, double *bothtails, double *lefttail, double *righttail, ulong _xparams);
        private static _dxv2_mannwhitneyutest _i_xv2_mannwhitneyutest = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_binomialdistribution(byte **error_msg, double *result, x_int *k, x_int *n, double *p, ulong _xparams);
        private static _dxv2_binomialdistribution _i_xv2_binomialdistribution = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_binomialcdistribution(byte **error_msg, double *result, x_int *k, x_int *n, double *p, ulong _xparams);
        private static _dxv2_binomialcdistribution _i_xv2_binomialcdistribution = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_invbinomialdistribution(byte **error_msg, double *result, x_int *k, x_int *n, double *y, ulong _xparams);
        private static _dxv2_invbinomialdistribution _i_xv2_invbinomialdistribution = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_onesamplesigntest(byte **error_msg, x_vector *x, x_int *n, double *median, double *bothtails, double *lefttail, double *righttail, ulong _xparams);
        private static _dxv2_onesamplesigntest _i_xv2_onesamplesigntest = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_studentttest1(byte **error_msg, x_vector *x, x_int *n, double *mean, double *bothtails, double *lefttail, double *righttail, ulong _xparams);
        private static _dxv2_studentttest1 _i_xv2_studentttest1 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_studentttest2(byte **error_msg, x_vector *x, x_int *n, x_vector *y, x_int *m, double *bothtails, double *lefttail, double *righttail, ulong _xparams);
        private static _dxv2_studentttest2 _i_xv2_studentttest2 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_unequalvariancettest(byte **error_msg, x_vector *x, x_int *n, x_vector *y, x_int *m, double *bothtails, double *lefttail, double *righttail, ulong _xparams);
        private static _dxv2_unequalvariancettest _i_xv2_unequalvariancettest = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_barycentriccalc(byte **error_msg, double *result, void **b, double *t, ulong _xparams);
        private static _dxv2_barycentriccalc _i_xv2_barycentriccalc = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_barycentricdiff1(byte **error_msg, void **b, double *t, double *f, double *df, ulong _xparams);
        private static _dxv2_barycentricdiff1 _i_xv2_barycentricdiff1 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_barycentricdiff2(byte **error_msg, void **b, double *t, double *f, double *df, double *d2f, ulong _xparams);
        private static _dxv2_barycentricdiff2 _i_xv2_barycentricdiff2 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_barycentriclintransx(byte **error_msg, void **b, double *ca, double *cb, ulong _xparams);
        private static _dxv2_barycentriclintransx _i_xv2_barycentriclintransx = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_barycentriclintransy(byte **error_msg, void **b, double *ca, double *cb, ulong _xparams);
        private static _dxv2_barycentriclintransy _i_xv2_barycentriclintransy = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_barycentricunpack(byte **error_msg, void **b, x_int *n, x_vector *x, x_vector *y, x_vector *w, ulong _xparams);
        private static _dxv2_barycentricunpack _i_xv2_barycentricunpack = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_barycentricbuildxyw(byte **error_msg, x_vector *x, x_vector *y, x_vector *w, x_int *n, void **b, ulong _xparams);
        private static _dxv2_barycentricbuildxyw _i_xv2_barycentricbuildxyw = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_barycentricbuildfloaterhormann(byte **error_msg, x_vector *x, x_vector *y, x_int *n, x_int *d, void **b, ulong _xparams);
        private static _dxv2_barycentricbuildfloaterhormann _i_xv2_barycentricbuildfloaterhormann = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_x_idwserialize(byte **error_msg, void **x, byte **dst);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_x_idwunserialize(byte **error_msg, byte **src, void **x);
        private static _d_x_idwserialize   _i_x_idwserialize   = null;
        private static _d_x_idwunserialize _i_x_idwunserialize = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_x_idwserialize_stream(byte **error_msg, void **x, native_stream_adapter.writer_delegate writer, IntPtr aux);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_x_idwunserialize_stream(byte **error_msg, native_stream_adapter.reader_delegate reader, IntPtr aux, void **x);
        private static _d_x_idwserialize_stream   _i_x_idwserialize_stream   = null;
        private static _d_x_idwunserialize_stream _i_x_idwunserialize_stream = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_idwcreatecalcbuffer(byte **error_msg, void **s, void **buf, ulong _xparams);
        private static _dxv2_idwcreatecalcbuffer _i_xv2_idwcreatecalcbuffer = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_idwbuildercreate(byte **error_msg, x_int *nx, x_int *ny, void **state, ulong _xparams);
        private static _dxv2_idwbuildercreate _i_xv2_idwbuildercreate = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_idwbuildersetnlayers(byte **error_msg, void **state, x_int *nlayers, ulong _xparams);
        private static _dxv2_idwbuildersetnlayers _i_xv2_idwbuildersetnlayers = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_idwbuildersetpoints(byte **error_msg, void **state, x_matrix *xy, x_int *n, ulong _xparams);
        private static _dxv2_idwbuildersetpoints _i_xv2_idwbuildersetpoints = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_idwbuildersetalgomstab(byte **error_msg, void **state, double *srad, ulong _xparams);
        private static _dxv2_idwbuildersetalgomstab _i_xv2_idwbuildersetalgomstab = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_idwbuildersetalgotextbookshepard(byte **error_msg, void **state, double *p, ulong _xparams);
        private static _dxv2_idwbuildersetalgotextbookshepard _i_xv2_idwbuildersetalgotextbookshepard = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_idwbuildersetalgotextbookmodshepard(byte **error_msg, void **state, double *r, ulong _xparams);
        private static _dxv2_idwbuildersetalgotextbookmodshepard _i_xv2_idwbuildersetalgotextbookmodshepard = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_idwbuildersetuserterm(byte **error_msg, void **state, double *v, ulong _xparams);
        private static _dxv2_idwbuildersetuserterm _i_xv2_idwbuildersetuserterm = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_idwbuildersetconstterm(byte **error_msg, void **state, ulong _xparams);
        private static _dxv2_idwbuildersetconstterm _i_xv2_idwbuildersetconstterm = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_idwbuildersetzeroterm(byte **error_msg, void **state, ulong _xparams);
        private static _dxv2_idwbuildersetzeroterm _i_xv2_idwbuildersetzeroterm = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_idwcalc1(byte **error_msg, double *result, void **s, double *x0, ulong _xparams);
        private static _dxv2_idwcalc1 _i_xv2_idwcalc1 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_idwcalc2(byte **error_msg, double *result, void **s, double *x0, double *x1, ulong _xparams);
        private static _dxv2_idwcalc2 _i_xv2_idwcalc2 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_idwcalc3(byte **error_msg, double *result, void **s, double *x0, double *x1, double *x2, ulong _xparams);
        private static _dxv2_idwcalc3 _i_xv2_idwcalc3 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_idwcalc(byte **error_msg, void **s, x_vector *x, x_vector *y, ulong _xparams);
        private static _dxv2_idwcalc _i_xv2_idwcalc = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_idwcalcbuf(byte **error_msg, void **s, x_vector *x, x_vector *y, ulong _xparams);
        private static _dxv2_idwcalcbuf _i_xv2_idwcalcbuf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_idwtscalcbuf(byte **error_msg, void **s, void **buf, x_vector *x, x_vector *y, ulong _xparams);
        private static _dxv2_idwtscalcbuf _i_xv2_idwtscalcbuf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_idwfit(byte **error_msg, void **state, void **model, x_idwreport *rep, ulong _xparams);
        private static _dxv2_idwfit _i_xv2_idwfit = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_polynomialbar2cheb(byte **error_msg, void **p, double *a, double *b, x_vector *t, ulong _xparams);
        private static _dxv2_polynomialbar2cheb _i_xv2_polynomialbar2cheb = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_polynomialcheb2bar(byte **error_msg, x_vector *t, x_int *n, double *a, double *b, void **p, ulong _xparams);
        private static _dxv2_polynomialcheb2bar _i_xv2_polynomialcheb2bar = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_polynomialbar2pow(byte **error_msg, void **p, double *c, double *s, x_vector *a, ulong _xparams);
        private static _dxv2_polynomialbar2pow _i_xv2_polynomialbar2pow = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_polynomialpow2bar(byte **error_msg, x_vector *a, x_int *n, double *c, double *s, void **p, ulong _xparams);
        private static _dxv2_polynomialpow2bar _i_xv2_polynomialpow2bar = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_polynomialbuild(byte **error_msg, x_vector *x, x_vector *y, x_int *n, void **p, ulong _xparams);
        private static _dxv2_polynomialbuild _i_xv2_polynomialbuild = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_polynomialbuildeqdist(byte **error_msg, double *a, double *b, x_vector *y, x_int *n, void **p, ulong _xparams);
        private static _dxv2_polynomialbuildeqdist _i_xv2_polynomialbuildeqdist = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_polynomialbuildcheb1(byte **error_msg, double *a, double *b, x_vector *y, x_int *n, void **p, ulong _xparams);
        private static _dxv2_polynomialbuildcheb1 _i_xv2_polynomialbuildcheb1 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_polynomialbuildcheb2(byte **error_msg, double *a, double *b, x_vector *y, x_int *n, void **p, ulong _xparams);
        private static _dxv2_polynomialbuildcheb2 _i_xv2_polynomialbuildcheb2 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_polynomialcalceqdist(byte **error_msg, double *result, double *a, double *b, x_vector *f, x_int *n, double *t, ulong _xparams);
        private static _dxv2_polynomialcalceqdist _i_xv2_polynomialcalceqdist = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_polynomialcalccheb1(byte **error_msg, double *result, double *a, double *b, x_vector *f, x_int *n, double *t, ulong _xparams);
        private static _dxv2_polynomialcalccheb1 _i_xv2_polynomialcalccheb1 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_polynomialcalccheb2(byte **error_msg, double *result, double *a, double *b, x_vector *f, x_int *n, double *t, ulong _xparams);
        private static _dxv2_polynomialcalccheb2 _i_xv2_polynomialcalccheb2 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spline1dbuildlinear(byte **error_msg, x_vector *x, x_vector *y, x_int *n, void **c, ulong _xparams);
        private static _dxv2_spline1dbuildlinear _i_xv2_spline1dbuildlinear = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spline1dbuildcubic(byte **error_msg, x_vector *x, x_vector *y, x_int *n, x_int *boundltype, double *boundl, x_int *boundrtype, double *boundr, void **c, ulong _xparams);
        private static _dxv2_spline1dbuildcubic _i_xv2_spline1dbuildcubic = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spline1dgriddiffcubic(byte **error_msg, x_vector *x, x_vector *y, x_int *n, x_int *boundltype, double *boundl, x_int *boundrtype, double *boundr, x_vector *d, ulong _xparams);
        private static _dxv2_spline1dgriddiffcubic _i_xv2_spline1dgriddiffcubic = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spline1dgriddiff2cubic(byte **error_msg, x_vector *x, x_vector *y, x_int *n, x_int *boundltype, double *boundl, x_int *boundrtype, double *boundr, x_vector *d1, x_vector *d2, ulong _xparams);
        private static _dxv2_spline1dgriddiff2cubic _i_xv2_spline1dgriddiff2cubic = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spline1dconvcubic(byte **error_msg, x_vector *x, x_vector *y, x_int *n, x_int *boundltype, double *boundl, x_int *boundrtype, double *boundr, x_vector *x2, x_int *n2, x_vector *y2, ulong _xparams);
        private static _dxv2_spline1dconvcubic _i_xv2_spline1dconvcubic = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spline1dconvdiffcubic(byte **error_msg, x_vector *x, x_vector *y, x_int *n, x_int *boundltype, double *boundl, x_int *boundrtype, double *boundr, x_vector *x2, x_int *n2, x_vector *y2, x_vector *d2, ulong _xparams);
        private static _dxv2_spline1dconvdiffcubic _i_xv2_spline1dconvdiffcubic = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spline1dconvdiff2cubic(byte **error_msg, x_vector *x, x_vector *y, x_int *n, x_int *boundltype, double *boundl, x_int *boundrtype, double *boundr, x_vector *x2, x_int *n2, x_vector *y2, x_vector *d2, x_vector *dd2, ulong _xparams);
        private static _dxv2_spline1dconvdiff2cubic _i_xv2_spline1dconvdiff2cubic = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spline1dbuildcatmullrom(byte **error_msg, x_vector *x, x_vector *y, x_int *n, x_int *boundtype, double *tension, void **c, ulong _xparams);
        private static _dxv2_spline1dbuildcatmullrom _i_xv2_spline1dbuildcatmullrom = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spline1dbuildhermite(byte **error_msg, x_vector *x, x_vector *y, x_vector *d, x_int *n, void **c, ulong _xparams);
        private static _dxv2_spline1dbuildhermite _i_xv2_spline1dbuildhermite = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spline1dbuildakima(byte **error_msg, x_vector *x, x_vector *y, x_int *n, void **c, ulong _xparams);
        private static _dxv2_spline1dbuildakima _i_xv2_spline1dbuildakima = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spline1dcalc(byte **error_msg, double *result, void **c, double *x, ulong _xparams);
        private static _dxv2_spline1dcalc _i_xv2_spline1dcalc = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spline1ddiff(byte **error_msg, void **c, double *x, double *s, double *ds, double *d2s, ulong _xparams);
        private static _dxv2_spline1ddiff _i_xv2_spline1ddiff = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spline1dunpack(byte **error_msg, void **c, x_int *n, x_matrix *tbl, ulong _xparams);
        private static _dxv2_spline1dunpack _i_xv2_spline1dunpack = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spline1dlintransx(byte **error_msg, void **c, double *a, double *b, ulong _xparams);
        private static _dxv2_spline1dlintransx _i_xv2_spline1dlintransx = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spline1dlintransy(byte **error_msg, void **c, double *a, double *b, ulong _xparams);
        private static _dxv2_spline1dlintransy _i_xv2_spline1dlintransy = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spline1dintegrate(byte **error_msg, double *result, void **c, double *x, ulong _xparams);
        private static _dxv2_spline1dintegrate _i_xv2_spline1dintegrate = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spline1dfit(byte **error_msg, x_vector *x, x_vector *y, x_int *n, x_int *m, double *lambdans, void **s, x_spline1dfitreport *rep, ulong _xparams);
        private static _dxv2_spline1dfit _i_xv2_spline1dfit = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spline1dbuildmonotone(byte **error_msg, x_vector *x, x_vector *y, x_int *n, void **c, ulong _xparams);
        private static _dxv2_spline1dbuildmonotone _i_xv2_spline1dbuildmonotone = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_lstfitpiecewiselinearrdpfixed(byte **error_msg, x_vector *x, x_vector *y, x_int *n, x_int *m, x_vector *x2, x_vector *y2, x_int *nsections, ulong _xparams);
        private static _dxv2_lstfitpiecewiselinearrdpfixed _i_xv2_lstfitpiecewiselinearrdpfixed = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_lstfitpiecewiselinearrdp(byte **error_msg, x_vector *x, x_vector *y, x_int *n, double *eps, x_vector *x2, x_vector *y2, x_int *nsections, ulong _xparams);
        private static _dxv2_lstfitpiecewiselinearrdp _i_xv2_lstfitpiecewiselinearrdp = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_polynomialfit(byte **error_msg, x_vector *x, x_vector *y, x_int *n, x_int *m, x_int *info, void **p, x_polynomialfitreport *rep, ulong _xparams);
        private static _dxv2_polynomialfit _i_xv2_polynomialfit = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_polynomialfitwc(byte **error_msg, x_vector *x, x_vector *y, x_vector *w, x_int *n, x_vector *xc, x_vector *yc, x_vector *dc, x_int *k, x_int *m, x_int *info, void **p, x_polynomialfitreport *rep, ulong _xparams);
        private static _dxv2_polynomialfitwc _i_xv2_polynomialfitwc = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_logisticcalc4(byte **error_msg, double *result, double *x, double *a, double *b, double *c, double *d, ulong _xparams);
        private static _dxv2_logisticcalc4 _i_xv2_logisticcalc4 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_logisticcalc5(byte **error_msg, double *result, double *x, double *a, double *b, double *c, double *d, double *g, ulong _xparams);
        private static _dxv2_logisticcalc5 _i_xv2_logisticcalc5 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_logisticfit4(byte **error_msg, x_vector *x, x_vector *y, x_int *n, double *a, double *b, double *c, double *d, x_lsfitreport *rep, ulong _xparams);
        private static _dxv2_logisticfit4 _i_xv2_logisticfit4 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_logisticfit4ec(byte **error_msg, x_vector *x, x_vector *y, x_int *n, double *cnstrleft, double *cnstrright, double *a, double *b, double *c, double *d, x_lsfitreport *rep, ulong _xparams);
        private static _dxv2_logisticfit4ec _i_xv2_logisticfit4ec = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_logisticfit5(byte **error_msg, x_vector *x, x_vector *y, x_int *n, double *a, double *b, double *c, double *d, double *g, x_lsfitreport *rep, ulong _xparams);
        private static _dxv2_logisticfit5 _i_xv2_logisticfit5 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_logisticfit5ec(byte **error_msg, x_vector *x, x_vector *y, x_int *n, double *cnstrleft, double *cnstrright, double *a, double *b, double *c, double *d, double *g, x_lsfitreport *rep, ulong _xparams);
        private static _dxv2_logisticfit5ec _i_xv2_logisticfit5ec = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_logisticfit45x(byte **error_msg, x_vector *x, x_vector *y, x_int *n, double *cnstrleft, double *cnstrright, byte *is4pl, double *lambdav, double *epsx, x_int *rscnt, double *a, double *b, double *c, double *d, double *g, x_lsfitreport *rep, ulong _xparams);
        private static _dxv2_logisticfit45x _i_xv2_logisticfit45x = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_barycentricfitfloaterhormannwc(byte **error_msg, x_vector *x, x_vector *y, x_vector *w, x_int *n, x_vector *xc, x_vector *yc, x_vector *dc, x_int *k, x_int *m, x_int *info, void **b, x_barycentricfitreport *rep, ulong _xparams);
        private static _dxv2_barycentricfitfloaterhormannwc _i_xv2_barycentricfitfloaterhormannwc = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_barycentricfitfloaterhormann(byte **error_msg, x_vector *x, x_vector *y, x_int *n, x_int *m, x_int *info, void **b, x_barycentricfitreport *rep, ulong _xparams);
        private static _dxv2_barycentricfitfloaterhormann _i_xv2_barycentricfitfloaterhormann = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spline1dfitcubicwc(byte **error_msg, x_vector *x, x_vector *y, x_vector *w, x_int *n, x_vector *xc, x_vector *yc, x_vector *dc, x_int *k, x_int *m, x_int *info, void **s, x_spline1dfitreport *rep, ulong _xparams);
        private static _dxv2_spline1dfitcubicwc _i_xv2_spline1dfitcubicwc = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spline1dfithermitewc(byte **error_msg, x_vector *x, x_vector *y, x_vector *w, x_int *n, x_vector *xc, x_vector *yc, x_vector *dc, x_int *k, x_int *m, x_int *info, void **s, x_spline1dfitreport *rep, ulong _xparams);
        private static _dxv2_spline1dfithermitewc _i_xv2_spline1dfithermitewc = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spline1dfitcubic(byte **error_msg, x_vector *x, x_vector *y, x_int *n, x_int *m, x_int *info, void **s, x_spline1dfitreport *rep, ulong _xparams);
        private static _dxv2_spline1dfitcubic _i_xv2_spline1dfitcubic = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spline1dfithermite(byte **error_msg, x_vector *x, x_vector *y, x_int *n, x_int *m, x_int *info, void **s, x_spline1dfitreport *rep, ulong _xparams);
        private static _dxv2_spline1dfithermite _i_xv2_spline1dfithermite = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_lsfitlinearw(byte **error_msg, x_vector *y, x_vector *w, x_matrix *fmatrix, x_int *n, x_int *m, x_int *info, x_vector *c, x_lsfitreport *rep, ulong _xparams);
        private static _dxv2_lsfitlinearw _i_xv2_lsfitlinearw = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_lsfitlinearwc(byte **error_msg, x_vector *y, x_vector *w, x_matrix *fmatrix, x_matrix *cmatrix, x_int *n, x_int *m, x_int *k, x_int *info, x_vector *c, x_lsfitreport *rep, ulong _xparams);
        private static _dxv2_lsfitlinearwc _i_xv2_lsfitlinearwc = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_lsfitlinear(byte **error_msg, x_vector *y, x_matrix *fmatrix, x_int *n, x_int *m, x_int *info, x_vector *c, x_lsfitreport *rep, ulong _xparams);
        private static _dxv2_lsfitlinear _i_xv2_lsfitlinear = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_lsfitlinearc(byte **error_msg, x_vector *y, x_matrix *fmatrix, x_matrix *cmatrix, x_int *n, x_int *m, x_int *k, x_int *info, x_vector *c, x_lsfitreport *rep, ulong _xparams);
        private static _dxv2_lsfitlinearc _i_xv2_lsfitlinearc = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_lsfitcreatewf(byte **error_msg, x_matrix *x, x_vector *y, x_vector *w, x_vector *c, x_int *n, x_int *m, x_int *k, double *diffstep, void **state, ulong _xparams);
        private static _dxv2_lsfitcreatewf _i_xv2_lsfitcreatewf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_lsfitcreatef(byte **error_msg, x_matrix *x, x_vector *y, x_vector *c, x_int *n, x_int *m, x_int *k, double *diffstep, void **state, ulong _xparams);
        private static _dxv2_lsfitcreatef _i_xv2_lsfitcreatef = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_lsfitcreatewfg(byte **error_msg, x_matrix *x, x_vector *y, x_vector *w, x_vector *c, x_int *n, x_int *m, x_int *k, byte *cheapfg, void **state, ulong _xparams);
        private static _dxv2_lsfitcreatewfg _i_xv2_lsfitcreatewfg = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_lsfitcreatefg(byte **error_msg, x_matrix *x, x_vector *y, x_vector *c, x_int *n, x_int *m, x_int *k, byte *cheapfg, void **state, ulong _xparams);
        private static _dxv2_lsfitcreatefg _i_xv2_lsfitcreatefg = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_lsfitcreatewfgh(byte **error_msg, x_matrix *x, x_vector *y, x_vector *w, x_vector *c, x_int *n, x_int *m, x_int *k, void **state, ulong _xparams);
        private static _dxv2_lsfitcreatewfgh _i_xv2_lsfitcreatewfgh = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_lsfitcreatefgh(byte **error_msg, x_matrix *x, x_vector *y, x_vector *c, x_int *n, x_int *m, x_int *k, void **state, ulong _xparams);
        private static _dxv2_lsfitcreatefgh _i_xv2_lsfitcreatefgh = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_lsfitsetcond(byte **error_msg, void **state, double *epsx, x_int *maxits, ulong _xparams);
        private static _dxv2_lsfitsetcond _i_xv2_lsfitsetcond = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_lsfitsetstpmax(byte **error_msg, void **state, double *stpmax, ulong _xparams);
        private static _dxv2_lsfitsetstpmax _i_xv2_lsfitsetstpmax = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_lsfitsetxrep(byte **error_msg, void **state, byte *needxrep, ulong _xparams);
        private static _dxv2_lsfitsetxrep _i_xv2_lsfitsetxrep = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_lsfitsetscale(byte **error_msg, void **state, x_vector *s, ulong _xparams);
        private static _dxv2_lsfitsetscale _i_xv2_lsfitsetscale = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_lsfitsetbc(byte **error_msg, void **state, x_vector *bndl, x_vector *bndu, ulong _xparams);
        private static _dxv2_lsfitsetbc _i_xv2_lsfitsetbc = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_lsfitsetlc(byte **error_msg, void **state, x_matrix *c, x_vector *ct, x_int *k, ulong _xparams);
        private static _dxv2_lsfitsetlc _i_xv2_lsfitsetlc = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_lsfititeration(byte **error_msg, byte *result, void **state, ulong _xparams);
        private static _dxv2_lsfititeration _i_xv2_lsfititeration = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_lsfitresults(byte **error_msg, void **state, x_int *info, x_vector *c, x_lsfitreport *rep, ulong _xparams);
        private static _dxv2_lsfitresults _i_xv2_lsfitresults = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_lsfitsetgradientcheck(byte **error_msg, void **state, double *teststep, ulong _xparams);
        private static _dxv2_lsfitsetgradientcheck _i_xv2_lsfitsetgradientcheck = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_fitspherels(byte **error_msg, x_matrix *xy, x_int *npoints, x_int *nx, x_vector *cx, double *r, ulong _xparams);
        private static _dxv2_fitspherels _i_xv2_fitspherels = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_fitspheremc(byte **error_msg, x_matrix *xy, x_int *npoints, x_int *nx, x_vector *cx, double *rhi, ulong _xparams);
        private static _dxv2_fitspheremc _i_xv2_fitspheremc = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_fitspheremi(byte **error_msg, x_matrix *xy, x_int *npoints, x_int *nx, x_vector *cx, double *rlo, ulong _xparams);
        private static _dxv2_fitspheremi _i_xv2_fitspheremi = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_fitspheremz(byte **error_msg, x_matrix *xy, x_int *npoints, x_int *nx, x_vector *cx, double *rlo, double *rhi, ulong _xparams);
        private static _dxv2_fitspheremz _i_xv2_fitspheremz = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_fitspherex(byte **error_msg, x_matrix *xy, x_int *npoints, x_int *nx, x_int *problemtype, double *epsx, x_int *aulits, double *penalty, x_vector *cx, double *rlo, double *rhi, ulong _xparams);
        private static _dxv2_fitspherex _i_xv2_fitspherex = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_pspline2build(byte **error_msg, x_matrix *xy, x_int *n, x_int *st, x_int *pt, void **p, ulong _xparams);
        private static _dxv2_pspline2build _i_xv2_pspline2build = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_pspline3build(byte **error_msg, x_matrix *xy, x_int *n, x_int *st, x_int *pt, void **p, ulong _xparams);
        private static _dxv2_pspline3build _i_xv2_pspline3build = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_pspline2buildperiodic(byte **error_msg, x_matrix *xy, x_int *n, x_int *st, x_int *pt, void **p, ulong _xparams);
        private static _dxv2_pspline2buildperiodic _i_xv2_pspline2buildperiodic = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_pspline3buildperiodic(byte **error_msg, x_matrix *xy, x_int *n, x_int *st, x_int *pt, void **p, ulong _xparams);
        private static _dxv2_pspline3buildperiodic _i_xv2_pspline3buildperiodic = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_pspline2parametervalues(byte **error_msg, void **p, x_int *n, x_vector *t, ulong _xparams);
        private static _dxv2_pspline2parametervalues _i_xv2_pspline2parametervalues = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_pspline3parametervalues(byte **error_msg, void **p, x_int *n, x_vector *t, ulong _xparams);
        private static _dxv2_pspline3parametervalues _i_xv2_pspline3parametervalues = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_pspline2calc(byte **error_msg, void **p, double *t, double *x, double *y, ulong _xparams);
        private static _dxv2_pspline2calc _i_xv2_pspline2calc = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_pspline3calc(byte **error_msg, void **p, double *t, double *x, double *y, double *z, ulong _xparams);
        private static _dxv2_pspline3calc _i_xv2_pspline3calc = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_pspline2tangent(byte **error_msg, void **p, double *t, double *x, double *y, ulong _xparams);
        private static _dxv2_pspline2tangent _i_xv2_pspline2tangent = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_pspline3tangent(byte **error_msg, void **p, double *t, double *x, double *y, double *z, ulong _xparams);
        private static _dxv2_pspline3tangent _i_xv2_pspline3tangent = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_pspline2diff(byte **error_msg, void **p, double *t, double *x, double *dx, double *y, double *dy, ulong _xparams);
        private static _dxv2_pspline2diff _i_xv2_pspline2diff = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_pspline3diff(byte **error_msg, void **p, double *t, double *x, double *dx, double *y, double *dy, double *z, double *dz, ulong _xparams);
        private static _dxv2_pspline3diff _i_xv2_pspline3diff = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_pspline2diff2(byte **error_msg, void **p, double *t, double *x, double *dx, double *d2x, double *y, double *dy, double *d2y, ulong _xparams);
        private static _dxv2_pspline2diff2 _i_xv2_pspline2diff2 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_pspline3diff2(byte **error_msg, void **p, double *t, double *x, double *dx, double *d2x, double *y, double *dy, double *d2y, double *z, double *dz, double *d2z, ulong _xparams);
        private static _dxv2_pspline3diff2 _i_xv2_pspline3diff2 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_pspline2arclength(byte **error_msg, double *result, void **p, double *a, double *b, ulong _xparams);
        private static _dxv2_pspline2arclength _i_xv2_pspline2arclength = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_pspline3arclength(byte **error_msg, double *result, void **p, double *a, double *b, ulong _xparams);
        private static _dxv2_pspline3arclength _i_xv2_pspline3arclength = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_parametricrdpfixed(byte **error_msg, x_matrix *x, x_int *n, x_int *d, x_int *stopm, double *stopeps, x_matrix *x2, x_vector *idx2, x_int *nsections, ulong _xparams);
        private static _dxv2_parametricrdpfixed _i_xv2_parametricrdpfixed = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_x_spline2dserialize(byte **error_msg, void **x, byte **dst);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_x_spline2dunserialize(byte **error_msg, byte **src, void **x);
        private static _d_x_spline2dserialize   _i_x_spline2dserialize   = null;
        private static _d_x_spline2dunserialize _i_x_spline2dunserialize = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_x_spline2dserialize_stream(byte **error_msg, void **x, native_stream_adapter.writer_delegate writer, IntPtr aux);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_x_spline2dunserialize_stream(byte **error_msg, native_stream_adapter.reader_delegate reader, IntPtr aux, void **x);
        private static _d_x_spline2dserialize_stream   _i_x_spline2dserialize_stream   = null;
        private static _d_x_spline2dunserialize_stream _i_x_spline2dunserialize_stream = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spline2dcalc(byte **error_msg, double *result, void **c, double *x, double *y, ulong _xparams);
        private static _dxv2_spline2dcalc _i_xv2_spline2dcalc = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spline2ddiff(byte **error_msg, void **c, double *x, double *y, double *f, double *fx, double *fy, double *fxy, ulong _xparams);
        private static _dxv2_spline2ddiff _i_xv2_spline2ddiff = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spline2dcalcvbuf(byte **error_msg, void **c, double *x, double *y, x_vector *f, ulong _xparams);
        private static _dxv2_spline2dcalcvbuf _i_xv2_spline2dcalcvbuf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spline2dcalcvi(byte **error_msg, double *result, void **c, double *x, double *y, x_int *i, ulong _xparams);
        private static _dxv2_spline2dcalcvi _i_xv2_spline2dcalcvi = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spline2dcalcv(byte **error_msg, void **c, double *x, double *y, x_vector *f, ulong _xparams);
        private static _dxv2_spline2dcalcv _i_xv2_spline2dcalcv = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spline2ddiffvi(byte **error_msg, void **c, double *x, double *y, x_int *i, double *f, double *fx, double *fy, double *fxy, ulong _xparams);
        private static _dxv2_spline2ddiffvi _i_xv2_spline2ddiffvi = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spline2dlintransxy(byte **error_msg, void **c, double *ax, double *bx, double *ay, double *by, ulong _xparams);
        private static _dxv2_spline2dlintransxy _i_xv2_spline2dlintransxy = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spline2dlintransf(byte **error_msg, void **c, double *a, double *b, ulong _xparams);
        private static _dxv2_spline2dlintransf _i_xv2_spline2dlintransf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spline2dcopy(byte **error_msg, void **c, void **cc, ulong _xparams);
        private static _dxv2_spline2dcopy _i_xv2_spline2dcopy = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spline2dresamplebicubic(byte **error_msg, x_matrix *a, x_int *oldheight, x_int *oldwidth, x_matrix *b, x_int *newheight, x_int *newwidth, ulong _xparams);
        private static _dxv2_spline2dresamplebicubic _i_xv2_spline2dresamplebicubic = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spline2dresamplebilinear(byte **error_msg, x_matrix *a, x_int *oldheight, x_int *oldwidth, x_matrix *b, x_int *newheight, x_int *newwidth, ulong _xparams);
        private static _dxv2_spline2dresamplebilinear _i_xv2_spline2dresamplebilinear = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spline2dbuildbilinearv(byte **error_msg, x_vector *x, x_int *n, x_vector *y, x_int *m, x_vector *f, x_int *d, void **c, ulong _xparams);
        private static _dxv2_spline2dbuildbilinearv _i_xv2_spline2dbuildbilinearv = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spline2dbuildbilinearmissing(byte **error_msg, x_vector *x, x_int *n, x_vector *y, x_int *m, x_vector *f, x_vector *missing, x_int *d, void **c, ulong _xparams);
        private static _dxv2_spline2dbuildbilinearmissing _i_xv2_spline2dbuildbilinearmissing = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spline2dbuildbicubicv(byte **error_msg, x_vector *x, x_int *n, x_vector *y, x_int *m, x_vector *f, x_int *d, void **c, ulong _xparams);
        private static _dxv2_spline2dbuildbicubicv _i_xv2_spline2dbuildbicubicv = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spline2dbuildbicubicmissing(byte **error_msg, x_vector *x, x_int *n, x_vector *y, x_int *m, x_vector *f, x_vector *missing, x_int *d, void **c, ulong _xparams);
        private static _dxv2_spline2dbuildbicubicmissing _i_xv2_spline2dbuildbicubicmissing = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spline2dunpackv(byte **error_msg, void **c, x_int *m, x_int *n, x_int *d, x_matrix *tbl, ulong _xparams);
        private static _dxv2_spline2dunpackv _i_xv2_spline2dunpackv = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spline2dbuildbilinear(byte **error_msg, x_vector *x, x_vector *y, x_matrix *f, x_int *m, x_int *n, void **c, ulong _xparams);
        private static _dxv2_spline2dbuildbilinear _i_xv2_spline2dbuildbilinear = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spline2dbuildbicubic(byte **error_msg, x_vector *x, x_vector *y, x_matrix *f, x_int *m, x_int *n, void **c, ulong _xparams);
        private static _dxv2_spline2dbuildbicubic _i_xv2_spline2dbuildbicubic = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spline2dunpack(byte **error_msg, void **c, x_int *m, x_int *n, x_matrix *tbl, ulong _xparams);
        private static _dxv2_spline2dunpack _i_xv2_spline2dunpack = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spline2dbuildercreate(byte **error_msg, x_int *d, void **state, ulong _xparams);
        private static _dxv2_spline2dbuildercreate _i_xv2_spline2dbuildercreate = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spline2dbuildersetuserterm(byte **error_msg, void **state, double *v, ulong _xparams);
        private static _dxv2_spline2dbuildersetuserterm _i_xv2_spline2dbuildersetuserterm = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spline2dbuildersetlinterm(byte **error_msg, void **state, ulong _xparams);
        private static _dxv2_spline2dbuildersetlinterm _i_xv2_spline2dbuildersetlinterm = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spline2dbuildersetconstterm(byte **error_msg, void **state, ulong _xparams);
        private static _dxv2_spline2dbuildersetconstterm _i_xv2_spline2dbuildersetconstterm = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spline2dbuildersetzeroterm(byte **error_msg, void **state, ulong _xparams);
        private static _dxv2_spline2dbuildersetzeroterm _i_xv2_spline2dbuildersetzeroterm = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spline2dbuildersetpoints(byte **error_msg, void **state, x_matrix *xy, x_int *n, ulong _xparams);
        private static _dxv2_spline2dbuildersetpoints _i_xv2_spline2dbuildersetpoints = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spline2dbuildersetareaauto(byte **error_msg, void **state, ulong _xparams);
        private static _dxv2_spline2dbuildersetareaauto _i_xv2_spline2dbuildersetareaauto = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spline2dbuildersetarea(byte **error_msg, void **state, double *xa, double *xb, double *ya, double *yb, ulong _xparams);
        private static _dxv2_spline2dbuildersetarea _i_xv2_spline2dbuildersetarea = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spline2dbuildersetgrid(byte **error_msg, void **state, x_int *kx, x_int *ky, ulong _xparams);
        private static _dxv2_spline2dbuildersetgrid _i_xv2_spline2dbuildersetgrid = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spline2dbuildersetalgofastddm(byte **error_msg, void **state, x_int *nlayers, double *lambdav, ulong _xparams);
        private static _dxv2_spline2dbuildersetalgofastddm _i_xv2_spline2dbuildersetalgofastddm = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spline2dbuildersetalgoblocklls(byte **error_msg, void **state, double *lambdans, ulong _xparams);
        private static _dxv2_spline2dbuildersetalgoblocklls _i_xv2_spline2dbuildersetalgoblocklls = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spline2dbuildersetalgonaivells(byte **error_msg, void **state, double *lambdans, ulong _xparams);
        private static _dxv2_spline2dbuildersetalgonaivells _i_xv2_spline2dbuildersetalgonaivells = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spline2dfit(byte **error_msg, void **state, void **s, x_spline2dfitreport *rep, ulong _xparams);
        private static _dxv2_spline2dfit _i_xv2_spline2dfit = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spline3dcalc(byte **error_msg, double *result, void **c, double *x, double *y, double *z, ulong _xparams);
        private static _dxv2_spline3dcalc _i_xv2_spline3dcalc = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spline3dlintransxyz(byte **error_msg, void **c, double *ax, double *bx, double *ay, double *by, double *az, double *bz, ulong _xparams);
        private static _dxv2_spline3dlintransxyz _i_xv2_spline3dlintransxyz = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spline3dlintransf(byte **error_msg, void **c, double *a, double *b, ulong _xparams);
        private static _dxv2_spline3dlintransf _i_xv2_spline3dlintransf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spline3dresampletrilinear(byte **error_msg, x_vector *a, x_int *oldzcount, x_int *oldycount, x_int *oldxcount, x_int *newzcount, x_int *newycount, x_int *newxcount, x_vector *b, ulong _xparams);
        private static _dxv2_spline3dresampletrilinear _i_xv2_spline3dresampletrilinear = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spline3dbuildtrilinearv(byte **error_msg, x_vector *x, x_int *n, x_vector *y, x_int *m, x_vector *z, x_int *l, x_vector *f, x_int *d, void **c, ulong _xparams);
        private static _dxv2_spline3dbuildtrilinearv _i_xv2_spline3dbuildtrilinearv = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spline3dcalcvbuf(byte **error_msg, void **c, double *x, double *y, double *z, x_vector *f, ulong _xparams);
        private static _dxv2_spline3dcalcvbuf _i_xv2_spline3dcalcvbuf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spline3dcalcv(byte **error_msg, void **c, double *x, double *y, double *z, x_vector *f, ulong _xparams);
        private static _dxv2_spline3dcalcv _i_xv2_spline3dcalcv = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spline3dunpackv(byte **error_msg, void **c, x_int *n, x_int *m, x_int *l, x_int *d, x_int *stype, x_matrix *tbl, ulong _xparams);
        private static _dxv2_spline3dunpackv _i_xv2_spline3dunpackv = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_nsfitspheremcc(byte **error_msg, x_matrix *xy, x_int *npoints, x_int *nx, x_vector *cx, double *rhi, ulong _xparams);
        private static _dxv2_nsfitspheremcc _i_xv2_nsfitspheremcc = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_nsfitspheremic(byte **error_msg, x_matrix *xy, x_int *npoints, x_int *nx, x_vector *cx, double *rlo, ulong _xparams);
        private static _dxv2_nsfitspheremic _i_xv2_nsfitspheremic = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_nsfitspheremzc(byte **error_msg, x_matrix *xy, x_int *npoints, x_int *nx, x_vector *cx, double *rlo, double *rhi, ulong _xparams);
        private static _dxv2_nsfitspheremzc _i_xv2_nsfitspheremzc = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_nsfitspherex(byte **error_msg, x_matrix *xy, x_int *npoints, x_int *nx, x_int *problemtype, double *epsx, x_int *aulits, double *penalty, x_vector *cx, double *rlo, double *rhi, ulong _xparams);
        private static _dxv2_nsfitspherex _i_xv2_nsfitspherex = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spline1dfitpenalized(byte **error_msg, x_vector *x, x_vector *y, x_int *n, x_int *m, double *rho, x_int *info, void **s, x_spline1dfitreport *rep, ulong _xparams);
        private static _dxv2_spline1dfitpenalized _i_xv2_spline1dfitpenalized = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_spline1dfitpenalizedw(byte **error_msg, x_vector *x, x_vector *y, x_vector *w, x_int *n, x_int *m, double *rho, x_int *info, void **s, x_spline1dfitreport *rep, ulong _xparams);
        private static _dxv2_spline1dfitpenalizedw _i_xv2_spline1dfitpenalizedw = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_x_rbfserialize(byte **error_msg, void **x, byte **dst);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_x_rbfunserialize(byte **error_msg, byte **src, void **x);
        private static _d_x_rbfserialize   _i_x_rbfserialize   = null;
        private static _d_x_rbfunserialize _i_x_rbfunserialize = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_x_rbfserialize_stream(byte **error_msg, void **x, native_stream_adapter.writer_delegate writer, IntPtr aux);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_x_rbfunserialize_stream(byte **error_msg, native_stream_adapter.reader_delegate reader, IntPtr aux, void **x);
        private static _d_x_rbfserialize_stream   _i_x_rbfserialize_stream   = null;
        private static _d_x_rbfunserialize_stream _i_x_rbfunserialize_stream = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rbfcreate(byte **error_msg, x_int *nx, x_int *ny, void **s, ulong _xparams);
        private static _dxv2_rbfcreate _i_xv2_rbfcreate = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rbfcreatecalcbuffer(byte **error_msg, void **s, void **buf, ulong _xparams);
        private static _dxv2_rbfcreatecalcbuffer _i_xv2_rbfcreatecalcbuffer = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rbfsetpoints(byte **error_msg, void **s, x_matrix *xy, x_int *n, ulong _xparams);
        private static _dxv2_rbfsetpoints _i_xv2_rbfsetpoints = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rbfsetpointsandscales(byte **error_msg, void **r, x_matrix *xy, x_int *n, x_vector *s, ulong _xparams);
        private static _dxv2_rbfsetpointsandscales _i_xv2_rbfsetpointsandscales = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rbfsetalgoqnn(byte **error_msg, void **s, double *q, double *z, ulong _xparams);
        private static _dxv2_rbfsetalgoqnn _i_xv2_rbfsetalgoqnn = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rbfsetalgomultilayer(byte **error_msg, void **s, double *rbase, x_int *nlayers, double *lambdav, ulong _xparams);
        private static _dxv2_rbfsetalgomultilayer _i_xv2_rbfsetalgomultilayer = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rbfsetalgohierarchical(byte **error_msg, void **s, double *rbase, x_int *nlayers, double *lambdans, ulong _xparams);
        private static _dxv2_rbfsetalgohierarchical _i_xv2_rbfsetalgohierarchical = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rbfsetalgothinplatespline(byte **error_msg, void **s, double *lambdav, ulong _xparams);
        private static _dxv2_rbfsetalgothinplatespline _i_xv2_rbfsetalgothinplatespline = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rbfsetalgomultiquadricmanual(byte **error_msg, void **s, double *alpha, double *lambdav, ulong _xparams);
        private static _dxv2_rbfsetalgomultiquadricmanual _i_xv2_rbfsetalgomultiquadricmanual = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rbfsetalgomultiquadricauto(byte **error_msg, void **s, double *lambdav, ulong _xparams);
        private static _dxv2_rbfsetalgomultiquadricauto _i_xv2_rbfsetalgomultiquadricauto = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rbfsetalgobiharmonic(byte **error_msg, void **s, double *lambdav, ulong _xparams);
        private static _dxv2_rbfsetalgobiharmonic _i_xv2_rbfsetalgobiharmonic = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rbfsetlinterm(byte **error_msg, void **s, ulong _xparams);
        private static _dxv2_rbfsetlinterm _i_xv2_rbfsetlinterm = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rbfsetconstterm(byte **error_msg, void **s, ulong _xparams);
        private static _dxv2_rbfsetconstterm _i_xv2_rbfsetconstterm = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rbfsetzeroterm(byte **error_msg, void **s, ulong _xparams);
        private static _dxv2_rbfsetzeroterm _i_xv2_rbfsetzeroterm = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rbfsetv2bf(byte **error_msg, void **s, x_int *bf, ulong _xparams);
        private static _dxv2_rbfsetv2bf _i_xv2_rbfsetv2bf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rbfsetv2its(byte **error_msg, void **s, x_int *maxits, ulong _xparams);
        private static _dxv2_rbfsetv2its _i_xv2_rbfsetv2its = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rbfsetv2supportr(byte **error_msg, void **s, double *r, ulong _xparams);
        private static _dxv2_rbfsetv2supportr _i_xv2_rbfsetv2supportr = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rbfsetv3tol(byte **error_msg, void **s, double *tol, ulong _xparams);
        private static _dxv2_rbfsetv3tol _i_xv2_rbfsetv3tol = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rbfbuildmodel(byte **error_msg, void **s, x_rbfreport *rep, ulong _xparams);
        private static _dxv2_rbfbuildmodel _i_xv2_rbfbuildmodel = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rbfcalc1(byte **error_msg, double *result, void **s, double *x0, ulong _xparams);
        private static _dxv2_rbfcalc1 _i_xv2_rbfcalc1 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rbfcalc2(byte **error_msg, double *result, void **s, double *x0, double *x1, ulong _xparams);
        private static _dxv2_rbfcalc2 _i_xv2_rbfcalc2 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rbfcalc3(byte **error_msg, double *result, void **s, double *x0, double *x1, double *x2, ulong _xparams);
        private static _dxv2_rbfcalc3 _i_xv2_rbfcalc3 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rbfdiff1(byte **error_msg, void **s, double *x0, double *y, double *dy0, ulong _xparams);
        private static _dxv2_rbfdiff1 _i_xv2_rbfdiff1 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rbfdiff2(byte **error_msg, void **s, double *x0, double *x1, double *y, double *dy0, double *dy1, ulong _xparams);
        private static _dxv2_rbfdiff2 _i_xv2_rbfdiff2 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rbfdiff3(byte **error_msg, void **s, double *x0, double *x1, double *x2, double *y, double *dy0, double *dy1, double *dy2, ulong _xparams);
        private static _dxv2_rbfdiff3 _i_xv2_rbfdiff3 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rbfsetfastevaltol(byte **error_msg, void **s, double *tol, ulong _xparams);
        private static _dxv2_rbfsetfastevaltol _i_xv2_rbfsetfastevaltol = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rbffastcalc(byte **error_msg, void **s, x_vector *x, x_vector *y, ulong _xparams);
        private static _dxv2_rbffastcalc _i_xv2_rbffastcalc = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rbfcalc(byte **error_msg, void **s, x_vector *x, x_vector *y, ulong _xparams);
        private static _dxv2_rbfcalc _i_xv2_rbfcalc = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rbfdiff(byte **error_msg, void **s, x_vector *x, x_vector *y, x_vector *dy, ulong _xparams);
        private static _dxv2_rbfdiff _i_xv2_rbfdiff = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rbfhess(byte **error_msg, void **s, x_vector *x, x_vector *y, x_vector *dy, x_vector *d2y, ulong _xparams);
        private static _dxv2_rbfhess _i_xv2_rbfhess = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rbfcalcbuf(byte **error_msg, void **s, x_vector *x, x_vector *y, ulong _xparams);
        private static _dxv2_rbfcalcbuf _i_xv2_rbfcalcbuf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rbfdiffbuf(byte **error_msg, void **s, x_vector *x, x_vector *y, x_vector *dy, ulong _xparams);
        private static _dxv2_rbfdiffbuf _i_xv2_rbfdiffbuf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rbfhessbuf(byte **error_msg, void **s, x_vector *x, x_vector *y, x_vector *dy, x_vector *d2y, ulong _xparams);
        private static _dxv2_rbfhessbuf _i_xv2_rbfhessbuf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rbftscalcbuf(byte **error_msg, void **s, void **buf, x_vector *x, x_vector *y, ulong _xparams);
        private static _dxv2_rbftscalcbuf _i_xv2_rbftscalcbuf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rbftsdiffbuf(byte **error_msg, void **s, void **buf, x_vector *x, x_vector *y, x_vector *dy, ulong _xparams);
        private static _dxv2_rbftsdiffbuf _i_xv2_rbftsdiffbuf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rbftshessbuf(byte **error_msg, void **s, void **buf, x_vector *x, x_vector *y, x_vector *dy, x_vector *d2y, ulong _xparams);
        private static _dxv2_rbftshessbuf _i_xv2_rbftshessbuf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rbfgridcalc2(byte **error_msg, void **s, x_vector *x0, x_int *n0, x_vector *x1, x_int *n1, x_matrix *y, ulong _xparams);
        private static _dxv2_rbfgridcalc2 _i_xv2_rbfgridcalc2 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rbfgridcalc2v(byte **error_msg, void **s, x_vector *x0, x_int *n0, x_vector *x1, x_int *n1, x_vector *y, ulong _xparams);
        private static _dxv2_rbfgridcalc2v _i_xv2_rbfgridcalc2v = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rbfgridcalc2vsubset(byte **error_msg, void **s, x_vector *x0, x_int *n0, x_vector *x1, x_int *n1, x_vector *flagy, x_vector *y, ulong _xparams);
        private static _dxv2_rbfgridcalc2vsubset _i_xv2_rbfgridcalc2vsubset = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rbfgridcalc3v(byte **error_msg, void **s, x_vector *x0, x_int *n0, x_vector *x1, x_int *n1, x_vector *x2, x_int *n2, x_vector *y, ulong _xparams);
        private static _dxv2_rbfgridcalc3v _i_xv2_rbfgridcalc3v = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rbfgridcalc3vsubset(byte **error_msg, void **s, x_vector *x0, x_int *n0, x_vector *x1, x_int *n1, x_vector *x2, x_int *n2, x_vector *flagy, x_vector *y, ulong _xparams);
        private static _dxv2_rbfgridcalc3vsubset _i_xv2_rbfgridcalc3vsubset = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rbfunpack(byte **error_msg, void **s, x_int *nx, x_int *ny, x_matrix *xwr, x_int *nc, x_matrix *v, x_int *modelversion, ulong _xparams);
        private static _dxv2_rbfunpack _i_xv2_rbfunpack = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rbfgetmodelversion(byte **error_msg, x_int *result, void **s, ulong _xparams);
        private static _dxv2_rbfgetmodelversion _i_xv2_rbfgetmodelversion = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rbfpeekprogress(byte **error_msg, double *result, void **s, ulong _xparams);
        private static _dxv2_rbfpeekprogress _i_xv2_rbfpeekprogress = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_rbfrequesttermination(byte **error_msg, void **s, ulong _xparams);
        private static _dxv2_rbfrequesttermination _i_xv2_rbfrequesttermination = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_fftc1d(byte **error_msg, x_vector *a, x_int *n, ulong _xparams);
        private static _dxv2_fftc1d _i_xv2_fftc1d = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_fftc1dinv(byte **error_msg, x_vector *a, x_int *n, ulong _xparams);
        private static _dxv2_fftc1dinv _i_xv2_fftc1dinv = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_fftr1d(byte **error_msg, x_vector *a, x_int *n, x_vector *f, ulong _xparams);
        private static _dxv2_fftr1d _i_xv2_fftr1d = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_fftr1dinv(byte **error_msg, x_vector *f, x_int *n, x_vector *a, ulong _xparams);
        private static _dxv2_fftr1dinv _i_xv2_fftr1dinv = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_fhtr1d(byte **error_msg, x_vector *a, x_int *n, ulong _xparams);
        private static _dxv2_fhtr1d _i_xv2_fhtr1d = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_fhtr1dinv(byte **error_msg, x_vector *a, x_int *n, ulong _xparams);
        private static _dxv2_fhtr1dinv _i_xv2_fhtr1dinv = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_convc1d(byte **error_msg, x_vector *a, x_int *m, x_vector *b, x_int *n, x_vector *r, ulong _xparams);
        private static _dxv2_convc1d _i_xv2_convc1d = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_convc1dinv(byte **error_msg, x_vector *a, x_int *m, x_vector *b, x_int *n, x_vector *r, ulong _xparams);
        private static _dxv2_convc1dinv _i_xv2_convc1dinv = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_convc1dcircular(byte **error_msg, x_vector *s, x_int *m, x_vector *r, x_int *n, x_vector *c, ulong _xparams);
        private static _dxv2_convc1dcircular _i_xv2_convc1dcircular = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_convc1dcircularinv(byte **error_msg, x_vector *a, x_int *m, x_vector *b, x_int *n, x_vector *r, ulong _xparams);
        private static _dxv2_convc1dcircularinv _i_xv2_convc1dcircularinv = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_convr1d(byte **error_msg, x_vector *a, x_int *m, x_vector *b, x_int *n, x_vector *r, ulong _xparams);
        private static _dxv2_convr1d _i_xv2_convr1d = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_convr1dinv(byte **error_msg, x_vector *a, x_int *m, x_vector *b, x_int *n, x_vector *r, ulong _xparams);
        private static _dxv2_convr1dinv _i_xv2_convr1dinv = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_convr1dcircular(byte **error_msg, x_vector *s, x_int *m, x_vector *r, x_int *n, x_vector *c, ulong _xparams);
        private static _dxv2_convr1dcircular _i_xv2_convr1dcircular = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_convr1dcircularinv(byte **error_msg, x_vector *a, x_int *m, x_vector *b, x_int *n, x_vector *r, ulong _xparams);
        private static _dxv2_convr1dcircularinv _i_xv2_convr1dcircularinv = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_corrc1d(byte **error_msg, x_vector *signal, x_int *n, x_vector *pattern, x_int *m, x_vector *r, ulong _xparams);
        private static _dxv2_corrc1d _i_xv2_corrc1d = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_corrc1dcircular(byte **error_msg, x_vector *signal, x_int *m, x_vector *pattern, x_int *n, x_vector *c, ulong _xparams);
        private static _dxv2_corrc1dcircular _i_xv2_corrc1dcircular = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_corrr1d(byte **error_msg, x_vector *signal, x_int *n, x_vector *pattern, x_int *m, x_vector *r, ulong _xparams);
        private static _dxv2_corrr1d _i_xv2_corrr1d = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_corrr1dcircular(byte **error_msg, x_vector *signal, x_int *m, x_vector *pattern, x_int *n, x_vector *c, ulong _xparams);
        private static _dxv2_corrr1dcircular _i_xv2_corrr1dcircular = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_exponentialintegralei(byte **error_msg, double *result, double *x, ulong _xparams);
        private static _dxv2_exponentialintegralei _i_xv2_exponentialintegralei = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_exponentialintegralen(byte **error_msg, double *result, double *x, x_int *n, ulong _xparams);
        private static _dxv2_exponentialintegralen _i_xv2_exponentialintegralen = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_jacobianellipticfunctions(byte **error_msg, double *u, double *m, double *sn, double *cn, double *dn, double *ph, ulong _xparams);
        private static _dxv2_jacobianellipticfunctions _i_xv2_jacobianellipticfunctions = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_sinecosineintegrals(byte **error_msg, double *x, double *si, double *ci, ulong _xparams);
        private static _dxv2_sinecosineintegrals _i_xv2_sinecosineintegrals = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_hyperbolicsinecosineintegrals(byte **error_msg, double *x, double *shi, double *chi, ulong _xparams);
        private static _dxv2_hyperbolicsinecosineintegrals _i_xv2_hyperbolicsinecosineintegrals = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_chebyshevcalculate(byte **error_msg, double *result, x_int *r, x_int *n, double *x, ulong _xparams);
        private static _dxv2_chebyshevcalculate _i_xv2_chebyshevcalculate = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_chebyshevsum(byte **error_msg, double *result, x_vector *c, x_int *r, x_int *n, double *x, ulong _xparams);
        private static _dxv2_chebyshevsum _i_xv2_chebyshevsum = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_chebyshevcoefficients(byte **error_msg, x_int *n, x_vector *c, ulong _xparams);
        private static _dxv2_chebyshevcoefficients _i_xv2_chebyshevcoefficients = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_fromchebyshev(byte **error_msg, x_vector *a, x_int *n, x_vector *b, ulong _xparams);
        private static _dxv2_fromchebyshev _i_xv2_fromchebyshev = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_poissondistribution(byte **error_msg, double *result, x_int *k, double *m, ulong _xparams);
        private static _dxv2_poissondistribution _i_xv2_poissondistribution = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_poissoncdistribution(byte **error_msg, double *result, x_int *k, double *m, ulong _xparams);
        private static _dxv2_poissoncdistribution _i_xv2_poissoncdistribution = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_invpoissondistribution(byte **error_msg, double *result, x_int *k, double *y, ulong _xparams);
        private static _dxv2_invpoissondistribution _i_xv2_invpoissondistribution = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_beta(byte **error_msg, double *result, double *a, double *b, ulong _xparams);
        private static _dxv2_beta _i_xv2_beta = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_fresnelintegral(byte **error_msg, double *x, double *c, double *s, ulong _xparams);
        private static _dxv2_fresnelintegral _i_xv2_fresnelintegral = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_psi(byte **error_msg, double *result, double *x, ulong _xparams);
        private static _dxv2_psi _i_xv2_psi = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_airy(byte **error_msg, double *x, double *ai, double *aip, double *bi, double *bip, ulong _xparams);
        private static _dxv2_airy _i_xv2_airy = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_dawsonintegral(byte **error_msg, double *result, double *x, ulong _xparams);
        private static _dxv2_dawsonintegral _i_xv2_dawsonintegral = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_hermitecalculate(byte **error_msg, double *result, x_int *n, double *x, ulong _xparams);
        private static _dxv2_hermitecalculate _i_xv2_hermitecalculate = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_hermitesum(byte **error_msg, double *result, x_vector *c, x_int *n, double *x, ulong _xparams);
        private static _dxv2_hermitesum _i_xv2_hermitesum = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_hermitecoefficients(byte **error_msg, x_int *n, x_vector *c, ulong _xparams);
        private static _dxv2_hermitecoefficients _i_xv2_hermitecoefficients = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_legendrecalculate(byte **error_msg, double *result, x_int *n, double *x, ulong _xparams);
        private static _dxv2_legendrecalculate _i_xv2_legendrecalculate = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_legendresum(byte **error_msg, double *result, x_vector *c, x_int *n, double *x, ulong _xparams);
        private static _dxv2_legendresum _i_xv2_legendresum = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_legendrecoefficients(byte **error_msg, x_int *n, x_vector *c, ulong _xparams);
        private static _dxv2_legendrecoefficients _i_xv2_legendrecoefficients = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_besselj0(byte **error_msg, double *result, double *x, ulong _xparams);
        private static _dxv2_besselj0 _i_xv2_besselj0 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_besselj1(byte **error_msg, double *result, double *x, ulong _xparams);
        private static _dxv2_besselj1 _i_xv2_besselj1 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_besseljn(byte **error_msg, double *result, x_int *n, double *x, ulong _xparams);
        private static _dxv2_besseljn _i_xv2_besseljn = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_bessely0(byte **error_msg, double *result, double *x, ulong _xparams);
        private static _dxv2_bessely0 _i_xv2_bessely0 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_bessely1(byte **error_msg, double *result, double *x, ulong _xparams);
        private static _dxv2_bessely1 _i_xv2_bessely1 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_besselyn(byte **error_msg, double *result, x_int *n, double *x, ulong _xparams);
        private static _dxv2_besselyn _i_xv2_besselyn = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_besseli0(byte **error_msg, double *result, double *x, ulong _xparams);
        private static _dxv2_besseli0 _i_xv2_besseli0 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_besseli1(byte **error_msg, double *result, double *x, ulong _xparams);
        private static _dxv2_besseli1 _i_xv2_besseli1 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_besselk0(byte **error_msg, double *result, double *x, ulong _xparams);
        private static _dxv2_besselk0 _i_xv2_besselk0 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_besselk1(byte **error_msg, double *result, double *x, ulong _xparams);
        private static _dxv2_besselk1 _i_xv2_besselk1 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_besselkn(byte **error_msg, double *result, x_int *nn, double *x, ulong _xparams);
        private static _dxv2_besselkn _i_xv2_besselkn = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_laguerrecalculate(byte **error_msg, double *result, x_int *n, double *x, ulong _xparams);
        private static _dxv2_laguerrecalculate _i_xv2_laguerrecalculate = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_laguerresum(byte **error_msg, double *result, x_vector *c, x_int *n, double *x, ulong _xparams);
        private static _dxv2_laguerresum _i_xv2_laguerresum = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_laguerrecoefficients(byte **error_msg, x_int *n, x_vector *c, ulong _xparams);
        private static _dxv2_laguerrecoefficients _i_xv2_laguerrecoefficients = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_ellipticintegralk(byte **error_msg, double *result, double *m, ulong _xparams);
        private static _dxv2_ellipticintegralk _i_xv2_ellipticintegralk = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_ellipticintegralkhighprecision(byte **error_msg, double *result, double *m1, ulong _xparams);
        private static _dxv2_ellipticintegralkhighprecision _i_xv2_ellipticintegralkhighprecision = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_incompleteellipticintegralk(byte **error_msg, double *result, double *phi, double *m, ulong _xparams);
        private static _dxv2_incompleteellipticintegralk _i_xv2_incompleteellipticintegralk = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_ellipticintegrale(byte **error_msg, double *result, double *m, ulong _xparams);
        private static _dxv2_ellipticintegrale _i_xv2_ellipticintegrale = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_incompleteellipticintegrale(byte **error_msg, double *result, double *phi, double *m, ulong _xparams);
        private static _dxv2_incompleteellipticintegrale _i_xv2_incompleteellipticintegrale = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_pcabuildbasis(byte **error_msg, x_matrix *x, x_int *npoints, x_int *nvars, x_int *info, x_vector *s2, x_matrix *v, ulong _xparams);
        private static _dxv2_pcabuildbasis _i_xv2_pcabuildbasis = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_pcatruncatedsubspace(byte **error_msg, x_matrix *x, x_int *npoints, x_int *nvars, x_int *nneeded, double *eps, x_int *maxits, x_vector *s2, x_matrix *v, ulong _xparams);
        private static _dxv2_pcatruncatedsubspace _i_xv2_pcatruncatedsubspace = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_pcatruncatedsubspacesparse(byte **error_msg, void **x, x_int *npoints, x_int *nvars, x_int *nneeded, double *eps, x_int *maxits, x_vector *s2, x_matrix *v, ulong _xparams);
        private static _dxv2_pcatruncatedsubspacesparse _i_xv2_pcatruncatedsubspacesparse = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_dsoptimalsplit2(byte **error_msg, x_vector *a, x_vector *c, x_int *n, x_int *info, double *threshold, double *pal, double *pbl, double *par, double *pbr, double *cve, ulong _xparams);
        private static _dxv2_dsoptimalsplit2 _i_xv2_dsoptimalsplit2 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_dsoptimalsplit2fast(byte **error_msg, x_vector *a, x_vector *c, x_vector *tiesbuf, x_vector *cntbuf, x_vector *bufr, x_vector *bufi, x_int *n, x_int *nc, double *alpha, x_int *info, double *threshold, double *rms, double *cvrms, ulong _xparams);
        private static _dxv2_dsoptimalsplit2fast _i_xv2_dsoptimalsplit2fast = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_x_mlpserialize(byte **error_msg, void **x, byte **dst);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_x_mlpunserialize(byte **error_msg, byte **src, void **x);
        private static _d_x_mlpserialize   _i_x_mlpserialize   = null;
        private static _d_x_mlpunserialize _i_x_mlpunserialize = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_x_mlpserialize_stream(byte **error_msg, void **x, native_stream_adapter.writer_delegate writer, IntPtr aux);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_x_mlpunserialize_stream(byte **error_msg, native_stream_adapter.reader_delegate reader, IntPtr aux, void **x);
        private static _d_x_mlpserialize_stream   _i_x_mlpserialize_stream   = null;
        private static _d_x_mlpunserialize_stream _i_x_mlpunserialize_stream = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpcreate0(byte **error_msg, x_int *nin, x_int *nout, void **network, ulong _xparams);
        private static _dxv2_mlpcreate0 _i_xv2_mlpcreate0 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpcreate1(byte **error_msg, x_int *nin, x_int *nhid, x_int *nout, void **network, ulong _xparams);
        private static _dxv2_mlpcreate1 _i_xv2_mlpcreate1 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpcreate2(byte **error_msg, x_int *nin, x_int *nhid1, x_int *nhid2, x_int *nout, void **network, ulong _xparams);
        private static _dxv2_mlpcreate2 _i_xv2_mlpcreate2 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpcreateb0(byte **error_msg, x_int *nin, x_int *nout, double *b, double *d, void **network, ulong _xparams);
        private static _dxv2_mlpcreateb0 _i_xv2_mlpcreateb0 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpcreateb1(byte **error_msg, x_int *nin, x_int *nhid, x_int *nout, double *b, double *d, void **network, ulong _xparams);
        private static _dxv2_mlpcreateb1 _i_xv2_mlpcreateb1 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpcreateb2(byte **error_msg, x_int *nin, x_int *nhid1, x_int *nhid2, x_int *nout, double *b, double *d, void **network, ulong _xparams);
        private static _dxv2_mlpcreateb2 _i_xv2_mlpcreateb2 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpcreater0(byte **error_msg, x_int *nin, x_int *nout, double *a, double *b, void **network, ulong _xparams);
        private static _dxv2_mlpcreater0 _i_xv2_mlpcreater0 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpcreater1(byte **error_msg, x_int *nin, x_int *nhid, x_int *nout, double *a, double *b, void **network, ulong _xparams);
        private static _dxv2_mlpcreater1 _i_xv2_mlpcreater1 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpcreater2(byte **error_msg, x_int *nin, x_int *nhid1, x_int *nhid2, x_int *nout, double *a, double *b, void **network, ulong _xparams);
        private static _dxv2_mlpcreater2 _i_xv2_mlpcreater2 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpcreatec0(byte **error_msg, x_int *nin, x_int *nout, void **network, ulong _xparams);
        private static _dxv2_mlpcreatec0 _i_xv2_mlpcreatec0 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpcreatec1(byte **error_msg, x_int *nin, x_int *nhid, x_int *nout, void **network, ulong _xparams);
        private static _dxv2_mlpcreatec1 _i_xv2_mlpcreatec1 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpcreatec2(byte **error_msg, x_int *nin, x_int *nhid1, x_int *nhid2, x_int *nout, void **network, ulong _xparams);
        private static _dxv2_mlpcreatec2 _i_xv2_mlpcreatec2 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpcopy(byte **error_msg, void **network1, void **network2, ulong _xparams);
        private static _dxv2_mlpcopy _i_xv2_mlpcopy = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpcopytunableparameters(byte **error_msg, void **network1, void **network2, ulong _xparams);
        private static _dxv2_mlpcopytunableparameters _i_xv2_mlpcopytunableparameters = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlprandomize(byte **error_msg, void **network, ulong _xparams);
        private static _dxv2_mlprandomize _i_xv2_mlprandomize = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlprandomizefull(byte **error_msg, void **network, ulong _xparams);
        private static _dxv2_mlprandomizefull _i_xv2_mlprandomizefull = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpinitpreprocessor(byte **error_msg, void **network, x_matrix *xy, x_int *ssize, ulong _xparams);
        private static _dxv2_mlpinitpreprocessor _i_xv2_mlpinitpreprocessor = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpproperties(byte **error_msg, void **network, x_int *nin, x_int *nout, x_int *wcount, ulong _xparams);
        private static _dxv2_mlpproperties _i_xv2_mlpproperties = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpgetinputscount(byte **error_msg, x_int *result, void **network, ulong _xparams);
        private static _dxv2_mlpgetinputscount _i_xv2_mlpgetinputscount = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpgetoutputscount(byte **error_msg, x_int *result, void **network, ulong _xparams);
        private static _dxv2_mlpgetoutputscount _i_xv2_mlpgetoutputscount = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpgetweightscount(byte **error_msg, x_int *result, void **network, ulong _xparams);
        private static _dxv2_mlpgetweightscount _i_xv2_mlpgetweightscount = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpissoftmax(byte **error_msg, byte *result, void **network, ulong _xparams);
        private static _dxv2_mlpissoftmax _i_xv2_mlpissoftmax = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpgetlayerscount(byte **error_msg, x_int *result, void **network, ulong _xparams);
        private static _dxv2_mlpgetlayerscount _i_xv2_mlpgetlayerscount = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpgetlayersize(byte **error_msg, x_int *result, void **network, x_int *k, ulong _xparams);
        private static _dxv2_mlpgetlayersize _i_xv2_mlpgetlayersize = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpgetinputscaling(byte **error_msg, void **network, x_int *i, double *mean, double *sigma, ulong _xparams);
        private static _dxv2_mlpgetinputscaling _i_xv2_mlpgetinputscaling = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpgetoutputscaling(byte **error_msg, void **network, x_int *i, double *mean, double *sigma, ulong _xparams);
        private static _dxv2_mlpgetoutputscaling _i_xv2_mlpgetoutputscaling = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpgetneuroninfo(byte **error_msg, void **network, x_int *k, x_int *i, x_int *fkind, double *threshold, ulong _xparams);
        private static _dxv2_mlpgetneuroninfo _i_xv2_mlpgetneuroninfo = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpgetweight(byte **error_msg, double *result, void **network, x_int *k0, x_int *i0, x_int *k1, x_int *i1, ulong _xparams);
        private static _dxv2_mlpgetweight _i_xv2_mlpgetweight = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpsetinputscaling(byte **error_msg, void **network, x_int *i, double *mean, double *sigma, ulong _xparams);
        private static _dxv2_mlpsetinputscaling _i_xv2_mlpsetinputscaling = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpsetoutputscaling(byte **error_msg, void **network, x_int *i, double *mean, double *sigma, ulong _xparams);
        private static _dxv2_mlpsetoutputscaling _i_xv2_mlpsetoutputscaling = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpsetneuroninfo(byte **error_msg, void **network, x_int *k, x_int *i, x_int *fkind, double *threshold, ulong _xparams);
        private static _dxv2_mlpsetneuroninfo _i_xv2_mlpsetneuroninfo = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpsetweight(byte **error_msg, void **network, x_int *k0, x_int *i0, x_int *k1, x_int *i1, double *w, ulong _xparams);
        private static _dxv2_mlpsetweight _i_xv2_mlpsetweight = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpactivationfunction(byte **error_msg, double *net, x_int *k, double *f, double *df, double *d2f, ulong _xparams);
        private static _dxv2_mlpactivationfunction _i_xv2_mlpactivationfunction = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpprocess(byte **error_msg, void **network, x_vector *x, x_vector *y, ulong _xparams);
        private static _dxv2_mlpprocess _i_xv2_mlpprocess = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpprocessi(byte **error_msg, void **network, x_vector *x, x_vector *y, ulong _xparams);
        private static _dxv2_mlpprocessi _i_xv2_mlpprocessi = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlperror(byte **error_msg, double *result, void **network, x_matrix *xy, x_int *npoints, ulong _xparams);
        private static _dxv2_mlperror _i_xv2_mlperror = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlperrorsparse(byte **error_msg, double *result, void **network, void **xy, x_int *npoints, ulong _xparams);
        private static _dxv2_mlperrorsparse _i_xv2_mlperrorsparse = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlperrorn(byte **error_msg, double *result, void **network, x_matrix *xy, x_int *ssize, ulong _xparams);
        private static _dxv2_mlperrorn _i_xv2_mlperrorn = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpclserror(byte **error_msg, x_int *result, void **network, x_matrix *xy, x_int *npoints, ulong _xparams);
        private static _dxv2_mlpclserror _i_xv2_mlpclserror = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlprelclserror(byte **error_msg, double *result, void **network, x_matrix *xy, x_int *npoints, ulong _xparams);
        private static _dxv2_mlprelclserror _i_xv2_mlprelclserror = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlprelclserrorsparse(byte **error_msg, double *result, void **network, void **xy, x_int *npoints, ulong _xparams);
        private static _dxv2_mlprelclserrorsparse _i_xv2_mlprelclserrorsparse = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpavgce(byte **error_msg, double *result, void **network, x_matrix *xy, x_int *npoints, ulong _xparams);
        private static _dxv2_mlpavgce _i_xv2_mlpavgce = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpavgcesparse(byte **error_msg, double *result, void **network, void **xy, x_int *npoints, ulong _xparams);
        private static _dxv2_mlpavgcesparse _i_xv2_mlpavgcesparse = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlprmserror(byte **error_msg, double *result, void **network, x_matrix *xy, x_int *npoints, ulong _xparams);
        private static _dxv2_mlprmserror _i_xv2_mlprmserror = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlprmserrorsparse(byte **error_msg, double *result, void **network, void **xy, x_int *npoints, ulong _xparams);
        private static _dxv2_mlprmserrorsparse _i_xv2_mlprmserrorsparse = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpavgerror(byte **error_msg, double *result, void **network, x_matrix *xy, x_int *npoints, ulong _xparams);
        private static _dxv2_mlpavgerror _i_xv2_mlpavgerror = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpavgerrorsparse(byte **error_msg, double *result, void **network, void **xy, x_int *npoints, ulong _xparams);
        private static _dxv2_mlpavgerrorsparse _i_xv2_mlpavgerrorsparse = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpavgrelerror(byte **error_msg, double *result, void **network, x_matrix *xy, x_int *npoints, ulong _xparams);
        private static _dxv2_mlpavgrelerror _i_xv2_mlpavgrelerror = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpavgrelerrorsparse(byte **error_msg, double *result, void **network, void **xy, x_int *npoints, ulong _xparams);
        private static _dxv2_mlpavgrelerrorsparse _i_xv2_mlpavgrelerrorsparse = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpgrad(byte **error_msg, void **network, x_vector *x, x_vector *desiredy, double *e, x_vector *grad, ulong _xparams);
        private static _dxv2_mlpgrad _i_xv2_mlpgrad = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpgradn(byte **error_msg, void **network, x_vector *x, x_vector *desiredy, double *e, x_vector *grad, ulong _xparams);
        private static _dxv2_mlpgradn _i_xv2_mlpgradn = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpgradbatch(byte **error_msg, void **network, x_matrix *xy, x_int *ssize, double *e, x_vector *grad, ulong _xparams);
        private static _dxv2_mlpgradbatch _i_xv2_mlpgradbatch = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpgradbatchsparse(byte **error_msg, void **network, void **xy, x_int *ssize, double *e, x_vector *grad, ulong _xparams);
        private static _dxv2_mlpgradbatchsparse _i_xv2_mlpgradbatchsparse = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpgradbatchsubset(byte **error_msg, void **network, x_matrix *xy, x_int *setsize, x_vector *idx, x_int *subsetsize, double *e, x_vector *grad, ulong _xparams);
        private static _dxv2_mlpgradbatchsubset _i_xv2_mlpgradbatchsubset = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpgradbatchsparsesubset(byte **error_msg, void **network, void **xy, x_int *setsize, x_vector *idx, x_int *subsetsize, double *e, x_vector *grad, ulong _xparams);
        private static _dxv2_mlpgradbatchsparsesubset _i_xv2_mlpgradbatchsparsesubset = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpgradnbatch(byte **error_msg, void **network, x_matrix *xy, x_int *ssize, double *e, x_vector *grad, ulong _xparams);
        private static _dxv2_mlpgradnbatch _i_xv2_mlpgradnbatch = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlphessiannbatch(byte **error_msg, void **network, x_matrix *xy, x_int *ssize, double *e, x_vector *grad, x_matrix *h, ulong _xparams);
        private static _dxv2_mlphessiannbatch _i_xv2_mlphessiannbatch = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlphessianbatch(byte **error_msg, void **network, x_matrix *xy, x_int *ssize, double *e, x_vector *grad, x_matrix *h, ulong _xparams);
        private static _dxv2_mlphessianbatch _i_xv2_mlphessianbatch = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpallerrorssubset(byte **error_msg, void **network, x_matrix *xy, x_int *setsize, x_vector *subset, x_int *subsetsize, x_modelerrors *rep, ulong _xparams);
        private static _dxv2_mlpallerrorssubset _i_xv2_mlpallerrorssubset = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpallerrorssparsesubset(byte **error_msg, void **network, void **xy, x_int *setsize, x_vector *subset, x_int *subsetsize, x_modelerrors *rep, ulong _xparams);
        private static _dxv2_mlpallerrorssparsesubset _i_xv2_mlpallerrorssparsesubset = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlperrorsubset(byte **error_msg, double *result, void **network, x_matrix *xy, x_int *setsize, x_vector *subset, x_int *subsetsize, ulong _xparams);
        private static _dxv2_mlperrorsubset _i_xv2_mlperrorsubset = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlperrorsparsesubset(byte **error_msg, double *result, void **network, void **xy, x_int *setsize, x_vector *subset, x_int *subsetsize, ulong _xparams);
        private static _dxv2_mlperrorsparsesubset _i_xv2_mlperrorsparsesubset = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_x_mlpeserialize(byte **error_msg, void **x, byte **dst);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_x_mlpeunserialize(byte **error_msg, byte **src, void **x);
        private static _d_x_mlpeserialize   _i_x_mlpeserialize   = null;
        private static _d_x_mlpeunserialize _i_x_mlpeunserialize = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_x_mlpeserialize_stream(byte **error_msg, void **x, native_stream_adapter.writer_delegate writer, IntPtr aux);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_x_mlpeunserialize_stream(byte **error_msg, native_stream_adapter.reader_delegate reader, IntPtr aux, void **x);
        private static _d_x_mlpeserialize_stream   _i_x_mlpeserialize_stream   = null;
        private static _d_x_mlpeunserialize_stream _i_x_mlpeunserialize_stream = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpecreate0(byte **error_msg, x_int *nin, x_int *nout, x_int *ensemblesize, void **ensemble, ulong _xparams);
        private static _dxv2_mlpecreate0 _i_xv2_mlpecreate0 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpecreate1(byte **error_msg, x_int *nin, x_int *nhid, x_int *nout, x_int *ensemblesize, void **ensemble, ulong _xparams);
        private static _dxv2_mlpecreate1 _i_xv2_mlpecreate1 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpecreate2(byte **error_msg, x_int *nin, x_int *nhid1, x_int *nhid2, x_int *nout, x_int *ensemblesize, void **ensemble, ulong _xparams);
        private static _dxv2_mlpecreate2 _i_xv2_mlpecreate2 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpecreateb0(byte **error_msg, x_int *nin, x_int *nout, double *b, double *d, x_int *ensemblesize, void **ensemble, ulong _xparams);
        private static _dxv2_mlpecreateb0 _i_xv2_mlpecreateb0 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpecreateb1(byte **error_msg, x_int *nin, x_int *nhid, x_int *nout, double *b, double *d, x_int *ensemblesize, void **ensemble, ulong _xparams);
        private static _dxv2_mlpecreateb1 _i_xv2_mlpecreateb1 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpecreateb2(byte **error_msg, x_int *nin, x_int *nhid1, x_int *nhid2, x_int *nout, double *b, double *d, x_int *ensemblesize, void **ensemble, ulong _xparams);
        private static _dxv2_mlpecreateb2 _i_xv2_mlpecreateb2 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpecreater0(byte **error_msg, x_int *nin, x_int *nout, double *a, double *b, x_int *ensemblesize, void **ensemble, ulong _xparams);
        private static _dxv2_mlpecreater0 _i_xv2_mlpecreater0 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpecreater1(byte **error_msg, x_int *nin, x_int *nhid, x_int *nout, double *a, double *b, x_int *ensemblesize, void **ensemble, ulong _xparams);
        private static _dxv2_mlpecreater1 _i_xv2_mlpecreater1 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpecreater2(byte **error_msg, x_int *nin, x_int *nhid1, x_int *nhid2, x_int *nout, double *a, double *b, x_int *ensemblesize, void **ensemble, ulong _xparams);
        private static _dxv2_mlpecreater2 _i_xv2_mlpecreater2 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpecreatec0(byte **error_msg, x_int *nin, x_int *nout, x_int *ensemblesize, void **ensemble, ulong _xparams);
        private static _dxv2_mlpecreatec0 _i_xv2_mlpecreatec0 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpecreatec1(byte **error_msg, x_int *nin, x_int *nhid, x_int *nout, x_int *ensemblesize, void **ensemble, ulong _xparams);
        private static _dxv2_mlpecreatec1 _i_xv2_mlpecreatec1 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpecreatec2(byte **error_msg, x_int *nin, x_int *nhid1, x_int *nhid2, x_int *nout, x_int *ensemblesize, void **ensemble, ulong _xparams);
        private static _dxv2_mlpecreatec2 _i_xv2_mlpecreatec2 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpecreatefromnetwork(byte **error_msg, void **network, x_int *ensemblesize, void **ensemble, ulong _xparams);
        private static _dxv2_mlpecreatefromnetwork _i_xv2_mlpecreatefromnetwork = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlperandomize(byte **error_msg, void **ensemble, ulong _xparams);
        private static _dxv2_mlperandomize _i_xv2_mlperandomize = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpeproperties(byte **error_msg, void **ensemble, x_int *nin, x_int *nout, ulong _xparams);
        private static _dxv2_mlpeproperties _i_xv2_mlpeproperties = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpeissoftmax(byte **error_msg, byte *result, void **ensemble, ulong _xparams);
        private static _dxv2_mlpeissoftmax _i_xv2_mlpeissoftmax = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpeprocess(byte **error_msg, void **ensemble, x_vector *x, x_vector *y, ulong _xparams);
        private static _dxv2_mlpeprocess _i_xv2_mlpeprocess = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpeprocessi(byte **error_msg, void **ensemble, x_vector *x, x_vector *y, ulong _xparams);
        private static _dxv2_mlpeprocessi _i_xv2_mlpeprocessi = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlperelclserror(byte **error_msg, double *result, void **ensemble, x_matrix *xy, x_int *npoints, ulong _xparams);
        private static _dxv2_mlperelclserror _i_xv2_mlperelclserror = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpeavgce(byte **error_msg, double *result, void **ensemble, x_matrix *xy, x_int *npoints, ulong _xparams);
        private static _dxv2_mlpeavgce _i_xv2_mlpeavgce = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpermserror(byte **error_msg, double *result, void **ensemble, x_matrix *xy, x_int *npoints, ulong _xparams);
        private static _dxv2_mlpermserror _i_xv2_mlpermserror = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpeavgerror(byte **error_msg, double *result, void **ensemble, x_matrix *xy, x_int *npoints, ulong _xparams);
        private static _dxv2_mlpeavgerror _i_xv2_mlpeavgerror = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpeavgrelerror(byte **error_msg, double *result, void **ensemble, x_matrix *xy, x_int *npoints, ulong _xparams);
        private static _dxv2_mlpeavgrelerror _i_xv2_mlpeavgrelerror = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_clusterizercreate(byte **error_msg, void **s, ulong _xparams);
        private static _dxv2_clusterizercreate _i_xv2_clusterizercreate = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_clusterizersetpoints(byte **error_msg, void **s, x_matrix *xy, x_int *npoints, x_int *nfeatures, x_int *disttype, ulong _xparams);
        private static _dxv2_clusterizersetpoints _i_xv2_clusterizersetpoints = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_clusterizersetdistances(byte **error_msg, void **s, x_matrix *d, x_int *npoints, byte *isupper, ulong _xparams);
        private static _dxv2_clusterizersetdistances _i_xv2_clusterizersetdistances = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_clusterizersetahcalgo(byte **error_msg, void **s, x_int *algo, ulong _xparams);
        private static _dxv2_clusterizersetahcalgo _i_xv2_clusterizersetahcalgo = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_clusterizersetkmeanslimits(byte **error_msg, void **s, x_int *restarts, x_int *maxits, ulong _xparams);
        private static _dxv2_clusterizersetkmeanslimits _i_xv2_clusterizersetkmeanslimits = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_clusterizersetkmeansinit(byte **error_msg, void **s, x_int *initalgo, ulong _xparams);
        private static _dxv2_clusterizersetkmeansinit _i_xv2_clusterizersetkmeansinit = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_clusterizersetseed(byte **error_msg, void **s, x_int *seed, ulong _xparams);
        private static _dxv2_clusterizersetseed _i_xv2_clusterizersetseed = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_clusterizerrunahc(byte **error_msg, void **s, x_ahcreport *rep, ulong _xparams);
        private static _dxv2_clusterizerrunahc _i_xv2_clusterizerrunahc = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_clusterizerrunkmeans(byte **error_msg, void **s, x_int *k, x_kmeansreport *rep, ulong _xparams);
        private static _dxv2_clusterizerrunkmeans _i_xv2_clusterizerrunkmeans = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_clusterizergetdistances(byte **error_msg, x_matrix *xy, x_int *npoints, x_int *nfeatures, x_int *disttype, x_matrix *d, ulong _xparams);
        private static _dxv2_clusterizergetdistances _i_xv2_clusterizergetdistances = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_clusterizergetkclusters(byte **error_msg, x_ahcreport *rep, x_int *k, x_vector *cidx, x_vector *cz, ulong _xparams);
        private static _dxv2_clusterizergetkclusters _i_xv2_clusterizergetkclusters = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_clusterizerseparatedbydist(byte **error_msg, x_ahcreport *rep, double *r, x_int *k, x_vector *cidx, x_vector *cz, ulong _xparams);
        private static _dxv2_clusterizerseparatedbydist _i_xv2_clusterizerseparatedbydist = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_clusterizerseparatedbycorr(byte **error_msg, x_ahcreport *rep, double *r, x_int *k, x_vector *cidx, x_vector *cz, ulong _xparams);
        private static _dxv2_clusterizerseparatedbycorr _i_xv2_clusterizerseparatedbycorr = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_x_dfserialize(byte **error_msg, void **x, byte **dst);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_x_dfunserialize(byte **error_msg, byte **src, void **x);
        private static _d_x_dfserialize   _i_x_dfserialize   = null;
        private static _d_x_dfunserialize _i_x_dfunserialize = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_x_dfserialize_stream(byte **error_msg, void **x, native_stream_adapter.writer_delegate writer, IntPtr aux);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_x_dfunserialize_stream(byte **error_msg, native_stream_adapter.reader_delegate reader, IntPtr aux, void **x);
        private static _d_x_dfserialize_stream   _i_x_dfserialize_stream   = null;
        private static _d_x_dfunserialize_stream _i_x_dfunserialize_stream = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_dfcreatebuffer(byte **error_msg, void **model, void **buf, ulong _xparams);
        private static _dxv2_dfcreatebuffer _i_xv2_dfcreatebuffer = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_dfbuildercreate(byte **error_msg, void **s, ulong _xparams);
        private static _dxv2_dfbuildercreate _i_xv2_dfbuildercreate = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_dfbuildersetdataset(byte **error_msg, void **s, x_matrix *xy, x_int *npoints, x_int *nvars, x_int *nclasses, ulong _xparams);
        private static _dxv2_dfbuildersetdataset _i_xv2_dfbuildersetdataset = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_dfbuildersetrndvars(byte **error_msg, void **s, x_int *rndvars, ulong _xparams);
        private static _dxv2_dfbuildersetrndvars _i_xv2_dfbuildersetrndvars = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_dfbuildersetrndvarsratio(byte **error_msg, void **s, double *f, ulong _xparams);
        private static _dxv2_dfbuildersetrndvarsratio _i_xv2_dfbuildersetrndvarsratio = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_dfbuildersetrndvarsauto(byte **error_msg, void **s, ulong _xparams);
        private static _dxv2_dfbuildersetrndvarsauto _i_xv2_dfbuildersetrndvarsauto = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_dfbuildersetsubsampleratio(byte **error_msg, void **s, double *f, ulong _xparams);
        private static _dxv2_dfbuildersetsubsampleratio _i_xv2_dfbuildersetsubsampleratio = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_dfbuildersetseed(byte **error_msg, void **s, x_int *seedval, ulong _xparams);
        private static _dxv2_dfbuildersetseed _i_xv2_dfbuildersetseed = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_dfbuildersetrdfalgo(byte **error_msg, void **s, x_int *algotype, ulong _xparams);
        private static _dxv2_dfbuildersetrdfalgo _i_xv2_dfbuildersetrdfalgo = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_dfbuildersetrdfsplitstrength(byte **error_msg, void **s, x_int *splitstrength, ulong _xparams);
        private static _dxv2_dfbuildersetrdfsplitstrength _i_xv2_dfbuildersetrdfsplitstrength = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_dfbuildersetimportancetrngini(byte **error_msg, void **s, ulong _xparams);
        private static _dxv2_dfbuildersetimportancetrngini _i_xv2_dfbuildersetimportancetrngini = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_dfbuildersetimportanceoobgini(byte **error_msg, void **s, ulong _xparams);
        private static _dxv2_dfbuildersetimportanceoobgini _i_xv2_dfbuildersetimportanceoobgini = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_dfbuildersetimportancepermutation(byte **error_msg, void **s, ulong _xparams);
        private static _dxv2_dfbuildersetimportancepermutation _i_xv2_dfbuildersetimportancepermutation = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_dfbuildersetimportancenone(byte **error_msg, void **s, ulong _xparams);
        private static _dxv2_dfbuildersetimportancenone _i_xv2_dfbuildersetimportancenone = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_dfbuildergetprogress(byte **error_msg, double *result, void **s, ulong _xparams);
        private static _dxv2_dfbuildergetprogress _i_xv2_dfbuildergetprogress = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_dfbuilderpeekprogress(byte **error_msg, double *result, void **s, ulong _xparams);
        private static _dxv2_dfbuilderpeekprogress _i_xv2_dfbuilderpeekprogress = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_dfbuilderbuildrandomforest(byte **error_msg, void **s, x_int *ntrees, void **df, x_dfreport *rep, ulong _xparams);
        private static _dxv2_dfbuilderbuildrandomforest _i_xv2_dfbuilderbuildrandomforest = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_dfbinarycompression(byte **error_msg, double *result, void **df, ulong _xparams);
        private static _dxv2_dfbinarycompression _i_xv2_dfbinarycompression = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_dfprocess(byte **error_msg, void **df, x_vector *x, x_vector *y, ulong _xparams);
        private static _dxv2_dfprocess _i_xv2_dfprocess = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_dfprocessi(byte **error_msg, void **df, x_vector *x, x_vector *y, ulong _xparams);
        private static _dxv2_dfprocessi _i_xv2_dfprocessi = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_dfprocess0(byte **error_msg, double *result, void **model, x_vector *x, ulong _xparams);
        private static _dxv2_dfprocess0 _i_xv2_dfprocess0 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_dfclassify(byte **error_msg, x_int *result, void **model, x_vector *x, ulong _xparams);
        private static _dxv2_dfclassify _i_xv2_dfclassify = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_dftsprocess(byte **error_msg, void **df, void **buf, x_vector *x, x_vector *y, ulong _xparams);
        private static _dxv2_dftsprocess _i_xv2_dftsprocess = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_dfrelclserror(byte **error_msg, double *result, void **df, x_matrix *xy, x_int *npoints, ulong _xparams);
        private static _dxv2_dfrelclserror _i_xv2_dfrelclserror = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_dfavgce(byte **error_msg, double *result, void **df, x_matrix *xy, x_int *npoints, ulong _xparams);
        private static _dxv2_dfavgce _i_xv2_dfavgce = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_dfrmserror(byte **error_msg, double *result, void **df, x_matrix *xy, x_int *npoints, ulong _xparams);
        private static _dxv2_dfrmserror _i_xv2_dfrmserror = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_dfavgerror(byte **error_msg, double *result, void **df, x_matrix *xy, x_int *npoints, ulong _xparams);
        private static _dxv2_dfavgerror _i_xv2_dfavgerror = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_dfavgrelerror(byte **error_msg, double *result, void **df, x_matrix *xy, x_int *npoints, ulong _xparams);
        private static _dxv2_dfavgrelerror _i_xv2_dfavgrelerror = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_dfbuildrandomdecisionforest(byte **error_msg, x_matrix *xy, x_int *npoints, x_int *nvars, x_int *nclasses, x_int *ntrees, double *r, x_int *info, void **df, x_dfreport *rep, ulong _xparams);
        private static _dxv2_dfbuildrandomdecisionforest _i_xv2_dfbuildrandomdecisionforest = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_dfbuildrandomdecisionforestx1(byte **error_msg, x_matrix *xy, x_int *npoints, x_int *nvars, x_int *nclasses, x_int *ntrees, x_int *nrndvars, double *r, x_int *info, void **df, x_dfreport *rep, ulong _xparams);
        private static _dxv2_dfbuildrandomdecisionforestx1 _i_xv2_dfbuildrandomdecisionforestx1 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_lrbuild(byte **error_msg, x_matrix *xy, x_int *npoints, x_int *nvars, x_int *info, void **lm, x_lrreport *ar, ulong _xparams);
        private static _dxv2_lrbuild _i_xv2_lrbuild = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_lrbuilds(byte **error_msg, x_matrix *xy, x_vector *s, x_int *npoints, x_int *nvars, x_int *info, void **lm, x_lrreport *ar, ulong _xparams);
        private static _dxv2_lrbuilds _i_xv2_lrbuilds = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_lrbuildzs(byte **error_msg, x_matrix *xy, x_vector *s, x_int *npoints, x_int *nvars, x_int *info, void **lm, x_lrreport *ar, ulong _xparams);
        private static _dxv2_lrbuildzs _i_xv2_lrbuildzs = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_lrbuildz(byte **error_msg, x_matrix *xy, x_int *npoints, x_int *nvars, x_int *info, void **lm, x_lrreport *ar, ulong _xparams);
        private static _dxv2_lrbuildz _i_xv2_lrbuildz = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_lrunpack(byte **error_msg, void **lm, x_vector *v, x_int *nvars, ulong _xparams);
        private static _dxv2_lrunpack _i_xv2_lrunpack = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_lrpack(byte **error_msg, x_vector *v, x_int *nvars, void **lm, ulong _xparams);
        private static _dxv2_lrpack _i_xv2_lrpack = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_lrprocess(byte **error_msg, double *result, void **lm, x_vector *x, ulong _xparams);
        private static _dxv2_lrprocess _i_xv2_lrprocess = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_lrrmserror(byte **error_msg, double *result, void **lm, x_matrix *xy, x_int *npoints, ulong _xparams);
        private static _dxv2_lrrmserror _i_xv2_lrrmserror = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_lravgerror(byte **error_msg, double *result, void **lm, x_matrix *xy, x_int *npoints, ulong _xparams);
        private static _dxv2_lravgerror _i_xv2_lravgerror = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_lravgrelerror(byte **error_msg, double *result, void **lm, x_matrix *xy, x_int *npoints, ulong _xparams);
        private static _dxv2_lravgrelerror _i_xv2_lravgrelerror = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_filtersma(byte **error_msg, x_vector *x, x_int *n, x_int *k, ulong _xparams);
        private static _dxv2_filtersma _i_xv2_filtersma = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_filterema(byte **error_msg, x_vector *x, x_int *n, double *alpha, ulong _xparams);
        private static _dxv2_filterema _i_xv2_filterema = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_filterlrma(byte **error_msg, x_vector *x, x_int *n, x_int *k, ulong _xparams);
        private static _dxv2_filterlrma _i_xv2_filterlrma = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_ssacreate(byte **error_msg, void **s, ulong _xparams);
        private static _dxv2_ssacreate _i_xv2_ssacreate = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_ssasetwindow(byte **error_msg, void **s, x_int *windowwidth, ulong _xparams);
        private static _dxv2_ssasetwindow _i_xv2_ssasetwindow = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_ssasetseed(byte **error_msg, void **s, x_int *seed, ulong _xparams);
        private static _dxv2_ssasetseed _i_xv2_ssasetseed = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_ssasetpoweruplength(byte **error_msg, void **s, x_int *pwlen, ulong _xparams);
        private static _dxv2_ssasetpoweruplength _i_xv2_ssasetpoweruplength = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_ssasetmemorylimit(byte **error_msg, void **s, x_int *memlimit, ulong _xparams);
        private static _dxv2_ssasetmemorylimit _i_xv2_ssasetmemorylimit = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_ssaaddsequence(byte **error_msg, void **s, x_vector *x, x_int *n, ulong _xparams);
        private static _dxv2_ssaaddsequence _i_xv2_ssaaddsequence = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_ssaappendpointandupdate(byte **error_msg, void **s, double *x, double *updateits, ulong _xparams);
        private static _dxv2_ssaappendpointandupdate _i_xv2_ssaappendpointandupdate = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_ssaappendsequenceandupdate(byte **error_msg, void **s, x_vector *x, x_int *nticks, double *updateits, ulong _xparams);
        private static _dxv2_ssaappendsequenceandupdate _i_xv2_ssaappendsequenceandupdate = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_ssasetalgoprecomputed(byte **error_msg, void **s, x_matrix *a, x_int *windowwidth, x_int *nbasis, ulong _xparams);
        private static _dxv2_ssasetalgoprecomputed _i_xv2_ssasetalgoprecomputed = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_ssasetalgotopkdirect(byte **error_msg, void **s, x_int *topk, ulong _xparams);
        private static _dxv2_ssasetalgotopkdirect _i_xv2_ssasetalgotopkdirect = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_ssasetalgotopkrealtime(byte **error_msg, void **s, x_int *topk, ulong _xparams);
        private static _dxv2_ssasetalgotopkrealtime _i_xv2_ssasetalgotopkrealtime = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_ssacleardata(byte **error_msg, void **s, ulong _xparams);
        private static _dxv2_ssacleardata _i_xv2_ssacleardata = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_ssagetbasis(byte **error_msg, void **s, x_matrix *a, x_vector *sv, x_int *windowwidth, x_int *nbasis, ulong _xparams);
        private static _dxv2_ssagetbasis _i_xv2_ssagetbasis = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_ssagetlrr(byte **error_msg, void **s, x_vector *a, x_int *windowwidth, ulong _xparams);
        private static _dxv2_ssagetlrr _i_xv2_ssagetlrr = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_ssaanalyzelastwindow(byte **error_msg, void **s, x_vector *trend, x_vector *noise, x_int *nticks, ulong _xparams);
        private static _dxv2_ssaanalyzelastwindow _i_xv2_ssaanalyzelastwindow = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_ssaanalyzelast(byte **error_msg, void **s, x_int *nticks, x_vector *trend, x_vector *noise, ulong _xparams);
        private static _dxv2_ssaanalyzelast _i_xv2_ssaanalyzelast = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_ssaanalyzesequence(byte **error_msg, void **s, x_vector *data, x_int *nticks, x_vector *trend, x_vector *noise, ulong _xparams);
        private static _dxv2_ssaanalyzesequence _i_xv2_ssaanalyzesequence = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_ssaforecastlast(byte **error_msg, void **s, x_int *nticks, x_vector *trend, ulong _xparams);
        private static _dxv2_ssaforecastlast _i_xv2_ssaforecastlast = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_ssaforecastsequence(byte **error_msg, void **s, x_vector *data, x_int *datalen, x_int *forecastlen, byte *applysmoothing, x_vector *trend, ulong _xparams);
        private static _dxv2_ssaforecastsequence _i_xv2_ssaforecastsequence = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_ssaforecastavglast(byte **error_msg, void **s, x_int *m, x_int *nticks, x_vector *trend, ulong _xparams);
        private static _dxv2_ssaforecastavglast _i_xv2_ssaforecastavglast = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_ssaforecastavgsequence(byte **error_msg, void **s, x_vector *data, x_int *datalen, x_int *m, x_int *forecastlen, byte *applysmoothing, x_vector *trend, ulong _xparams);
        private static _dxv2_ssaforecastavgsequence _i_xv2_ssaforecastavgsequence = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_fisherlda(byte **error_msg, x_matrix *xy, x_int *npoints, x_int *nvars, x_int *nclasses, x_int *info, x_vector *w, ulong _xparams);
        private static _dxv2_fisherlda _i_xv2_fisherlda = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_fisherldan(byte **error_msg, x_matrix *xy, x_int *npoints, x_int *nvars, x_int *nclasses, x_int *info, x_matrix *w, ulong _xparams);
        private static _dxv2_fisherldan _i_xv2_fisherldan = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mcpdcreate(byte **error_msg, x_int *n, void **s, ulong _xparams);
        private static _dxv2_mcpdcreate _i_xv2_mcpdcreate = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mcpdcreateentry(byte **error_msg, x_int *n, x_int *entrystate, void **s, ulong _xparams);
        private static _dxv2_mcpdcreateentry _i_xv2_mcpdcreateentry = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mcpdcreateexit(byte **error_msg, x_int *n, x_int *exitstate, void **s, ulong _xparams);
        private static _dxv2_mcpdcreateexit _i_xv2_mcpdcreateexit = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mcpdcreateentryexit(byte **error_msg, x_int *n, x_int *entrystate, x_int *exitstate, void **s, ulong _xparams);
        private static _dxv2_mcpdcreateentryexit _i_xv2_mcpdcreateentryexit = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mcpdaddtrack(byte **error_msg, void **s, x_matrix *xy, x_int *k, ulong _xparams);
        private static _dxv2_mcpdaddtrack _i_xv2_mcpdaddtrack = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mcpdsetec(byte **error_msg, void **s, x_matrix *ec, ulong _xparams);
        private static _dxv2_mcpdsetec _i_xv2_mcpdsetec = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mcpdaddec(byte **error_msg, void **s, x_int *i, x_int *j, double *c, ulong _xparams);
        private static _dxv2_mcpdaddec _i_xv2_mcpdaddec = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mcpdsetbc(byte **error_msg, void **s, x_matrix *bndl, x_matrix *bndu, ulong _xparams);
        private static _dxv2_mcpdsetbc _i_xv2_mcpdsetbc = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mcpdaddbc(byte **error_msg, void **s, x_int *i, x_int *j, double *bndl, double *bndu, ulong _xparams);
        private static _dxv2_mcpdaddbc _i_xv2_mcpdaddbc = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mcpdsetlc(byte **error_msg, void **s, x_matrix *c, x_vector *ct, x_int *k, ulong _xparams);
        private static _dxv2_mcpdsetlc _i_xv2_mcpdsetlc = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mcpdsettikhonovregularizer(byte **error_msg, void **s, double *v, ulong _xparams);
        private static _dxv2_mcpdsettikhonovregularizer _i_xv2_mcpdsettikhonovregularizer = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mcpdsetprior(byte **error_msg, void **s, x_matrix *pp, ulong _xparams);
        private static _dxv2_mcpdsetprior _i_xv2_mcpdsetprior = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mcpdsetpredictionweights(byte **error_msg, void **s, x_vector *pw, ulong _xparams);
        private static _dxv2_mcpdsetpredictionweights _i_xv2_mcpdsetpredictionweights = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mcpdsolve(byte **error_msg, void **s, ulong _xparams);
        private static _dxv2_mcpdsolve _i_xv2_mcpdsolve = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mcpdresults(byte **error_msg, void **s, x_matrix *p, x_mcpdreport *rep, ulong _xparams);
        private static _dxv2_mcpdresults _i_xv2_mcpdresults = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mnltrainh(byte **error_msg, x_matrix *xy, x_int *npoints, x_int *nvars, x_int *nclasses, x_int *info, void **lm, x_mnlreport *rep, ulong _xparams);
        private static _dxv2_mnltrainh _i_xv2_mnltrainh = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mnlprocess(byte **error_msg, void **lm, x_vector *x, x_vector *y, ulong _xparams);
        private static _dxv2_mnlprocess _i_xv2_mnlprocess = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mnlprocessi(byte **error_msg, void **lm, x_vector *x, x_vector *y, ulong _xparams);
        private static _dxv2_mnlprocessi _i_xv2_mnlprocessi = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mnlunpack(byte **error_msg, void **lm, x_matrix *a, x_int *nvars, x_int *nclasses, ulong _xparams);
        private static _dxv2_mnlunpack _i_xv2_mnlunpack = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mnlpack(byte **error_msg, x_matrix *a, x_int *nvars, x_int *nclasses, void **lm, ulong _xparams);
        private static _dxv2_mnlpack _i_xv2_mnlpack = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mnlavgce(byte **error_msg, double *result, void **lm, x_matrix *xy, x_int *npoints, ulong _xparams);
        private static _dxv2_mnlavgce _i_xv2_mnlavgce = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mnlrelclserror(byte **error_msg, double *result, void **lm, x_matrix *xy, x_int *npoints, ulong _xparams);
        private static _dxv2_mnlrelclserror _i_xv2_mnlrelclserror = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mnlrmserror(byte **error_msg, double *result, void **lm, x_matrix *xy, x_int *npoints, ulong _xparams);
        private static _dxv2_mnlrmserror _i_xv2_mnlrmserror = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mnlavgerror(byte **error_msg, double *result, void **lm, x_matrix *xy, x_int *npoints, ulong _xparams);
        private static _dxv2_mnlavgerror _i_xv2_mnlavgerror = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mnlavgrelerror(byte **error_msg, double *result, void **lm, x_matrix *xy, x_int *ssize, ulong _xparams);
        private static _dxv2_mnlavgrelerror _i_xv2_mnlavgrelerror = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mnlclserror(byte **error_msg, x_int *result, void **lm, x_matrix *xy, x_int *npoints, ulong _xparams);
        private static _dxv2_mnlclserror _i_xv2_mnlclserror = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_x_knnserialize(byte **error_msg, void **x, byte **dst);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_x_knnunserialize(byte **error_msg, byte **src, void **x);
        private static _d_x_knnserialize   _i_x_knnserialize   = null;
        private static _d_x_knnunserialize _i_x_knnunserialize = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_x_knnserialize_stream(byte **error_msg, void **x, native_stream_adapter.writer_delegate writer, IntPtr aux);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_x_knnunserialize_stream(byte **error_msg, native_stream_adapter.reader_delegate reader, IntPtr aux, void **x);
        private static _d_x_knnserialize_stream   _i_x_knnserialize_stream   = null;
        private static _d_x_knnunserialize_stream _i_x_knnunserialize_stream = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_knncreatebuffer(byte **error_msg, void **model, void **buf, ulong _xparams);
        private static _dxv2_knncreatebuffer _i_xv2_knncreatebuffer = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_knnbuildercreate(byte **error_msg, void **s, ulong _xparams);
        private static _dxv2_knnbuildercreate _i_xv2_knnbuildercreate = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_knnbuildersetdatasetreg(byte **error_msg, void **s, x_matrix *xy, x_int *npoints, x_int *nvars, x_int *nout, ulong _xparams);
        private static _dxv2_knnbuildersetdatasetreg _i_xv2_knnbuildersetdatasetreg = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_knnbuildersetdatasetcls(byte **error_msg, void **s, x_matrix *xy, x_int *npoints, x_int *nvars, x_int *nclasses, ulong _xparams);
        private static _dxv2_knnbuildersetdatasetcls _i_xv2_knnbuildersetdatasetcls = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_knnbuildersetnorm(byte **error_msg, void **s, x_int *nrmtype, ulong _xparams);
        private static _dxv2_knnbuildersetnorm _i_xv2_knnbuildersetnorm = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_knnbuilderbuildknnmodel(byte **error_msg, void **s, x_int *k, double *eps, void **model, x_knnreport *rep, ulong _xparams);
        private static _dxv2_knnbuilderbuildknnmodel _i_xv2_knnbuilderbuildknnmodel = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_knnrewritekeps(byte **error_msg, void **model, x_int *k, double *eps, ulong _xparams);
        private static _dxv2_knnrewritekeps _i_xv2_knnrewritekeps = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_knnprocess(byte **error_msg, void **model, x_vector *x, x_vector *y, ulong _xparams);
        private static _dxv2_knnprocess _i_xv2_knnprocess = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_knnprocess0(byte **error_msg, double *result, void **model, x_vector *x, ulong _xparams);
        private static _dxv2_knnprocess0 _i_xv2_knnprocess0 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_knnclassify(byte **error_msg, x_int *result, void **model, x_vector *x, ulong _xparams);
        private static _dxv2_knnclassify _i_xv2_knnclassify = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_knnprocessi(byte **error_msg, void **model, x_vector *x, x_vector *y, ulong _xparams);
        private static _dxv2_knnprocessi _i_xv2_knnprocessi = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_knntsprocess(byte **error_msg, void **model, void **buf, x_vector *x, x_vector *y, ulong _xparams);
        private static _dxv2_knntsprocess _i_xv2_knntsprocess = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_knnrelclserror(byte **error_msg, double *result, void **model, x_matrix *xy, x_int *npoints, ulong _xparams);
        private static _dxv2_knnrelclserror _i_xv2_knnrelclserror = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_knnavgce(byte **error_msg, double *result, void **model, x_matrix *xy, x_int *npoints, ulong _xparams);
        private static _dxv2_knnavgce _i_xv2_knnavgce = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_knnrmserror(byte **error_msg, double *result, void **model, x_matrix *xy, x_int *npoints, ulong _xparams);
        private static _dxv2_knnrmserror _i_xv2_knnrmserror = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_knnavgerror(byte **error_msg, double *result, void **model, x_matrix *xy, x_int *npoints, ulong _xparams);
        private static _dxv2_knnavgerror _i_xv2_knnavgerror = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_knnavgrelerror(byte **error_msg, double *result, void **model, x_matrix *xy, x_int *npoints, ulong _xparams);
        private static _dxv2_knnavgrelerror _i_xv2_knnavgrelerror = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_knnallerrors(byte **error_msg, void **model, x_matrix *xy, x_int *npoints, x_knnreport *rep, ulong _xparams);
        private static _dxv2_knnallerrors _i_xv2_knnallerrors = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlptrainlm(byte **error_msg, void **network, x_matrix *xy, x_int *npoints, double *decay, x_int *restarts, x_int *info, x_mlpreport *rep, ulong _xparams);
        private static _dxv2_mlptrainlm _i_xv2_mlptrainlm = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlptrainlbfgs(byte **error_msg, void **network, x_matrix *xy, x_int *npoints, double *decay, x_int *restarts, double *wstep, x_int *maxits, x_int *info, x_mlpreport *rep, ulong _xparams);
        private static _dxv2_mlptrainlbfgs _i_xv2_mlptrainlbfgs = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlptraines(byte **error_msg, void **network, x_matrix *trnxy, x_int *trnsize, x_matrix *valxy, x_int *valsize, double *decay, x_int *restarts, x_int *info, x_mlpreport *rep, ulong _xparams);
        private static _dxv2_mlptraines _i_xv2_mlptraines = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpkfoldcvlbfgs(byte **error_msg, void **network, x_matrix *xy, x_int *npoints, double *decay, x_int *restarts, double *wstep, x_int *maxits, x_int *foldscount, x_int *info, x_mlpreport *rep, x_mlpcvreport *cvrep, ulong _xparams);
        private static _dxv2_mlpkfoldcvlbfgs _i_xv2_mlpkfoldcvlbfgs = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpkfoldcvlm(byte **error_msg, void **network, x_matrix *xy, x_int *npoints, double *decay, x_int *restarts, x_int *foldscount, x_int *info, x_mlpreport *rep, x_mlpcvreport *cvrep, ulong _xparams);
        private static _dxv2_mlpkfoldcvlm _i_xv2_mlpkfoldcvlm = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpkfoldcv(byte **error_msg, void **s, void **network, x_int *nrestarts, x_int *foldscount, x_mlpreport *rep, ulong _xparams);
        private static _dxv2_mlpkfoldcv _i_xv2_mlpkfoldcv = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpcreatetrainer(byte **error_msg, x_int *nin, x_int *nout, void **s, ulong _xparams);
        private static _dxv2_mlpcreatetrainer _i_xv2_mlpcreatetrainer = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpcreatetrainercls(byte **error_msg, x_int *nin, x_int *nclasses, void **s, ulong _xparams);
        private static _dxv2_mlpcreatetrainercls _i_xv2_mlpcreatetrainercls = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpsetdataset(byte **error_msg, void **s, x_matrix *xy, x_int *npoints, ulong _xparams);
        private static _dxv2_mlpsetdataset _i_xv2_mlpsetdataset = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpsetsparsedataset(byte **error_msg, void **s, void **xy, x_int *npoints, ulong _xparams);
        private static _dxv2_mlpsetsparsedataset _i_xv2_mlpsetsparsedataset = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpsetdecay(byte **error_msg, void **s, double *decay, ulong _xparams);
        private static _dxv2_mlpsetdecay _i_xv2_mlpsetdecay = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpsetcond(byte **error_msg, void **s, double *wstep, x_int *maxits, ulong _xparams);
        private static _dxv2_mlpsetcond _i_xv2_mlpsetcond = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpsetalgobatch(byte **error_msg, void **s, ulong _xparams);
        private static _dxv2_mlpsetalgobatch _i_xv2_mlpsetalgobatch = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlptrainnetwork(byte **error_msg, void **s, void **network, x_int *nrestarts, x_mlpreport *rep, ulong _xparams);
        private static _dxv2_mlptrainnetwork _i_xv2_mlptrainnetwork = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpstarttraining(byte **error_msg, void **s, void **network, byte *randomstart, ulong _xparams);
        private static _dxv2_mlpstarttraining _i_xv2_mlpstarttraining = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpcontinuetraining(byte **error_msg, byte *result, void **s, void **network, ulong _xparams);
        private static _dxv2_mlpcontinuetraining _i_xv2_mlpcontinuetraining = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpebagginglm(byte **error_msg, void **ensemble, x_matrix *xy, x_int *npoints, double *decay, x_int *restarts, x_int *info, x_mlpreport *rep, x_mlpcvreport *ooberrors, ulong _xparams);
        private static _dxv2_mlpebagginglm _i_xv2_mlpebagginglm = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpebagginglbfgs(byte **error_msg, void **ensemble, x_matrix *xy, x_int *npoints, double *decay, x_int *restarts, double *wstep, x_int *maxits, x_int *info, x_mlpreport *rep, x_mlpcvreport *ooberrors, ulong _xparams);
        private static _dxv2_mlpebagginglbfgs _i_xv2_mlpebagginglbfgs = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlpetraines(byte **error_msg, void **ensemble, x_matrix *xy, x_int *npoints, double *decay, x_int *restarts, x_int *info, x_mlpreport *rep, ulong _xparams);
        private static _dxv2_mlpetraines _i_xv2_mlpetraines = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_mlptrainensemblees(byte **error_msg, void **s, void **ensemble, x_int *nrestarts, x_mlpreport *rep, ulong _xparams);
        private static _dxv2_mlptrainensemblees _i_xv2_mlptrainensemblees = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _dxv2_kmeansgenerate(byte **error_msg, x_matrix *xy, x_int *npoints, x_int *nvars, x_int *k, x_int *restarts, x_int *info, x_matrix *c, x_vector *xyc, ulong _xparams);
        private static _dxv2_kmeansgenerate _i_xv2_kmeansgenerate = null;


    //
    // This function loads pointers to functions of ALGLIB HPC core.
    // This function must be called once by activatealglibcore() during
    // initialization of HPC core.
    //
    private static void LoadALGLIBFunctions(IntPtr hTmpDL)
    {
        LoadXFunction(hTmpDL, "x_activate_core",            out x_activate_core);
        LoadXFunction(hTmpDL, "x_malloc",                   out x_malloc);
        LoadXFunction(hTmpDL, "x_free",                     out x_free);
        LoadXFunction(hTmpDL, "x_setnworkers",              out x_setnworkers);
        LoadXFunction(hTmpDL, "x_alloc_counter",            out x_alloc_counter);
        LoadXFunction(hTmpDL, "x_alloc_counter_activate",   out x_alloc_counter_activate);
        LoadXFunction(hTmpDL, "x_set_dbg_flag",             out x_set_dbg_flag);
        LoadXFunction(hTmpDL, "x_get_dbg_value",            out x_get_dbg_value);
        LoadXFunction(hTmpDL, "x_free_disposed_items",      out x_free_disposed_items);
        LoadXFunction(hTmpDL, "x_trace_file",               out x_trace_file);
        LoadXFunction(hTmpDL, "x_trace_disable",            out x_trace_disable);
        LoadXFunction(hTmpDL, "x_obj_copy_hqrndstate", out _i_x_obj_copy_hqrndstate);
        LoadXFunction(hTmpDL, "x_obj_free_hqrndstate", out _i_x_obj_free_hqrndstate);
            LoadXFunction(hTmpDL, "alglib_xv2_hqrndrandomize", out _i_xv2_hqrndrandomize);
            LoadXFunction(hTmpDL, "alglib_xv2_hqrndseed", out _i_xv2_hqrndseed);
            LoadXFunction(hTmpDL, "alglib_xv2_hqrnduniformr", out _i_xv2_hqrnduniformr);
            LoadXFunction(hTmpDL, "alglib_xv2_hqrnduniformi", out _i_xv2_hqrnduniformi);
            LoadXFunction(hTmpDL, "alglib_xv2_hqrndnormal", out _i_xv2_hqrndnormal);
            LoadXFunction(hTmpDL, "alglib_xv2_hqrndnormalv", out _i_xv2_hqrndnormalv);
            LoadXFunction(hTmpDL, "alglib_xv2_hqrndnormalm", out _i_xv2_hqrndnormalm);
            LoadXFunction(hTmpDL, "alglib_xv2_hqrndunit2", out _i_xv2_hqrndunit2);
            LoadXFunction(hTmpDL, "alglib_xv2_hqrndnormal2", out _i_xv2_hqrndnormal2);
            LoadXFunction(hTmpDL, "alglib_xv2_hqrndexponential", out _i_xv2_hqrndexponential);
            LoadXFunction(hTmpDL, "alglib_xv2_hqrnddiscrete", out _i_xv2_hqrnddiscrete);
            LoadXFunction(hTmpDL, "alglib_xv2_hqrndcontinuous", out _i_xv2_hqrndcontinuous);
            LoadXFunction(hTmpDL, "alglib_xv2_cmatrixtranspose", out _i_xv2_cmatrixtranspose);
            LoadXFunction(hTmpDL, "alglib_xv2_rmatrixtranspose", out _i_xv2_rmatrixtranspose);
            LoadXFunction(hTmpDL, "alglib_xv2_rmatrixenforcesymmetricity", out _i_xv2_rmatrixenforcesymmetricity);
            LoadXFunction(hTmpDL, "alglib_xv2_cmatrixcopy", out _i_xv2_cmatrixcopy);
            LoadXFunction(hTmpDL, "alglib_xv2_rvectorcopy", out _i_xv2_rvectorcopy);
            LoadXFunction(hTmpDL, "alglib_xv2_rmatrixcopy", out _i_xv2_rmatrixcopy);
            LoadXFunction(hTmpDL, "alglib_xv2_rmatrixgencopy", out _i_xv2_rmatrixgencopy);
            LoadXFunction(hTmpDL, "alglib_xv2_rmatrixger", out _i_xv2_rmatrixger);
            LoadXFunction(hTmpDL, "alglib_xv2_cmatrixrank1", out _i_xv2_cmatrixrank1);
            LoadXFunction(hTmpDL, "alglib_xv2_rmatrixrank1", out _i_xv2_rmatrixrank1);
            LoadXFunction(hTmpDL, "alglib_xv2_rmatrixgemv", out _i_xv2_rmatrixgemv);
            LoadXFunction(hTmpDL, "alglib_xv2_cmatrixmv", out _i_xv2_cmatrixmv);
            LoadXFunction(hTmpDL, "alglib_xv2_rmatrixmv", out _i_xv2_rmatrixmv);
            LoadXFunction(hTmpDL, "alglib_xv2_rmatrixsymv", out _i_xv2_rmatrixsymv);
            LoadXFunction(hTmpDL, "alglib_xv2_rmatrixsyvmv", out _i_xv2_rmatrixsyvmv);
            LoadXFunction(hTmpDL, "alglib_xv2_rmatrixtrsv", out _i_xv2_rmatrixtrsv);
            LoadXFunction(hTmpDL, "alglib_xv2_cmatrixrighttrsm", out _i_xv2_cmatrixrighttrsm);
            LoadXFunction(hTmpDL, "alglib_xv2_cmatrixlefttrsm", out _i_xv2_cmatrixlefttrsm);
            LoadXFunction(hTmpDL, "alglib_xv2_rmatrixrighttrsm", out _i_xv2_rmatrixrighttrsm);
            LoadXFunction(hTmpDL, "alglib_xv2_rmatrixlefttrsm", out _i_xv2_rmatrixlefttrsm);
            LoadXFunction(hTmpDL, "alglib_xv2_cmatrixherk", out _i_xv2_cmatrixherk);
            LoadXFunction(hTmpDL, "alglib_xv2_rmatrixsyrk", out _i_xv2_rmatrixsyrk);
            LoadXFunction(hTmpDL, "alglib_xv2_cmatrixgemm", out _i_xv2_cmatrixgemm);
            LoadXFunction(hTmpDL, "alglib_xv2_rmatrixgemm", out _i_xv2_rmatrixgemm);
            LoadXFunction(hTmpDL, "alglib_xv2_cmatrixsyrk", out _i_xv2_cmatrixsyrk);
            LoadXFunction(hTmpDL, "alglib_xv2_rmatrixqr", out _i_xv2_rmatrixqr);
            LoadXFunction(hTmpDL, "alglib_xv2_rmatrixlq", out _i_xv2_rmatrixlq);
            LoadXFunction(hTmpDL, "alglib_xv2_cmatrixqr", out _i_xv2_cmatrixqr);
            LoadXFunction(hTmpDL, "alglib_xv2_cmatrixlq", out _i_xv2_cmatrixlq);
            LoadXFunction(hTmpDL, "alglib_xv2_rmatrixqrunpackq", out _i_xv2_rmatrixqrunpackq);
            LoadXFunction(hTmpDL, "alglib_xv2_rmatrixqrunpackr", out _i_xv2_rmatrixqrunpackr);
            LoadXFunction(hTmpDL, "alglib_xv2_rmatrixlqunpackq", out _i_xv2_rmatrixlqunpackq);
            LoadXFunction(hTmpDL, "alglib_xv2_rmatrixlqunpackl", out _i_xv2_rmatrixlqunpackl);
            LoadXFunction(hTmpDL, "alglib_xv2_cmatrixqrunpackq", out _i_xv2_cmatrixqrunpackq);
            LoadXFunction(hTmpDL, "alglib_xv2_cmatrixqrunpackr", out _i_xv2_cmatrixqrunpackr);
            LoadXFunction(hTmpDL, "alglib_xv2_cmatrixlqunpackq", out _i_xv2_cmatrixlqunpackq);
            LoadXFunction(hTmpDL, "alglib_xv2_cmatrixlqunpackl", out _i_xv2_cmatrixlqunpackl);
            LoadXFunction(hTmpDL, "alglib_xv2_rmatrixbd", out _i_xv2_rmatrixbd);
            LoadXFunction(hTmpDL, "alglib_xv2_rmatrixbdunpackq", out _i_xv2_rmatrixbdunpackq);
            LoadXFunction(hTmpDL, "alglib_xv2_rmatrixbdmultiplybyq", out _i_xv2_rmatrixbdmultiplybyq);
            LoadXFunction(hTmpDL, "alglib_xv2_rmatrixbdunpackpt", out _i_xv2_rmatrixbdunpackpt);
            LoadXFunction(hTmpDL, "alglib_xv2_rmatrixbdmultiplybyp", out _i_xv2_rmatrixbdmultiplybyp);
            LoadXFunction(hTmpDL, "alglib_xv2_rmatrixbdunpackdiagonals", out _i_xv2_rmatrixbdunpackdiagonals);
            LoadXFunction(hTmpDL, "alglib_xv2_rmatrixhessenberg", out _i_xv2_rmatrixhessenberg);
            LoadXFunction(hTmpDL, "alglib_xv2_rmatrixhessenbergunpackq", out _i_xv2_rmatrixhessenbergunpackq);
            LoadXFunction(hTmpDL, "alglib_xv2_rmatrixhessenbergunpackh", out _i_xv2_rmatrixhessenbergunpackh);
            LoadXFunction(hTmpDL, "alglib_xv2_smatrixtd", out _i_xv2_smatrixtd);
            LoadXFunction(hTmpDL, "alglib_xv2_smatrixtdunpackq", out _i_xv2_smatrixtdunpackq);
            LoadXFunction(hTmpDL, "alglib_xv2_hmatrixtd", out _i_xv2_hmatrixtd);
            LoadXFunction(hTmpDL, "alglib_xv2_hmatrixtdunpackq", out _i_xv2_hmatrixtdunpackq);
            LoadXFunction(hTmpDL, "alglib_xv2_rmatrixrndorthogonal", out _i_xv2_rmatrixrndorthogonal);
            LoadXFunction(hTmpDL, "alglib_xv2_rmatrixrndcond", out _i_xv2_rmatrixrndcond);
            LoadXFunction(hTmpDL, "alglib_xv2_cmatrixrndorthogonal", out _i_xv2_cmatrixrndorthogonal);
            LoadXFunction(hTmpDL, "alglib_xv2_cmatrixrndcond", out _i_xv2_cmatrixrndcond);
            LoadXFunction(hTmpDL, "alglib_xv2_smatrixrndcond", out _i_xv2_smatrixrndcond);
            LoadXFunction(hTmpDL, "alglib_xv2_spdmatrixrndcond", out _i_xv2_spdmatrixrndcond);
            LoadXFunction(hTmpDL, "alglib_xv2_hmatrixrndcond", out _i_xv2_hmatrixrndcond);
            LoadXFunction(hTmpDL, "alglib_xv2_hpdmatrixrndcond", out _i_xv2_hpdmatrixrndcond);
            LoadXFunction(hTmpDL, "alglib_xv2_rmatrixrndorthogonalfromtheright", out _i_xv2_rmatrixrndorthogonalfromtheright);
            LoadXFunction(hTmpDL, "alglib_xv2_rmatrixrndorthogonalfromtheleft", out _i_xv2_rmatrixrndorthogonalfromtheleft);
            LoadXFunction(hTmpDL, "alglib_xv2_cmatrixrndorthogonalfromtheright", out _i_xv2_cmatrixrndorthogonalfromtheright);
            LoadXFunction(hTmpDL, "alglib_xv2_cmatrixrndorthogonalfromtheleft", out _i_xv2_cmatrixrndorthogonalfromtheleft);
            LoadXFunction(hTmpDL, "alglib_xv2_smatrixrndmultiply", out _i_xv2_smatrixrndmultiply);
            LoadXFunction(hTmpDL, "alglib_xv2_hmatrixrndmultiply", out _i_xv2_hmatrixrndmultiply);
        LoadXFunction(hTmpDL, "x_obj_copy_sparsematrix", out _i_x_obj_copy_sparsematrix);
        LoadXFunction(hTmpDL, "x_obj_free_sparsematrix", out _i_x_obj_free_sparsematrix);
        LoadXFunction(hTmpDL, "x_obj_copy_sparsebuffers", out _i_x_obj_copy_sparsebuffers);
        LoadXFunction(hTmpDL, "x_obj_free_sparsebuffers", out _i_x_obj_free_sparsebuffers);
            LoadXFunction(hTmpDL, "alglib_sparseserialize",   out _i_x_sparseserialize);
            LoadXFunction(hTmpDL, "alglib_sparseunserialize", out _i_x_sparseunserialize);
            LoadXFunction(hTmpDL, "alglib_sparseserialize_stream",   out _i_x_sparseserialize_stream);
            LoadXFunction(hTmpDL, "alglib_sparseunserialize_stream", out _i_x_sparseunserialize_stream);
            LoadXFunction(hTmpDL, "alglib_xv2_sparsecreate", out _i_xv2_sparsecreate);
            LoadXFunction(hTmpDL, "alglib_xv2_sparsecreatebuf", out _i_xv2_sparsecreatebuf);
            LoadXFunction(hTmpDL, "alglib_xv2_sparsecreatecrs", out _i_xv2_sparsecreatecrs);
            LoadXFunction(hTmpDL, "alglib_xv2_sparsecreatecrsbuf", out _i_xv2_sparsecreatecrsbuf);
            LoadXFunction(hTmpDL, "alglib_xv2_sparsecreatesks", out _i_xv2_sparsecreatesks);
            LoadXFunction(hTmpDL, "alglib_xv2_sparsecreatesksbuf", out _i_xv2_sparsecreatesksbuf);
            LoadXFunction(hTmpDL, "alglib_xv2_sparsecreatesksband", out _i_xv2_sparsecreatesksband);
            LoadXFunction(hTmpDL, "alglib_xv2_sparsecreatesksbandbuf", out _i_xv2_sparsecreatesksbandbuf);
            LoadXFunction(hTmpDL, "alglib_xv2_sparsecopy", out _i_xv2_sparsecopy);
            LoadXFunction(hTmpDL, "alglib_xv2_sparsecopybuf", out _i_xv2_sparsecopybuf);
            LoadXFunction(hTmpDL, "alglib_xv2_sparseswap", out _i_xv2_sparseswap);
            LoadXFunction(hTmpDL, "alglib_xv2_sparseadd", out _i_xv2_sparseadd);
            LoadXFunction(hTmpDL, "alglib_xv2_sparseset", out _i_xv2_sparseset);
            LoadXFunction(hTmpDL, "alglib_xv2_sparseget", out _i_xv2_sparseget);
            LoadXFunction(hTmpDL, "alglib_xv2_sparseexists", out _i_xv2_sparseexists);
            LoadXFunction(hTmpDL, "alglib_xv2_sparsegetdiagonal", out _i_xv2_sparsegetdiagonal);
            LoadXFunction(hTmpDL, "alglib_xv2_sparsemv", out _i_xv2_sparsemv);
            LoadXFunction(hTmpDL, "alglib_xv2_sparsemtv", out _i_xv2_sparsemtv);
            LoadXFunction(hTmpDL, "alglib_xv2_sparsegemv", out _i_xv2_sparsegemv);
            LoadXFunction(hTmpDL, "alglib_xv2_sparsemv2", out _i_xv2_sparsemv2);
            LoadXFunction(hTmpDL, "alglib_xv2_sparsesmv", out _i_xv2_sparsesmv);
            LoadXFunction(hTmpDL, "alglib_xv2_sparsevsmv", out _i_xv2_sparsevsmv);
            LoadXFunction(hTmpDL, "alglib_xv2_sparsemm", out _i_xv2_sparsemm);
            LoadXFunction(hTmpDL, "alglib_xv2_sparsemtm", out _i_xv2_sparsemtm);
            LoadXFunction(hTmpDL, "alglib_xv2_sparsemm2", out _i_xv2_sparsemm2);
            LoadXFunction(hTmpDL, "alglib_xv2_sparsesmm", out _i_xv2_sparsesmm);
            LoadXFunction(hTmpDL, "alglib_xv2_sparsetrmv", out _i_xv2_sparsetrmv);
            LoadXFunction(hTmpDL, "alglib_xv2_sparsetrsv", out _i_xv2_sparsetrsv);
            LoadXFunction(hTmpDL, "alglib_xv2_sparsesymmpermtbl", out _i_xv2_sparsesymmpermtbl);
            LoadXFunction(hTmpDL, "alglib_xv2_sparsesymmpermtblbuf", out _i_xv2_sparsesymmpermtblbuf);
            LoadXFunction(hTmpDL, "alglib_xv2_sparseresizematrix", out _i_xv2_sparseresizematrix);
            LoadXFunction(hTmpDL, "alglib_xv2_sparseenumerate", out _i_xv2_sparseenumerate);
            LoadXFunction(hTmpDL, "alglib_xv2_sparserewriteexisting", out _i_xv2_sparserewriteexisting);
            LoadXFunction(hTmpDL, "alglib_xv2_sparsegetrow", out _i_xv2_sparsegetrow);
            LoadXFunction(hTmpDL, "alglib_xv2_sparsegetcompressedrow", out _i_xv2_sparsegetcompressedrow);
            LoadXFunction(hTmpDL, "alglib_xv2_sparsetransposesks", out _i_xv2_sparsetransposesks);
            LoadXFunction(hTmpDL, "alglib_xv2_sparsetransposecrs", out _i_xv2_sparsetransposecrs);
            LoadXFunction(hTmpDL, "alglib_xv2_sparsecopytransposecrs", out _i_xv2_sparsecopytransposecrs);
            LoadXFunction(hTmpDL, "alglib_xv2_sparsecopytransposecrsbuf", out _i_xv2_sparsecopytransposecrsbuf);
            LoadXFunction(hTmpDL, "alglib_xv2_sparseconvertto", out _i_xv2_sparseconvertto);
            LoadXFunction(hTmpDL, "alglib_xv2_sparsecopytobuf", out _i_xv2_sparsecopytobuf);
            LoadXFunction(hTmpDL, "alglib_xv2_sparseconverttohash", out _i_xv2_sparseconverttohash);
            LoadXFunction(hTmpDL, "alglib_xv2_sparsecopytohash", out _i_xv2_sparsecopytohash);
            LoadXFunction(hTmpDL, "alglib_xv2_sparsecopytohashbuf", out _i_xv2_sparsecopytohashbuf);
            LoadXFunction(hTmpDL, "alglib_xv2_sparseconverttocrs", out _i_xv2_sparseconverttocrs);
            LoadXFunction(hTmpDL, "alglib_xv2_sparsecopytocrs", out _i_xv2_sparsecopytocrs);
            LoadXFunction(hTmpDL, "alglib_xv2_sparsecopytocrsbuf", out _i_xv2_sparsecopytocrsbuf);
            LoadXFunction(hTmpDL, "alglib_xv2_sparseconverttosks", out _i_xv2_sparseconverttosks);
            LoadXFunction(hTmpDL, "alglib_xv2_sparsecopytosks", out _i_xv2_sparsecopytosks);
            LoadXFunction(hTmpDL, "alglib_xv2_sparsecopytosksbuf", out _i_xv2_sparsecopytosksbuf);
            LoadXFunction(hTmpDL, "alglib_xv2_sparsegetmatrixtype", out _i_xv2_sparsegetmatrixtype);
            LoadXFunction(hTmpDL, "alglib_xv2_sparseishash", out _i_xv2_sparseishash);
            LoadXFunction(hTmpDL, "alglib_xv2_sparseiscrs", out _i_xv2_sparseiscrs);
            LoadXFunction(hTmpDL, "alglib_xv2_sparseissks", out _i_xv2_sparseissks);
            LoadXFunction(hTmpDL, "alglib_xv2_sparsefree", out _i_xv2_sparsefree);
            LoadXFunction(hTmpDL, "alglib_xv2_sparsegetnrows", out _i_xv2_sparsegetnrows);
            LoadXFunction(hTmpDL, "alglib_xv2_sparsegetncols", out _i_xv2_sparsegetncols);
            LoadXFunction(hTmpDL, "alglib_xv2_sparsegetuppercount", out _i_xv2_sparsegetuppercount);
            LoadXFunction(hTmpDL, "alglib_xv2_sparsegetlowercount", out _i_xv2_sparsegetlowercount);
        LoadXFunction(hTmpDL, "x_obj_copy_eigsubspacestate", out _i_x_obj_copy_eigsubspacestate);
        LoadXFunction(hTmpDL, "x_obj_free_eigsubspacestate", out _i_x_obj_free_eigsubspacestate);
            LoadXFunction(hTmpDL, "alglib_xv2_eigsubspacecreate", out _i_xv2_eigsubspacecreate);
            LoadXFunction(hTmpDL, "alglib_xv2_eigsubspacecreatebuf", out _i_xv2_eigsubspacecreatebuf);
            LoadXFunction(hTmpDL, "alglib_xv2_eigsubspacesetcond", out _i_xv2_eigsubspacesetcond);
            LoadXFunction(hTmpDL, "alglib_xv2_eigsubspacesetwarmstart", out _i_xv2_eigsubspacesetwarmstart);
            LoadXFunction(hTmpDL, "alglib_xv2_eigsubspaceoocstart", out _i_xv2_eigsubspaceoocstart);
            LoadXFunction(hTmpDL, "alglib_xv2_eigsubspaceooccontinue", out _i_xv2_eigsubspaceooccontinue);
            LoadXFunction(hTmpDL, "alglib_xv2_eigsubspaceoocgetrequestinfo", out _i_xv2_eigsubspaceoocgetrequestinfo);
            LoadXFunction(hTmpDL, "alglib_xv2_eigsubspaceoocgetrequestdata", out _i_xv2_eigsubspaceoocgetrequestdata);
            LoadXFunction(hTmpDL, "alglib_xv2_eigsubspaceoocsendresult", out _i_xv2_eigsubspaceoocsendresult);
            LoadXFunction(hTmpDL, "alglib_xv2_eigsubspaceoocstop", out _i_xv2_eigsubspaceoocstop);
            LoadXFunction(hTmpDL, "alglib_xv2_eigsubspacesolvedenses", out _i_xv2_eigsubspacesolvedenses);
            LoadXFunction(hTmpDL, "alglib_xv2_eigsubspacesolvesparses", out _i_xv2_eigsubspacesolvesparses);
            LoadXFunction(hTmpDL, "alglib_xv2_smatrixevd", out _i_xv2_smatrixevd);
            LoadXFunction(hTmpDL, "alglib_xv2_smatrixevdr", out _i_xv2_smatrixevdr);
            LoadXFunction(hTmpDL, "alglib_xv2_smatrixevdi", out _i_xv2_smatrixevdi);
            LoadXFunction(hTmpDL, "alglib_xv2_hmatrixevd", out _i_xv2_hmatrixevd);
            LoadXFunction(hTmpDL, "alglib_xv2_hmatrixevdr", out _i_xv2_hmatrixevdr);
            LoadXFunction(hTmpDL, "alglib_xv2_hmatrixevdi", out _i_xv2_hmatrixevdi);
            LoadXFunction(hTmpDL, "alglib_xv2_smatrixtdevd", out _i_xv2_smatrixtdevd);
            LoadXFunction(hTmpDL, "alglib_xv2_smatrixtdevdr", out _i_xv2_smatrixtdevdr);
            LoadXFunction(hTmpDL, "alglib_xv2_smatrixtdevdi", out _i_xv2_smatrixtdevdi);
            LoadXFunction(hTmpDL, "alglib_xv2_rmatrixevd", out _i_xv2_rmatrixevd);
        LoadXFunction(hTmpDL, "x_obj_copy_sparsedecompositionanalysis", out _i_x_obj_copy_sparsedecompositionanalysis);
        LoadXFunction(hTmpDL, "x_obj_free_sparsedecompositionanalysis", out _i_x_obj_free_sparsedecompositionanalysis);
            LoadXFunction(hTmpDL, "alglib_xv2_rmatrixlu", out _i_xv2_rmatrixlu);
            LoadXFunction(hTmpDL, "alglib_xv2_cmatrixlu", out _i_xv2_cmatrixlu);
            LoadXFunction(hTmpDL, "alglib_xv2_hpdmatrixcholesky", out _i_xv2_hpdmatrixcholesky);
            LoadXFunction(hTmpDL, "alglib_xv2_spdmatrixcholesky", out _i_xv2_spdmatrixcholesky);
            LoadXFunction(hTmpDL, "alglib_xv2_spdmatrixcholeskyupdateadd1", out _i_xv2_spdmatrixcholeskyupdateadd1);
            LoadXFunction(hTmpDL, "alglib_xv2_spdmatrixcholeskyupdatefix", out _i_xv2_spdmatrixcholeskyupdatefix);
            LoadXFunction(hTmpDL, "alglib_xv2_spdmatrixcholeskyupdateadd1buf", out _i_xv2_spdmatrixcholeskyupdateadd1buf);
            LoadXFunction(hTmpDL, "alglib_xv2_spdmatrixcholeskyupdatefixbuf", out _i_xv2_spdmatrixcholeskyupdatefixbuf);
            LoadXFunction(hTmpDL, "alglib_xv2_sparselu", out _i_xv2_sparselu);
            LoadXFunction(hTmpDL, "alglib_xv2_sparsecholeskyskyline", out _i_xv2_sparsecholeskyskyline);
            LoadXFunction(hTmpDL, "alglib_xv2_sparsecholesky", out _i_xv2_sparsecholesky);
            LoadXFunction(hTmpDL, "alglib_xv2_sparsecholeskyp", out _i_xv2_sparsecholeskyp);
            LoadXFunction(hTmpDL, "alglib_xv2_sparsecholeskyanalyze", out _i_xv2_sparsecholeskyanalyze);
            LoadXFunction(hTmpDL, "alglib_xv2_sparsecholeskyfactorize", out _i_xv2_sparsecholeskyfactorize);
            LoadXFunction(hTmpDL, "alglib_xv2_sparsecholeskyreload", out _i_xv2_sparsecholeskyreload);
            LoadXFunction(hTmpDL, "alglib_xv2_polynomialsolve", out _i_xv2_polynomialsolve);
            LoadXFunction(hTmpDL, "alglib_xv2_rmatrixbdsvd", out _i_xv2_rmatrixbdsvd);
            LoadXFunction(hTmpDL, "alglib_xv2_rmatrixsvd", out _i_xv2_rmatrixsvd);
            LoadXFunction(hTmpDL, "alglib_xv2_rmatrixrcond1", out _i_xv2_rmatrixrcond1);
            LoadXFunction(hTmpDL, "alglib_xv2_rmatrixrcondinf", out _i_xv2_rmatrixrcondinf);
            LoadXFunction(hTmpDL, "alglib_xv2_spdmatrixrcond", out _i_xv2_spdmatrixrcond);
            LoadXFunction(hTmpDL, "alglib_xv2_rmatrixtrrcond1", out _i_xv2_rmatrixtrrcond1);
            LoadXFunction(hTmpDL, "alglib_xv2_rmatrixtrrcondinf", out _i_xv2_rmatrixtrrcondinf);
            LoadXFunction(hTmpDL, "alglib_xv2_hpdmatrixrcond", out _i_xv2_hpdmatrixrcond);
            LoadXFunction(hTmpDL, "alglib_xv2_cmatrixrcond1", out _i_xv2_cmatrixrcond1);
            LoadXFunction(hTmpDL, "alglib_xv2_cmatrixrcondinf", out _i_xv2_cmatrixrcondinf);
            LoadXFunction(hTmpDL, "alglib_xv2_rmatrixlurcond1", out _i_xv2_rmatrixlurcond1);
            LoadXFunction(hTmpDL, "alglib_xv2_rmatrixlurcondinf", out _i_xv2_rmatrixlurcondinf);
            LoadXFunction(hTmpDL, "alglib_xv2_spdmatrixcholeskyrcond", out _i_xv2_spdmatrixcholeskyrcond);
            LoadXFunction(hTmpDL, "alglib_xv2_hpdmatrixcholeskyrcond", out _i_xv2_hpdmatrixcholeskyrcond);
            LoadXFunction(hTmpDL, "alglib_xv2_cmatrixlurcond1", out _i_xv2_cmatrixlurcond1);
            LoadXFunction(hTmpDL, "alglib_xv2_cmatrixlurcondinf", out _i_xv2_cmatrixlurcondinf);
            LoadXFunction(hTmpDL, "alglib_xv2_cmatrixtrrcond1", out _i_xv2_cmatrixtrrcond1);
            LoadXFunction(hTmpDL, "alglib_xv2_cmatrixtrrcondinf", out _i_xv2_cmatrixtrrcondinf);
            LoadXFunction(hTmpDL, "alglib_xv2_rmatrixsolve", out _i_xv2_rmatrixsolve);
            LoadXFunction(hTmpDL, "alglib_xv2_rmatrixsolvefast", out _i_xv2_rmatrixsolvefast);
            LoadXFunction(hTmpDL, "alglib_xv2_rmatrixsolvem", out _i_xv2_rmatrixsolvem);
            LoadXFunction(hTmpDL, "alglib_xv2_rmatrixsolvemfast", out _i_xv2_rmatrixsolvemfast);
            LoadXFunction(hTmpDL, "alglib_xv2_rmatrixlusolve", out _i_xv2_rmatrixlusolve);
            LoadXFunction(hTmpDL, "alglib_xv2_rmatrixlusolvefast", out _i_xv2_rmatrixlusolvefast);
            LoadXFunction(hTmpDL, "alglib_xv2_rmatrixlusolvem", out _i_xv2_rmatrixlusolvem);
            LoadXFunction(hTmpDL, "alglib_xv2_rmatrixlusolvemfast", out _i_xv2_rmatrixlusolvemfast);
            LoadXFunction(hTmpDL, "alglib_xv2_rmatrixmixedsolve", out _i_xv2_rmatrixmixedsolve);
            LoadXFunction(hTmpDL, "alglib_xv2_rmatrixmixedsolvem", out _i_xv2_rmatrixmixedsolvem);
            LoadXFunction(hTmpDL, "alglib_xv2_cmatrixsolvem", out _i_xv2_cmatrixsolvem);
            LoadXFunction(hTmpDL, "alglib_xv2_cmatrixsolvemfast", out _i_xv2_cmatrixsolvemfast);
            LoadXFunction(hTmpDL, "alglib_xv2_cmatrixsolve", out _i_xv2_cmatrixsolve);
            LoadXFunction(hTmpDL, "alglib_xv2_cmatrixsolvefast", out _i_xv2_cmatrixsolvefast);
            LoadXFunction(hTmpDL, "alglib_xv2_cmatrixlusolvem", out _i_xv2_cmatrixlusolvem);
            LoadXFunction(hTmpDL, "alglib_xv2_cmatrixlusolvemfast", out _i_xv2_cmatrixlusolvemfast);
            LoadXFunction(hTmpDL, "alglib_xv2_cmatrixlusolve", out _i_xv2_cmatrixlusolve);
            LoadXFunction(hTmpDL, "alglib_xv2_cmatrixlusolvefast", out _i_xv2_cmatrixlusolvefast);
            LoadXFunction(hTmpDL, "alglib_xv2_cmatrixmixedsolvem", out _i_xv2_cmatrixmixedsolvem);
            LoadXFunction(hTmpDL, "alglib_xv2_cmatrixmixedsolve", out _i_xv2_cmatrixmixedsolve);
            LoadXFunction(hTmpDL, "alglib_xv2_spdmatrixsolvem", out _i_xv2_spdmatrixsolvem);
            LoadXFunction(hTmpDL, "alglib_xv2_spdmatrixsolvemfast", out _i_xv2_spdmatrixsolvemfast);
            LoadXFunction(hTmpDL, "alglib_xv2_spdmatrixsolve", out _i_xv2_spdmatrixsolve);
            LoadXFunction(hTmpDL, "alglib_xv2_spdmatrixsolvefast", out _i_xv2_spdmatrixsolvefast);
            LoadXFunction(hTmpDL, "alglib_xv2_spdmatrixcholeskysolvem", out _i_xv2_spdmatrixcholeskysolvem);
            LoadXFunction(hTmpDL, "alglib_xv2_spdmatrixcholeskysolvemfast", out _i_xv2_spdmatrixcholeskysolvemfast);
            LoadXFunction(hTmpDL, "alglib_xv2_spdmatrixcholeskysolve", out _i_xv2_spdmatrixcholeskysolve);
            LoadXFunction(hTmpDL, "alglib_xv2_spdmatrixcholeskysolvefast", out _i_xv2_spdmatrixcholeskysolvefast);
            LoadXFunction(hTmpDL, "alglib_xv2_hpdmatrixsolvem", out _i_xv2_hpdmatrixsolvem);
            LoadXFunction(hTmpDL, "alglib_xv2_hpdmatrixsolvemfast", out _i_xv2_hpdmatrixsolvemfast);
            LoadXFunction(hTmpDL, "alglib_xv2_hpdmatrixsolve", out _i_xv2_hpdmatrixsolve);
            LoadXFunction(hTmpDL, "alglib_xv2_hpdmatrixsolvefast", out _i_xv2_hpdmatrixsolvefast);
            LoadXFunction(hTmpDL, "alglib_xv2_hpdmatrixcholeskysolvem", out _i_xv2_hpdmatrixcholeskysolvem);
            LoadXFunction(hTmpDL, "alglib_xv2_hpdmatrixcholeskysolvemfast", out _i_xv2_hpdmatrixcholeskysolvemfast);
            LoadXFunction(hTmpDL, "alglib_xv2_hpdmatrixcholeskysolve", out _i_xv2_hpdmatrixcholeskysolve);
            LoadXFunction(hTmpDL, "alglib_xv2_hpdmatrixcholeskysolvefast", out _i_xv2_hpdmatrixcholeskysolvefast);
            LoadXFunction(hTmpDL, "alglib_xv2_rmatrixsolvels", out _i_xv2_rmatrixsolvels);
            LoadXFunction(hTmpDL, "alglib_xv2_sparsespdsolvesks", out _i_xv2_sparsespdsolvesks);
            LoadXFunction(hTmpDL, "alglib_xv2_sparsespdsolve", out _i_xv2_sparsespdsolve);
            LoadXFunction(hTmpDL, "alglib_xv2_sparsespdcholeskysolve", out _i_xv2_sparsespdcholeskysolve);
            LoadXFunction(hTmpDL, "alglib_xv2_sparsesolve", out _i_xv2_sparsesolve);
            LoadXFunction(hTmpDL, "alglib_xv2_sparselusolve", out _i_xv2_sparselusolve);
        LoadXFunction(hTmpDL, "x_obj_copy_sparsesolverstate", out _i_x_obj_copy_sparsesolverstate);
        LoadXFunction(hTmpDL, "x_obj_free_sparsesolverstate", out _i_x_obj_free_sparsesolverstate);
            LoadXFunction(hTmpDL, "alglib_xv2_sparsesolvesymmetricgmres", out _i_xv2_sparsesolvesymmetricgmres);
            LoadXFunction(hTmpDL, "alglib_xv2_sparsesolvegmres", out _i_xv2_sparsesolvegmres);
            LoadXFunction(hTmpDL, "alglib_xv2_sparsesolvercreate", out _i_xv2_sparsesolvercreate);
            LoadXFunction(hTmpDL, "alglib_xv2_sparsesolversetalgogmres", out _i_xv2_sparsesolversetalgogmres);
            LoadXFunction(hTmpDL, "alglib_xv2_sparsesolversetstartingpoint", out _i_xv2_sparsesolversetstartingpoint);
            LoadXFunction(hTmpDL, "alglib_xv2_sparsesolversetcond", out _i_xv2_sparsesolversetcond);
            LoadXFunction(hTmpDL, "alglib_xv2_sparsesolversolvesymmetric", out _i_xv2_sparsesolversolvesymmetric);
            LoadXFunction(hTmpDL, "alglib_xv2_sparsesolversolve", out _i_xv2_sparsesolversolve);
            LoadXFunction(hTmpDL, "alglib_xv2_sparsesolverresults", out _i_xv2_sparsesolverresults);
            LoadXFunction(hTmpDL, "alglib_xv2_sparsesolversetxrep", out _i_xv2_sparsesolversetxrep);
            LoadXFunction(hTmpDL, "alglib_xv2_sparsesolveroocstart", out _i_xv2_sparsesolveroocstart);
            LoadXFunction(hTmpDL, "alglib_xv2_sparsesolverooccontinue", out _i_xv2_sparsesolverooccontinue);
            LoadXFunction(hTmpDL, "alglib_xv2_sparsesolveroocgetrequestinfo", out _i_xv2_sparsesolveroocgetrequestinfo);
            LoadXFunction(hTmpDL, "alglib_xv2_sparsesolveroocgetrequestdata", out _i_xv2_sparsesolveroocgetrequestdata);
            LoadXFunction(hTmpDL, "alglib_xv2_sparsesolveroocgetrequestdata1", out _i_xv2_sparsesolveroocgetrequestdata1);
            LoadXFunction(hTmpDL, "alglib_xv2_sparsesolveroocsendresult", out _i_xv2_sparsesolveroocsendresult);
            LoadXFunction(hTmpDL, "alglib_xv2_sparsesolveroocstop", out _i_xv2_sparsesolveroocstop);
            LoadXFunction(hTmpDL, "alglib_xv2_sparsesolverrequesttermination", out _i_xv2_sparsesolverrequesttermination);
        LoadXFunction(hTmpDL, "x_obj_copy_lincgstate", out _i_x_obj_copy_lincgstate);
        LoadXFunction(hTmpDL, "x_obj_free_lincgstate", out _i_x_obj_free_lincgstate);
            LoadXFunction(hTmpDL, "alglib_xv2_lincgcreate", out _i_xv2_lincgcreate);
            LoadXFunction(hTmpDL, "alglib_xv2_lincgsetstartingpoint", out _i_xv2_lincgsetstartingpoint);
            LoadXFunction(hTmpDL, "alglib_xv2_lincgsetprecunit", out _i_xv2_lincgsetprecunit);
            LoadXFunction(hTmpDL, "alglib_xv2_lincgsetprecdiag", out _i_xv2_lincgsetprecdiag);
            LoadXFunction(hTmpDL, "alglib_xv2_lincgsetcond", out _i_xv2_lincgsetcond);
            LoadXFunction(hTmpDL, "alglib_xv2_lincgsolvesparse", out _i_xv2_lincgsolvesparse);
            LoadXFunction(hTmpDL, "alglib_xv2_lincgresults", out _i_xv2_lincgresults);
            LoadXFunction(hTmpDL, "alglib_xv2_lincgsetrestartfreq", out _i_xv2_lincgsetrestartfreq);
            LoadXFunction(hTmpDL, "alglib_xv2_lincgsetrupdatefreq", out _i_xv2_lincgsetrupdatefreq);
            LoadXFunction(hTmpDL, "alglib_xv2_lincgsetxrep", out _i_xv2_lincgsetxrep);
        LoadXFunction(hTmpDL, "x_obj_copy_normestimatorstate", out _i_x_obj_copy_normestimatorstate);
        LoadXFunction(hTmpDL, "x_obj_free_normestimatorstate", out _i_x_obj_free_normestimatorstate);
            LoadXFunction(hTmpDL, "alglib_xv2_normestimatorcreate", out _i_xv2_normestimatorcreate);
            LoadXFunction(hTmpDL, "alglib_xv2_normestimatorsetseed", out _i_xv2_normestimatorsetseed);
            LoadXFunction(hTmpDL, "alglib_xv2_normestimatorestimatesparse", out _i_xv2_normestimatorestimatesparse);
            LoadXFunction(hTmpDL, "alglib_xv2_normestimatorresults", out _i_xv2_normestimatorresults);
        LoadXFunction(hTmpDL, "x_obj_copy_linlsqrstate", out _i_x_obj_copy_linlsqrstate);
        LoadXFunction(hTmpDL, "x_obj_free_linlsqrstate", out _i_x_obj_free_linlsqrstate);
            LoadXFunction(hTmpDL, "alglib_xv2_linlsqrcreate", out _i_xv2_linlsqrcreate);
            LoadXFunction(hTmpDL, "alglib_xv2_linlsqrcreatebuf", out _i_xv2_linlsqrcreatebuf);
            LoadXFunction(hTmpDL, "alglib_xv2_linlsqrsetprecunit", out _i_xv2_linlsqrsetprecunit);
            LoadXFunction(hTmpDL, "alglib_xv2_linlsqrsetprecdiag", out _i_xv2_linlsqrsetprecdiag);
            LoadXFunction(hTmpDL, "alglib_xv2_linlsqrsetlambdai", out _i_xv2_linlsqrsetlambdai);
            LoadXFunction(hTmpDL, "alglib_xv2_linlsqrsolvesparse", out _i_xv2_linlsqrsolvesparse);
            LoadXFunction(hTmpDL, "alglib_xv2_linlsqrsetcond", out _i_xv2_linlsqrsetcond);
            LoadXFunction(hTmpDL, "alglib_xv2_linlsqrresults", out _i_xv2_linlsqrresults);
            LoadXFunction(hTmpDL, "alglib_xv2_linlsqrsetxrep", out _i_xv2_linlsqrsetxrep);
            LoadXFunction(hTmpDL, "alglib_xv2_linlsqrpeekiterationscount", out _i_xv2_linlsqrpeekiterationscount);
            LoadXFunction(hTmpDL, "alglib_xv2_linlsqrrequesttermination", out _i_xv2_linlsqrrequesttermination);
        LoadXFunction(hTmpDL, "x_obj_copy_nleqstate", out _i_x_obj_copy_nleqstate);
        LoadXFunction(hTmpDL, "x_obj_free_nleqstate", out _i_x_obj_free_nleqstate);
        LoadXFunction(hTmpDL, "x_nleqstate_get_needf", out _i_x_nleqstate_get_needf);
        LoadXFunction(hTmpDL, "x_nleqstate_set_needf", out _i_x_nleqstate_set_needf);
        LoadXFunction(hTmpDL, "x_nleqstate_get_needfij", out _i_x_nleqstate_get_needfij);
        LoadXFunction(hTmpDL, "x_nleqstate_set_needfij", out _i_x_nleqstate_set_needfij);
        LoadXFunction(hTmpDL, "x_nleqstate_get_xupdated", out _i_x_nleqstate_get_xupdated);
        LoadXFunction(hTmpDL, "x_nleqstate_set_xupdated", out _i_x_nleqstate_set_xupdated);
        LoadXFunction(hTmpDL, "x_nleqstate_get_f", out _i_x_nleqstate_get_f);
        LoadXFunction(hTmpDL, "x_nleqstate_set_f", out _i_x_nleqstate_set_f);
        LoadXFunction(hTmpDL, "x_nleqstate_get_fi", out _i_x_nleqstate_get_fi);
        LoadXFunction(hTmpDL, "x_nleqstate_get_j", out _i_x_nleqstate_get_j);
        LoadXFunction(hTmpDL, "x_nleqstate_get_x", out _i_x_nleqstate_get_x);
            LoadXFunction(hTmpDL, "alglib_xv2_nleqcreatelm", out _i_xv2_nleqcreatelm);
            LoadXFunction(hTmpDL, "alglib_xv2_nleqsetcond", out _i_xv2_nleqsetcond);
            LoadXFunction(hTmpDL, "alglib_xv2_nleqsetxrep", out _i_xv2_nleqsetxrep);
            LoadXFunction(hTmpDL, "alglib_xv2_nleqsetstpmax", out _i_xv2_nleqsetstpmax);
            LoadXFunction(hTmpDL, "alglib_xv2_nleqiteration", out _i_xv2_nleqiteration);
            LoadXFunction(hTmpDL, "alglib_xv2_nleqresults", out _i_xv2_nleqresults);
            LoadXFunction(hTmpDL, "alglib_xv2_nleqresultsbuf", out _i_xv2_nleqresultsbuf);
            LoadXFunction(hTmpDL, "alglib_xv2_nleqrestartfrom", out _i_xv2_nleqrestartfrom);
            LoadXFunction(hTmpDL, "alglib_xv2_rmatrixluinverse", out _i_xv2_rmatrixluinverse);
            LoadXFunction(hTmpDL, "alglib_xv2_rmatrixinverse", out _i_xv2_rmatrixinverse);
            LoadXFunction(hTmpDL, "alglib_xv2_cmatrixluinverse", out _i_xv2_cmatrixluinverse);
            LoadXFunction(hTmpDL, "alglib_xv2_cmatrixinverse", out _i_xv2_cmatrixinverse);
            LoadXFunction(hTmpDL, "alglib_xv2_spdmatrixcholeskyinverse", out _i_xv2_spdmatrixcholeskyinverse);
            LoadXFunction(hTmpDL, "alglib_xv2_spdmatrixinverse", out _i_xv2_spdmatrixinverse);
            LoadXFunction(hTmpDL, "alglib_xv2_hpdmatrixcholeskyinverse", out _i_xv2_hpdmatrixcholeskyinverse);
            LoadXFunction(hTmpDL, "alglib_xv2_hpdmatrixinverse", out _i_xv2_hpdmatrixinverse);
            LoadXFunction(hTmpDL, "alglib_xv2_rmatrixtrinverse", out _i_xv2_rmatrixtrinverse);
            LoadXFunction(hTmpDL, "alglib_xv2_cmatrixtrinverse", out _i_xv2_cmatrixtrinverse);
        LoadXFunction(hTmpDL, "x_obj_copy_minlbfgsstate", out _i_x_obj_copy_minlbfgsstate);
        LoadXFunction(hTmpDL, "x_obj_free_minlbfgsstate", out _i_x_obj_free_minlbfgsstate);
        LoadXFunction(hTmpDL, "x_minlbfgsstate_get_needf", out _i_x_minlbfgsstate_get_needf);
        LoadXFunction(hTmpDL, "x_minlbfgsstate_set_needf", out _i_x_minlbfgsstate_set_needf);
        LoadXFunction(hTmpDL, "x_minlbfgsstate_get_needfg", out _i_x_minlbfgsstate_get_needfg);
        LoadXFunction(hTmpDL, "x_minlbfgsstate_set_needfg", out _i_x_minlbfgsstate_set_needfg);
        LoadXFunction(hTmpDL, "x_minlbfgsstate_get_xupdated", out _i_x_minlbfgsstate_get_xupdated);
        LoadXFunction(hTmpDL, "x_minlbfgsstate_set_xupdated", out _i_x_minlbfgsstate_set_xupdated);
        LoadXFunction(hTmpDL, "x_minlbfgsstate_get_f", out _i_x_minlbfgsstate_get_f);
        LoadXFunction(hTmpDL, "x_minlbfgsstate_set_f", out _i_x_minlbfgsstate_set_f);
        LoadXFunction(hTmpDL, "x_minlbfgsstate_get_g", out _i_x_minlbfgsstate_get_g);
        LoadXFunction(hTmpDL, "x_minlbfgsstate_get_x", out _i_x_minlbfgsstate_get_x);
            LoadXFunction(hTmpDL, "alglib_xv2_minlbfgscreate", out _i_xv2_minlbfgscreate);
            LoadXFunction(hTmpDL, "alglib_xv2_minlbfgscreatef", out _i_xv2_minlbfgscreatef);
            LoadXFunction(hTmpDL, "alglib_xv2_minlbfgssetcond", out _i_xv2_minlbfgssetcond);
            LoadXFunction(hTmpDL, "alglib_xv2_minlbfgssetxrep", out _i_xv2_minlbfgssetxrep);
            LoadXFunction(hTmpDL, "alglib_xv2_minlbfgssetstpmax", out _i_xv2_minlbfgssetstpmax);
            LoadXFunction(hTmpDL, "alglib_xv2_minlbfgssetscale", out _i_xv2_minlbfgssetscale);
            LoadXFunction(hTmpDL, "alglib_xv2_minlbfgssetprecdefault", out _i_xv2_minlbfgssetprecdefault);
            LoadXFunction(hTmpDL, "alglib_xv2_minlbfgssetpreccholesky", out _i_xv2_minlbfgssetpreccholesky);
            LoadXFunction(hTmpDL, "alglib_xv2_minlbfgssetprecdiag", out _i_xv2_minlbfgssetprecdiag);
            LoadXFunction(hTmpDL, "alglib_xv2_minlbfgssetprecscale", out _i_xv2_minlbfgssetprecscale);
            LoadXFunction(hTmpDL, "alglib_xv2_minlbfgsiteration", out _i_xv2_minlbfgsiteration);
            LoadXFunction(hTmpDL, "alglib_xv2_minlbfgsoptguardgradient", out _i_xv2_minlbfgsoptguardgradient);
            LoadXFunction(hTmpDL, "alglib_xv2_minlbfgsoptguardsmoothness", out _i_xv2_minlbfgsoptguardsmoothness);
            LoadXFunction(hTmpDL, "alglib_xv2_minlbfgsoptguardresults", out _i_xv2_minlbfgsoptguardresults);
            LoadXFunction(hTmpDL, "alglib_xv2_minlbfgsoptguardnonc1test0results", out _i_xv2_minlbfgsoptguardnonc1test0results);
            LoadXFunction(hTmpDL, "alglib_xv2_minlbfgsoptguardnonc1test1results", out _i_xv2_minlbfgsoptguardnonc1test1results);
            LoadXFunction(hTmpDL, "alglib_xv2_minlbfgsresults", out _i_xv2_minlbfgsresults);
            LoadXFunction(hTmpDL, "alglib_xv2_minlbfgsresultsbuf", out _i_xv2_minlbfgsresultsbuf);
            LoadXFunction(hTmpDL, "alglib_xv2_minlbfgsrestartfrom", out _i_xv2_minlbfgsrestartfrom);
            LoadXFunction(hTmpDL, "alglib_xv2_minlbfgsrequesttermination", out _i_xv2_minlbfgsrequesttermination);
        LoadXFunction(hTmpDL, "x_obj_copy_minbleicstate", out _i_x_obj_copy_minbleicstate);
        LoadXFunction(hTmpDL, "x_obj_free_minbleicstate", out _i_x_obj_free_minbleicstate);
        LoadXFunction(hTmpDL, "x_minbleicstate_get_needf", out _i_x_minbleicstate_get_needf);
        LoadXFunction(hTmpDL, "x_minbleicstate_set_needf", out _i_x_minbleicstate_set_needf);
        LoadXFunction(hTmpDL, "x_minbleicstate_get_needfg", out _i_x_minbleicstate_get_needfg);
        LoadXFunction(hTmpDL, "x_minbleicstate_set_needfg", out _i_x_minbleicstate_set_needfg);
        LoadXFunction(hTmpDL, "x_minbleicstate_get_xupdated", out _i_x_minbleicstate_get_xupdated);
        LoadXFunction(hTmpDL, "x_minbleicstate_set_xupdated", out _i_x_minbleicstate_set_xupdated);
        LoadXFunction(hTmpDL, "x_minbleicstate_get_f", out _i_x_minbleicstate_get_f);
        LoadXFunction(hTmpDL, "x_minbleicstate_set_f", out _i_x_minbleicstate_set_f);
        LoadXFunction(hTmpDL, "x_minbleicstate_get_g", out _i_x_minbleicstate_get_g);
        LoadXFunction(hTmpDL, "x_minbleicstate_get_x", out _i_x_minbleicstate_get_x);
            LoadXFunction(hTmpDL, "alglib_xv2_minbleiccreate", out _i_xv2_minbleiccreate);
            LoadXFunction(hTmpDL, "alglib_xv2_minbleiccreatef", out _i_xv2_minbleiccreatef);
            LoadXFunction(hTmpDL, "alglib_xv2_minbleicsetbc", out _i_xv2_minbleicsetbc);
            LoadXFunction(hTmpDL, "alglib_xv2_minbleicsetlc", out _i_xv2_minbleicsetlc);
            LoadXFunction(hTmpDL, "alglib_xv2_minbleicsetcond", out _i_xv2_minbleicsetcond);
            LoadXFunction(hTmpDL, "alglib_xv2_minbleicsetscale", out _i_xv2_minbleicsetscale);
            LoadXFunction(hTmpDL, "alglib_xv2_minbleicsetprecdefault", out _i_xv2_minbleicsetprecdefault);
            LoadXFunction(hTmpDL, "alglib_xv2_minbleicsetprecdiag", out _i_xv2_minbleicsetprecdiag);
            LoadXFunction(hTmpDL, "alglib_xv2_minbleicsetprecscale", out _i_xv2_minbleicsetprecscale);
            LoadXFunction(hTmpDL, "alglib_xv2_minbleicsetxrep", out _i_xv2_minbleicsetxrep);
            LoadXFunction(hTmpDL, "alglib_xv2_minbleicsetstpmax", out _i_xv2_minbleicsetstpmax);
            LoadXFunction(hTmpDL, "alglib_xv2_minbleiciteration", out _i_xv2_minbleiciteration);
            LoadXFunction(hTmpDL, "alglib_xv2_minbleicoptguardgradient", out _i_xv2_minbleicoptguardgradient);
            LoadXFunction(hTmpDL, "alglib_xv2_minbleicoptguardsmoothness", out _i_xv2_minbleicoptguardsmoothness);
            LoadXFunction(hTmpDL, "alglib_xv2_minbleicoptguardresults", out _i_xv2_minbleicoptguardresults);
            LoadXFunction(hTmpDL, "alglib_xv2_minbleicoptguardnonc1test0results", out _i_xv2_minbleicoptguardnonc1test0results);
            LoadXFunction(hTmpDL, "alglib_xv2_minbleicoptguardnonc1test1results", out _i_xv2_minbleicoptguardnonc1test1results);
            LoadXFunction(hTmpDL, "alglib_xv2_minbleicresults", out _i_xv2_minbleicresults);
            LoadXFunction(hTmpDL, "alglib_xv2_minbleicresultsbuf", out _i_xv2_minbleicresultsbuf);
            LoadXFunction(hTmpDL, "alglib_xv2_minbleicrestartfrom", out _i_xv2_minbleicrestartfrom);
            LoadXFunction(hTmpDL, "alglib_xv2_minbleicrequesttermination", out _i_xv2_minbleicrequesttermination);
        LoadXFunction(hTmpDL, "x_obj_copy_minqpstate", out _i_x_obj_copy_minqpstate);
        LoadXFunction(hTmpDL, "x_obj_free_minqpstate", out _i_x_obj_free_minqpstate);
            LoadXFunction(hTmpDL, "alglib_xv2_minqpcreate", out _i_xv2_minqpcreate);
            LoadXFunction(hTmpDL, "alglib_xv2_minqpsetlinearterm", out _i_xv2_minqpsetlinearterm);
            LoadXFunction(hTmpDL, "alglib_xv2_minqpsetquadraticterm", out _i_xv2_minqpsetquadraticterm);
            LoadXFunction(hTmpDL, "alglib_xv2_minqpsetquadratictermsparse", out _i_xv2_minqpsetquadratictermsparse);
            LoadXFunction(hTmpDL, "alglib_xv2_minqpsetstartingpoint", out _i_xv2_minqpsetstartingpoint);
            LoadXFunction(hTmpDL, "alglib_xv2_minqpsetorigin", out _i_xv2_minqpsetorigin);
            LoadXFunction(hTmpDL, "alglib_xv2_minqpsetscale", out _i_xv2_minqpsetscale);
            LoadXFunction(hTmpDL, "alglib_xv2_minqpsetscaleautodiag", out _i_xv2_minqpsetscaleautodiag);
            LoadXFunction(hTmpDL, "alglib_xv2_minqpsetalgobleic", out _i_xv2_minqpsetalgobleic);
            LoadXFunction(hTmpDL, "alglib_xv2_minqpsetalgodenseaul", out _i_xv2_minqpsetalgodenseaul);
            LoadXFunction(hTmpDL, "alglib_xv2_minqpsetalgodenseipm", out _i_xv2_minqpsetalgodenseipm);
            LoadXFunction(hTmpDL, "alglib_xv2_minqpsetalgosparseipm", out _i_xv2_minqpsetalgosparseipm);
            LoadXFunction(hTmpDL, "alglib_xv2_minqpsetalgoquickqp", out _i_xv2_minqpsetalgoquickqp);
            LoadXFunction(hTmpDL, "alglib_xv2_minqpsetbc", out _i_xv2_minqpsetbc);
            LoadXFunction(hTmpDL, "alglib_xv2_minqpsetbcall", out _i_xv2_minqpsetbcall);
            LoadXFunction(hTmpDL, "alglib_xv2_minqpsetbci", out _i_xv2_minqpsetbci);
            LoadXFunction(hTmpDL, "alglib_xv2_minqpsetlc", out _i_xv2_minqpsetlc);
            LoadXFunction(hTmpDL, "alglib_xv2_minqpsetlcsparse", out _i_xv2_minqpsetlcsparse);
            LoadXFunction(hTmpDL, "alglib_xv2_minqpsetlcmixed", out _i_xv2_minqpsetlcmixed);
            LoadXFunction(hTmpDL, "alglib_xv2_minqpsetlcmixedlegacy", out _i_xv2_minqpsetlcmixedlegacy);
            LoadXFunction(hTmpDL, "alglib_xv2_minqpsetlc2dense", out _i_xv2_minqpsetlc2dense);
            LoadXFunction(hTmpDL, "alglib_xv2_minqpsetlc2", out _i_xv2_minqpsetlc2);
            LoadXFunction(hTmpDL, "alglib_xv2_minqpsetlc2mixed", out _i_xv2_minqpsetlc2mixed);
            LoadXFunction(hTmpDL, "alglib_xv2_minqpaddlc2dense", out _i_xv2_minqpaddlc2dense);
            LoadXFunction(hTmpDL, "alglib_xv2_minqpaddlc2", out _i_xv2_minqpaddlc2);
            LoadXFunction(hTmpDL, "alglib_xv2_minqpaddlc2sparsefromdense", out _i_xv2_minqpaddlc2sparsefromdense);
            LoadXFunction(hTmpDL, "alglib_xv2_minqpoptimize", out _i_xv2_minqpoptimize);
            LoadXFunction(hTmpDL, "alglib_xv2_minqpresults", out _i_xv2_minqpresults);
            LoadXFunction(hTmpDL, "alglib_xv2_minqpresultsbuf", out _i_xv2_minqpresultsbuf);
        LoadXFunction(hTmpDL, "x_obj_copy_minlmstate", out _i_x_obj_copy_minlmstate);
        LoadXFunction(hTmpDL, "x_obj_free_minlmstate", out _i_x_obj_free_minlmstate);
        LoadXFunction(hTmpDL, "x_minlmstate_get_needf", out _i_x_minlmstate_get_needf);
        LoadXFunction(hTmpDL, "x_minlmstate_set_needf", out _i_x_minlmstate_set_needf);
        LoadXFunction(hTmpDL, "x_minlmstate_get_needfg", out _i_x_minlmstate_get_needfg);
        LoadXFunction(hTmpDL, "x_minlmstate_set_needfg", out _i_x_minlmstate_set_needfg);
        LoadXFunction(hTmpDL, "x_minlmstate_get_needfgh", out _i_x_minlmstate_get_needfgh);
        LoadXFunction(hTmpDL, "x_minlmstate_set_needfgh", out _i_x_minlmstate_set_needfgh);
        LoadXFunction(hTmpDL, "x_minlmstate_get_needfi", out _i_x_minlmstate_get_needfi);
        LoadXFunction(hTmpDL, "x_minlmstate_set_needfi", out _i_x_minlmstate_set_needfi);
        LoadXFunction(hTmpDL, "x_minlmstate_get_needfij", out _i_x_minlmstate_get_needfij);
        LoadXFunction(hTmpDL, "x_minlmstate_set_needfij", out _i_x_minlmstate_set_needfij);
        LoadXFunction(hTmpDL, "x_minlmstate_get_xupdated", out _i_x_minlmstate_get_xupdated);
        LoadXFunction(hTmpDL, "x_minlmstate_set_xupdated", out _i_x_minlmstate_set_xupdated);
        LoadXFunction(hTmpDL, "x_minlmstate_get_f", out _i_x_minlmstate_get_f);
        LoadXFunction(hTmpDL, "x_minlmstate_set_f", out _i_x_minlmstate_set_f);
        LoadXFunction(hTmpDL, "x_minlmstate_get_fi", out _i_x_minlmstate_get_fi);
        LoadXFunction(hTmpDL, "x_minlmstate_get_g", out _i_x_minlmstate_get_g);
        LoadXFunction(hTmpDL, "x_minlmstate_get_h", out _i_x_minlmstate_get_h);
        LoadXFunction(hTmpDL, "x_minlmstate_get_j", out _i_x_minlmstate_get_j);
        LoadXFunction(hTmpDL, "x_minlmstate_get_x", out _i_x_minlmstate_get_x);
            LoadXFunction(hTmpDL, "alglib_xv2_minlmcreatevj", out _i_xv2_minlmcreatevj);
            LoadXFunction(hTmpDL, "alglib_xv2_minlmcreatev", out _i_xv2_minlmcreatev);
            LoadXFunction(hTmpDL, "alglib_xv2_minlmcreatefgh", out _i_xv2_minlmcreatefgh);
            LoadXFunction(hTmpDL, "alglib_xv2_minlmsetcond", out _i_xv2_minlmsetcond);
            LoadXFunction(hTmpDL, "alglib_xv2_minlmsetxrep", out _i_xv2_minlmsetxrep);
            LoadXFunction(hTmpDL, "alglib_xv2_minlmsetstpmax", out _i_xv2_minlmsetstpmax);
            LoadXFunction(hTmpDL, "alglib_xv2_minlmsetscale", out _i_xv2_minlmsetscale);
            LoadXFunction(hTmpDL, "alglib_xv2_minlmsetbc", out _i_xv2_minlmsetbc);
            LoadXFunction(hTmpDL, "alglib_xv2_minlmsetlc", out _i_xv2_minlmsetlc);
            LoadXFunction(hTmpDL, "alglib_xv2_minlmsetacctype", out _i_xv2_minlmsetacctype);
            LoadXFunction(hTmpDL, "alglib_xv2_minlmiteration", out _i_xv2_minlmiteration);
            LoadXFunction(hTmpDL, "alglib_xv2_minlmoptguardgradient", out _i_xv2_minlmoptguardgradient);
            LoadXFunction(hTmpDL, "alglib_xv2_minlmoptguardresults", out _i_xv2_minlmoptguardresults);
            LoadXFunction(hTmpDL, "alglib_xv2_minlmresults", out _i_xv2_minlmresults);
            LoadXFunction(hTmpDL, "alglib_xv2_minlmresultsbuf", out _i_xv2_minlmresultsbuf);
            LoadXFunction(hTmpDL, "alglib_xv2_minlmrestartfrom", out _i_xv2_minlmrestartfrom);
            LoadXFunction(hTmpDL, "alglib_xv2_minlmrequesttermination", out _i_xv2_minlmrequesttermination);
            LoadXFunction(hTmpDL, "alglib_xv2_minlmcreatevgj", out _i_xv2_minlmcreatevgj);
            LoadXFunction(hTmpDL, "alglib_xv2_minlmcreatefgj", out _i_xv2_minlmcreatefgj);
            LoadXFunction(hTmpDL, "alglib_xv2_minlmcreatefj", out _i_xv2_minlmcreatefj);
        LoadXFunction(hTmpDL, "x_obj_copy_mincgstate", out _i_x_obj_copy_mincgstate);
        LoadXFunction(hTmpDL, "x_obj_free_mincgstate", out _i_x_obj_free_mincgstate);
        LoadXFunction(hTmpDL, "x_mincgstate_get_needf", out _i_x_mincgstate_get_needf);
        LoadXFunction(hTmpDL, "x_mincgstate_set_needf", out _i_x_mincgstate_set_needf);
        LoadXFunction(hTmpDL, "x_mincgstate_get_needfg", out _i_x_mincgstate_get_needfg);
        LoadXFunction(hTmpDL, "x_mincgstate_set_needfg", out _i_x_mincgstate_set_needfg);
        LoadXFunction(hTmpDL, "x_mincgstate_get_xupdated", out _i_x_mincgstate_get_xupdated);
        LoadXFunction(hTmpDL, "x_mincgstate_set_xupdated", out _i_x_mincgstate_set_xupdated);
        LoadXFunction(hTmpDL, "x_mincgstate_get_f", out _i_x_mincgstate_get_f);
        LoadXFunction(hTmpDL, "x_mincgstate_set_f", out _i_x_mincgstate_set_f);
        LoadXFunction(hTmpDL, "x_mincgstate_get_g", out _i_x_mincgstate_get_g);
        LoadXFunction(hTmpDL, "x_mincgstate_get_x", out _i_x_mincgstate_get_x);
            LoadXFunction(hTmpDL, "alglib_xv2_mincgcreate", out _i_xv2_mincgcreate);
            LoadXFunction(hTmpDL, "alglib_xv2_mincgcreatef", out _i_xv2_mincgcreatef);
            LoadXFunction(hTmpDL, "alglib_xv2_mincgsetcond", out _i_xv2_mincgsetcond);
            LoadXFunction(hTmpDL, "alglib_xv2_mincgsetscale", out _i_xv2_mincgsetscale);
            LoadXFunction(hTmpDL, "alglib_xv2_mincgsetxrep", out _i_xv2_mincgsetxrep);
            LoadXFunction(hTmpDL, "alglib_xv2_mincgsetcgtype", out _i_xv2_mincgsetcgtype);
            LoadXFunction(hTmpDL, "alglib_xv2_mincgsetstpmax", out _i_xv2_mincgsetstpmax);
            LoadXFunction(hTmpDL, "alglib_xv2_mincgsuggeststep", out _i_xv2_mincgsuggeststep);
            LoadXFunction(hTmpDL, "alglib_xv2_mincgsetprecdefault", out _i_xv2_mincgsetprecdefault);
            LoadXFunction(hTmpDL, "alglib_xv2_mincgsetprecdiag", out _i_xv2_mincgsetprecdiag);
            LoadXFunction(hTmpDL, "alglib_xv2_mincgsetprecscale", out _i_xv2_mincgsetprecscale);
            LoadXFunction(hTmpDL, "alglib_xv2_mincgiteration", out _i_xv2_mincgiteration);
            LoadXFunction(hTmpDL, "alglib_xv2_mincgoptguardgradient", out _i_xv2_mincgoptguardgradient);
            LoadXFunction(hTmpDL, "alglib_xv2_mincgoptguardsmoothness", out _i_xv2_mincgoptguardsmoothness);
            LoadXFunction(hTmpDL, "alglib_xv2_mincgoptguardresults", out _i_xv2_mincgoptguardresults);
            LoadXFunction(hTmpDL, "alglib_xv2_mincgoptguardnonc1test0results", out _i_xv2_mincgoptguardnonc1test0results);
            LoadXFunction(hTmpDL, "alglib_xv2_mincgoptguardnonc1test1results", out _i_xv2_mincgoptguardnonc1test1results);
            LoadXFunction(hTmpDL, "alglib_xv2_mincgresults", out _i_xv2_mincgresults);
            LoadXFunction(hTmpDL, "alglib_xv2_mincgresultsbuf", out _i_xv2_mincgresultsbuf);
            LoadXFunction(hTmpDL, "alglib_xv2_mincgrestartfrom", out _i_xv2_mincgrestartfrom);
            LoadXFunction(hTmpDL, "alglib_xv2_mincgrequesttermination", out _i_xv2_mincgrequesttermination);
        LoadXFunction(hTmpDL, "x_obj_copy_minlpstate", out _i_x_obj_copy_minlpstate);
        LoadXFunction(hTmpDL, "x_obj_free_minlpstate", out _i_x_obj_free_minlpstate);
            LoadXFunction(hTmpDL, "alglib_xv2_minlpcreate", out _i_xv2_minlpcreate);
            LoadXFunction(hTmpDL, "alglib_xv2_minlpsetalgodss", out _i_xv2_minlpsetalgodss);
            LoadXFunction(hTmpDL, "alglib_xv2_minlpsetalgoipm", out _i_xv2_minlpsetalgoipm);
            LoadXFunction(hTmpDL, "alglib_xv2_minlpsetcost", out _i_xv2_minlpsetcost);
            LoadXFunction(hTmpDL, "alglib_xv2_minlpsetscale", out _i_xv2_minlpsetscale);
            LoadXFunction(hTmpDL, "alglib_xv2_minlpsetbc", out _i_xv2_minlpsetbc);
            LoadXFunction(hTmpDL, "alglib_xv2_minlpsetbcall", out _i_xv2_minlpsetbcall);
            LoadXFunction(hTmpDL, "alglib_xv2_minlpsetbci", out _i_xv2_minlpsetbci);
            LoadXFunction(hTmpDL, "alglib_xv2_minlpsetlc", out _i_xv2_minlpsetlc);
            LoadXFunction(hTmpDL, "alglib_xv2_minlpsetlc2dense", out _i_xv2_minlpsetlc2dense);
            LoadXFunction(hTmpDL, "alglib_xv2_minlpsetlc2", out _i_xv2_minlpsetlc2);
            LoadXFunction(hTmpDL, "alglib_xv2_minlpaddlc2dense", out _i_xv2_minlpaddlc2dense);
            LoadXFunction(hTmpDL, "alglib_xv2_minlpaddlc2", out _i_xv2_minlpaddlc2);
            LoadXFunction(hTmpDL, "alglib_xv2_minlpoptimize", out _i_xv2_minlpoptimize);
            LoadXFunction(hTmpDL, "alglib_xv2_minlpresults", out _i_xv2_minlpresults);
            LoadXFunction(hTmpDL, "alglib_xv2_minlpresultsbuf", out _i_xv2_minlpresultsbuf);
        LoadXFunction(hTmpDL, "x_obj_copy_minnlcstate", out _i_x_obj_copy_minnlcstate);
        LoadXFunction(hTmpDL, "x_obj_free_minnlcstate", out _i_x_obj_free_minnlcstate);
        LoadXFunction(hTmpDL, "x_minnlcstate_get_needfi", out _i_x_minnlcstate_get_needfi);
        LoadXFunction(hTmpDL, "x_minnlcstate_set_needfi", out _i_x_minnlcstate_set_needfi);
        LoadXFunction(hTmpDL, "x_minnlcstate_get_needfij", out _i_x_minnlcstate_get_needfij);
        LoadXFunction(hTmpDL, "x_minnlcstate_set_needfij", out _i_x_minnlcstate_set_needfij);
        LoadXFunction(hTmpDL, "x_minnlcstate_get_xupdated", out _i_x_minnlcstate_get_xupdated);
        LoadXFunction(hTmpDL, "x_minnlcstate_set_xupdated", out _i_x_minnlcstate_set_xupdated);
        LoadXFunction(hTmpDL, "x_minnlcstate_get_f", out _i_x_minnlcstate_get_f);
        LoadXFunction(hTmpDL, "x_minnlcstate_set_f", out _i_x_minnlcstate_set_f);
        LoadXFunction(hTmpDL, "x_minnlcstate_get_fi", out _i_x_minnlcstate_get_fi);
        LoadXFunction(hTmpDL, "x_minnlcstate_get_j", out _i_x_minnlcstate_get_j);
        LoadXFunction(hTmpDL, "x_minnlcstate_get_x", out _i_x_minnlcstate_get_x);
            LoadXFunction(hTmpDL, "alglib_xv2_minnlccreate", out _i_xv2_minnlccreate);
            LoadXFunction(hTmpDL, "alglib_xv2_minnlccreatef", out _i_xv2_minnlccreatef);
            LoadXFunction(hTmpDL, "alglib_xv2_minnlcsetbc", out _i_xv2_minnlcsetbc);
            LoadXFunction(hTmpDL, "alglib_xv2_minnlcsetlc", out _i_xv2_minnlcsetlc);
            LoadXFunction(hTmpDL, "alglib_xv2_minnlcsetnlc", out _i_xv2_minnlcsetnlc);
            LoadXFunction(hTmpDL, "alglib_xv2_minnlcsetcond", out _i_xv2_minnlcsetcond);
            LoadXFunction(hTmpDL, "alglib_xv2_minnlcsetscale", out _i_xv2_minnlcsetscale);
            LoadXFunction(hTmpDL, "alglib_xv2_minnlcsetprecinexact", out _i_xv2_minnlcsetprecinexact);
            LoadXFunction(hTmpDL, "alglib_xv2_minnlcsetprecexactlowrank", out _i_xv2_minnlcsetprecexactlowrank);
            LoadXFunction(hTmpDL, "alglib_xv2_minnlcsetprecexactrobust", out _i_xv2_minnlcsetprecexactrobust);
            LoadXFunction(hTmpDL, "alglib_xv2_minnlcsetprecnone", out _i_xv2_minnlcsetprecnone);
            LoadXFunction(hTmpDL, "alglib_xv2_minnlcsetstpmax", out _i_xv2_minnlcsetstpmax);
            LoadXFunction(hTmpDL, "alglib_xv2_minnlcsetalgoaul", out _i_xv2_minnlcsetalgoaul);
            LoadXFunction(hTmpDL, "alglib_xv2_minnlcsetalgoslp", out _i_xv2_minnlcsetalgoslp);
            LoadXFunction(hTmpDL, "alglib_xv2_minnlcsetalgosqp", out _i_xv2_minnlcsetalgosqp);
            LoadXFunction(hTmpDL, "alglib_xv2_minnlcsetxrep", out _i_xv2_minnlcsetxrep);
            LoadXFunction(hTmpDL, "alglib_xv2_minnlciteration", out _i_xv2_minnlciteration);
            LoadXFunction(hTmpDL, "alglib_xv2_minnlcoptguardgradient", out _i_xv2_minnlcoptguardgradient);
            LoadXFunction(hTmpDL, "alglib_xv2_minnlcoptguardsmoothness", out _i_xv2_minnlcoptguardsmoothness);
            LoadXFunction(hTmpDL, "alglib_xv2_minnlcoptguardresults", out _i_xv2_minnlcoptguardresults);
            LoadXFunction(hTmpDL, "alglib_xv2_minnlcoptguardnonc1test0results", out _i_xv2_minnlcoptguardnonc1test0results);
            LoadXFunction(hTmpDL, "alglib_xv2_minnlcoptguardnonc1test1results", out _i_xv2_minnlcoptguardnonc1test1results);
            LoadXFunction(hTmpDL, "alglib_xv2_minnlcresults", out _i_xv2_minnlcresults);
            LoadXFunction(hTmpDL, "alglib_xv2_minnlcresultsbuf", out _i_xv2_minnlcresultsbuf);
            LoadXFunction(hTmpDL, "alglib_xv2_minnlcrequesttermination", out _i_xv2_minnlcrequesttermination);
            LoadXFunction(hTmpDL, "alglib_xv2_minnlcrestartfrom", out _i_xv2_minnlcrestartfrom);
        LoadXFunction(hTmpDL, "x_obj_copy_minnsstate", out _i_x_obj_copy_minnsstate);
        LoadXFunction(hTmpDL, "x_obj_free_minnsstate", out _i_x_obj_free_minnsstate);
        LoadXFunction(hTmpDL, "x_minnsstate_get_needfi", out _i_x_minnsstate_get_needfi);
        LoadXFunction(hTmpDL, "x_minnsstate_set_needfi", out _i_x_minnsstate_set_needfi);
        LoadXFunction(hTmpDL, "x_minnsstate_get_needfij", out _i_x_minnsstate_get_needfij);
        LoadXFunction(hTmpDL, "x_minnsstate_set_needfij", out _i_x_minnsstate_set_needfij);
        LoadXFunction(hTmpDL, "x_minnsstate_get_xupdated", out _i_x_minnsstate_get_xupdated);
        LoadXFunction(hTmpDL, "x_minnsstate_set_xupdated", out _i_x_minnsstate_set_xupdated);
        LoadXFunction(hTmpDL, "x_minnsstate_get_f", out _i_x_minnsstate_get_f);
        LoadXFunction(hTmpDL, "x_minnsstate_set_f", out _i_x_minnsstate_set_f);
        LoadXFunction(hTmpDL, "x_minnsstate_get_fi", out _i_x_minnsstate_get_fi);
        LoadXFunction(hTmpDL, "x_minnsstate_get_j", out _i_x_minnsstate_get_j);
        LoadXFunction(hTmpDL, "x_minnsstate_get_x", out _i_x_minnsstate_get_x);
            LoadXFunction(hTmpDL, "alglib_xv2_minnscreate", out _i_xv2_minnscreate);
            LoadXFunction(hTmpDL, "alglib_xv2_minnscreatef", out _i_xv2_minnscreatef);
            LoadXFunction(hTmpDL, "alglib_xv2_minnssetbc", out _i_xv2_minnssetbc);
            LoadXFunction(hTmpDL, "alglib_xv2_minnssetlc", out _i_xv2_minnssetlc);
            LoadXFunction(hTmpDL, "alglib_xv2_minnssetnlc", out _i_xv2_minnssetnlc);
            LoadXFunction(hTmpDL, "alglib_xv2_minnssetcond", out _i_xv2_minnssetcond);
            LoadXFunction(hTmpDL, "alglib_xv2_minnssetscale", out _i_xv2_minnssetscale);
            LoadXFunction(hTmpDL, "alglib_xv2_minnssetalgoags", out _i_xv2_minnssetalgoags);
            LoadXFunction(hTmpDL, "alglib_xv2_minnssetxrep", out _i_xv2_minnssetxrep);
            LoadXFunction(hTmpDL, "alglib_xv2_minnsrequesttermination", out _i_xv2_minnsrequesttermination);
            LoadXFunction(hTmpDL, "alglib_xv2_minnsiteration", out _i_xv2_minnsiteration);
            LoadXFunction(hTmpDL, "alglib_xv2_minnsresults", out _i_xv2_minnsresults);
            LoadXFunction(hTmpDL, "alglib_xv2_minnsresultsbuf", out _i_xv2_minnsresultsbuf);
            LoadXFunction(hTmpDL, "alglib_xv2_minnsrestartfrom", out _i_xv2_minnsrestartfrom);
        LoadXFunction(hTmpDL, "x_obj_copy_minasastate", out _i_x_obj_copy_minasastate);
        LoadXFunction(hTmpDL, "x_obj_free_minasastate", out _i_x_obj_free_minasastate);
        LoadXFunction(hTmpDL, "x_minasastate_get_needfg", out _i_x_minasastate_get_needfg);
        LoadXFunction(hTmpDL, "x_minasastate_set_needfg", out _i_x_minasastate_set_needfg);
        LoadXFunction(hTmpDL, "x_minasastate_get_xupdated", out _i_x_minasastate_get_xupdated);
        LoadXFunction(hTmpDL, "x_minasastate_set_xupdated", out _i_x_minasastate_set_xupdated);
        LoadXFunction(hTmpDL, "x_minasastate_get_f", out _i_x_minasastate_get_f);
        LoadXFunction(hTmpDL, "x_minasastate_set_f", out _i_x_minasastate_set_f);
        LoadXFunction(hTmpDL, "x_minasastate_get_g", out _i_x_minasastate_get_g);
        LoadXFunction(hTmpDL, "x_minasastate_get_x", out _i_x_minasastate_get_x);
            LoadXFunction(hTmpDL, "alglib_xv2_minlbfgssetdefaultpreconditioner", out _i_xv2_minlbfgssetdefaultpreconditioner);
            LoadXFunction(hTmpDL, "alglib_xv2_minlbfgssetcholeskypreconditioner", out _i_xv2_minlbfgssetcholeskypreconditioner);
            LoadXFunction(hTmpDL, "alglib_xv2_minbleicsetbarrierwidth", out _i_xv2_minbleicsetbarrierwidth);
            LoadXFunction(hTmpDL, "alglib_xv2_minbleicsetbarrierdecay", out _i_xv2_minbleicsetbarrierdecay);
            LoadXFunction(hTmpDL, "alglib_xv2_minasacreate", out _i_xv2_minasacreate);
            LoadXFunction(hTmpDL, "alglib_xv2_minasasetcond", out _i_xv2_minasasetcond);
            LoadXFunction(hTmpDL, "alglib_xv2_minasasetxrep", out _i_xv2_minasasetxrep);
            LoadXFunction(hTmpDL, "alglib_xv2_minasasetalgorithm", out _i_xv2_minasasetalgorithm);
            LoadXFunction(hTmpDL, "alglib_xv2_minasasetstpmax", out _i_xv2_minasasetstpmax);
            LoadXFunction(hTmpDL, "alglib_xv2_minasaiteration", out _i_xv2_minasaiteration);
            LoadXFunction(hTmpDL, "alglib_xv2_minasaresults", out _i_xv2_minasaresults);
            LoadXFunction(hTmpDL, "alglib_xv2_minasaresultsbuf", out _i_xv2_minasaresultsbuf);
            LoadXFunction(hTmpDL, "alglib_xv2_minasarestartfrom", out _i_xv2_minasarestartfrom);
        LoadXFunction(hTmpDL, "x_obj_copy_minbcstate", out _i_x_obj_copy_minbcstate);
        LoadXFunction(hTmpDL, "x_obj_free_minbcstate", out _i_x_obj_free_minbcstate);
        LoadXFunction(hTmpDL, "x_minbcstate_get_needf", out _i_x_minbcstate_get_needf);
        LoadXFunction(hTmpDL, "x_minbcstate_set_needf", out _i_x_minbcstate_set_needf);
        LoadXFunction(hTmpDL, "x_minbcstate_get_needfg", out _i_x_minbcstate_get_needfg);
        LoadXFunction(hTmpDL, "x_minbcstate_set_needfg", out _i_x_minbcstate_set_needfg);
        LoadXFunction(hTmpDL, "x_minbcstate_get_xupdated", out _i_x_minbcstate_get_xupdated);
        LoadXFunction(hTmpDL, "x_minbcstate_set_xupdated", out _i_x_minbcstate_set_xupdated);
        LoadXFunction(hTmpDL, "x_minbcstate_get_f", out _i_x_minbcstate_get_f);
        LoadXFunction(hTmpDL, "x_minbcstate_set_f", out _i_x_minbcstate_set_f);
        LoadXFunction(hTmpDL, "x_minbcstate_get_g", out _i_x_minbcstate_get_g);
        LoadXFunction(hTmpDL, "x_minbcstate_get_x", out _i_x_minbcstate_get_x);
            LoadXFunction(hTmpDL, "alglib_xv2_minbccreate", out _i_xv2_minbccreate);
            LoadXFunction(hTmpDL, "alglib_xv2_minbccreatef", out _i_xv2_minbccreatef);
            LoadXFunction(hTmpDL, "alglib_xv2_minbcsetbc", out _i_xv2_minbcsetbc);
            LoadXFunction(hTmpDL, "alglib_xv2_minbcsetcond", out _i_xv2_minbcsetcond);
            LoadXFunction(hTmpDL, "alglib_xv2_minbcsetscale", out _i_xv2_minbcsetscale);
            LoadXFunction(hTmpDL, "alglib_xv2_minbcsetprecdefault", out _i_xv2_minbcsetprecdefault);
            LoadXFunction(hTmpDL, "alglib_xv2_minbcsetprecdiag", out _i_xv2_minbcsetprecdiag);
            LoadXFunction(hTmpDL, "alglib_xv2_minbcsetprecscale", out _i_xv2_minbcsetprecscale);
            LoadXFunction(hTmpDL, "alglib_xv2_minbcsetxrep", out _i_xv2_minbcsetxrep);
            LoadXFunction(hTmpDL, "alglib_xv2_minbcsetstpmax", out _i_xv2_minbcsetstpmax);
            LoadXFunction(hTmpDL, "alglib_xv2_minbciteration", out _i_xv2_minbciteration);
            LoadXFunction(hTmpDL, "alglib_xv2_minbcoptguardgradient", out _i_xv2_minbcoptguardgradient);
            LoadXFunction(hTmpDL, "alglib_xv2_minbcoptguardsmoothness", out _i_xv2_minbcoptguardsmoothness);
            LoadXFunction(hTmpDL, "alglib_xv2_minbcoptguardresults", out _i_xv2_minbcoptguardresults);
            LoadXFunction(hTmpDL, "alglib_xv2_minbcoptguardnonc1test0results", out _i_xv2_minbcoptguardnonc1test0results);
            LoadXFunction(hTmpDL, "alglib_xv2_minbcoptguardnonc1test1results", out _i_xv2_minbcoptguardnonc1test1results);
            LoadXFunction(hTmpDL, "alglib_xv2_minbcresults", out _i_xv2_minbcresults);
            LoadXFunction(hTmpDL, "alglib_xv2_minbcresultsbuf", out _i_xv2_minbcresultsbuf);
            LoadXFunction(hTmpDL, "alglib_xv2_minbcrestartfrom", out _i_xv2_minbcrestartfrom);
            LoadXFunction(hTmpDL, "alglib_xv2_minbcrequesttermination", out _i_xv2_minbcrequesttermination);
        LoadXFunction(hTmpDL, "x_obj_copy_lptestproblem", out _i_x_obj_copy_lptestproblem);
        LoadXFunction(hTmpDL, "x_obj_free_lptestproblem", out _i_x_obj_free_lptestproblem);
            LoadXFunction(hTmpDL, "alglib_lptestproblemserialize",   out _i_x_lptestproblemserialize);
            LoadXFunction(hTmpDL, "alglib_lptestproblemunserialize", out _i_x_lptestproblemunserialize);
            LoadXFunction(hTmpDL, "alglib_lptestproblemserialize_stream",   out _i_x_lptestproblemserialize_stream);
            LoadXFunction(hTmpDL, "alglib_lptestproblemunserialize_stream", out _i_x_lptestproblemunserialize_stream);
            LoadXFunction(hTmpDL, "alglib_xv2_lptestproblemcreate", out _i_xv2_lptestproblemcreate);
            LoadXFunction(hTmpDL, "alglib_xv2_lptestproblemhasknowntarget", out _i_xv2_lptestproblemhasknowntarget);
            LoadXFunction(hTmpDL, "alglib_xv2_lptestproblemgettargetf", out _i_xv2_lptestproblemgettargetf);
            LoadXFunction(hTmpDL, "alglib_xv2_lptestproblemgetn", out _i_xv2_lptestproblemgetn);
            LoadXFunction(hTmpDL, "alglib_xv2_lptestproblemgetm", out _i_xv2_lptestproblemgetm);
            LoadXFunction(hTmpDL, "alglib_xv2_lptestproblemsetscale", out _i_xv2_lptestproblemsetscale);
            LoadXFunction(hTmpDL, "alglib_xv2_lptestproblemsetcost", out _i_xv2_lptestproblemsetcost);
            LoadXFunction(hTmpDL, "alglib_xv2_lptestproblemsetbc", out _i_xv2_lptestproblemsetbc);
            LoadXFunction(hTmpDL, "alglib_xv2_lptestproblemsetlc2", out _i_xv2_lptestproblemsetlc2);
            LoadXFunction(hTmpDL, "alglib_xv2_xdbgminlpcreatefromtestproblem", out _i_xv2_xdbgminlpcreatefromtestproblem);
            LoadXFunction(hTmpDL, "alglib_xv2_xdebuginitrecord1", out _i_xv2_xdebuginitrecord1);
            LoadXFunction(hTmpDL, "alglib_xv2_xdebugb1count", out _i_xv2_xdebugb1count);
            LoadXFunction(hTmpDL, "alglib_xv2_xdebugb1not", out _i_xv2_xdebugb1not);
            LoadXFunction(hTmpDL, "alglib_xv2_xdebugb1appendcopy", out _i_xv2_xdebugb1appendcopy);
            LoadXFunction(hTmpDL, "alglib_xv2_xdebugb1outeven", out _i_xv2_xdebugb1outeven);
            LoadXFunction(hTmpDL, "alglib_xv2_xdebugi1sum", out _i_xv2_xdebugi1sum);
            LoadXFunction(hTmpDL, "alglib_xv2_xdebugi1neg", out _i_xv2_xdebugi1neg);
            LoadXFunction(hTmpDL, "alglib_xv2_xdebugi1appendcopy", out _i_xv2_xdebugi1appendcopy);
            LoadXFunction(hTmpDL, "alglib_xv2_xdebugi1outeven", out _i_xv2_xdebugi1outeven);
            LoadXFunction(hTmpDL, "alglib_xv2_xdebugr1sum", out _i_xv2_xdebugr1sum);
            LoadXFunction(hTmpDL, "alglib_xv2_xdebugr1neg", out _i_xv2_xdebugr1neg);
            LoadXFunction(hTmpDL, "alglib_xv2_xdebugr1appendcopy", out _i_xv2_xdebugr1appendcopy);
            LoadXFunction(hTmpDL, "alglib_xv2_xdebugr1outeven", out _i_xv2_xdebugr1outeven);
            LoadXFunction(hTmpDL, "alglib_xv2_xdebugc1sum", out _i_xv2_xdebugc1sum);
            LoadXFunction(hTmpDL, "alglib_xv2_xdebugc1neg", out _i_xv2_xdebugc1neg);
            LoadXFunction(hTmpDL, "alglib_xv2_xdebugc1appendcopy", out _i_xv2_xdebugc1appendcopy);
            LoadXFunction(hTmpDL, "alglib_xv2_xdebugc1outeven", out _i_xv2_xdebugc1outeven);
            LoadXFunction(hTmpDL, "alglib_xv2_xdebugb2count", out _i_xv2_xdebugb2count);
            LoadXFunction(hTmpDL, "alglib_xv2_xdebugb2not", out _i_xv2_xdebugb2not);
            LoadXFunction(hTmpDL, "alglib_xv2_xdebugb2transpose", out _i_xv2_xdebugb2transpose);
            LoadXFunction(hTmpDL, "alglib_xv2_xdebugb2outsin", out _i_xv2_xdebugb2outsin);
            LoadXFunction(hTmpDL, "alglib_xv2_xdebugi2sum", out _i_xv2_xdebugi2sum);
            LoadXFunction(hTmpDL, "alglib_xv2_xdebugi2neg", out _i_xv2_xdebugi2neg);
            LoadXFunction(hTmpDL, "alglib_xv2_xdebugi2transpose", out _i_xv2_xdebugi2transpose);
            LoadXFunction(hTmpDL, "alglib_xv2_xdebugi2outsin", out _i_xv2_xdebugi2outsin);
            LoadXFunction(hTmpDL, "alglib_xv2_xdebugr2sum", out _i_xv2_xdebugr2sum);
            LoadXFunction(hTmpDL, "alglib_xv2_xdebugr2neg", out _i_xv2_xdebugr2neg);
            LoadXFunction(hTmpDL, "alglib_xv2_xdebugr2transpose", out _i_xv2_xdebugr2transpose);
            LoadXFunction(hTmpDL, "alglib_xv2_xdebugr2outsin", out _i_xv2_xdebugr2outsin);
            LoadXFunction(hTmpDL, "alglib_xv2_xdebugc2sum", out _i_xv2_xdebugc2sum);
            LoadXFunction(hTmpDL, "alglib_xv2_xdebugc2neg", out _i_xv2_xdebugc2neg);
            LoadXFunction(hTmpDL, "alglib_xv2_xdebugc2transpose", out _i_xv2_xdebugc2transpose);
            LoadXFunction(hTmpDL, "alglib_xv2_xdebugc2outsincos", out _i_xv2_xdebugc2outsincos);
            LoadXFunction(hTmpDL, "alglib_xv2_xdebugmaskedbiasedproductsum", out _i_xv2_xdebugmaskedbiasedproductsum);
        LoadXFunction(hTmpDL, "x_obj_copy_kdtreerequestbuffer", out _i_x_obj_copy_kdtreerequestbuffer);
        LoadXFunction(hTmpDL, "x_obj_free_kdtreerequestbuffer", out _i_x_obj_free_kdtreerequestbuffer);
        LoadXFunction(hTmpDL, "x_obj_copy_kdtree", out _i_x_obj_copy_kdtree);
        LoadXFunction(hTmpDL, "x_obj_free_kdtree", out _i_x_obj_free_kdtree);
            LoadXFunction(hTmpDL, "alglib_kdtreeserialize",   out _i_x_kdtreeserialize);
            LoadXFunction(hTmpDL, "alglib_kdtreeunserialize", out _i_x_kdtreeunserialize);
            LoadXFunction(hTmpDL, "alglib_kdtreeserialize_stream",   out _i_x_kdtreeserialize_stream);
            LoadXFunction(hTmpDL, "alglib_kdtreeunserialize_stream", out _i_x_kdtreeunserialize_stream);
            LoadXFunction(hTmpDL, "alglib_xv2_kdtreebuild", out _i_xv2_kdtreebuild);
            LoadXFunction(hTmpDL, "alglib_xv2_kdtreebuildtagged", out _i_xv2_kdtreebuildtagged);
            LoadXFunction(hTmpDL, "alglib_xv2_kdtreecreaterequestbuffer", out _i_xv2_kdtreecreaterequestbuffer);
            LoadXFunction(hTmpDL, "alglib_xv2_kdtreequeryknn", out _i_xv2_kdtreequeryknn);
            LoadXFunction(hTmpDL, "alglib_xv2_kdtreetsqueryknn", out _i_xv2_kdtreetsqueryknn);
            LoadXFunction(hTmpDL, "alglib_xv2_kdtreequeryrnn", out _i_xv2_kdtreequeryrnn);
            LoadXFunction(hTmpDL, "alglib_xv2_kdtreequeryrnnu", out _i_xv2_kdtreequeryrnnu);
            LoadXFunction(hTmpDL, "alglib_xv2_kdtreetsqueryrnn", out _i_xv2_kdtreetsqueryrnn);
            LoadXFunction(hTmpDL, "alglib_xv2_kdtreetsqueryrnnu", out _i_xv2_kdtreetsqueryrnnu);
            LoadXFunction(hTmpDL, "alglib_xv2_kdtreequeryaknn", out _i_xv2_kdtreequeryaknn);
            LoadXFunction(hTmpDL, "alglib_xv2_kdtreetsqueryaknn", out _i_xv2_kdtreetsqueryaknn);
            LoadXFunction(hTmpDL, "alglib_xv2_kdtreequerybox", out _i_xv2_kdtreequerybox);
            LoadXFunction(hTmpDL, "alglib_xv2_kdtreetsquerybox", out _i_xv2_kdtreetsquerybox);
            LoadXFunction(hTmpDL, "alglib_xv2_kdtreequeryresultsx", out _i_xv2_kdtreequeryresultsx);
            LoadXFunction(hTmpDL, "alglib_xv2_kdtreequeryresultsxy", out _i_xv2_kdtreequeryresultsxy);
            LoadXFunction(hTmpDL, "alglib_xv2_kdtreequeryresultstags", out _i_xv2_kdtreequeryresultstags);
            LoadXFunction(hTmpDL, "alglib_xv2_kdtreequeryresultsdistances", out _i_xv2_kdtreequeryresultsdistances);
            LoadXFunction(hTmpDL, "alglib_xv2_kdtreetsqueryresultsx", out _i_xv2_kdtreetsqueryresultsx);
            LoadXFunction(hTmpDL, "alglib_xv2_kdtreetsqueryresultsxy", out _i_xv2_kdtreetsqueryresultsxy);
            LoadXFunction(hTmpDL, "alglib_xv2_kdtreetsqueryresultstags", out _i_xv2_kdtreetsqueryresultstags);
            LoadXFunction(hTmpDL, "alglib_xv2_kdtreetsqueryresultsdistances", out _i_xv2_kdtreetsqueryresultsdistances);
            LoadXFunction(hTmpDL, "alglib_xv2_kdtreequeryresultsxi", out _i_xv2_kdtreequeryresultsxi);
            LoadXFunction(hTmpDL, "alglib_xv2_kdtreequeryresultsxyi", out _i_xv2_kdtreequeryresultsxyi);
            LoadXFunction(hTmpDL, "alglib_xv2_kdtreequeryresultstagsi", out _i_xv2_kdtreequeryresultstagsi);
            LoadXFunction(hTmpDL, "alglib_xv2_kdtreequeryresultsdistancesi", out _i_xv2_kdtreequeryresultsdistancesi);
        LoadXFunction(hTmpDL, "x_obj_copy_odesolverstate", out _i_x_obj_copy_odesolverstate);
        LoadXFunction(hTmpDL, "x_obj_free_odesolverstate", out _i_x_obj_free_odesolverstate);
        LoadXFunction(hTmpDL, "x_odesolverstate_get_needdy", out _i_x_odesolverstate_get_needdy);
        LoadXFunction(hTmpDL, "x_odesolverstate_set_needdy", out _i_x_odesolverstate_set_needdy);
        LoadXFunction(hTmpDL, "x_odesolverstate_get_y", out _i_x_odesolverstate_get_y);
        LoadXFunction(hTmpDL, "x_odesolverstate_get_dy", out _i_x_odesolverstate_get_dy);
        LoadXFunction(hTmpDL, "x_odesolverstate_get_x", out _i_x_odesolverstate_get_x);
        LoadXFunction(hTmpDL, "x_odesolverstate_set_x", out _i_x_odesolverstate_set_x);
            LoadXFunction(hTmpDL, "alglib_xv2_odesolverrkck", out _i_xv2_odesolverrkck);
            LoadXFunction(hTmpDL, "alglib_xv2_odesolveriteration", out _i_xv2_odesolveriteration);
            LoadXFunction(hTmpDL, "alglib_xv2_odesolverresults", out _i_xv2_odesolverresults);
            LoadXFunction(hTmpDL, "alglib_xv2_rmatrixinvupdatesimple", out _i_xv2_rmatrixinvupdatesimple);
            LoadXFunction(hTmpDL, "alglib_xv2_rmatrixinvupdaterow", out _i_xv2_rmatrixinvupdaterow);
            LoadXFunction(hTmpDL, "alglib_xv2_rmatrixinvupdatecolumn", out _i_xv2_rmatrixinvupdatecolumn);
            LoadXFunction(hTmpDL, "alglib_xv2_rmatrixinvupdateuv", out _i_xv2_rmatrixinvupdateuv);
            LoadXFunction(hTmpDL, "alglib_xv2_rmatrixschur", out _i_xv2_rmatrixschur);
            LoadXFunction(hTmpDL, "alglib_xv2_smatrixgevd", out _i_xv2_smatrixgevd);
            LoadXFunction(hTmpDL, "alglib_xv2_smatrixgevdreduce", out _i_xv2_smatrixgevdreduce);
            LoadXFunction(hTmpDL, "alglib_xv2_rmatrixludet", out _i_xv2_rmatrixludet);
            LoadXFunction(hTmpDL, "alglib_xv2_rmatrixdet", out _i_xv2_rmatrixdet);
            LoadXFunction(hTmpDL, "alglib_xv2_cmatrixludet", out _i_xv2_cmatrixludet);
            LoadXFunction(hTmpDL, "alglib_xv2_cmatrixdet", out _i_xv2_cmatrixdet);
            LoadXFunction(hTmpDL, "alglib_xv2_spdmatrixcholeskydet", out _i_xv2_spdmatrixcholeskydet);
            LoadXFunction(hTmpDL, "alglib_xv2_spdmatrixdet", out _i_xv2_spdmatrixdet);
            LoadXFunction(hTmpDL, "alglib_xv2_gammafunction", out _i_xv2_gammafunction);
            LoadXFunction(hTmpDL, "alglib_xv2_lngamma", out _i_xv2_lngamma);
            LoadXFunction(hTmpDL, "alglib_xv2_gqgeneraterec", out _i_xv2_gqgeneraterec);
            LoadXFunction(hTmpDL, "alglib_xv2_gqgenerategausslobattorec", out _i_xv2_gqgenerategausslobattorec);
            LoadXFunction(hTmpDL, "alglib_xv2_gqgenerategaussradaurec", out _i_xv2_gqgenerategaussradaurec);
            LoadXFunction(hTmpDL, "alglib_xv2_gqgenerategausslegendre", out _i_xv2_gqgenerategausslegendre);
            LoadXFunction(hTmpDL, "alglib_xv2_gqgenerategaussjacobi", out _i_xv2_gqgenerategaussjacobi);
            LoadXFunction(hTmpDL, "alglib_xv2_gqgenerategausslaguerre", out _i_xv2_gqgenerategausslaguerre);
            LoadXFunction(hTmpDL, "alglib_xv2_gqgenerategausshermite", out _i_xv2_gqgenerategausshermite);
            LoadXFunction(hTmpDL, "alglib_xv2_gkqgeneraterec", out _i_xv2_gkqgeneraterec);
            LoadXFunction(hTmpDL, "alglib_xv2_gkqgenerategausslegendre", out _i_xv2_gkqgenerategausslegendre);
            LoadXFunction(hTmpDL, "alglib_xv2_gkqgenerategaussjacobi", out _i_xv2_gkqgenerategaussjacobi);
            LoadXFunction(hTmpDL, "alglib_xv2_gkqlegendrecalc", out _i_xv2_gkqlegendrecalc);
            LoadXFunction(hTmpDL, "alglib_xv2_gkqlegendretbl", out _i_xv2_gkqlegendretbl);
        LoadXFunction(hTmpDL, "x_obj_copy_autogkstate", out _i_x_obj_copy_autogkstate);
        LoadXFunction(hTmpDL, "x_obj_free_autogkstate", out _i_x_obj_free_autogkstate);
        LoadXFunction(hTmpDL, "x_autogkstate_get_needf", out _i_x_autogkstate_get_needf);
        LoadXFunction(hTmpDL, "x_autogkstate_set_needf", out _i_x_autogkstate_set_needf);
        LoadXFunction(hTmpDL, "x_autogkstate_get_x", out _i_x_autogkstate_get_x);
        LoadXFunction(hTmpDL, "x_autogkstate_set_x", out _i_x_autogkstate_set_x);
        LoadXFunction(hTmpDL, "x_autogkstate_get_xminusa", out _i_x_autogkstate_get_xminusa);
        LoadXFunction(hTmpDL, "x_autogkstate_set_xminusa", out _i_x_autogkstate_set_xminusa);
        LoadXFunction(hTmpDL, "x_autogkstate_get_bminusx", out _i_x_autogkstate_get_bminusx);
        LoadXFunction(hTmpDL, "x_autogkstate_set_bminusx", out _i_x_autogkstate_set_bminusx);
        LoadXFunction(hTmpDL, "x_autogkstate_get_f", out _i_x_autogkstate_get_f);
        LoadXFunction(hTmpDL, "x_autogkstate_set_f", out _i_x_autogkstate_set_f);
            LoadXFunction(hTmpDL, "alglib_xv2_autogksmooth", out _i_xv2_autogksmooth);
            LoadXFunction(hTmpDL, "alglib_xv2_autogksmoothw", out _i_xv2_autogksmoothw);
            LoadXFunction(hTmpDL, "alglib_xv2_autogksingular", out _i_xv2_autogksingular);
            LoadXFunction(hTmpDL, "alglib_xv2_autogkiteration", out _i_xv2_autogkiteration);
            LoadXFunction(hTmpDL, "alglib_xv2_autogkresults", out _i_xv2_autogkresults);
            LoadXFunction(hTmpDL, "alglib_xv2_errorfunction", out _i_xv2_errorfunction);
            LoadXFunction(hTmpDL, "alglib_xv2_errorfunctionc", out _i_xv2_errorfunctionc);
            LoadXFunction(hTmpDL, "alglib_xv2_normaldistribution", out _i_xv2_normaldistribution);
            LoadXFunction(hTmpDL, "alglib_xv2_normalpdf", out _i_xv2_normalpdf);
            LoadXFunction(hTmpDL, "alglib_xv2_normalcdf", out _i_xv2_normalcdf);
            LoadXFunction(hTmpDL, "alglib_xv2_inverf", out _i_xv2_inverf);
            LoadXFunction(hTmpDL, "alglib_xv2_invnormaldistribution", out _i_xv2_invnormaldistribution);
            LoadXFunction(hTmpDL, "alglib_xv2_invnormalcdf", out _i_xv2_invnormalcdf);
            LoadXFunction(hTmpDL, "alglib_xv2_bivariatenormalpdf", out _i_xv2_bivariatenormalpdf);
            LoadXFunction(hTmpDL, "alglib_xv2_bivariatenormalcdf", out _i_xv2_bivariatenormalcdf);
            LoadXFunction(hTmpDL, "alglib_xv2_incompletebeta", out _i_xv2_incompletebeta);
            LoadXFunction(hTmpDL, "alglib_xv2_invincompletebeta", out _i_xv2_invincompletebeta);
            LoadXFunction(hTmpDL, "alglib_xv2_studenttdistribution", out _i_xv2_studenttdistribution);
            LoadXFunction(hTmpDL, "alglib_xv2_invstudenttdistribution", out _i_xv2_invstudenttdistribution);
            LoadXFunction(hTmpDL, "alglib_xv2_samplemoments", out _i_xv2_samplemoments);
            LoadXFunction(hTmpDL, "alglib_xv2_samplemean", out _i_xv2_samplemean);
            LoadXFunction(hTmpDL, "alglib_xv2_samplevariance", out _i_xv2_samplevariance);
            LoadXFunction(hTmpDL, "alglib_xv2_sampleskewness", out _i_xv2_sampleskewness);
            LoadXFunction(hTmpDL, "alglib_xv2_samplekurtosis", out _i_xv2_samplekurtosis);
            LoadXFunction(hTmpDL, "alglib_xv2_sampleadev", out _i_xv2_sampleadev);
            LoadXFunction(hTmpDL, "alglib_xv2_samplemedian", out _i_xv2_samplemedian);
            LoadXFunction(hTmpDL, "alglib_xv2_samplepercentile", out _i_xv2_samplepercentile);
            LoadXFunction(hTmpDL, "alglib_xv2_cov2", out _i_xv2_cov2);
            LoadXFunction(hTmpDL, "alglib_xv2_pearsoncorr2", out _i_xv2_pearsoncorr2);
            LoadXFunction(hTmpDL, "alglib_xv2_spearmancorr2", out _i_xv2_spearmancorr2);
            LoadXFunction(hTmpDL, "alglib_xv2_covm", out _i_xv2_covm);
            LoadXFunction(hTmpDL, "alglib_xv2_pearsoncorrm", out _i_xv2_pearsoncorrm);
            LoadXFunction(hTmpDL, "alglib_xv2_spearmancorrm", out _i_xv2_spearmancorrm);
            LoadXFunction(hTmpDL, "alglib_xv2_covm2", out _i_xv2_covm2);
            LoadXFunction(hTmpDL, "alglib_xv2_pearsoncorrm2", out _i_xv2_pearsoncorrm2);
            LoadXFunction(hTmpDL, "alglib_xv2_spearmancorrm2", out _i_xv2_spearmancorrm2);
            LoadXFunction(hTmpDL, "alglib_xv2_rankdata", out _i_xv2_rankdata);
            LoadXFunction(hTmpDL, "alglib_xv2_rankdatacentered", out _i_xv2_rankdatacentered);
            LoadXFunction(hTmpDL, "alglib_xv2_pearsoncorrelation", out _i_xv2_pearsoncorrelation);
            LoadXFunction(hTmpDL, "alglib_xv2_spearmanrankcorrelation", out _i_xv2_spearmanrankcorrelation);
            LoadXFunction(hTmpDL, "alglib_xv2_pearsoncorrelationsignificance", out _i_xv2_pearsoncorrelationsignificance);
            LoadXFunction(hTmpDL, "alglib_xv2_spearmanrankcorrelationsignificance", out _i_xv2_spearmanrankcorrelationsignificance);
            LoadXFunction(hTmpDL, "alglib_xv2_jarqueberatest", out _i_xv2_jarqueberatest);
            LoadXFunction(hTmpDL, "alglib_xv2_fdistribution", out _i_xv2_fdistribution);
            LoadXFunction(hTmpDL, "alglib_xv2_fcdistribution", out _i_xv2_fcdistribution);
            LoadXFunction(hTmpDL, "alglib_xv2_invfdistribution", out _i_xv2_invfdistribution);
            LoadXFunction(hTmpDL, "alglib_xv2_incompletegamma", out _i_xv2_incompletegamma);
            LoadXFunction(hTmpDL, "alglib_xv2_incompletegammac", out _i_xv2_incompletegammac);
            LoadXFunction(hTmpDL, "alglib_xv2_invincompletegammac", out _i_xv2_invincompletegammac);
            LoadXFunction(hTmpDL, "alglib_xv2_chisquaredistribution", out _i_xv2_chisquaredistribution);
            LoadXFunction(hTmpDL, "alglib_xv2_chisquarecdistribution", out _i_xv2_chisquarecdistribution);
            LoadXFunction(hTmpDL, "alglib_xv2_invchisquaredistribution", out _i_xv2_invchisquaredistribution);
            LoadXFunction(hTmpDL, "alglib_xv2_ftest", out _i_xv2_ftest);
            LoadXFunction(hTmpDL, "alglib_xv2_onesamplevariancetest", out _i_xv2_onesamplevariancetest);
            LoadXFunction(hTmpDL, "alglib_xv2_wilcoxonsignedranktest", out _i_xv2_wilcoxonsignedranktest);
            LoadXFunction(hTmpDL, "alglib_xv2_mannwhitneyutest", out _i_xv2_mannwhitneyutest);
            LoadXFunction(hTmpDL, "alglib_xv2_binomialdistribution", out _i_xv2_binomialdistribution);
            LoadXFunction(hTmpDL, "alglib_xv2_binomialcdistribution", out _i_xv2_binomialcdistribution);
            LoadXFunction(hTmpDL, "alglib_xv2_invbinomialdistribution", out _i_xv2_invbinomialdistribution);
            LoadXFunction(hTmpDL, "alglib_xv2_onesamplesigntest", out _i_xv2_onesamplesigntest);
            LoadXFunction(hTmpDL, "alglib_xv2_studentttest1", out _i_xv2_studentttest1);
            LoadXFunction(hTmpDL, "alglib_xv2_studentttest2", out _i_xv2_studentttest2);
            LoadXFunction(hTmpDL, "alglib_xv2_unequalvariancettest", out _i_xv2_unequalvariancettest);
        LoadXFunction(hTmpDL, "x_obj_copy_barycentricinterpolant", out _i_x_obj_copy_barycentricinterpolant);
        LoadXFunction(hTmpDL, "x_obj_free_barycentricinterpolant", out _i_x_obj_free_barycentricinterpolant);
            LoadXFunction(hTmpDL, "alglib_xv2_barycentriccalc", out _i_xv2_barycentriccalc);
            LoadXFunction(hTmpDL, "alglib_xv2_barycentricdiff1", out _i_xv2_barycentricdiff1);
            LoadXFunction(hTmpDL, "alglib_xv2_barycentricdiff2", out _i_xv2_barycentricdiff2);
            LoadXFunction(hTmpDL, "alglib_xv2_barycentriclintransx", out _i_xv2_barycentriclintransx);
            LoadXFunction(hTmpDL, "alglib_xv2_barycentriclintransy", out _i_xv2_barycentriclintransy);
            LoadXFunction(hTmpDL, "alglib_xv2_barycentricunpack", out _i_xv2_barycentricunpack);
            LoadXFunction(hTmpDL, "alglib_xv2_barycentricbuildxyw", out _i_xv2_barycentricbuildxyw);
            LoadXFunction(hTmpDL, "alglib_xv2_barycentricbuildfloaterhormann", out _i_xv2_barycentricbuildfloaterhormann);
        LoadXFunction(hTmpDL, "x_obj_copy_idwcalcbuffer", out _i_x_obj_copy_idwcalcbuffer);
        LoadXFunction(hTmpDL, "x_obj_free_idwcalcbuffer", out _i_x_obj_free_idwcalcbuffer);
        LoadXFunction(hTmpDL, "x_obj_copy_idwmodel", out _i_x_obj_copy_idwmodel);
        LoadXFunction(hTmpDL, "x_obj_free_idwmodel", out _i_x_obj_free_idwmodel);
        LoadXFunction(hTmpDL, "x_obj_copy_idwbuilder", out _i_x_obj_copy_idwbuilder);
        LoadXFunction(hTmpDL, "x_obj_free_idwbuilder", out _i_x_obj_free_idwbuilder);
            LoadXFunction(hTmpDL, "alglib_idwserialize",   out _i_x_idwserialize);
            LoadXFunction(hTmpDL, "alglib_idwunserialize", out _i_x_idwunserialize);
            LoadXFunction(hTmpDL, "alglib_idwserialize_stream",   out _i_x_idwserialize_stream);
            LoadXFunction(hTmpDL, "alglib_idwunserialize_stream", out _i_x_idwunserialize_stream);
            LoadXFunction(hTmpDL, "alglib_xv2_idwcreatecalcbuffer", out _i_xv2_idwcreatecalcbuffer);
            LoadXFunction(hTmpDL, "alglib_xv2_idwbuildercreate", out _i_xv2_idwbuildercreate);
            LoadXFunction(hTmpDL, "alglib_xv2_idwbuildersetnlayers", out _i_xv2_idwbuildersetnlayers);
            LoadXFunction(hTmpDL, "alglib_xv2_idwbuildersetpoints", out _i_xv2_idwbuildersetpoints);
            LoadXFunction(hTmpDL, "alglib_xv2_idwbuildersetalgomstab", out _i_xv2_idwbuildersetalgomstab);
            LoadXFunction(hTmpDL, "alglib_xv2_idwbuildersetalgotextbookshepard", out _i_xv2_idwbuildersetalgotextbookshepard);
            LoadXFunction(hTmpDL, "alglib_xv2_idwbuildersetalgotextbookmodshepard", out _i_xv2_idwbuildersetalgotextbookmodshepard);
            LoadXFunction(hTmpDL, "alglib_xv2_idwbuildersetuserterm", out _i_xv2_idwbuildersetuserterm);
            LoadXFunction(hTmpDL, "alglib_xv2_idwbuildersetconstterm", out _i_xv2_idwbuildersetconstterm);
            LoadXFunction(hTmpDL, "alglib_xv2_idwbuildersetzeroterm", out _i_xv2_idwbuildersetzeroterm);
            LoadXFunction(hTmpDL, "alglib_xv2_idwcalc1", out _i_xv2_idwcalc1);
            LoadXFunction(hTmpDL, "alglib_xv2_idwcalc2", out _i_xv2_idwcalc2);
            LoadXFunction(hTmpDL, "alglib_xv2_idwcalc3", out _i_xv2_idwcalc3);
            LoadXFunction(hTmpDL, "alglib_xv2_idwcalc", out _i_xv2_idwcalc);
            LoadXFunction(hTmpDL, "alglib_xv2_idwcalcbuf", out _i_xv2_idwcalcbuf);
            LoadXFunction(hTmpDL, "alglib_xv2_idwtscalcbuf", out _i_xv2_idwtscalcbuf);
            LoadXFunction(hTmpDL, "alglib_xv2_idwfit", out _i_xv2_idwfit);
            LoadXFunction(hTmpDL, "alglib_xv2_polynomialbar2cheb", out _i_xv2_polynomialbar2cheb);
            LoadXFunction(hTmpDL, "alglib_xv2_polynomialcheb2bar", out _i_xv2_polynomialcheb2bar);
            LoadXFunction(hTmpDL, "alglib_xv2_polynomialbar2pow", out _i_xv2_polynomialbar2pow);
            LoadXFunction(hTmpDL, "alglib_xv2_polynomialpow2bar", out _i_xv2_polynomialpow2bar);
            LoadXFunction(hTmpDL, "alglib_xv2_polynomialbuild", out _i_xv2_polynomialbuild);
            LoadXFunction(hTmpDL, "alglib_xv2_polynomialbuildeqdist", out _i_xv2_polynomialbuildeqdist);
            LoadXFunction(hTmpDL, "alglib_xv2_polynomialbuildcheb1", out _i_xv2_polynomialbuildcheb1);
            LoadXFunction(hTmpDL, "alglib_xv2_polynomialbuildcheb2", out _i_xv2_polynomialbuildcheb2);
            LoadXFunction(hTmpDL, "alglib_xv2_polynomialcalceqdist", out _i_xv2_polynomialcalceqdist);
            LoadXFunction(hTmpDL, "alglib_xv2_polynomialcalccheb1", out _i_xv2_polynomialcalccheb1);
            LoadXFunction(hTmpDL, "alglib_xv2_polynomialcalccheb2", out _i_xv2_polynomialcalccheb2);
        LoadXFunction(hTmpDL, "x_obj_copy_spline1dinterpolant", out _i_x_obj_copy_spline1dinterpolant);
        LoadXFunction(hTmpDL, "x_obj_free_spline1dinterpolant", out _i_x_obj_free_spline1dinterpolant);
            LoadXFunction(hTmpDL, "alglib_xv2_spline1dbuildlinear", out _i_xv2_spline1dbuildlinear);
            LoadXFunction(hTmpDL, "alglib_xv2_spline1dbuildcubic", out _i_xv2_spline1dbuildcubic);
            LoadXFunction(hTmpDL, "alglib_xv2_spline1dgriddiffcubic", out _i_xv2_spline1dgriddiffcubic);
            LoadXFunction(hTmpDL, "alglib_xv2_spline1dgriddiff2cubic", out _i_xv2_spline1dgriddiff2cubic);
            LoadXFunction(hTmpDL, "alglib_xv2_spline1dconvcubic", out _i_xv2_spline1dconvcubic);
            LoadXFunction(hTmpDL, "alglib_xv2_spline1dconvdiffcubic", out _i_xv2_spline1dconvdiffcubic);
            LoadXFunction(hTmpDL, "alglib_xv2_spline1dconvdiff2cubic", out _i_xv2_spline1dconvdiff2cubic);
            LoadXFunction(hTmpDL, "alglib_xv2_spline1dbuildcatmullrom", out _i_xv2_spline1dbuildcatmullrom);
            LoadXFunction(hTmpDL, "alglib_xv2_spline1dbuildhermite", out _i_xv2_spline1dbuildhermite);
            LoadXFunction(hTmpDL, "alglib_xv2_spline1dbuildakima", out _i_xv2_spline1dbuildakima);
            LoadXFunction(hTmpDL, "alglib_xv2_spline1dcalc", out _i_xv2_spline1dcalc);
            LoadXFunction(hTmpDL, "alglib_xv2_spline1ddiff", out _i_xv2_spline1ddiff);
            LoadXFunction(hTmpDL, "alglib_xv2_spline1dunpack", out _i_xv2_spline1dunpack);
            LoadXFunction(hTmpDL, "alglib_xv2_spline1dlintransx", out _i_xv2_spline1dlintransx);
            LoadXFunction(hTmpDL, "alglib_xv2_spline1dlintransy", out _i_xv2_spline1dlintransy);
            LoadXFunction(hTmpDL, "alglib_xv2_spline1dintegrate", out _i_xv2_spline1dintegrate);
            LoadXFunction(hTmpDL, "alglib_xv2_spline1dfit", out _i_xv2_spline1dfit);
            LoadXFunction(hTmpDL, "alglib_xv2_spline1dbuildmonotone", out _i_xv2_spline1dbuildmonotone);
        LoadXFunction(hTmpDL, "x_obj_copy_lsfitstate", out _i_x_obj_copy_lsfitstate);
        LoadXFunction(hTmpDL, "x_obj_free_lsfitstate", out _i_x_obj_free_lsfitstate);
        LoadXFunction(hTmpDL, "x_lsfitstate_get_needf", out _i_x_lsfitstate_get_needf);
        LoadXFunction(hTmpDL, "x_lsfitstate_set_needf", out _i_x_lsfitstate_set_needf);
        LoadXFunction(hTmpDL, "x_lsfitstate_get_needfg", out _i_x_lsfitstate_get_needfg);
        LoadXFunction(hTmpDL, "x_lsfitstate_set_needfg", out _i_x_lsfitstate_set_needfg);
        LoadXFunction(hTmpDL, "x_lsfitstate_get_needfgh", out _i_x_lsfitstate_get_needfgh);
        LoadXFunction(hTmpDL, "x_lsfitstate_set_needfgh", out _i_x_lsfitstate_set_needfgh);
        LoadXFunction(hTmpDL, "x_lsfitstate_get_xupdated", out _i_x_lsfitstate_get_xupdated);
        LoadXFunction(hTmpDL, "x_lsfitstate_set_xupdated", out _i_x_lsfitstate_set_xupdated);
        LoadXFunction(hTmpDL, "x_lsfitstate_get_c", out _i_x_lsfitstate_get_c);
        LoadXFunction(hTmpDL, "x_lsfitstate_get_f", out _i_x_lsfitstate_get_f);
        LoadXFunction(hTmpDL, "x_lsfitstate_set_f", out _i_x_lsfitstate_set_f);
        LoadXFunction(hTmpDL, "x_lsfitstate_get_g", out _i_x_lsfitstate_get_g);
        LoadXFunction(hTmpDL, "x_lsfitstate_get_h", out _i_x_lsfitstate_get_h);
        LoadXFunction(hTmpDL, "x_lsfitstate_get_x", out _i_x_lsfitstate_get_x);
            LoadXFunction(hTmpDL, "alglib_xv2_lstfitpiecewiselinearrdpfixed", out _i_xv2_lstfitpiecewiselinearrdpfixed);
            LoadXFunction(hTmpDL, "alglib_xv2_lstfitpiecewiselinearrdp", out _i_xv2_lstfitpiecewiselinearrdp);
            LoadXFunction(hTmpDL, "alglib_xv2_polynomialfit", out _i_xv2_polynomialfit);
            LoadXFunction(hTmpDL, "alglib_xv2_polynomialfitwc", out _i_xv2_polynomialfitwc);
            LoadXFunction(hTmpDL, "alglib_xv2_logisticcalc4", out _i_xv2_logisticcalc4);
            LoadXFunction(hTmpDL, "alglib_xv2_logisticcalc5", out _i_xv2_logisticcalc5);
            LoadXFunction(hTmpDL, "alglib_xv2_logisticfit4", out _i_xv2_logisticfit4);
            LoadXFunction(hTmpDL, "alglib_xv2_logisticfit4ec", out _i_xv2_logisticfit4ec);
            LoadXFunction(hTmpDL, "alglib_xv2_logisticfit5", out _i_xv2_logisticfit5);
            LoadXFunction(hTmpDL, "alglib_xv2_logisticfit5ec", out _i_xv2_logisticfit5ec);
            LoadXFunction(hTmpDL, "alglib_xv2_logisticfit45x", out _i_xv2_logisticfit45x);
            LoadXFunction(hTmpDL, "alglib_xv2_barycentricfitfloaterhormannwc", out _i_xv2_barycentricfitfloaterhormannwc);
            LoadXFunction(hTmpDL, "alglib_xv2_barycentricfitfloaterhormann", out _i_xv2_barycentricfitfloaterhormann);
            LoadXFunction(hTmpDL, "alglib_xv2_spline1dfitcubicwc", out _i_xv2_spline1dfitcubicwc);
            LoadXFunction(hTmpDL, "alglib_xv2_spline1dfithermitewc", out _i_xv2_spline1dfithermitewc);
            LoadXFunction(hTmpDL, "alglib_xv2_spline1dfitcubic", out _i_xv2_spline1dfitcubic);
            LoadXFunction(hTmpDL, "alglib_xv2_spline1dfithermite", out _i_xv2_spline1dfithermite);
            LoadXFunction(hTmpDL, "alglib_xv2_lsfitlinearw", out _i_xv2_lsfitlinearw);
            LoadXFunction(hTmpDL, "alglib_xv2_lsfitlinearwc", out _i_xv2_lsfitlinearwc);
            LoadXFunction(hTmpDL, "alglib_xv2_lsfitlinear", out _i_xv2_lsfitlinear);
            LoadXFunction(hTmpDL, "alglib_xv2_lsfitlinearc", out _i_xv2_lsfitlinearc);
            LoadXFunction(hTmpDL, "alglib_xv2_lsfitcreatewf", out _i_xv2_lsfitcreatewf);
            LoadXFunction(hTmpDL, "alglib_xv2_lsfitcreatef", out _i_xv2_lsfitcreatef);
            LoadXFunction(hTmpDL, "alglib_xv2_lsfitcreatewfg", out _i_xv2_lsfitcreatewfg);
            LoadXFunction(hTmpDL, "alglib_xv2_lsfitcreatefg", out _i_xv2_lsfitcreatefg);
            LoadXFunction(hTmpDL, "alglib_xv2_lsfitcreatewfgh", out _i_xv2_lsfitcreatewfgh);
            LoadXFunction(hTmpDL, "alglib_xv2_lsfitcreatefgh", out _i_xv2_lsfitcreatefgh);
            LoadXFunction(hTmpDL, "alglib_xv2_lsfitsetcond", out _i_xv2_lsfitsetcond);
            LoadXFunction(hTmpDL, "alglib_xv2_lsfitsetstpmax", out _i_xv2_lsfitsetstpmax);
            LoadXFunction(hTmpDL, "alglib_xv2_lsfitsetxrep", out _i_xv2_lsfitsetxrep);
            LoadXFunction(hTmpDL, "alglib_xv2_lsfitsetscale", out _i_xv2_lsfitsetscale);
            LoadXFunction(hTmpDL, "alglib_xv2_lsfitsetbc", out _i_xv2_lsfitsetbc);
            LoadXFunction(hTmpDL, "alglib_xv2_lsfitsetlc", out _i_xv2_lsfitsetlc);
            LoadXFunction(hTmpDL, "alglib_xv2_lsfititeration", out _i_xv2_lsfititeration);
            LoadXFunction(hTmpDL, "alglib_xv2_lsfitresults", out _i_xv2_lsfitresults);
            LoadXFunction(hTmpDL, "alglib_xv2_lsfitsetgradientcheck", out _i_xv2_lsfitsetgradientcheck);
            LoadXFunction(hTmpDL, "alglib_xv2_fitspherels", out _i_xv2_fitspherels);
            LoadXFunction(hTmpDL, "alglib_xv2_fitspheremc", out _i_xv2_fitspheremc);
            LoadXFunction(hTmpDL, "alglib_xv2_fitspheremi", out _i_xv2_fitspheremi);
            LoadXFunction(hTmpDL, "alglib_xv2_fitspheremz", out _i_xv2_fitspheremz);
            LoadXFunction(hTmpDL, "alglib_xv2_fitspherex", out _i_xv2_fitspherex);
        LoadXFunction(hTmpDL, "x_obj_copy_pspline2interpolant", out _i_x_obj_copy_pspline2interpolant);
        LoadXFunction(hTmpDL, "x_obj_free_pspline2interpolant", out _i_x_obj_free_pspline2interpolant);
        LoadXFunction(hTmpDL, "x_obj_copy_pspline3interpolant", out _i_x_obj_copy_pspline3interpolant);
        LoadXFunction(hTmpDL, "x_obj_free_pspline3interpolant", out _i_x_obj_free_pspline3interpolant);
            LoadXFunction(hTmpDL, "alglib_xv2_pspline2build", out _i_xv2_pspline2build);
            LoadXFunction(hTmpDL, "alglib_xv2_pspline3build", out _i_xv2_pspline3build);
            LoadXFunction(hTmpDL, "alglib_xv2_pspline2buildperiodic", out _i_xv2_pspline2buildperiodic);
            LoadXFunction(hTmpDL, "alglib_xv2_pspline3buildperiodic", out _i_xv2_pspline3buildperiodic);
            LoadXFunction(hTmpDL, "alglib_xv2_pspline2parametervalues", out _i_xv2_pspline2parametervalues);
            LoadXFunction(hTmpDL, "alglib_xv2_pspline3parametervalues", out _i_xv2_pspline3parametervalues);
            LoadXFunction(hTmpDL, "alglib_xv2_pspline2calc", out _i_xv2_pspline2calc);
            LoadXFunction(hTmpDL, "alglib_xv2_pspline3calc", out _i_xv2_pspline3calc);
            LoadXFunction(hTmpDL, "alglib_xv2_pspline2tangent", out _i_xv2_pspline2tangent);
            LoadXFunction(hTmpDL, "alglib_xv2_pspline3tangent", out _i_xv2_pspline3tangent);
            LoadXFunction(hTmpDL, "alglib_xv2_pspline2diff", out _i_xv2_pspline2diff);
            LoadXFunction(hTmpDL, "alglib_xv2_pspline3diff", out _i_xv2_pspline3diff);
            LoadXFunction(hTmpDL, "alglib_xv2_pspline2diff2", out _i_xv2_pspline2diff2);
            LoadXFunction(hTmpDL, "alglib_xv2_pspline3diff2", out _i_xv2_pspline3diff2);
            LoadXFunction(hTmpDL, "alglib_xv2_pspline2arclength", out _i_xv2_pspline2arclength);
            LoadXFunction(hTmpDL, "alglib_xv2_pspline3arclength", out _i_xv2_pspline3arclength);
            LoadXFunction(hTmpDL, "alglib_xv2_parametricrdpfixed", out _i_xv2_parametricrdpfixed);
        LoadXFunction(hTmpDL, "x_obj_copy_spline2dinterpolant", out _i_x_obj_copy_spline2dinterpolant);
        LoadXFunction(hTmpDL, "x_obj_free_spline2dinterpolant", out _i_x_obj_free_spline2dinterpolant);
        LoadXFunction(hTmpDL, "x_obj_copy_spline2dbuilder", out _i_x_obj_copy_spline2dbuilder);
        LoadXFunction(hTmpDL, "x_obj_free_spline2dbuilder", out _i_x_obj_free_spline2dbuilder);
            LoadXFunction(hTmpDL, "alglib_spline2dserialize",   out _i_x_spline2dserialize);
            LoadXFunction(hTmpDL, "alglib_spline2dunserialize", out _i_x_spline2dunserialize);
            LoadXFunction(hTmpDL, "alglib_spline2dserialize_stream",   out _i_x_spline2dserialize_stream);
            LoadXFunction(hTmpDL, "alglib_spline2dunserialize_stream", out _i_x_spline2dunserialize_stream);
            LoadXFunction(hTmpDL, "alglib_xv2_spline2dcalc", out _i_xv2_spline2dcalc);
            LoadXFunction(hTmpDL, "alglib_xv2_spline2ddiff", out _i_xv2_spline2ddiff);
            LoadXFunction(hTmpDL, "alglib_xv2_spline2dcalcvbuf", out _i_xv2_spline2dcalcvbuf);
            LoadXFunction(hTmpDL, "alglib_xv2_spline2dcalcvi", out _i_xv2_spline2dcalcvi);
            LoadXFunction(hTmpDL, "alglib_xv2_spline2dcalcv", out _i_xv2_spline2dcalcv);
            LoadXFunction(hTmpDL, "alglib_xv2_spline2ddiffvi", out _i_xv2_spline2ddiffvi);
            LoadXFunction(hTmpDL, "alglib_xv2_spline2dlintransxy", out _i_xv2_spline2dlintransxy);
            LoadXFunction(hTmpDL, "alglib_xv2_spline2dlintransf", out _i_xv2_spline2dlintransf);
            LoadXFunction(hTmpDL, "alglib_xv2_spline2dcopy", out _i_xv2_spline2dcopy);
            LoadXFunction(hTmpDL, "alglib_xv2_spline2dresamplebicubic", out _i_xv2_spline2dresamplebicubic);
            LoadXFunction(hTmpDL, "alglib_xv2_spline2dresamplebilinear", out _i_xv2_spline2dresamplebilinear);
            LoadXFunction(hTmpDL, "alglib_xv2_spline2dbuildbilinearv", out _i_xv2_spline2dbuildbilinearv);
            LoadXFunction(hTmpDL, "alglib_xv2_spline2dbuildbilinearmissing", out _i_xv2_spline2dbuildbilinearmissing);
            LoadXFunction(hTmpDL, "alglib_xv2_spline2dbuildbicubicv", out _i_xv2_spline2dbuildbicubicv);
            LoadXFunction(hTmpDL, "alglib_xv2_spline2dbuildbicubicmissing", out _i_xv2_spline2dbuildbicubicmissing);
            LoadXFunction(hTmpDL, "alglib_xv2_spline2dunpackv", out _i_xv2_spline2dunpackv);
            LoadXFunction(hTmpDL, "alglib_xv2_spline2dbuildbilinear", out _i_xv2_spline2dbuildbilinear);
            LoadXFunction(hTmpDL, "alglib_xv2_spline2dbuildbicubic", out _i_xv2_spline2dbuildbicubic);
            LoadXFunction(hTmpDL, "alglib_xv2_spline2dunpack", out _i_xv2_spline2dunpack);
            LoadXFunction(hTmpDL, "alglib_xv2_spline2dbuildercreate", out _i_xv2_spline2dbuildercreate);
            LoadXFunction(hTmpDL, "alglib_xv2_spline2dbuildersetuserterm", out _i_xv2_spline2dbuildersetuserterm);
            LoadXFunction(hTmpDL, "alglib_xv2_spline2dbuildersetlinterm", out _i_xv2_spline2dbuildersetlinterm);
            LoadXFunction(hTmpDL, "alglib_xv2_spline2dbuildersetconstterm", out _i_xv2_spline2dbuildersetconstterm);
            LoadXFunction(hTmpDL, "alglib_xv2_spline2dbuildersetzeroterm", out _i_xv2_spline2dbuildersetzeroterm);
            LoadXFunction(hTmpDL, "alglib_xv2_spline2dbuildersetpoints", out _i_xv2_spline2dbuildersetpoints);
            LoadXFunction(hTmpDL, "alglib_xv2_spline2dbuildersetareaauto", out _i_xv2_spline2dbuildersetareaauto);
            LoadXFunction(hTmpDL, "alglib_xv2_spline2dbuildersetarea", out _i_xv2_spline2dbuildersetarea);
            LoadXFunction(hTmpDL, "alglib_xv2_spline2dbuildersetgrid", out _i_xv2_spline2dbuildersetgrid);
            LoadXFunction(hTmpDL, "alglib_xv2_spline2dbuildersetalgofastddm", out _i_xv2_spline2dbuildersetalgofastddm);
            LoadXFunction(hTmpDL, "alglib_xv2_spline2dbuildersetalgoblocklls", out _i_xv2_spline2dbuildersetalgoblocklls);
            LoadXFunction(hTmpDL, "alglib_xv2_spline2dbuildersetalgonaivells", out _i_xv2_spline2dbuildersetalgonaivells);
            LoadXFunction(hTmpDL, "alglib_xv2_spline2dfit", out _i_xv2_spline2dfit);
        LoadXFunction(hTmpDL, "x_obj_copy_spline3dinterpolant", out _i_x_obj_copy_spline3dinterpolant);
        LoadXFunction(hTmpDL, "x_obj_free_spline3dinterpolant", out _i_x_obj_free_spline3dinterpolant);
            LoadXFunction(hTmpDL, "alglib_xv2_spline3dcalc", out _i_xv2_spline3dcalc);
            LoadXFunction(hTmpDL, "alglib_xv2_spline3dlintransxyz", out _i_xv2_spline3dlintransxyz);
            LoadXFunction(hTmpDL, "alglib_xv2_spline3dlintransf", out _i_xv2_spline3dlintransf);
            LoadXFunction(hTmpDL, "alglib_xv2_spline3dresampletrilinear", out _i_xv2_spline3dresampletrilinear);
            LoadXFunction(hTmpDL, "alglib_xv2_spline3dbuildtrilinearv", out _i_xv2_spline3dbuildtrilinearv);
            LoadXFunction(hTmpDL, "alglib_xv2_spline3dcalcvbuf", out _i_xv2_spline3dcalcvbuf);
            LoadXFunction(hTmpDL, "alglib_xv2_spline3dcalcv", out _i_xv2_spline3dcalcv);
            LoadXFunction(hTmpDL, "alglib_xv2_spline3dunpackv", out _i_xv2_spline3dunpackv);
            LoadXFunction(hTmpDL, "alglib_xv2_nsfitspheremcc", out _i_xv2_nsfitspheremcc);
            LoadXFunction(hTmpDL, "alglib_xv2_nsfitspheremic", out _i_xv2_nsfitspheremic);
            LoadXFunction(hTmpDL, "alglib_xv2_nsfitspheremzc", out _i_xv2_nsfitspheremzc);
            LoadXFunction(hTmpDL, "alglib_xv2_nsfitspherex", out _i_xv2_nsfitspherex);
            LoadXFunction(hTmpDL, "alglib_xv2_spline1dfitpenalized", out _i_xv2_spline1dfitpenalized);
            LoadXFunction(hTmpDL, "alglib_xv2_spline1dfitpenalizedw", out _i_xv2_spline1dfitpenalizedw);
        LoadXFunction(hTmpDL, "x_obj_copy_rbfcalcbuffer", out _i_x_obj_copy_rbfcalcbuffer);
        LoadXFunction(hTmpDL, "x_obj_free_rbfcalcbuffer", out _i_x_obj_free_rbfcalcbuffer);
        LoadXFunction(hTmpDL, "x_obj_copy_rbfmodel", out _i_x_obj_copy_rbfmodel);
        LoadXFunction(hTmpDL, "x_obj_free_rbfmodel", out _i_x_obj_free_rbfmodel);
            LoadXFunction(hTmpDL, "alglib_rbfserialize",   out _i_x_rbfserialize);
            LoadXFunction(hTmpDL, "alglib_rbfunserialize", out _i_x_rbfunserialize);
            LoadXFunction(hTmpDL, "alglib_rbfserialize_stream",   out _i_x_rbfserialize_stream);
            LoadXFunction(hTmpDL, "alglib_rbfunserialize_stream", out _i_x_rbfunserialize_stream);
            LoadXFunction(hTmpDL, "alglib_xv2_rbfcreate", out _i_xv2_rbfcreate);
            LoadXFunction(hTmpDL, "alglib_xv2_rbfcreatecalcbuffer", out _i_xv2_rbfcreatecalcbuffer);
            LoadXFunction(hTmpDL, "alglib_xv2_rbfsetpoints", out _i_xv2_rbfsetpoints);
            LoadXFunction(hTmpDL, "alglib_xv2_rbfsetpointsandscales", out _i_xv2_rbfsetpointsandscales);
            LoadXFunction(hTmpDL, "alglib_xv2_rbfsetalgoqnn", out _i_xv2_rbfsetalgoqnn);
            LoadXFunction(hTmpDL, "alglib_xv2_rbfsetalgomultilayer", out _i_xv2_rbfsetalgomultilayer);
            LoadXFunction(hTmpDL, "alglib_xv2_rbfsetalgohierarchical", out _i_xv2_rbfsetalgohierarchical);
            LoadXFunction(hTmpDL, "alglib_xv2_rbfsetalgothinplatespline", out _i_xv2_rbfsetalgothinplatespline);
            LoadXFunction(hTmpDL, "alglib_xv2_rbfsetalgomultiquadricmanual", out _i_xv2_rbfsetalgomultiquadricmanual);
            LoadXFunction(hTmpDL, "alglib_xv2_rbfsetalgomultiquadricauto", out _i_xv2_rbfsetalgomultiquadricauto);
            LoadXFunction(hTmpDL, "alglib_xv2_rbfsetalgobiharmonic", out _i_xv2_rbfsetalgobiharmonic);
            LoadXFunction(hTmpDL, "alglib_xv2_rbfsetlinterm", out _i_xv2_rbfsetlinterm);
            LoadXFunction(hTmpDL, "alglib_xv2_rbfsetconstterm", out _i_xv2_rbfsetconstterm);
            LoadXFunction(hTmpDL, "alglib_xv2_rbfsetzeroterm", out _i_xv2_rbfsetzeroterm);
            LoadXFunction(hTmpDL, "alglib_xv2_rbfsetv2bf", out _i_xv2_rbfsetv2bf);
            LoadXFunction(hTmpDL, "alglib_xv2_rbfsetv2its", out _i_xv2_rbfsetv2its);
            LoadXFunction(hTmpDL, "alglib_xv2_rbfsetv2supportr", out _i_xv2_rbfsetv2supportr);
            LoadXFunction(hTmpDL, "alglib_xv2_rbfsetv3tol", out _i_xv2_rbfsetv3tol);
            LoadXFunction(hTmpDL, "alglib_xv2_rbfbuildmodel", out _i_xv2_rbfbuildmodel);
            LoadXFunction(hTmpDL, "alglib_xv2_rbfcalc1", out _i_xv2_rbfcalc1);
            LoadXFunction(hTmpDL, "alglib_xv2_rbfcalc2", out _i_xv2_rbfcalc2);
            LoadXFunction(hTmpDL, "alglib_xv2_rbfcalc3", out _i_xv2_rbfcalc3);
            LoadXFunction(hTmpDL, "alglib_xv2_rbfdiff1", out _i_xv2_rbfdiff1);
            LoadXFunction(hTmpDL, "alglib_xv2_rbfdiff2", out _i_xv2_rbfdiff2);
            LoadXFunction(hTmpDL, "alglib_xv2_rbfdiff3", out _i_xv2_rbfdiff3);
            LoadXFunction(hTmpDL, "alglib_xv2_rbfsetfastevaltol", out _i_xv2_rbfsetfastevaltol);
            LoadXFunction(hTmpDL, "alglib_xv2_rbffastcalc", out _i_xv2_rbffastcalc);
            LoadXFunction(hTmpDL, "alglib_xv2_rbfcalc", out _i_xv2_rbfcalc);
            LoadXFunction(hTmpDL, "alglib_xv2_rbfdiff", out _i_xv2_rbfdiff);
            LoadXFunction(hTmpDL, "alglib_xv2_rbfhess", out _i_xv2_rbfhess);
            LoadXFunction(hTmpDL, "alglib_xv2_rbfcalcbuf", out _i_xv2_rbfcalcbuf);
            LoadXFunction(hTmpDL, "alglib_xv2_rbfdiffbuf", out _i_xv2_rbfdiffbuf);
            LoadXFunction(hTmpDL, "alglib_xv2_rbfhessbuf", out _i_xv2_rbfhessbuf);
            LoadXFunction(hTmpDL, "alglib_xv2_rbftscalcbuf", out _i_xv2_rbftscalcbuf);
            LoadXFunction(hTmpDL, "alglib_xv2_rbftsdiffbuf", out _i_xv2_rbftsdiffbuf);
            LoadXFunction(hTmpDL, "alglib_xv2_rbftshessbuf", out _i_xv2_rbftshessbuf);
            LoadXFunction(hTmpDL, "alglib_xv2_rbfgridcalc2", out _i_xv2_rbfgridcalc2);
            LoadXFunction(hTmpDL, "alglib_xv2_rbfgridcalc2v", out _i_xv2_rbfgridcalc2v);
            LoadXFunction(hTmpDL, "alglib_xv2_rbfgridcalc2vsubset", out _i_xv2_rbfgridcalc2vsubset);
            LoadXFunction(hTmpDL, "alglib_xv2_rbfgridcalc3v", out _i_xv2_rbfgridcalc3v);
            LoadXFunction(hTmpDL, "alglib_xv2_rbfgridcalc3vsubset", out _i_xv2_rbfgridcalc3vsubset);
            LoadXFunction(hTmpDL, "alglib_xv2_rbfunpack", out _i_xv2_rbfunpack);
            LoadXFunction(hTmpDL, "alglib_xv2_rbfgetmodelversion", out _i_xv2_rbfgetmodelversion);
            LoadXFunction(hTmpDL, "alglib_xv2_rbfpeekprogress", out _i_xv2_rbfpeekprogress);
            LoadXFunction(hTmpDL, "alglib_xv2_rbfrequesttermination", out _i_xv2_rbfrequesttermination);
            LoadXFunction(hTmpDL, "alglib_xv2_fftc1d", out _i_xv2_fftc1d);
            LoadXFunction(hTmpDL, "alglib_xv2_fftc1dinv", out _i_xv2_fftc1dinv);
            LoadXFunction(hTmpDL, "alglib_xv2_fftr1d", out _i_xv2_fftr1d);
            LoadXFunction(hTmpDL, "alglib_xv2_fftr1dinv", out _i_xv2_fftr1dinv);
            LoadXFunction(hTmpDL, "alglib_xv2_fhtr1d", out _i_xv2_fhtr1d);
            LoadXFunction(hTmpDL, "alglib_xv2_fhtr1dinv", out _i_xv2_fhtr1dinv);
            LoadXFunction(hTmpDL, "alglib_xv2_convc1d", out _i_xv2_convc1d);
            LoadXFunction(hTmpDL, "alglib_xv2_convc1dinv", out _i_xv2_convc1dinv);
            LoadXFunction(hTmpDL, "alglib_xv2_convc1dcircular", out _i_xv2_convc1dcircular);
            LoadXFunction(hTmpDL, "alglib_xv2_convc1dcircularinv", out _i_xv2_convc1dcircularinv);
            LoadXFunction(hTmpDL, "alglib_xv2_convr1d", out _i_xv2_convr1d);
            LoadXFunction(hTmpDL, "alglib_xv2_convr1dinv", out _i_xv2_convr1dinv);
            LoadXFunction(hTmpDL, "alglib_xv2_convr1dcircular", out _i_xv2_convr1dcircular);
            LoadXFunction(hTmpDL, "alglib_xv2_convr1dcircularinv", out _i_xv2_convr1dcircularinv);
            LoadXFunction(hTmpDL, "alglib_xv2_corrc1d", out _i_xv2_corrc1d);
            LoadXFunction(hTmpDL, "alglib_xv2_corrc1dcircular", out _i_xv2_corrc1dcircular);
            LoadXFunction(hTmpDL, "alglib_xv2_corrr1d", out _i_xv2_corrr1d);
            LoadXFunction(hTmpDL, "alglib_xv2_corrr1dcircular", out _i_xv2_corrr1dcircular);
            LoadXFunction(hTmpDL, "alglib_xv2_exponentialintegralei", out _i_xv2_exponentialintegralei);
            LoadXFunction(hTmpDL, "alglib_xv2_exponentialintegralen", out _i_xv2_exponentialintegralen);
            LoadXFunction(hTmpDL, "alglib_xv2_jacobianellipticfunctions", out _i_xv2_jacobianellipticfunctions);
            LoadXFunction(hTmpDL, "alglib_xv2_sinecosineintegrals", out _i_xv2_sinecosineintegrals);
            LoadXFunction(hTmpDL, "alglib_xv2_hyperbolicsinecosineintegrals", out _i_xv2_hyperbolicsinecosineintegrals);
            LoadXFunction(hTmpDL, "alglib_xv2_chebyshevcalculate", out _i_xv2_chebyshevcalculate);
            LoadXFunction(hTmpDL, "alglib_xv2_chebyshevsum", out _i_xv2_chebyshevsum);
            LoadXFunction(hTmpDL, "alglib_xv2_chebyshevcoefficients", out _i_xv2_chebyshevcoefficients);
            LoadXFunction(hTmpDL, "alglib_xv2_fromchebyshev", out _i_xv2_fromchebyshev);
            LoadXFunction(hTmpDL, "alglib_xv2_poissondistribution", out _i_xv2_poissondistribution);
            LoadXFunction(hTmpDL, "alglib_xv2_poissoncdistribution", out _i_xv2_poissoncdistribution);
            LoadXFunction(hTmpDL, "alglib_xv2_invpoissondistribution", out _i_xv2_invpoissondistribution);
            LoadXFunction(hTmpDL, "alglib_xv2_beta", out _i_xv2_beta);
            LoadXFunction(hTmpDL, "alglib_xv2_fresnelintegral", out _i_xv2_fresnelintegral);
            LoadXFunction(hTmpDL, "alglib_xv2_psi", out _i_xv2_psi);
            LoadXFunction(hTmpDL, "alglib_xv2_airy", out _i_xv2_airy);
            LoadXFunction(hTmpDL, "alglib_xv2_dawsonintegral", out _i_xv2_dawsonintegral);
            LoadXFunction(hTmpDL, "alglib_xv2_hermitecalculate", out _i_xv2_hermitecalculate);
            LoadXFunction(hTmpDL, "alglib_xv2_hermitesum", out _i_xv2_hermitesum);
            LoadXFunction(hTmpDL, "alglib_xv2_hermitecoefficients", out _i_xv2_hermitecoefficients);
            LoadXFunction(hTmpDL, "alglib_xv2_legendrecalculate", out _i_xv2_legendrecalculate);
            LoadXFunction(hTmpDL, "alglib_xv2_legendresum", out _i_xv2_legendresum);
            LoadXFunction(hTmpDL, "alglib_xv2_legendrecoefficients", out _i_xv2_legendrecoefficients);
            LoadXFunction(hTmpDL, "alglib_xv2_besselj0", out _i_xv2_besselj0);
            LoadXFunction(hTmpDL, "alglib_xv2_besselj1", out _i_xv2_besselj1);
            LoadXFunction(hTmpDL, "alglib_xv2_besseljn", out _i_xv2_besseljn);
            LoadXFunction(hTmpDL, "alglib_xv2_bessely0", out _i_xv2_bessely0);
            LoadXFunction(hTmpDL, "alglib_xv2_bessely1", out _i_xv2_bessely1);
            LoadXFunction(hTmpDL, "alglib_xv2_besselyn", out _i_xv2_besselyn);
            LoadXFunction(hTmpDL, "alglib_xv2_besseli0", out _i_xv2_besseli0);
            LoadXFunction(hTmpDL, "alglib_xv2_besseli1", out _i_xv2_besseli1);
            LoadXFunction(hTmpDL, "alglib_xv2_besselk0", out _i_xv2_besselk0);
            LoadXFunction(hTmpDL, "alglib_xv2_besselk1", out _i_xv2_besselk1);
            LoadXFunction(hTmpDL, "alglib_xv2_besselkn", out _i_xv2_besselkn);
            LoadXFunction(hTmpDL, "alglib_xv2_laguerrecalculate", out _i_xv2_laguerrecalculate);
            LoadXFunction(hTmpDL, "alglib_xv2_laguerresum", out _i_xv2_laguerresum);
            LoadXFunction(hTmpDL, "alglib_xv2_laguerrecoefficients", out _i_xv2_laguerrecoefficients);
            LoadXFunction(hTmpDL, "alglib_xv2_ellipticintegralk", out _i_xv2_ellipticintegralk);
            LoadXFunction(hTmpDL, "alglib_xv2_ellipticintegralkhighprecision", out _i_xv2_ellipticintegralkhighprecision);
            LoadXFunction(hTmpDL, "alglib_xv2_incompleteellipticintegralk", out _i_xv2_incompleteellipticintegralk);
            LoadXFunction(hTmpDL, "alglib_xv2_ellipticintegrale", out _i_xv2_ellipticintegrale);
            LoadXFunction(hTmpDL, "alglib_xv2_incompleteellipticintegrale", out _i_xv2_incompleteellipticintegrale);
            LoadXFunction(hTmpDL, "alglib_xv2_pcabuildbasis", out _i_xv2_pcabuildbasis);
            LoadXFunction(hTmpDL, "alglib_xv2_pcatruncatedsubspace", out _i_xv2_pcatruncatedsubspace);
            LoadXFunction(hTmpDL, "alglib_xv2_pcatruncatedsubspacesparse", out _i_xv2_pcatruncatedsubspacesparse);
            LoadXFunction(hTmpDL, "alglib_xv2_dsoptimalsplit2", out _i_xv2_dsoptimalsplit2);
            LoadXFunction(hTmpDL, "alglib_xv2_dsoptimalsplit2fast", out _i_xv2_dsoptimalsplit2fast);
        LoadXFunction(hTmpDL, "x_obj_copy_multilayerperceptron", out _i_x_obj_copy_multilayerperceptron);
        LoadXFunction(hTmpDL, "x_obj_free_multilayerperceptron", out _i_x_obj_free_multilayerperceptron);
            LoadXFunction(hTmpDL, "alglib_mlpserialize",   out _i_x_mlpserialize);
            LoadXFunction(hTmpDL, "alglib_mlpunserialize", out _i_x_mlpunserialize);
            LoadXFunction(hTmpDL, "alglib_mlpserialize_stream",   out _i_x_mlpserialize_stream);
            LoadXFunction(hTmpDL, "alglib_mlpunserialize_stream", out _i_x_mlpunserialize_stream);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpcreate0", out _i_xv2_mlpcreate0);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpcreate1", out _i_xv2_mlpcreate1);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpcreate2", out _i_xv2_mlpcreate2);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpcreateb0", out _i_xv2_mlpcreateb0);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpcreateb1", out _i_xv2_mlpcreateb1);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpcreateb2", out _i_xv2_mlpcreateb2);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpcreater0", out _i_xv2_mlpcreater0);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpcreater1", out _i_xv2_mlpcreater1);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpcreater2", out _i_xv2_mlpcreater2);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpcreatec0", out _i_xv2_mlpcreatec0);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpcreatec1", out _i_xv2_mlpcreatec1);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpcreatec2", out _i_xv2_mlpcreatec2);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpcopy", out _i_xv2_mlpcopy);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpcopytunableparameters", out _i_xv2_mlpcopytunableparameters);
            LoadXFunction(hTmpDL, "alglib_xv2_mlprandomize", out _i_xv2_mlprandomize);
            LoadXFunction(hTmpDL, "alglib_xv2_mlprandomizefull", out _i_xv2_mlprandomizefull);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpinitpreprocessor", out _i_xv2_mlpinitpreprocessor);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpproperties", out _i_xv2_mlpproperties);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpgetinputscount", out _i_xv2_mlpgetinputscount);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpgetoutputscount", out _i_xv2_mlpgetoutputscount);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpgetweightscount", out _i_xv2_mlpgetweightscount);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpissoftmax", out _i_xv2_mlpissoftmax);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpgetlayerscount", out _i_xv2_mlpgetlayerscount);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpgetlayersize", out _i_xv2_mlpgetlayersize);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpgetinputscaling", out _i_xv2_mlpgetinputscaling);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpgetoutputscaling", out _i_xv2_mlpgetoutputscaling);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpgetneuroninfo", out _i_xv2_mlpgetneuroninfo);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpgetweight", out _i_xv2_mlpgetweight);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpsetinputscaling", out _i_xv2_mlpsetinputscaling);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpsetoutputscaling", out _i_xv2_mlpsetoutputscaling);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpsetneuroninfo", out _i_xv2_mlpsetneuroninfo);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpsetweight", out _i_xv2_mlpsetweight);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpactivationfunction", out _i_xv2_mlpactivationfunction);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpprocess", out _i_xv2_mlpprocess);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpprocessi", out _i_xv2_mlpprocessi);
            LoadXFunction(hTmpDL, "alglib_xv2_mlperror", out _i_xv2_mlperror);
            LoadXFunction(hTmpDL, "alglib_xv2_mlperrorsparse", out _i_xv2_mlperrorsparse);
            LoadXFunction(hTmpDL, "alglib_xv2_mlperrorn", out _i_xv2_mlperrorn);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpclserror", out _i_xv2_mlpclserror);
            LoadXFunction(hTmpDL, "alglib_xv2_mlprelclserror", out _i_xv2_mlprelclserror);
            LoadXFunction(hTmpDL, "alglib_xv2_mlprelclserrorsparse", out _i_xv2_mlprelclserrorsparse);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpavgce", out _i_xv2_mlpavgce);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpavgcesparse", out _i_xv2_mlpavgcesparse);
            LoadXFunction(hTmpDL, "alglib_xv2_mlprmserror", out _i_xv2_mlprmserror);
            LoadXFunction(hTmpDL, "alglib_xv2_mlprmserrorsparse", out _i_xv2_mlprmserrorsparse);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpavgerror", out _i_xv2_mlpavgerror);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpavgerrorsparse", out _i_xv2_mlpavgerrorsparse);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpavgrelerror", out _i_xv2_mlpavgrelerror);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpavgrelerrorsparse", out _i_xv2_mlpavgrelerrorsparse);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpgrad", out _i_xv2_mlpgrad);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpgradn", out _i_xv2_mlpgradn);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpgradbatch", out _i_xv2_mlpgradbatch);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpgradbatchsparse", out _i_xv2_mlpgradbatchsparse);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpgradbatchsubset", out _i_xv2_mlpgradbatchsubset);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpgradbatchsparsesubset", out _i_xv2_mlpgradbatchsparsesubset);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpgradnbatch", out _i_xv2_mlpgradnbatch);
            LoadXFunction(hTmpDL, "alglib_xv2_mlphessiannbatch", out _i_xv2_mlphessiannbatch);
            LoadXFunction(hTmpDL, "alglib_xv2_mlphessianbatch", out _i_xv2_mlphessianbatch);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpallerrorssubset", out _i_xv2_mlpallerrorssubset);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpallerrorssparsesubset", out _i_xv2_mlpallerrorssparsesubset);
            LoadXFunction(hTmpDL, "alglib_xv2_mlperrorsubset", out _i_xv2_mlperrorsubset);
            LoadXFunction(hTmpDL, "alglib_xv2_mlperrorsparsesubset", out _i_xv2_mlperrorsparsesubset);
        LoadXFunction(hTmpDL, "x_obj_copy_mlpensemble", out _i_x_obj_copy_mlpensemble);
        LoadXFunction(hTmpDL, "x_obj_free_mlpensemble", out _i_x_obj_free_mlpensemble);
            LoadXFunction(hTmpDL, "alglib_mlpeserialize",   out _i_x_mlpeserialize);
            LoadXFunction(hTmpDL, "alglib_mlpeunserialize", out _i_x_mlpeunserialize);
            LoadXFunction(hTmpDL, "alglib_mlpeserialize_stream",   out _i_x_mlpeserialize_stream);
            LoadXFunction(hTmpDL, "alglib_mlpeunserialize_stream", out _i_x_mlpeunserialize_stream);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpecreate0", out _i_xv2_mlpecreate0);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpecreate1", out _i_xv2_mlpecreate1);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpecreate2", out _i_xv2_mlpecreate2);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpecreateb0", out _i_xv2_mlpecreateb0);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpecreateb1", out _i_xv2_mlpecreateb1);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpecreateb2", out _i_xv2_mlpecreateb2);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpecreater0", out _i_xv2_mlpecreater0);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpecreater1", out _i_xv2_mlpecreater1);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpecreater2", out _i_xv2_mlpecreater2);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpecreatec0", out _i_xv2_mlpecreatec0);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpecreatec1", out _i_xv2_mlpecreatec1);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpecreatec2", out _i_xv2_mlpecreatec2);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpecreatefromnetwork", out _i_xv2_mlpecreatefromnetwork);
            LoadXFunction(hTmpDL, "alglib_xv2_mlperandomize", out _i_xv2_mlperandomize);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpeproperties", out _i_xv2_mlpeproperties);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpeissoftmax", out _i_xv2_mlpeissoftmax);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpeprocess", out _i_xv2_mlpeprocess);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpeprocessi", out _i_xv2_mlpeprocessi);
            LoadXFunction(hTmpDL, "alglib_xv2_mlperelclserror", out _i_xv2_mlperelclserror);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpeavgce", out _i_xv2_mlpeavgce);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpermserror", out _i_xv2_mlpermserror);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpeavgerror", out _i_xv2_mlpeavgerror);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpeavgrelerror", out _i_xv2_mlpeavgrelerror);
        LoadXFunction(hTmpDL, "x_obj_copy_clusterizerstate", out _i_x_obj_copy_clusterizerstate);
        LoadXFunction(hTmpDL, "x_obj_free_clusterizerstate", out _i_x_obj_free_clusterizerstate);
            LoadXFunction(hTmpDL, "alglib_xv2_clusterizercreate", out _i_xv2_clusterizercreate);
            LoadXFunction(hTmpDL, "alglib_xv2_clusterizersetpoints", out _i_xv2_clusterizersetpoints);
            LoadXFunction(hTmpDL, "alglib_xv2_clusterizersetdistances", out _i_xv2_clusterizersetdistances);
            LoadXFunction(hTmpDL, "alglib_xv2_clusterizersetahcalgo", out _i_xv2_clusterizersetahcalgo);
            LoadXFunction(hTmpDL, "alglib_xv2_clusterizersetkmeanslimits", out _i_xv2_clusterizersetkmeanslimits);
            LoadXFunction(hTmpDL, "alglib_xv2_clusterizersetkmeansinit", out _i_xv2_clusterizersetkmeansinit);
            LoadXFunction(hTmpDL, "alglib_xv2_clusterizersetseed", out _i_xv2_clusterizersetseed);
            LoadXFunction(hTmpDL, "alglib_xv2_clusterizerrunahc", out _i_xv2_clusterizerrunahc);
            LoadXFunction(hTmpDL, "alglib_xv2_clusterizerrunkmeans", out _i_xv2_clusterizerrunkmeans);
            LoadXFunction(hTmpDL, "alglib_xv2_clusterizergetdistances", out _i_xv2_clusterizergetdistances);
            LoadXFunction(hTmpDL, "alglib_xv2_clusterizergetkclusters", out _i_xv2_clusterizergetkclusters);
            LoadXFunction(hTmpDL, "alglib_xv2_clusterizerseparatedbydist", out _i_xv2_clusterizerseparatedbydist);
            LoadXFunction(hTmpDL, "alglib_xv2_clusterizerseparatedbycorr", out _i_xv2_clusterizerseparatedbycorr);
        LoadXFunction(hTmpDL, "x_obj_copy_decisionforestbuilder", out _i_x_obj_copy_decisionforestbuilder);
        LoadXFunction(hTmpDL, "x_obj_free_decisionforestbuilder", out _i_x_obj_free_decisionforestbuilder);
        LoadXFunction(hTmpDL, "x_obj_copy_decisionforestbuffer", out _i_x_obj_copy_decisionforestbuffer);
        LoadXFunction(hTmpDL, "x_obj_free_decisionforestbuffer", out _i_x_obj_free_decisionforestbuffer);
        LoadXFunction(hTmpDL, "x_obj_copy_decisionforest", out _i_x_obj_copy_decisionforest);
        LoadXFunction(hTmpDL, "x_obj_free_decisionforest", out _i_x_obj_free_decisionforest);
            LoadXFunction(hTmpDL, "alglib_dfserialize",   out _i_x_dfserialize);
            LoadXFunction(hTmpDL, "alglib_dfunserialize", out _i_x_dfunserialize);
            LoadXFunction(hTmpDL, "alglib_dfserialize_stream",   out _i_x_dfserialize_stream);
            LoadXFunction(hTmpDL, "alglib_dfunserialize_stream", out _i_x_dfunserialize_stream);
            LoadXFunction(hTmpDL, "alglib_xv2_dfcreatebuffer", out _i_xv2_dfcreatebuffer);
            LoadXFunction(hTmpDL, "alglib_xv2_dfbuildercreate", out _i_xv2_dfbuildercreate);
            LoadXFunction(hTmpDL, "alglib_xv2_dfbuildersetdataset", out _i_xv2_dfbuildersetdataset);
            LoadXFunction(hTmpDL, "alglib_xv2_dfbuildersetrndvars", out _i_xv2_dfbuildersetrndvars);
            LoadXFunction(hTmpDL, "alglib_xv2_dfbuildersetrndvarsratio", out _i_xv2_dfbuildersetrndvarsratio);
            LoadXFunction(hTmpDL, "alglib_xv2_dfbuildersetrndvarsauto", out _i_xv2_dfbuildersetrndvarsauto);
            LoadXFunction(hTmpDL, "alglib_xv2_dfbuildersetsubsampleratio", out _i_xv2_dfbuildersetsubsampleratio);
            LoadXFunction(hTmpDL, "alglib_xv2_dfbuildersetseed", out _i_xv2_dfbuildersetseed);
            LoadXFunction(hTmpDL, "alglib_xv2_dfbuildersetrdfalgo", out _i_xv2_dfbuildersetrdfalgo);
            LoadXFunction(hTmpDL, "alglib_xv2_dfbuildersetrdfsplitstrength", out _i_xv2_dfbuildersetrdfsplitstrength);
            LoadXFunction(hTmpDL, "alglib_xv2_dfbuildersetimportancetrngini", out _i_xv2_dfbuildersetimportancetrngini);
            LoadXFunction(hTmpDL, "alglib_xv2_dfbuildersetimportanceoobgini", out _i_xv2_dfbuildersetimportanceoobgini);
            LoadXFunction(hTmpDL, "alglib_xv2_dfbuildersetimportancepermutation", out _i_xv2_dfbuildersetimportancepermutation);
            LoadXFunction(hTmpDL, "alglib_xv2_dfbuildersetimportancenone", out _i_xv2_dfbuildersetimportancenone);
            LoadXFunction(hTmpDL, "alglib_xv2_dfbuildergetprogress", out _i_xv2_dfbuildergetprogress);
            LoadXFunction(hTmpDL, "alglib_xv2_dfbuilderpeekprogress", out _i_xv2_dfbuilderpeekprogress);
            LoadXFunction(hTmpDL, "alglib_xv2_dfbuilderbuildrandomforest", out _i_xv2_dfbuilderbuildrandomforest);
            LoadXFunction(hTmpDL, "alglib_xv2_dfbinarycompression", out _i_xv2_dfbinarycompression);
            LoadXFunction(hTmpDL, "alglib_xv2_dfprocess", out _i_xv2_dfprocess);
            LoadXFunction(hTmpDL, "alglib_xv2_dfprocessi", out _i_xv2_dfprocessi);
            LoadXFunction(hTmpDL, "alglib_xv2_dfprocess0", out _i_xv2_dfprocess0);
            LoadXFunction(hTmpDL, "alglib_xv2_dfclassify", out _i_xv2_dfclassify);
            LoadXFunction(hTmpDL, "alglib_xv2_dftsprocess", out _i_xv2_dftsprocess);
            LoadXFunction(hTmpDL, "alglib_xv2_dfrelclserror", out _i_xv2_dfrelclserror);
            LoadXFunction(hTmpDL, "alglib_xv2_dfavgce", out _i_xv2_dfavgce);
            LoadXFunction(hTmpDL, "alglib_xv2_dfrmserror", out _i_xv2_dfrmserror);
            LoadXFunction(hTmpDL, "alglib_xv2_dfavgerror", out _i_xv2_dfavgerror);
            LoadXFunction(hTmpDL, "alglib_xv2_dfavgrelerror", out _i_xv2_dfavgrelerror);
            LoadXFunction(hTmpDL, "alglib_xv2_dfbuildrandomdecisionforest", out _i_xv2_dfbuildrandomdecisionforest);
            LoadXFunction(hTmpDL, "alglib_xv2_dfbuildrandomdecisionforestx1", out _i_xv2_dfbuildrandomdecisionforestx1);
        LoadXFunction(hTmpDL, "x_obj_copy_linearmodel", out _i_x_obj_copy_linearmodel);
        LoadXFunction(hTmpDL, "x_obj_free_linearmodel", out _i_x_obj_free_linearmodel);
            LoadXFunction(hTmpDL, "alglib_xv2_lrbuild", out _i_xv2_lrbuild);
            LoadXFunction(hTmpDL, "alglib_xv2_lrbuilds", out _i_xv2_lrbuilds);
            LoadXFunction(hTmpDL, "alglib_xv2_lrbuildzs", out _i_xv2_lrbuildzs);
            LoadXFunction(hTmpDL, "alglib_xv2_lrbuildz", out _i_xv2_lrbuildz);
            LoadXFunction(hTmpDL, "alglib_xv2_lrunpack", out _i_xv2_lrunpack);
            LoadXFunction(hTmpDL, "alglib_xv2_lrpack", out _i_xv2_lrpack);
            LoadXFunction(hTmpDL, "alglib_xv2_lrprocess", out _i_xv2_lrprocess);
            LoadXFunction(hTmpDL, "alglib_xv2_lrrmserror", out _i_xv2_lrrmserror);
            LoadXFunction(hTmpDL, "alglib_xv2_lravgerror", out _i_xv2_lravgerror);
            LoadXFunction(hTmpDL, "alglib_xv2_lravgrelerror", out _i_xv2_lravgrelerror);
            LoadXFunction(hTmpDL, "alglib_xv2_filtersma", out _i_xv2_filtersma);
            LoadXFunction(hTmpDL, "alglib_xv2_filterema", out _i_xv2_filterema);
            LoadXFunction(hTmpDL, "alglib_xv2_filterlrma", out _i_xv2_filterlrma);
        LoadXFunction(hTmpDL, "x_obj_copy_ssamodel", out _i_x_obj_copy_ssamodel);
        LoadXFunction(hTmpDL, "x_obj_free_ssamodel", out _i_x_obj_free_ssamodel);
            LoadXFunction(hTmpDL, "alglib_xv2_ssacreate", out _i_xv2_ssacreate);
            LoadXFunction(hTmpDL, "alglib_xv2_ssasetwindow", out _i_xv2_ssasetwindow);
            LoadXFunction(hTmpDL, "alglib_xv2_ssasetseed", out _i_xv2_ssasetseed);
            LoadXFunction(hTmpDL, "alglib_xv2_ssasetpoweruplength", out _i_xv2_ssasetpoweruplength);
            LoadXFunction(hTmpDL, "alglib_xv2_ssasetmemorylimit", out _i_xv2_ssasetmemorylimit);
            LoadXFunction(hTmpDL, "alglib_xv2_ssaaddsequence", out _i_xv2_ssaaddsequence);
            LoadXFunction(hTmpDL, "alglib_xv2_ssaappendpointandupdate", out _i_xv2_ssaappendpointandupdate);
            LoadXFunction(hTmpDL, "alglib_xv2_ssaappendsequenceandupdate", out _i_xv2_ssaappendsequenceandupdate);
            LoadXFunction(hTmpDL, "alglib_xv2_ssasetalgoprecomputed", out _i_xv2_ssasetalgoprecomputed);
            LoadXFunction(hTmpDL, "alglib_xv2_ssasetalgotopkdirect", out _i_xv2_ssasetalgotopkdirect);
            LoadXFunction(hTmpDL, "alglib_xv2_ssasetalgotopkrealtime", out _i_xv2_ssasetalgotopkrealtime);
            LoadXFunction(hTmpDL, "alglib_xv2_ssacleardata", out _i_xv2_ssacleardata);
            LoadXFunction(hTmpDL, "alglib_xv2_ssagetbasis", out _i_xv2_ssagetbasis);
            LoadXFunction(hTmpDL, "alglib_xv2_ssagetlrr", out _i_xv2_ssagetlrr);
            LoadXFunction(hTmpDL, "alglib_xv2_ssaanalyzelastwindow", out _i_xv2_ssaanalyzelastwindow);
            LoadXFunction(hTmpDL, "alglib_xv2_ssaanalyzelast", out _i_xv2_ssaanalyzelast);
            LoadXFunction(hTmpDL, "alglib_xv2_ssaanalyzesequence", out _i_xv2_ssaanalyzesequence);
            LoadXFunction(hTmpDL, "alglib_xv2_ssaforecastlast", out _i_xv2_ssaforecastlast);
            LoadXFunction(hTmpDL, "alglib_xv2_ssaforecastsequence", out _i_xv2_ssaforecastsequence);
            LoadXFunction(hTmpDL, "alglib_xv2_ssaforecastavglast", out _i_xv2_ssaforecastavglast);
            LoadXFunction(hTmpDL, "alglib_xv2_ssaforecastavgsequence", out _i_xv2_ssaforecastavgsequence);
            LoadXFunction(hTmpDL, "alglib_xv2_fisherlda", out _i_xv2_fisherlda);
            LoadXFunction(hTmpDL, "alglib_xv2_fisherldan", out _i_xv2_fisherldan);
        LoadXFunction(hTmpDL, "x_obj_copy_mcpdstate", out _i_x_obj_copy_mcpdstate);
        LoadXFunction(hTmpDL, "x_obj_free_mcpdstate", out _i_x_obj_free_mcpdstate);
            LoadXFunction(hTmpDL, "alglib_xv2_mcpdcreate", out _i_xv2_mcpdcreate);
            LoadXFunction(hTmpDL, "alglib_xv2_mcpdcreateentry", out _i_xv2_mcpdcreateentry);
            LoadXFunction(hTmpDL, "alglib_xv2_mcpdcreateexit", out _i_xv2_mcpdcreateexit);
            LoadXFunction(hTmpDL, "alglib_xv2_mcpdcreateentryexit", out _i_xv2_mcpdcreateentryexit);
            LoadXFunction(hTmpDL, "alglib_xv2_mcpdaddtrack", out _i_xv2_mcpdaddtrack);
            LoadXFunction(hTmpDL, "alglib_xv2_mcpdsetec", out _i_xv2_mcpdsetec);
            LoadXFunction(hTmpDL, "alglib_xv2_mcpdaddec", out _i_xv2_mcpdaddec);
            LoadXFunction(hTmpDL, "alglib_xv2_mcpdsetbc", out _i_xv2_mcpdsetbc);
            LoadXFunction(hTmpDL, "alglib_xv2_mcpdaddbc", out _i_xv2_mcpdaddbc);
            LoadXFunction(hTmpDL, "alglib_xv2_mcpdsetlc", out _i_xv2_mcpdsetlc);
            LoadXFunction(hTmpDL, "alglib_xv2_mcpdsettikhonovregularizer", out _i_xv2_mcpdsettikhonovregularizer);
            LoadXFunction(hTmpDL, "alglib_xv2_mcpdsetprior", out _i_xv2_mcpdsetprior);
            LoadXFunction(hTmpDL, "alglib_xv2_mcpdsetpredictionweights", out _i_xv2_mcpdsetpredictionweights);
            LoadXFunction(hTmpDL, "alglib_xv2_mcpdsolve", out _i_xv2_mcpdsolve);
            LoadXFunction(hTmpDL, "alglib_xv2_mcpdresults", out _i_xv2_mcpdresults);
        LoadXFunction(hTmpDL, "x_obj_copy_logitmodel", out _i_x_obj_copy_logitmodel);
        LoadXFunction(hTmpDL, "x_obj_free_logitmodel", out _i_x_obj_free_logitmodel);
            LoadXFunction(hTmpDL, "alglib_xv2_mnltrainh", out _i_xv2_mnltrainh);
            LoadXFunction(hTmpDL, "alglib_xv2_mnlprocess", out _i_xv2_mnlprocess);
            LoadXFunction(hTmpDL, "alglib_xv2_mnlprocessi", out _i_xv2_mnlprocessi);
            LoadXFunction(hTmpDL, "alglib_xv2_mnlunpack", out _i_xv2_mnlunpack);
            LoadXFunction(hTmpDL, "alglib_xv2_mnlpack", out _i_xv2_mnlpack);
            LoadXFunction(hTmpDL, "alglib_xv2_mnlavgce", out _i_xv2_mnlavgce);
            LoadXFunction(hTmpDL, "alglib_xv2_mnlrelclserror", out _i_xv2_mnlrelclserror);
            LoadXFunction(hTmpDL, "alglib_xv2_mnlrmserror", out _i_xv2_mnlrmserror);
            LoadXFunction(hTmpDL, "alglib_xv2_mnlavgerror", out _i_xv2_mnlavgerror);
            LoadXFunction(hTmpDL, "alglib_xv2_mnlavgrelerror", out _i_xv2_mnlavgrelerror);
            LoadXFunction(hTmpDL, "alglib_xv2_mnlclserror", out _i_xv2_mnlclserror);
        LoadXFunction(hTmpDL, "x_obj_copy_knnbuffer", out _i_x_obj_copy_knnbuffer);
        LoadXFunction(hTmpDL, "x_obj_free_knnbuffer", out _i_x_obj_free_knnbuffer);
        LoadXFunction(hTmpDL, "x_obj_copy_knnbuilder", out _i_x_obj_copy_knnbuilder);
        LoadXFunction(hTmpDL, "x_obj_free_knnbuilder", out _i_x_obj_free_knnbuilder);
        LoadXFunction(hTmpDL, "x_obj_copy_knnmodel", out _i_x_obj_copy_knnmodel);
        LoadXFunction(hTmpDL, "x_obj_free_knnmodel", out _i_x_obj_free_knnmodel);
            LoadXFunction(hTmpDL, "alglib_knnserialize",   out _i_x_knnserialize);
            LoadXFunction(hTmpDL, "alglib_knnunserialize", out _i_x_knnunserialize);
            LoadXFunction(hTmpDL, "alglib_knnserialize_stream",   out _i_x_knnserialize_stream);
            LoadXFunction(hTmpDL, "alglib_knnunserialize_stream", out _i_x_knnunserialize_stream);
            LoadXFunction(hTmpDL, "alglib_xv2_knncreatebuffer", out _i_xv2_knncreatebuffer);
            LoadXFunction(hTmpDL, "alglib_xv2_knnbuildercreate", out _i_xv2_knnbuildercreate);
            LoadXFunction(hTmpDL, "alglib_xv2_knnbuildersetdatasetreg", out _i_xv2_knnbuildersetdatasetreg);
            LoadXFunction(hTmpDL, "alglib_xv2_knnbuildersetdatasetcls", out _i_xv2_knnbuildersetdatasetcls);
            LoadXFunction(hTmpDL, "alglib_xv2_knnbuildersetnorm", out _i_xv2_knnbuildersetnorm);
            LoadXFunction(hTmpDL, "alglib_xv2_knnbuilderbuildknnmodel", out _i_xv2_knnbuilderbuildknnmodel);
            LoadXFunction(hTmpDL, "alglib_xv2_knnrewritekeps", out _i_xv2_knnrewritekeps);
            LoadXFunction(hTmpDL, "alglib_xv2_knnprocess", out _i_xv2_knnprocess);
            LoadXFunction(hTmpDL, "alglib_xv2_knnprocess0", out _i_xv2_knnprocess0);
            LoadXFunction(hTmpDL, "alglib_xv2_knnclassify", out _i_xv2_knnclassify);
            LoadXFunction(hTmpDL, "alglib_xv2_knnprocessi", out _i_xv2_knnprocessi);
            LoadXFunction(hTmpDL, "alglib_xv2_knntsprocess", out _i_xv2_knntsprocess);
            LoadXFunction(hTmpDL, "alglib_xv2_knnrelclserror", out _i_xv2_knnrelclserror);
            LoadXFunction(hTmpDL, "alglib_xv2_knnavgce", out _i_xv2_knnavgce);
            LoadXFunction(hTmpDL, "alglib_xv2_knnrmserror", out _i_xv2_knnrmserror);
            LoadXFunction(hTmpDL, "alglib_xv2_knnavgerror", out _i_xv2_knnavgerror);
            LoadXFunction(hTmpDL, "alglib_xv2_knnavgrelerror", out _i_xv2_knnavgrelerror);
            LoadXFunction(hTmpDL, "alglib_xv2_knnallerrors", out _i_xv2_knnallerrors);
        LoadXFunction(hTmpDL, "x_obj_copy_mlptrainer", out _i_x_obj_copy_mlptrainer);
        LoadXFunction(hTmpDL, "x_obj_free_mlptrainer", out _i_x_obj_free_mlptrainer);
            LoadXFunction(hTmpDL, "alglib_xv2_mlptrainlm", out _i_xv2_mlptrainlm);
            LoadXFunction(hTmpDL, "alglib_xv2_mlptrainlbfgs", out _i_xv2_mlptrainlbfgs);
            LoadXFunction(hTmpDL, "alglib_xv2_mlptraines", out _i_xv2_mlptraines);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpkfoldcvlbfgs", out _i_xv2_mlpkfoldcvlbfgs);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpkfoldcvlm", out _i_xv2_mlpkfoldcvlm);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpkfoldcv", out _i_xv2_mlpkfoldcv);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpcreatetrainer", out _i_xv2_mlpcreatetrainer);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpcreatetrainercls", out _i_xv2_mlpcreatetrainercls);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpsetdataset", out _i_xv2_mlpsetdataset);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpsetsparsedataset", out _i_xv2_mlpsetsparsedataset);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpsetdecay", out _i_xv2_mlpsetdecay);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpsetcond", out _i_xv2_mlpsetcond);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpsetalgobatch", out _i_xv2_mlpsetalgobatch);
            LoadXFunction(hTmpDL, "alglib_xv2_mlptrainnetwork", out _i_xv2_mlptrainnetwork);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpstarttraining", out _i_xv2_mlpstarttraining);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpcontinuetraining", out _i_xv2_mlpcontinuetraining);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpebagginglm", out _i_xv2_mlpebagginglm);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpebagginglbfgs", out _i_xv2_mlpebagginglbfgs);
            LoadXFunction(hTmpDL, "alglib_xv2_mlpetraines", out _i_xv2_mlpetraines);
            LoadXFunction(hTmpDL, "alglib_xv2_mlptrainensemblees", out _i_xv2_mlptrainensemblees);
            LoadXFunction(hTmpDL, "alglib_xv2_kmeansgenerate", out _i_xv2_kmeansgenerate);

    }
    
}
